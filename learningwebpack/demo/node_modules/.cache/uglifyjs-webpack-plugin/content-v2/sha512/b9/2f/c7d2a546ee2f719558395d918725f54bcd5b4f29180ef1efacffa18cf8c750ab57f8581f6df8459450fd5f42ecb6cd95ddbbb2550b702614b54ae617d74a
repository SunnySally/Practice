{"map":"{\"version\":3,\"sources\":[\"webpack/bootstrap\"],\"names\":[\"installedModules\",\"__webpack_require__\",\"moduleId\",\"exports\",\"module\",\"i\",\"l\",\"modules\",\"call\",\"m\",\"c\",\"d\",\"name\",\"getter\",\"o\",\"Object\",\"defineProperty\",\"enumerable\",\"get\",\"r\",\"Symbol\",\"toStringTag\",\"value\",\"t\",\"mode\",\"__esModule\",\"ns\",\"create\",\"key\",\"bind\",\"n\",\"object\",\"property\",\"prototype\",\"hasOwnProperty\",\"p\",\"s\"],\"mappings\":\"aACA,IAAAA,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,GAAA,EACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,EAAAA,EAAAD,QAAAF,GAGAG,EAAAE,GAAA,EAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GAA0CK,YAAA,EAAAC,IAAAL,KAK1CZ,EAAAkB,EAAA,SAAAhB,GACA,oBAAAiB,QAAAA,OAAAC,aACAN,OAAAC,eAAAb,EAAAiB,OAAAC,aAAwDC,MAAA,WAExDP,OAAAC,eAAAb,EAAA,cAAiDmB,OAAA,KAQjDrB,EAAAsB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAArB,EAAAqB,IACA,EAAAE,EAAA,OAAAF,EACA,GAAA,EAAAE,GAAA,iBAAAF,GAAAA,GAAAA,EAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFA1B,EAAAkB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,MAAAA,IACzC,EAAAE,GAAA,iBAAAF,EAAA,IAAA,IAAAM,KAAAN,EAAArB,EAAAU,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAzB,EAAA6B,EAAA,SAAA1B,GACA,IAAAS,EAAAT,GAAAA,EAAAqB,WACA,WAA2B,OAAArB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD/B,EAAAkC,EAAA,GAIAlC,EAAAA,EAAAmC,EAAA\",\"sourcesContent\":[\" \\t// The module cache\\n \\tvar installedModules = {};\\n\\n \\t// The require function\\n \\tfunction __webpack_require__(moduleId) {\\n\\n \\t\\t// Check if module is in cache\\n \\t\\tif(installedModules[moduleId]) {\\n \\t\\t\\treturn installedModules[moduleId].exports;\\n \\t\\t}\\n \\t\\t// Create a new module (and put it into the cache)\\n \\t\\tvar module = installedModules[moduleId] = {\\n \\t\\t\\ti: moduleId,\\n \\t\\t\\tl: false,\\n \\t\\t\\texports: {}\\n \\t\\t};\\n\\n \\t\\t// Execute the module function\\n \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n\\n \\t\\t// Flag the module as loaded\\n \\t\\tmodule.l = true;\\n\\n \\t\\t// Return the exports of the module\\n \\t\\treturn module.exports;\\n \\t}\\n\\n\\n \\t// expose the modules object (__webpack_modules__)\\n \\t__webpack_require__.m = modules;\\n\\n \\t// expose the module cache\\n \\t__webpack_require__.c = installedModules;\\n\\n \\t// define getter function for harmony exports\\n \\t__webpack_require__.d = function(exports, name, getter) {\\n \\t\\tif(!__webpack_require__.o(exports, name)) {\\n \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n \\t\\t}\\n \\t};\\n\\n \\t// define __esModule on exports\\n \\t__webpack_require__.r = function(exports) {\\n \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n \\t\\t}\\n \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n \\t};\\n\\n \\t// create a fake namespace object\\n \\t// mode & 1: value is a module id, require it\\n \\t// mode & 2: merge all properties of value into the ns\\n \\t// mode & 4: return value when already ns object\\n \\t// mode & 8|1: behave like require\\n \\t__webpack_require__.t = function(value, mode) {\\n \\t\\tif(mode & 1) value = __webpack_require__(value);\\n \\t\\tif(mode & 8) return value;\\n \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n \\t\\tvar ns = Object.create(null);\\n \\t\\t__webpack_require__.r(ns);\\n \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n \\t\\treturn ns;\\n \\t};\\n\\n \\t// getDefaultExport function for compatibility with non-harmony modules\\n \\t__webpack_require__.n = function(module) {\\n \\t\\tvar getter = module && module.__esModule ?\\n \\t\\t\\tfunction getDefault() { return module['default']; } :\\n \\t\\t\\tfunction getModuleExports() { return module; };\\n \\t\\t__webpack_require__.d(getter, 'a', getter);\\n \\t\\treturn getter;\\n \\t};\\n\\n \\t// Object.prototype.hasOwnProperty.call\\n \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n\\n \\t// __webpack_public_path__\\n \\t__webpack_require__.p = \\\"\\\";\\n\\n\\n \\t// Load entry module and return exports\\n \\treturn __webpack_require__(__webpack_require__.s = 1);\\n\"]}","code":"!function(g){var I={};function t(C){if(I[C])return I[C].exports;var A=I[C]={i:C,l:!1,exports:{}};return g[C].call(A.exports,A,A.exports,t),A.l=!0,A.exports}t.m=g,t.c=I,t.d=function(g,I,C){t.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:C})},t.r=function(g){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(g,\"__esModule\",{value:!0})},t.t=function(g,I){if(1&I&&(g=t(g)),8&I)return g;if(4&I&&\"object\"==typeof g&&g&&g.__esModule)return g;var C=Object.create(null);if(t.r(C),Object.defineProperty(C,\"default\",{enumerable:!0,value:g}),2&I&&\"string\"!=typeof g)for(var A in g)t.d(C,A,function(I){return g[I]}.bind(null,A));return C},t.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return t.d(I,\"a\",I),I},t.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},t.p=\"\",t(t.s=1)}([function(module,exports,__webpack_require__){eval(\"var __WEBPACK_AMD_DEFINE_RESULT__;(typeof navigator !== \\\"undefined\\\") && (function(root, factory) {\\r\\n    if (true) {\\r\\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\\r\\n            return factory(root);\\r\\n        }).call(exports, __webpack_require__, exports, module),\\n\\t\\t\\t\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\r\\n    } else {}\\r\\n}((window || {}), function(window) {\\r\\n    \\\"use strict\\\";\\r\\n    var svgNS = \\\"http://www.w3.org/2000/svg\\\";\\r\\n\\r\\nvar locationHref = '';\\r\\n\\r\\nvar initialDefaultFrame = -999999;\\r\\n\\nvar subframeEnabled = true;\\r\\nvar expressionsPlugin;\\r\\nvar isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\\r\\nvar cachedColors = {};\\r\\nvar bm_rounder = Math.round;\\r\\nvar bm_rnd;\\r\\nvar bm_pow = Math.pow;\\r\\nvar bm_sqrt = Math.sqrt;\\r\\nvar bm_abs = Math.abs;\\r\\nvar bm_floor = Math.floor;\\r\\nvar bm_max = Math.max;\\r\\nvar bm_min = Math.min;\\r\\nvar blitter = 10;\\r\\n\\r\\nvar BMMath = {};\\r\\n(function(){\\r\\n    var propertyNames = Object.getOwnPropertyNames(Math);\\r\\n    var i, len = propertyNames.length;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        BMMath[propertyNames[i]] = Math[propertyNames[i]];\\r\\n    }\\r\\n}());\\r\\n\\r\\nfunction ProjectInterface(){return {};}\\r\\n\\r\\nBMMath.random = Math.random;\\r\\nBMMath.abs = function(val){\\r\\n    var tOfVal = typeof val;\\r\\n    if(tOfVal === 'object' && val.length){\\r\\n        var absArr = createSizedArray(val.length);\\r\\n        var i, len = val.length;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            absArr[i] = Math.abs(val[i]);\\r\\n        }\\r\\n        return absArr;\\r\\n    }\\r\\n    return Math.abs(val);\\r\\n\\r\\n};\\r\\nvar defaultCurveSegments = 150;\\r\\nvar degToRads = Math.PI/180;\\r\\nvar roundCorner = 0.5519;\\r\\n\\r\\nfunction roundValues(flag){\\r\\n    if(flag){\\r\\n        bm_rnd = Math.round;\\r\\n    }else{\\r\\n        bm_rnd = function(val){\\r\\n            return val;\\r\\n        };\\r\\n    }\\r\\n}\\r\\nroundValues(false);\\r\\n\\r\\nfunction styleDiv(element){\\r\\n    element.style.position = 'absolute';\\r\\n    element.style.top = 0;\\r\\n    element.style.left = 0;\\r\\n    element.style.display = 'block';\\r\\n    element.style.transformOrigin = element.style.webkitTransformOrigin = '0 0';\\r\\n    element.style.backfaceVisibility  = element.style.webkitBackfaceVisibility = 'visible';\\r\\n    element.style.transformStyle = element.style.webkitTransformStyle = element.style.mozTransformStyle = \\\"preserve-3d\\\";\\r\\n}\\r\\n\\r\\nfunction BMEnterFrameEvent(n,c,t,d){\\r\\n    this.type = n;\\r\\n    this.currentTime = c;\\r\\n    this.totalTime = t;\\r\\n    this.direction = d < 0 ? -1:1;\\r\\n}\\r\\n\\r\\nfunction BMCompleteEvent(n,d){\\r\\n    this.type = n;\\r\\n    this.direction = d < 0 ? -1:1;\\r\\n}\\r\\n\\r\\nfunction BMCompleteLoopEvent(n,c,t,d){\\r\\n    this.type = n;\\r\\n    this.currentLoop = t;\\r\\n    this.totalLoops = c;\\r\\n    this.direction = d < 0 ? -1:1;\\r\\n}\\r\\n\\r\\nfunction BMSegmentStartEvent(n,f,t){\\r\\n    this.type = n;\\r\\n    this.firstFrame = f;\\r\\n    this.totalFrames = t;\\r\\n}\\r\\n\\r\\nfunction BMDestroyEvent(n,t){\\r\\n    this.type = n;\\r\\n    this.target = t;\\r\\n}\\r\\n\\r\\nfunction randomString(length, chars){\\r\\n    if(chars === undefined){\\r\\n        chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890';\\r\\n    }\\r\\n    var i;\\r\\n    var result = '';\\r\\n    for (i = length; i > 0; --i) result += chars[Math.round(Math.random() * (chars.length - 1))];\\r\\n    return result;\\r\\n}\\r\\n\\r\\nfunction HSVtoRGB(h, s, v) {\\r\\n    var r, g, b, i, f, p, q, t;\\r\\n    i = Math.floor(h * 6);\\r\\n    f = h * 6 - i;\\r\\n    p = v * (1 - s);\\r\\n    q = v * (1 - f * s);\\r\\n    t = v * (1 - (1 - f) * s);\\r\\n    switch (i % 6) {\\r\\n        case 0: r = v; g = t; b = p; break;\\r\\n        case 1: r = q; g = v; b = p; break;\\r\\n        case 2: r = p; g = v; b = t; break;\\r\\n        case 3: r = p; g = q; b = v; break;\\r\\n        case 4: r = t; g = p; b = v; break;\\r\\n        case 5: r = v; g = p; b = q; break;\\r\\n    }\\r\\n    return [ r,\\r\\n        g,\\r\\n         b ];\\r\\n}\\r\\n\\r\\nfunction RGBtoHSV(r, g, b) {\\r\\n    var max = Math.max(r, g, b), min = Math.min(r, g, b),\\r\\n        d = max - min,\\r\\n        h,\\r\\n        s = (max === 0 ? 0 : d / max),\\r\\n        v = max / 255;\\r\\n\\r\\n    switch (max) {\\r\\n        case min: h = 0; break;\\r\\n        case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;\\r\\n        case g: h = (b - r) + d * 2; h /= 6 * d; break;\\r\\n        case b: h = (r - g) + d * 4; h /= 6 * d; break;\\r\\n    }\\r\\n\\r\\n    return [\\r\\n         h,\\r\\n         s,\\r\\n         v\\r\\n    ];\\r\\n}\\r\\n\\r\\nfunction addSaturationToRGB(color,offset){\\r\\n    var hsv = RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);\\r\\n    hsv[1] += offset;\\r\\n    if (hsv[1] > 1) {\\r\\n        hsv[1] = 1;\\r\\n    }\\r\\n    else if (hsv[1] <= 0) {\\r\\n        hsv[1] = 0;\\r\\n    }\\r\\n    return HSVtoRGB(hsv[0],hsv[1],hsv[2]);\\r\\n}\\r\\n\\r\\nfunction addBrightnessToRGB(color,offset){\\r\\n    var hsv = RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);\\r\\n    hsv[2] += offset;\\r\\n    if (hsv[2] > 1) {\\r\\n        hsv[2] = 1;\\r\\n    }\\r\\n    else if (hsv[2] < 0) {\\r\\n        hsv[2] = 0;\\r\\n    }\\r\\n    return HSVtoRGB(hsv[0],hsv[1],hsv[2]);\\r\\n}\\r\\n\\r\\nfunction addHueToRGB(color,offset) {\\r\\n    var hsv = RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);\\r\\n    hsv[0] += offset/360;\\r\\n    if (hsv[0] > 1) {\\r\\n        hsv[0] -= 1;\\r\\n    }\\r\\n    else if (hsv[0] < 0) {\\r\\n        hsv[0] += 1;\\r\\n    }\\r\\n    return HSVtoRGB(hsv[0],hsv[1],hsv[2]);\\r\\n}\\r\\n\\r\\nvar rgbToHex = (function(){\\r\\n    var colorMap = [];\\r\\n    var i;\\r\\n    var hex;\\r\\n    for(i=0;i<256;i+=1){\\r\\n        hex = i.toString(16);\\r\\n        colorMap[i] = hex.length == 1 ? '0' + hex : hex;\\r\\n    }\\r\\n\\r\\n    return function(r, g, b) {\\r\\n        if(r<0){\\r\\n            r = 0;\\r\\n        }\\r\\n        if(g<0){\\r\\n            g = 0;\\r\\n        }\\r\\n        if(b<0){\\r\\n            b = 0;\\r\\n        }\\r\\n        return '#' + colorMap[r] + colorMap[g] + colorMap[b];\\r\\n    };\\r\\n}());\\nfunction BaseEvent(){}\\r\\nBaseEvent.prototype = {\\r\\n\\ttriggerEvent: function (eventName, args) {\\r\\n\\t    if (this._cbs[eventName]) {\\r\\n\\t        var len = this._cbs[eventName].length;\\r\\n\\t        for (var i = 0; i < len; i++){\\r\\n\\t            this._cbs[eventName][i](args);\\r\\n\\t        }\\r\\n\\t    }\\r\\n\\t},\\r\\n\\taddEventListener: function (eventName, callback) {\\r\\n\\t    if (!this._cbs[eventName]){\\r\\n\\t        this._cbs[eventName] = [];\\r\\n\\t    }\\r\\n\\t    this._cbs[eventName].push(callback);\\r\\n\\r\\n\\t\\treturn function() {\\r\\n\\t\\t\\tthis.removeEventListener(eventName, callback);\\r\\n\\t\\t}.bind(this);\\r\\n\\t},\\r\\n\\tremoveEventListener: function (eventName,callback){\\r\\n\\t    if (!callback){\\r\\n\\t        this._cbs[eventName] = null;\\r\\n\\t    }else if(this._cbs[eventName]){\\r\\n\\t        var i = 0, len = this._cbs[eventName].length;\\r\\n\\t        while(i<len){\\r\\n\\t            if(this._cbs[eventName][i] === callback){\\r\\n\\t                this._cbs[eventName].splice(i,1);\\r\\n\\t                i -=1;\\r\\n\\t                len -= 1;\\r\\n\\t            }\\r\\n\\t            i += 1;\\r\\n\\t        }\\r\\n\\t        if(!this._cbs[eventName].length){\\r\\n\\t            this._cbs[eventName] = null;\\r\\n\\t        }\\r\\n\\t    }\\r\\n\\t}\\r\\n};\\nvar createTypedArray = (function(){\\r\\n\\tfunction createRegularArray(type, len){\\r\\n\\t\\tvar i = 0, arr = [], value;\\r\\n\\t\\tswitch(type) {\\r\\n\\t\\t\\tcase 'int16':\\r\\n\\t\\t\\tcase 'uint8c':\\r\\n\\t\\t\\t\\tvalue = 1;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\tdefault:\\r\\n\\t\\t\\t\\tvalue = 1.1;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t}\\r\\n\\t\\tfor(i = 0; i < len; i += 1) {\\r\\n\\t\\t\\tarr.push(value);\\r\\n\\t\\t}\\r\\n\\t\\treturn arr;\\r\\n\\t}\\r\\n\\tfunction createTypedArray(type, len){\\r\\n\\t\\tif(type === 'float32') {\\r\\n\\t\\t\\treturn new Float32Array(len);\\r\\n\\t\\t} else if(type === 'int16') {\\r\\n\\t\\t\\treturn new Int16Array(len);\\r\\n\\t\\t} else if(type === 'uint8c') {\\r\\n\\t\\t\\treturn new Uint8ClampedArray(len);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\tif(typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function') {\\r\\n\\t\\treturn createTypedArray;\\r\\n\\t} else {\\r\\n\\t\\treturn createRegularArray;\\r\\n\\t}\\r\\n}());\\r\\n\\r\\nfunction createSizedArray(len) {\\r\\n\\treturn Array.apply(null,{length:len});\\r\\n}\\nfunction createNS(type) {\\r\\n\\t//return {appendChild:function(){},setAttribute:function(){},style:{}}\\r\\n\\treturn document.createElementNS(svgNS, type);\\r\\n}\\nfunction createTag(type) {\\r\\n\\t//return {appendChild:function(){},setAttribute:function(){},style:{}}\\r\\n\\treturn document.createElement(type);\\r\\n}\\nfunction DynamicPropertyContainer(){};\\r\\nDynamicPropertyContainer.prototype = {\\r\\n\\taddDynamicProperty: function(prop) {\\r\\n\\t\\tif(this.dynamicProperties.indexOf(prop) === -1) {\\r\\n\\t        this.dynamicProperties.push(prop);\\r\\n\\t        this.container.addDynamicProperty(this);\\r\\n\\t    \\tthis._isAnimated = true;\\r\\n\\t    }\\r\\n\\t},\\r\\n\\titerateDynamicProperties: function(){\\r\\n\\t    this._mdf = false;\\r\\n\\t    var i, len = this.dynamicProperties.length;\\r\\n\\t    for(i=0;i<len;i+=1){\\r\\n\\t        this.dynamicProperties[i].getValue();\\r\\n\\t        if(this.dynamicProperties[i]._mdf) {\\r\\n\\t            this._mdf = true;\\r\\n\\t        }\\r\\n\\t    }\\r\\n\\t},\\r\\n\\tinitDynamicPropertyContainer: function(container){\\r\\n\\t    this.container = container;\\r\\n\\t    this.dynamicProperties = [];\\r\\n\\t    this._mdf = false;\\r\\n\\t    this._isAnimated = false;\\r\\n\\t}\\r\\n}\\n/*!\\r\\n Transformation Matrix v2.0\\r\\n (c) Epistemex 2014-2015\\r\\n www.epistemex.com\\r\\n By Ken Fyrstenberg\\r\\n Contributions by leeoniya.\\r\\n License: MIT, header required.\\r\\n */\\r\\n\\r\\n/**\\r\\n * 2D transformation matrix object initialized with identity matrix.\\r\\n *\\r\\n * The matrix can synchronize a canvas context by supplying the context\\r\\n * as an argument, or later apply current absolute transform to an\\r\\n * existing context.\\r\\n *\\r\\n * All values are handled as floating point values.\\r\\n *\\r\\n * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix\\r\\n * @prop {number} a - scale x\\r\\n * @prop {number} b - shear y\\r\\n * @prop {number} c - shear x\\r\\n * @prop {number} d - scale y\\r\\n * @prop {number} e - translate x\\r\\n * @prop {number} f - translate y\\r\\n * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context\\r\\n * @constructor\\r\\n */\\r\\n\\r\\nvar Matrix = (function(){\\r\\n\\r\\n    var _cos = Math.cos;\\r\\n    var _sin = Math.sin;\\r\\n    var _tan = Math.tan;\\r\\n    var _rnd = Math.round;\\r\\n\\r\\n    function reset(){\\r\\n        this.props[0] = 1;\\r\\n        this.props[1] = 0;\\r\\n        this.props[2] = 0;\\r\\n        this.props[3] = 0;\\r\\n        this.props[4] = 0;\\r\\n        this.props[5] = 1;\\r\\n        this.props[6] = 0;\\r\\n        this.props[7] = 0;\\r\\n        this.props[8] = 0;\\r\\n        this.props[9] = 0;\\r\\n        this.props[10] = 1;\\r\\n        this.props[11] = 0;\\r\\n        this.props[12] = 0;\\r\\n        this.props[13] = 0;\\r\\n        this.props[14] = 0;\\r\\n        this.props[15] = 1;\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    function rotate(angle) {\\r\\n        if(angle === 0){\\r\\n            return this;\\r\\n        }\\r\\n        var mCos = _cos(angle);\\r\\n        var mSin = _sin(angle);\\r\\n        return this._t(mCos, -mSin,  0, 0, mSin,  mCos, 0, 0, 0,  0,  1, 0, 0, 0, 0, 1);\\r\\n    }\\r\\n\\r\\n    function rotateX(angle){\\r\\n        if(angle === 0){\\r\\n            return this;\\r\\n        }\\r\\n        var mCos = _cos(angle);\\r\\n        var mSin = _sin(angle);\\r\\n        return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin,  mCos, 0, 0, 0, 0, 1);\\r\\n    }\\r\\n\\r\\n    function rotateY(angle){\\r\\n        if(angle === 0){\\r\\n            return this;\\r\\n        }\\r\\n        var mCos = _cos(angle);\\r\\n        var mSin = _sin(angle);\\r\\n        return this._t(mCos,  0,  mSin, 0, 0, 1, 0, 0, -mSin,  0,  mCos, 0, 0, 0, 0, 1);\\r\\n    }\\r\\n\\r\\n    function rotateZ(angle){\\r\\n        if(angle === 0){\\r\\n            return this;\\r\\n        }\\r\\n        var mCos = _cos(angle);\\r\\n        var mSin = _sin(angle);\\r\\n        return this._t(mCos, -mSin,  0, 0, mSin,  mCos, 0, 0, 0,  0,  1, 0, 0, 0, 0, 1);\\r\\n    }\\r\\n\\r\\n    function shear(sx,sy){\\r\\n        return this._t(1, sy, sx, 1, 0, 0);\\r\\n    }\\r\\n\\r\\n    function skew(ax, ay){\\r\\n        return this.shear(_tan(ax), _tan(ay));\\r\\n    }\\r\\n\\r\\n    function skewFromAxis(ax, angle){\\r\\n        var mCos = _cos(angle);\\r\\n        var mSin = _sin(angle);\\r\\n        return this._t(mCos, mSin,  0, 0, -mSin,  mCos, 0, 0, 0,  0,  1, 0, 0, 0, 0, 1)\\r\\n            ._t(1, 0,  0, 0, _tan(ax),  1, 0, 0, 0,  0,  1, 0, 0, 0, 0, 1)\\r\\n            ._t(mCos, -mSin,  0, 0, mSin,  mCos, 0, 0, 0,  0,  1, 0, 0, 0, 0, 1);\\r\\n        //return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);\\r\\n    }\\r\\n\\r\\n    function scale(sx, sy, sz) {\\r\\n        if(!sz && sz !== 0) {\\r\\n            sz = 1;\\r\\n        }\\r\\n        if(sx === 1 && sy === 1 && sz === 1){\\r\\n            return this;\\r\\n        }\\r\\n        return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);\\r\\n    }\\r\\n\\r\\n    function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {\\r\\n        this.props[0] = a;\\r\\n        this.props[1] = b;\\r\\n        this.props[2] = c;\\r\\n        this.props[3] = d;\\r\\n        this.props[4] = e;\\r\\n        this.props[5] = f;\\r\\n        this.props[6] = g;\\r\\n        this.props[7] = h;\\r\\n        this.props[8] = i;\\r\\n        this.props[9] = j;\\r\\n        this.props[10] = k;\\r\\n        this.props[11] = l;\\r\\n        this.props[12] = m;\\r\\n        this.props[13] = n;\\r\\n        this.props[14] = o;\\r\\n        this.props[15] = p;\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    function translate(tx, ty, tz) {\\r\\n        tz = tz || 0;\\r\\n        if(tx !== 0 || ty !== 0 || tz !== 0){\\r\\n            return this._t(1,0,0,0,0,1,0,0,0,0,1,0,tx,ty,tz,1);\\r\\n        }\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {\\r\\n\\r\\n        var _p = this.props;\\r\\n\\r\\n        if(a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0){\\r\\n            //NOTE: commenting this condition because TurboFan deoptimizes code when present\\r\\n            //if(m2 !== 0 || n2 !== 0 || o2 !== 0){\\r\\n                _p[12] = _p[12] * a2 + _p[15] * m2;\\r\\n                _p[13] = _p[13] * f2 + _p[15] * n2;\\r\\n                _p[14] = _p[14] * k2 + _p[15] * o2;\\r\\n                _p[15] = _p[15] * p2;\\r\\n            //}\\r\\n            this._identityCalculated = false;\\r\\n            return this;\\r\\n        }\\r\\n\\r\\n        var a1 = _p[0];\\r\\n        var b1 = _p[1];\\r\\n        var c1 = _p[2];\\r\\n        var d1 = _p[3];\\r\\n        var e1 = _p[4];\\r\\n        var f1 = _p[5];\\r\\n        var g1 = _p[6];\\r\\n        var h1 = _p[7];\\r\\n        var i1 = _p[8];\\r\\n        var j1 = _p[9];\\r\\n        var k1 = _p[10];\\r\\n        var l1 = _p[11];\\r\\n        var m1 = _p[12];\\r\\n        var n1 = _p[13];\\r\\n        var o1 = _p[14];\\r\\n        var p1 = _p[15];\\r\\n\\r\\n        /* matrix order (canvas compatible):\\r\\n         * ace\\r\\n         * bdf\\r\\n         * 001\\r\\n         */\\r\\n        _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;\\r\\n        _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2 ;\\r\\n        _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2 ;\\r\\n        _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2 ;\\r\\n\\r\\n        _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2 ;\\r\\n        _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2 ;\\r\\n        _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2 ;\\r\\n        _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2 ;\\r\\n\\r\\n        _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2 ;\\r\\n        _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2 ;\\r\\n        _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2 ;\\r\\n        _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2 ;\\r\\n\\r\\n        _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2 ;\\r\\n        _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2 ;\\r\\n        _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2 ;\\r\\n        _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2 ;\\r\\n\\r\\n        this._identityCalculated = false;\\r\\n        return this;\\r\\n    }\\r\\n\\r\\n    function isIdentity() {\\r\\n        if(!this._identityCalculated){\\r\\n            this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);\\r\\n            this._identityCalculated = true;\\r\\n        }\\r\\n        return this._identity;\\r\\n    }\\r\\n\\r\\n    function equals(matr){\\r\\n        var i = 0;\\r\\n        while (i < 16) {\\r\\n            if(matr.props[i] !== this.props[i]) {\\r\\n                return false;\\r\\n            }\\r\\n            i+=1;\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function clone(matr){\\r\\n        var i;\\r\\n        for(i=0;i<16;i+=1){\\r\\n            matr.props[i] = this.props[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function cloneFromProps(props){\\r\\n        var i;\\r\\n        for(i=0;i<16;i+=1){\\r\\n            this.props[i] = props[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function applyToPoint(x, y, z) {\\r\\n\\r\\n        return {\\r\\n            x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],\\r\\n            y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],\\r\\n            z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]\\r\\n        };\\r\\n        /*return {\\r\\n         x: x * me.a + y * me.c + me.e,\\r\\n         y: x * me.b + y * me.d + me.f\\r\\n         };*/\\r\\n    }\\r\\n    function applyToX(x, y, z) {\\r\\n        return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];\\r\\n    }\\r\\n    function applyToY(x, y, z) {\\r\\n        return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];\\r\\n    }\\r\\n    function applyToZ(x, y, z) {\\r\\n        return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];\\r\\n    }\\r\\n\\r\\n    function inversePoint(pt) {\\r\\n        var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];\\r\\n        var a = this.props[5]/determinant;\\r\\n        var b = - this.props[1]/determinant;\\r\\n        var c = - this.props[4]/determinant;\\r\\n        var d = this.props[0]/determinant;\\r\\n        var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12])/determinant;\\r\\n        var f = - (this.props[0] * this.props[13] - this.props[1] * this.props[12])/determinant;\\r\\n        return [pt[0] * a + pt[1] * c + e, pt[0] * b + pt[1] * d + f, 0];\\r\\n    }\\r\\n\\r\\n    function inversePoints(pts){\\r\\n        var i, len = pts.length, retPts = [];\\r\\n        for(i=0;i<len;i+=1){\\r\\n            retPts[i] = inversePoint(pts[i]);\\r\\n        }\\r\\n        return retPts;\\r\\n    }\\r\\n\\r\\n    function applyToTriplePoints(pt1, pt2, pt3) {\\r\\n        var arr = createTypedArray('float32', 6);\\r\\n        if(this.isIdentity()) {\\r\\n            arr[0] = pt1[0];\\r\\n            arr[1] = pt1[1];\\r\\n            arr[2] = pt2[0];\\r\\n            arr[3] = pt2[1];\\r\\n            arr[4] = pt3[0];\\r\\n            arr[5] = pt3[1];\\r\\n        } else {\\r\\n            var p0 = this.props[0], p1 = this.props[1], p4 = this.props[4], p5 = this.props[5], p12 = this.props[12], p13 = this.props[13];\\r\\n            arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;\\r\\n            arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;\\r\\n            arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;\\r\\n            arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;\\r\\n            arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;\\r\\n            arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;\\r\\n        }\\r\\n        return arr;\\r\\n    }\\r\\n\\r\\n    function applyToPointArray(x,y,z){\\r\\n        var arr;\\r\\n        if(this.isIdentity()) {\\r\\n            arr = [x,y,z];\\r\\n        } else {\\r\\n            arr = [x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]];\\r\\n        }\\r\\n        return arr;\\r\\n    }\\r\\n\\r\\n    function applyToPointStringified(x, y) {\\r\\n        if(this.isIdentity()) {\\r\\n            return x + ',' + y;\\r\\n        }\\r\\n        var _p = this.props;\\r\\n        return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100+','+ Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;\\r\\n    }\\r\\n\\r\\n    function toCSS() {\\r\\n        //Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.\\r\\n        /*if(this.isIdentity()) {\\r\\n            return '';\\r\\n        }*/\\r\\n        var i = 0;\\r\\n        var props = this.props;\\r\\n        var cssValue = 'matrix3d(';\\r\\n        var v = 10000;\\r\\n        while(i<16){\\r\\n            cssValue += _rnd(props[i]*v)/v;\\r\\n            cssValue += i === 15 ? ')':',';\\r\\n            i += 1;\\r\\n        }\\r\\n        return cssValue;\\r\\n    }\\r\\n\\r\\n    function roundMatrixProperty(val) {\\r\\n        var v = 10000;\\r\\n        if((val < 0.000001 && val > 0) || (val > -0.000001 && val < 0)) {\\r\\n            return _rnd(val * v) / v;\\r\\n        }\\r\\n        return val;\\r\\n    }\\r\\n\\r\\n    function to2dCSS() {\\r\\n        //Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.\\r\\n        /*if(this.isIdentity()) {\\r\\n            return '';\\r\\n        }*/\\r\\n        var props = this.props;\\r\\n        var _a = roundMatrixProperty(props[0]);\\r\\n        var _b = roundMatrixProperty(props[1]);\\r\\n        var _c = roundMatrixProperty(props[4]);\\r\\n        var _d = roundMatrixProperty(props[5]);\\r\\n        var _e = roundMatrixProperty(props[12]);\\r\\n        var _f = roundMatrixProperty(props[13]);\\r\\n        return \\\"matrix(\\\" + _a + ',' + _b + ',' + _c + ',' + _d + ',' + _e + ',' + _f + \\\")\\\";\\r\\n    }\\r\\n\\r\\n    return function(){\\r\\n        this.reset = reset;\\r\\n        this.rotate = rotate;\\r\\n        this.rotateX = rotateX;\\r\\n        this.rotateY = rotateY;\\r\\n        this.rotateZ = rotateZ;\\r\\n        this.skew = skew;\\r\\n        this.skewFromAxis = skewFromAxis;\\r\\n        this.shear = shear;\\r\\n        this.scale = scale;\\r\\n        this.setTransform = setTransform;\\r\\n        this.translate = translate;\\r\\n        this.transform = transform;\\r\\n        this.applyToPoint = applyToPoint;\\r\\n        this.applyToX = applyToX;\\r\\n        this.applyToY = applyToY;\\r\\n        this.applyToZ = applyToZ;\\r\\n        this.applyToPointArray = applyToPointArray;\\r\\n        this.applyToTriplePoints = applyToTriplePoints;\\r\\n        this.applyToPointStringified = applyToPointStringified;\\r\\n        this.toCSS = toCSS;\\r\\n        this.to2dCSS = to2dCSS;\\r\\n        this.clone = clone;\\r\\n        this.cloneFromProps = cloneFromProps;\\r\\n        this.equals = equals;\\r\\n        this.inversePoints = inversePoints;\\r\\n        this.inversePoint = inversePoint;\\r\\n        this._t = this.transform;\\r\\n        this.isIdentity = isIdentity;\\r\\n        this._identity = true;\\r\\n        this._identityCalculated = false;\\r\\n\\r\\n        this.props = createTypedArray('float32', 16);\\r\\n        this.reset();\\r\\n    };\\r\\n}());\\r\\n\\n/*\\r\\n Copyright 2014 David Bau.\\r\\n\\r\\n Permission is hereby granted, free of charge, to any person obtaining\\r\\n a copy of this software and associated documentation files (the\\r\\n \\\"Software\\\"), to deal in the Software without restriction, including\\r\\n without limitation the rights to use, copy, modify, merge, publish,\\r\\n distribute, sublicense, and/or sell copies of the Software, and to\\r\\n permit persons to whom the Software is furnished to do so, subject to\\r\\n the following conditions:\\r\\n\\r\\n The above copyright notice and this permission notice shall be\\r\\n included in all copies or substantial portions of the Software.\\r\\n\\r\\n THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND,\\r\\n EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\r\\n MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\\r\\n IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\\r\\n CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\\r\\n TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\\r\\n SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\r\\n\\r\\n */\\r\\n\\r\\n(function (pool, math) {\\r\\n//\\r\\n// The following constants are related to IEEE 754 limits.\\r\\n//\\r\\n    var global = this,\\r\\n        width = 256,        // each RC4 output is 0 <= x < 256\\r\\n        chunks = 6,         // at least six RC4 outputs for each double\\r\\n        digits = 52,        // there are 52 significant digits in a double\\r\\n        rngname = 'random', // rngname: name for Math.random and Math.seedrandom\\r\\n        startdenom = math.pow(width, chunks),\\r\\n        significance = math.pow(2, digits),\\r\\n        overflow = significance * 2,\\r\\n        mask = width - 1,\\r\\n        nodecrypto;         // node.js crypto module, initialized at the bottom.\\r\\n\\r\\n//\\r\\n// seedrandom()\\r\\n// This is the seedrandom function described above.\\r\\n//\\r\\n    function seedrandom(seed, options, callback) {\\r\\n        var key = [];\\r\\n        options = (options === true) ? { entropy: true } : (options || {});\\r\\n\\r\\n        // Flatten the seed string or build one from local entropy if needed.\\r\\n        var shortseed = mixkey(flatten(\\r\\n            options.entropy ? [seed, tostring(pool)] :\\r\\n                (seed === null) ? autoseed() : seed, 3), key);\\r\\n\\r\\n        // Use the seed to initialize an ARC4 generator.\\r\\n        var arc4 = new ARC4(key);\\r\\n\\r\\n        // This function returns a random double in [0, 1) that contains\\r\\n        // randomness in every bit of the mantissa of the IEEE 754 value.\\r\\n        var prng = function() {\\r\\n            var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48\\r\\n                d = startdenom,                 //   and denominator d = 2 ^ 48.\\r\\n                x = 0;                          //   and no 'extra last byte'.\\r\\n            while (n < significance) {          // Fill up all significant digits by\\r\\n                n = (n + x) * width;              //   shifting numerator and\\r\\n                d *= width;                       //   denominator and generating a\\r\\n                x = arc4.g(1);                    //   new least-significant-byte.\\r\\n            }\\r\\n            while (n >= overflow) {             // To avoid rounding up, before adding\\r\\n                n /= 2;                           //   last byte, shift everything\\r\\n                d /= 2;                           //   right using integer math until\\r\\n                x >>>= 1;                         //   we have exactly the desired bits.\\r\\n            }\\r\\n            return (n + x) / d;                 // Form the number within [0, 1).\\r\\n        };\\r\\n\\r\\n        prng.int32 = function() { return arc4.g(4) | 0; };\\r\\n        prng.quick = function() { return arc4.g(4) / 0x100000000; };\\r\\n        prng.double = prng;\\r\\n\\r\\n        // Mix the randomness into accumulated entropy.\\r\\n        mixkey(tostring(arc4.S), pool);\\r\\n\\r\\n        // Calling convention: what to return as a function of prng, seed, is_math.\\r\\n        return (options.pass || callback ||\\r\\n        function(prng, seed, is_math_call, state) {\\r\\n            if (state) {\\r\\n                // Load the arc4 state from the given state if it has an S array.\\r\\n                if (state.S) { copy(state, arc4); }\\r\\n                // Only provide the .state method if requested via options.state.\\r\\n                prng.state = function() { return copy(arc4, {}); };\\r\\n            }\\r\\n\\r\\n            // If called as a method of Math (Math.seedrandom()), mutate\\r\\n            // Math.random because that is how seedrandom.js has worked since v1.0.\\r\\n            if (is_math_call) { math[rngname] = prng; return seed; }\\r\\n\\r\\n            // Otherwise, it is a newer calling convention, so return the\\r\\n            // prng directly.\\r\\n            else return prng;\\r\\n        })(\\r\\n            prng,\\r\\n            shortseed,\\r\\n            'global' in options ? options.global : (this == math),\\r\\n            options.state);\\r\\n    }\\r\\n    math['seed' + rngname] = seedrandom;\\r\\n\\r\\n//\\r\\n// ARC4\\r\\n//\\r\\n// An ARC4 implementation.  The constructor takes a key in the form of\\r\\n// an array of at most (width) integers that should be 0 <= x < (width).\\r\\n//\\r\\n// The g(count) method returns a pseudorandom integer that concatenates\\r\\n// the next (count) outputs from ARC4.  Its return value is a number x\\r\\n// that is in the range 0 <= x < (width ^ count).\\r\\n//\\r\\n    function ARC4(key) {\\r\\n        var t, keylen = key.length,\\r\\n            me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];\\r\\n\\r\\n        // The empty key [] is treated as [0].\\r\\n        if (!keylen) { key = [keylen++]; }\\r\\n\\r\\n        // Set up S using the standard key scheduling algorithm.\\r\\n        while (i < width) {\\r\\n            s[i] = i++;\\r\\n        }\\r\\n        for (i = 0; i < width; i++) {\\r\\n            s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];\\r\\n            s[j] = t;\\r\\n        }\\r\\n\\r\\n        // The \\\"g\\\" method returns the next (count) outputs as one number.\\r\\n        me.g = function(count) {\\r\\n            // Using instance members instead of closure state nearly doubles speed.\\r\\n            var t, r = 0,\\r\\n                i = me.i, j = me.j, s = me.S;\\r\\n            while (count--) {\\r\\n                t = s[i = mask & (i + 1)];\\r\\n                r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];\\r\\n            }\\r\\n            me.i = i; me.j = j;\\r\\n            return r;\\r\\n            // For robust unpredictability, the function call below automatically\\r\\n            // discards an initial batch of values.  This is called RC4-drop[256].\\r\\n            // See http://google.com/search?q=rsa+fluhrer+response&btnI\\r\\n        };\\r\\n    }\\r\\n\\r\\n//\\r\\n// copy()\\r\\n// Copies internal state of ARC4 to or from a plain object.\\r\\n//\\r\\n    function copy(f, t) {\\r\\n        t.i = f.i;\\r\\n        t.j = f.j;\\r\\n        t.S = f.S.slice();\\r\\n        return t;\\r\\n    }\\r\\n\\r\\n//\\r\\n// flatten()\\r\\n// Converts an object tree to nested arrays of strings.\\r\\n//\\r\\n    function flatten(obj, depth) {\\r\\n        var result = [], typ = (typeof obj), prop;\\r\\n        if (depth && typ == 'object') {\\r\\n            for (prop in obj) {\\r\\n                try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}\\r\\n            }\\r\\n        }\\r\\n        return (result.length ? result : typ == 'string' ? obj : obj + '\\\\0');\\r\\n    }\\r\\n\\r\\n//\\r\\n// mixkey()\\r\\n// Mixes a string seed into a key that is an array of integers, and\\r\\n// returns a shortened string seed that is equivalent to the result key.\\r\\n//\\r\\n    function mixkey(seed, key) {\\r\\n        var stringseed = seed + '', smear, j = 0;\\r\\n        while (j < stringseed.length) {\\r\\n            key[mask & j] =\\r\\n                mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));\\r\\n        }\\r\\n        return tostring(key);\\r\\n    }\\r\\n\\r\\n//\\r\\n// autoseed()\\r\\n// Returns an object for autoseeding, using window.crypto and Node crypto\\r\\n// module if available.\\r\\n//\\r\\n    function autoseed() {\\r\\n        try {\\r\\n            if (nodecrypto) { return tostring(nodecrypto.randomBytes(width)); }\\r\\n            var out = new Uint8Array(width);\\r\\n            (global.crypto || global.msCrypto).getRandomValues(out);\\r\\n            return tostring(out);\\r\\n        } catch (e) {\\r\\n            var browser = global.navigator,\\r\\n                plugins = browser && browser.plugins;\\r\\n            return [+new Date(), global, plugins, global.screen, tostring(pool)];\\r\\n        }\\r\\n    }\\r\\n\\r\\n//\\r\\n// tostring()\\r\\n// Converts an array of charcodes to a string\\r\\n//\\r\\n    function tostring(a) {\\r\\n        return String.fromCharCode.apply(0, a);\\r\\n    }\\r\\n\\r\\n//\\r\\n// When seedrandom.js is loaded, we immediately mix a few bits\\r\\n// from the built-in RNG into the entropy pool.  Because we do\\r\\n// not want to interfere with deterministic PRNG state later,\\r\\n// seedrandom will not call math.random on its own again after\\r\\n// initialization.\\r\\n//\\r\\n    mixkey(math.random(), pool);\\r\\n\\r\\n//\\r\\n// Nodejs and AMD support: export the implementation as a module using\\r\\n// either convention.\\r\\n//\\r\\n\\r\\n// End anonymous scope, and pass initial values.\\r\\n})(\\r\\n    [],     // pool: entropy pool starts empty\\r\\n    BMMath    // math: package containing random, pow, and seedrandom\\r\\n);\\nvar BezierFactory = (function(){\\r\\n    /**\\r\\n     * BezierEasing - use bezier curve for transition easing function\\r\\n     * by Gaëtan Renaudeau 2014 - 2015 – MIT License\\r\\n     *\\r\\n     * Credits: is based on Firefox's nsSMILKeySpline.cpp\\r\\n     * Usage:\\r\\n     * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])\\r\\n     * spline.get(x) => returns the easing value | x must be in [0, 1] range\\r\\n     *\\r\\n     */\\r\\n\\r\\n        var ob = {};\\r\\n    ob.getBezierEasing = getBezierEasing;\\r\\n    var beziers = {};\\r\\n\\r\\n    function getBezierEasing(a,b,c,d,nm){\\r\\n        var str = nm || ('bez_' + a+'_'+b+'_'+c+'_'+d).replace(/\\\\./g, 'p');\\r\\n        if(beziers[str]){\\r\\n            return beziers[str];\\r\\n        }\\r\\n        var bezEasing = new BezierEasing([a,b,c,d]);\\r\\n        beziers[str] = bezEasing;\\r\\n        return bezEasing;\\r\\n    }\\r\\n\\r\\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\\r\\n    var NEWTON_ITERATIONS = 4;\\r\\n    var NEWTON_MIN_SLOPE = 0.001;\\r\\n    var SUBDIVISION_PRECISION = 0.0000001;\\r\\n    var SUBDIVISION_MAX_ITERATIONS = 10;\\r\\n\\r\\n    var kSplineTableSize = 11;\\r\\n    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\\r\\n\\r\\n    var float32ArraySupported = typeof Float32Array === \\\"function\\\";\\r\\n\\r\\n    function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\\r\\n    function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\\r\\n    function C (aA1)      { return 3.0 * aA1; }\\r\\n\\r\\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\\r\\n    function calcBezier (aT, aA1, aA2) {\\r\\n        return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;\\r\\n    }\\r\\n\\r\\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\\r\\n    function getSlope (aT, aA1, aA2) {\\r\\n        return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\\r\\n    }\\r\\n\\r\\n    function binarySubdivide (aX, aA, aB, mX1, mX2) {\\r\\n        var currentX, currentT, i = 0;\\r\\n        do {\\r\\n            currentT = aA + (aB - aA) / 2.0;\\r\\n            currentX = calcBezier(currentT, mX1, mX2) - aX;\\r\\n            if (currentX > 0.0) {\\r\\n                aB = currentT;\\r\\n            } else {\\r\\n                aA = currentT;\\r\\n            }\\r\\n        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\\r\\n        return currentT;\\r\\n    }\\r\\n\\r\\n    function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {\\r\\n        for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\\r\\n            var currentSlope = getSlope(aGuessT, mX1, mX2);\\r\\n            if (currentSlope === 0.0) return aGuessT;\\r\\n            var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\\r\\n            aGuessT -= currentX / currentSlope;\\r\\n        }\\r\\n        return aGuessT;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * points is an array of [ mX1, mY1, mX2, mY2 ]\\r\\n     */\\r\\n    function BezierEasing (points) {\\r\\n        this._p = points;\\r\\n        this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\\r\\n        this._precomputed = false;\\r\\n\\r\\n        this.get = this.get.bind(this);\\r\\n    }\\r\\n\\r\\n    BezierEasing.prototype = {\\r\\n\\r\\n        get: function (x) {\\r\\n            var mX1 = this._p[0],\\r\\n                mY1 = this._p[1],\\r\\n                mX2 = this._p[2],\\r\\n                mY2 = this._p[3];\\r\\n            if (!this._precomputed) this._precompute();\\r\\n            if (mX1 === mY1 && mX2 === mY2) return x; // linear\\r\\n            // Because JavaScript number are imprecise, we should guarantee the extremes are right.\\r\\n            if (x === 0) return 0;\\r\\n            if (x === 1) return 1;\\r\\n            return calcBezier(this._getTForX(x), mY1, mY2);\\r\\n        },\\r\\n\\r\\n        // Private part\\r\\n\\r\\n        _precompute: function () {\\r\\n            var mX1 = this._p[0],\\r\\n                mY1 = this._p[1],\\r\\n                mX2 = this._p[2],\\r\\n                mY2 = this._p[3];\\r\\n            this._precomputed = true;\\r\\n            if (mX1 !== mY1 || mX2 !== mY2)\\r\\n                this._calcSampleValues();\\r\\n        },\\r\\n\\r\\n        _calcSampleValues: function () {\\r\\n            var mX1 = this._p[0],\\r\\n                mX2 = this._p[2];\\r\\n            for (var i = 0; i < kSplineTableSize; ++i) {\\r\\n                this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\\r\\n            }\\r\\n        },\\r\\n\\r\\n        /**\\r\\n         * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.\\r\\n         */\\r\\n        _getTForX: function (aX) {\\r\\n            var mX1 = this._p[0],\\r\\n                mX2 = this._p[2],\\r\\n                mSampleValues = this._mSampleValues;\\r\\n\\r\\n            var intervalStart = 0.0;\\r\\n            var currentSample = 1;\\r\\n            var lastSample = kSplineTableSize - 1;\\r\\n\\r\\n            for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {\\r\\n                intervalStart += kSampleStepSize;\\r\\n            }\\r\\n            --currentSample;\\r\\n\\r\\n            // Interpolate to provide an initial guess for t\\r\\n            var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);\\r\\n            var guessForT = intervalStart + dist * kSampleStepSize;\\r\\n\\r\\n            var initialSlope = getSlope(guessForT, mX1, mX2);\\r\\n            if (initialSlope >= NEWTON_MIN_SLOPE) {\\r\\n                return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\\r\\n            } else if (initialSlope === 0.0) {\\r\\n                return guessForT;\\r\\n            } else {\\r\\n                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n\\r\\n    return ob;\\r\\n\\r\\n}());\\n(function () {\\r\\n    var lastTime = 0;\\r\\n    var vendors = ['ms', 'moz', 'webkit', 'o'];\\r\\n    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\\r\\n        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\\r\\n        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];\\r\\n    }\\r\\n    if(!window.requestAnimationFrame)\\r\\n        window.requestAnimationFrame = function (callback, element) {\\r\\n            var currTime = new Date().getTime();\\r\\n            var timeToCall = Math.max(0, 16 - (currTime - lastTime));\\r\\n            var id = setTimeout(function () {\\r\\n                    callback(currTime + timeToCall);\\r\\n                },\\r\\n                timeToCall);\\r\\n            lastTime = currTime + timeToCall;\\r\\n            return id;\\r\\n        };\\r\\n    if(!window.cancelAnimationFrame)\\r\\n        window.cancelAnimationFrame = function (id) {\\r\\n            clearTimeout(id);\\r\\n        };\\r\\n}());\\r\\n\\nfunction extendPrototype(sources,destination){\\r\\n    var i, len = sources.length, sourcePrototype;\\r\\n    for (i = 0;i < len;i += 1) {\\r\\n        sourcePrototype = sources[i].prototype;\\r\\n        for (var attr in sourcePrototype) {\\r\\n            if (sourcePrototype.hasOwnProperty(attr)) destination.prototype[attr] = sourcePrototype[attr];\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nfunction getDescriptor(object, prop) {\\r\\n    return Object.getOwnPropertyDescriptor(object, prop);\\r\\n}\\r\\n\\r\\nfunction createProxyFunction(prototype) {\\r\\n\\tfunction ProxyFunction(){}\\r\\n\\tProxyFunction.prototype = prototype;\\r\\n\\treturn ProxyFunction;\\r\\n}\\nfunction bezFunction(){\\r\\n\\r\\n    var easingFunctions = [];\\r\\n    var math = Math;\\r\\n\\r\\n    function pointOnLine2D(x1,y1, x2,y2, x3,y3){\\r\\n        var det1 = (x1*y2) + (y1*x3) + (x2*y3) - (x3*y2) - (y3*x1) - (x2*y1);\\r\\n        return det1 > -0.001 && det1 < 0.001;\\r\\n    }\\r\\n\\r\\n    function pointOnLine3D(x1,y1,z1, x2,y2,z2, x3,y3,z3){\\r\\n        if(z1 === 0 && z2 === 0 && z3 === 0) {\\r\\n            return pointOnLine2D(x1,y1, x2,y2, x3,y3);\\r\\n        }\\r\\n        var dist1 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) + Math.pow(z2 - z1, 2));\\r\\n        var dist2 = Math.sqrt(Math.pow(x3 - x1, 2) + Math.pow(y3 - y1, 2) + Math.pow(z3 - z1, 2));\\r\\n        var dist3 = Math.sqrt(Math.pow(x3 - x2, 2) + Math.pow(y3 - y2, 2) + Math.pow(z3 - z2, 2));\\r\\n        var diffDist;\\r\\n        if(dist1 > dist2){\\r\\n            if(dist1 > dist3){\\r\\n                diffDist = dist1 - dist2 - dist3;\\r\\n            } else {\\r\\n                diffDist = dist3 - dist2 - dist1;\\r\\n            }\\r\\n        } else if(dist3 > dist2){\\r\\n            diffDist = dist3 - dist2 - dist1;\\r\\n        } else {\\r\\n            diffDist = dist2 - dist1 - dist3;\\r\\n        }\\r\\n        return diffDist > -0.0001 && diffDist < 0.0001;\\r\\n    }\\r\\n\\r\\n    var getBezierLength = (function(){\\r\\n\\r\\n        return function(pt1,pt2,pt3,pt4){\\r\\n            var curveSegments = defaultCurveSegments;\\r\\n            var k;\\r\\n            var i, len;\\r\\n            var ptCoord,perc,addedLength = 0;\\r\\n            var ptDistance;\\r\\n            var point = [],lastPoint = [];\\r\\n            var lengthData = bezier_length_pool.newElement();\\r\\n            len = pt3.length;\\r\\n            for(k=0;k<curveSegments;k+=1){\\r\\n                perc = k/(curveSegments-1);\\r\\n                ptDistance = 0;\\r\\n                for(i=0;i<len;i+=1){\\r\\n                    ptCoord = bm_pow(1-perc,3)*pt1[i]+3*bm_pow(1-perc,2)*perc*pt3[i]+3*(1-perc)*bm_pow(perc,2)*pt4[i]+bm_pow(perc,3)*pt2[i];\\r\\n                    point[i] = ptCoord;\\r\\n                    if(lastPoint[i] !== null){\\r\\n                        ptDistance += bm_pow(point[i] - lastPoint[i],2);\\r\\n                    }\\r\\n                    lastPoint[i] = point[i];\\r\\n                }\\r\\n                if(ptDistance){\\r\\n                    ptDistance = bm_sqrt(ptDistance);\\r\\n                    addedLength += ptDistance;\\r\\n                }\\r\\n                lengthData.percents[k] = perc;\\r\\n                lengthData.lengths[k] = addedLength;\\r\\n            }\\r\\n            lengthData.addedLength = addedLength;\\r\\n            return lengthData;\\r\\n        };\\r\\n    }());\\r\\n\\r\\n    function getSegmentsLength(shapeData) {\\r\\n        var segmentsLength = segments_length_pool.newElement();\\r\\n        var closed = shapeData.c;\\r\\n        var pathV = shapeData.v;\\r\\n        var pathO = shapeData.o;\\r\\n        var pathI = shapeData.i;\\r\\n        var i, len = shapeData._length;\\r\\n        var lengths = segmentsLength.lengths;\\r\\n        var totalLength = 0;\\r\\n        for(i=0;i<len-1;i+=1){\\r\\n            lengths[i] = getBezierLength(pathV[i],pathV[i+1],pathO[i],pathI[i+1]);\\r\\n            totalLength += lengths[i].addedLength;\\r\\n        }\\r\\n        if(closed && len){\\r\\n            lengths[i] = getBezierLength(pathV[i],pathV[0],pathO[i],pathI[0]);\\r\\n            totalLength += lengths[i].addedLength;\\r\\n        }\\r\\n        segmentsLength.totalLength = totalLength;\\r\\n        return segmentsLength;\\r\\n    }\\r\\n\\r\\n    function BezierData(length){\\r\\n        this.segmentLength = 0;\\r\\n        this.points = new Array(length);\\r\\n    }\\r\\n\\r\\n    function PointData(partial,point){\\r\\n        this.partialLength = partial;\\r\\n        this.point = point;\\r\\n    }\\r\\n\\r\\n    var buildBezierData = (function(){\\r\\n\\r\\n        var storedData = {};\\r\\n\\r\\n        return function (keyData){\\r\\n            var pt1 = keyData.s;\\r\\n            var pt2 = keyData.e;\\r\\n            var pt3 = keyData.to;\\r\\n            var pt4 = keyData.ti;\\r\\n            var bezierName = (pt1[0]+'_'+pt1[1]+'_'+pt2[0]+'_'+pt2[1]+'_'+pt3[0]+'_'+pt3[1]+'_'+pt4[0]+'_'+pt4[1]).replace(/\\\\./g, 'p');\\r\\n            if(storedData[bezierName]){\\r\\n                keyData.bezierData = storedData[bezierName];\\r\\n                return;\\r\\n            }\\r\\n            var curveSegments = defaultCurveSegments;\\r\\n            var k, i, len;\\r\\n            var ptCoord,perc,addedLength = 0;\\r\\n            var ptDistance;\\r\\n            var point,lastPoint = null;\\r\\n            if (pt1.length === 2 && (pt1[0] != pt2[0] || pt1[1] != pt2[1]) && pointOnLine2D(pt1[0],pt1[1],pt2[0],pt2[1],pt1[0]+pt3[0],pt1[1]+pt3[1]) && pointOnLine2D(pt1[0],pt1[1],pt2[0],pt2[1],pt2[0]+pt4[0],pt2[1]+pt4[1])){\\r\\n                curveSegments = 2;\\r\\n            }\\r\\n            var bezierData = new BezierData(curveSegments);\\r\\n            len = pt3.length;\\r\\n            for (k = 0; k < curveSegments; k += 1) {\\r\\n                point = createSizedArray(len);\\r\\n                perc = k / (curveSegments - 1);\\r\\n                ptDistance = 0;\\r\\n                for (i = 0; i < len; i += 1){\\r\\n                    ptCoord = bm_pow(1-perc,3)*pt1[i]+3*bm_pow(1-perc,2)*perc*(pt1[i] + pt3[i])+3*(1-perc)*bm_pow(perc,2)*(pt2[i] + pt4[i])+bm_pow(perc,3)*pt2[i];\\r\\n                    point[i] = ptCoord;\\r\\n                    if(lastPoint !== null){\\r\\n                        ptDistance += bm_pow(point[i] - lastPoint[i],2);\\r\\n                    }\\r\\n                }\\r\\n                ptDistance = bm_sqrt(ptDistance);\\r\\n                addedLength += ptDistance;\\r\\n                bezierData.points[k] = new PointData(ptDistance, point);\\r\\n                lastPoint = point;\\r\\n            }\\r\\n            bezierData.segmentLength = addedLength;\\r\\n            keyData.bezierData = bezierData;\\r\\n            storedData[bezierName] = bezierData;\\r\\n        };\\r\\n    }());\\r\\n\\r\\n    function getDistancePerc(perc,bezierData){\\r\\n        var percents = bezierData.percents;\\r\\n        var lengths = bezierData.lengths;\\r\\n        var len = percents.length;\\r\\n        var initPos = bm_floor((len-1)*perc);\\r\\n        var lengthPos = perc*bezierData.addedLength;\\r\\n        var lPerc = 0;\\r\\n        if(initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]){\\r\\n            return percents[initPos];\\r\\n        }else{\\r\\n            var dir = lengths[initPos] > lengthPos ? -1 : 1;\\r\\n            var flag = true;\\r\\n            while(flag){\\r\\n                if(lengths[initPos] <= lengthPos && lengths[initPos+1] > lengthPos){\\r\\n                    lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos+1] - lengths[initPos]);\\r\\n                    flag = false;\\r\\n                }else{\\r\\n                    initPos += dir;\\r\\n                }\\r\\n                if(initPos < 0 || initPos >= len - 1){\\r\\n                    //FIX for TypedArrays that don't store floating point values with enough accuracy\\r\\n                    if(initPos === len - 1) {\\r\\n                        return percents[initPos];\\r\\n                    }\\r\\n                    flag = false;\\r\\n                }\\r\\n            }\\r\\n            return percents[initPos] + (percents[initPos+1] - percents[initPos])*lPerc;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {\\r\\n        var t1 = getDistancePerc(percent,bezierData);\\r\\n        var u0 = 1;\\r\\n        var u1 = 1 - t1;\\r\\n        var ptX = Math.round((u1*u1*u1* pt1[0] + (t1*u1*u1 + u1*t1*u1 + u1*u1*t1)* pt3[0] + (t1*t1*u1 + u1*t1*t1 + t1*u1*t1)*pt4[0] + t1*t1*t1* pt2[0])* 1000) / 1000;\\r\\n        var ptY = Math.round((u1*u1*u1* pt1[1] + (t1*u1*u1 + u1*t1*u1 + u1*u1*t1)* pt3[1] + (t1*t1*u1 + u1*t1*t1 + t1*u1*t1)*pt4[1] + t1*t1*t1* pt2[1])* 1000) / 1000;\\r\\n        return [ptX, ptY];\\r\\n    }\\r\\n\\r\\n    function getSegmentArray() {\\r\\n\\r\\n    }\\r\\n\\r\\n    var bezier_segment_points = createTypedArray('float32', 8);\\r\\n\\r\\n    function getNewSegment(pt1,pt2,pt3,pt4,startPerc,endPerc, bezierData){\\r\\n\\r\\n        startPerc = startPerc < 0 ? 0 : startPerc > 1 ? 1 : startPerc;\\r\\n        var t0 = getDistancePerc(startPerc,bezierData);\\r\\n        endPerc = endPerc > 1 ? 1 : endPerc;\\r\\n        var t1 = getDistancePerc(endPerc,bezierData);\\r\\n        var i, len = pt1.length;\\r\\n        var u0 = 1 - t0;\\r\\n        var u1 = 1 - t1;\\r\\n        var u0u0u0 = u0*u0*u0;\\r\\n        var t0u0u0_3 = t0*u0*u0*3;\\r\\n        var t0t0u0_3 = t0*t0*u0*3;\\r\\n        var t0t0t0 = t0*t0*t0;\\r\\n        //\\r\\n        var u0u0u1 = u0*u0*u1;\\r\\n        var t0u0u1_3 = t0*u0*u1 + u0*t0*u1 + u0*u0*t1;\\r\\n        var t0t0u1_3 = t0*t0*u1 + u0*t0*t1 + t0*u0*t1;\\r\\n        var t0t0t1 = t0*t0*t1;\\r\\n        //\\r\\n        var u0u1u1 = u0*u1*u1;\\r\\n        var t0u1u1_3 = t0*u1*u1 + u0*t1*u1 + u0*u1*t1;\\r\\n        var t0t1u1_3 = t0*t1*u1 + u0*t1*t1 + t0*u1*t1;\\r\\n        var t0t1t1 = t0*t1*t1;\\r\\n        //\\r\\n        var u1u1u1 = u1*u1*u1;\\r\\n        var t1u1u1_3 = t1*u1*u1 + u1*t1*u1 + u1*u1*t1;\\r\\n        var t1t1u1_3 = t1*t1*u1 + u1*t1*t1 + t1*u1*t1;\\r\\n        var t1t1t1 = t1*t1*t1;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            bezier_segment_points[i * 4] = Math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000;\\r\\n            bezier_segment_points[i * 4 + 1] = Math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000;\\r\\n            bezier_segment_points[i * 4 + 2] = Math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000;\\r\\n            bezier_segment_points[i * 4 + 3] = Math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000;\\r\\n        }\\r\\n\\r\\n        return bezier_segment_points;\\r\\n    }\\r\\n\\r\\n    return {\\r\\n        getSegmentsLength : getSegmentsLength,\\r\\n        getNewSegment : getNewSegment,\\r\\n        getPointInSegment : getPointInSegment,\\r\\n        buildBezierData : buildBezierData,\\r\\n        pointOnLine2D : pointOnLine2D,\\r\\n        pointOnLine3D : pointOnLine3D\\r\\n    };\\r\\n}\\r\\n\\r\\nvar bez = bezFunction();\\nfunction dataFunctionManager(){\\r\\n\\r\\n    //var tCanvasHelper = createTag('canvas').getContext('2d');\\r\\n\\r\\n    function completeLayers(layers, comps, fontManager){\\r\\n        var layerData;\\r\\n        var animArray, lastFrame;\\r\\n        var i, len = layers.length;\\r\\n        var j, jLen, k, kLen;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            layerData = layers[i];\\r\\n            if(!('ks' in layerData) || layerData.completed){\\r\\n                continue;\\r\\n            }\\r\\n            layerData.completed = true;\\r\\n            if(layerData.tt){\\r\\n                layers[i-1].td = layerData.tt;\\r\\n            }\\r\\n            animArray = [];\\r\\n            lastFrame = -1;\\r\\n            if(layerData.hasMask){\\r\\n                var maskProps = layerData.masksProperties;\\r\\n                jLen = maskProps.length;\\r\\n                for(j=0;j<jLen;j+=1){\\r\\n                    if(maskProps[j].pt.k.i){\\r\\n                        convertPathsToAbsoluteValues(maskProps[j].pt.k);\\r\\n                    }else{\\r\\n                        kLen = maskProps[j].pt.k.length;\\r\\n                        for(k=0;k<kLen;k+=1){\\r\\n                            if(maskProps[j].pt.k[k].s){\\r\\n                                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);\\r\\n                            }\\r\\n                            if(maskProps[j].pt.k[k].e){\\r\\n                                convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            if(layerData.ty===0){\\r\\n                layerData.layers = findCompLayers(layerData.refId, comps);\\r\\n                completeLayers(layerData.layers,comps, fontManager);\\r\\n            }else if(layerData.ty === 4){\\r\\n                completeShapes(layerData.shapes);\\r\\n            }else if(layerData.ty == 5){\\r\\n                completeText(layerData, fontManager);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function findCompLayers(id,comps){\\r\\n        var i = 0, len = comps.length;\\r\\n        while(i<len){\\r\\n            if(comps[i].id === id){\\r\\n                if(!comps[i].layers.__used) {\\r\\n                    comps[i].layers.__used = true;\\r\\n                    return comps[i].layers;\\r\\n                }\\r\\n                return JSON.parse(JSON.stringify(comps[i].layers));\\r\\n            }\\r\\n            i += 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function completeShapes(arr){\\r\\n        var i, len = arr.length;\\r\\n        var j, jLen;\\r\\n        var hasPaths = false;\\r\\n        for(i=len-1;i>=0;i-=1){\\r\\n            if(arr[i].ty == 'sh'){\\r\\n                if(arr[i].ks.k.i){\\r\\n                    convertPathsToAbsoluteValues(arr[i].ks.k);\\r\\n                }else{\\r\\n                    jLen = arr[i].ks.k.length;\\r\\n                    for(j=0;j<jLen;j+=1){\\r\\n                        if(arr[i].ks.k[j].s){\\r\\n                            convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);\\r\\n                        }\\r\\n                        if(arr[i].ks.k[j].e){\\r\\n                            convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n                hasPaths = true;\\r\\n            }else if(arr[i].ty == 'gr'){\\r\\n                completeShapes(arr[i].it);\\r\\n            }\\r\\n        }\\r\\n        /*if(hasPaths){\\r\\n            //mx: distance\\r\\n            //ss: sensitivity\\r\\n            //dc: decay\\r\\n            arr.splice(arr.length-1,0,{\\r\\n                \\\"ty\\\": \\\"ms\\\",\\r\\n                \\\"mx\\\":20,\\r\\n                \\\"ss\\\":10,\\r\\n                 \\\"dc\\\":0.001,\\r\\n                \\\"maxDist\\\":200\\r\\n            });\\r\\n        }*/\\r\\n    }\\r\\n\\r\\n    function convertPathsToAbsoluteValues(path){\\r\\n        var i, len = path.i.length;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            path.i[i][0] += path.v[i][0];\\r\\n            path.i[i][1] += path.v[i][1];\\r\\n            path.o[i][0] += path.v[i][0];\\r\\n            path.o[i][1] += path.v[i][1];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function checkVersion(minimum,animVersionString){\\r\\n        var animVersion = animVersionString ? animVersionString.split('.') : [100,100,100];\\r\\n        if(minimum[0]>animVersion[0]){\\r\\n            return true;\\r\\n        } else if(animVersion[0] > minimum[0]){\\r\\n            return false;\\r\\n        }\\r\\n        if(minimum[1]>animVersion[1]){\\r\\n            return true;\\r\\n        } else if(animVersion[1] > minimum[1]){\\r\\n            return false;\\r\\n        }\\r\\n        if(minimum[2]>animVersion[2]){\\r\\n            return true;\\r\\n        } else if(animVersion[2] > minimum[2]){\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    var checkText = (function(){\\r\\n        var minimumVersion = [4,4,14];\\r\\n\\r\\n        function updateTextLayer(textLayer){\\r\\n            var documentData = textLayer.t.d;\\r\\n            textLayer.t.d = {\\r\\n                k: [\\r\\n                    {\\r\\n                        s:documentData,\\r\\n                        t:0\\r\\n                    }\\r\\n                ]\\r\\n            };\\r\\n        }\\r\\n\\r\\n        function iterateLayers(layers){\\r\\n            var i, len = layers.length;\\r\\n            for(i=0;i<len;i+=1){\\r\\n                if(layers[i].ty === 5){\\r\\n                    updateTextLayer(layers[i]);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return function (animationData){\\r\\n            if(checkVersion(minimumVersion,animationData.v)){\\r\\n                iterateLayers(animationData.layers);\\r\\n                if(animationData.assets){\\r\\n                    var i, len = animationData.assets.length;\\r\\n                    for(i=0;i<len;i+=1){\\r\\n                        if(animationData.assets[i].layers){\\r\\n                            iterateLayers(animationData.assets[i].layers);\\r\\n\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        };\\r\\n    }());\\r\\n\\r\\n    var checkChars = (function() {\\r\\n        var minimumVersion = [4,7,99];\\r\\n        return function (animationData){\\r\\n            if(animationData.chars && !checkVersion(minimumVersion,animationData.v)){\\r\\n                var i, len = animationData.chars.length, j, jLen, k, kLen;\\r\\n                var pathData, paths;\\r\\n                for(i = 0; i < len; i += 1) {\\r\\n                    if(animationData.chars[i].data && animationData.chars[i].data.shapes) {\\r\\n                        paths = animationData.chars[i].data.shapes[0].it;\\r\\n                        jLen = paths.length;\\r\\n\\r\\n                        for(j = 0; j < jLen; j += 1) {\\r\\n                            pathData = paths[j].ks.k;\\r\\n                            if(!pathData.__converted) {\\r\\n                                convertPathsToAbsoluteValues(paths[j].ks.k);\\r\\n                                pathData.__converted = true;\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        };\\r\\n    }());\\r\\n\\r\\n    var checkColors = (function(){\\r\\n        var minimumVersion = [4,1,9];\\r\\n\\r\\n        function iterateShapes(shapes){\\r\\n            var i, len = shapes.length;\\r\\n            var j, jLen;\\r\\n            for(i=0;i<len;i+=1){\\r\\n                if(shapes[i].ty === 'gr'){\\r\\n                    iterateShapes(shapes[i].it);\\r\\n                }else if(shapes[i].ty === 'fl' || shapes[i].ty === 'st'){\\r\\n                    if(shapes[i].c.k && shapes[i].c.k[0].i){\\r\\n                        jLen = shapes[i].c.k.length;\\r\\n                        for(j=0;j<jLen;j+=1){\\r\\n                            if(shapes[i].c.k[j].s){\\r\\n                                shapes[i].c.k[j].s[0] /= 255;\\r\\n                                shapes[i].c.k[j].s[1] /= 255;\\r\\n                                shapes[i].c.k[j].s[2] /= 255;\\r\\n                                shapes[i].c.k[j].s[3] /= 255;\\r\\n                            }\\r\\n                            if(shapes[i].c.k[j].e){\\r\\n                                shapes[i].c.k[j].e[0] /= 255;\\r\\n                                shapes[i].c.k[j].e[1] /= 255;\\r\\n                                shapes[i].c.k[j].e[2] /= 255;\\r\\n                                shapes[i].c.k[j].e[3] /= 255;\\r\\n                            }\\r\\n                        }\\r\\n                    } else {\\r\\n                        shapes[i].c.k[0] /= 255;\\r\\n                        shapes[i].c.k[1] /= 255;\\r\\n                        shapes[i].c.k[2] /= 255;\\r\\n                        shapes[i].c.k[3] /= 255;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        function iterateLayers(layers){\\r\\n            var i, len = layers.length;\\r\\n            for(i=0;i<len;i+=1){\\r\\n                if(layers[i].ty === 4){\\r\\n                    iterateShapes(layers[i].shapes);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return function (animationData){\\r\\n            if(checkVersion(minimumVersion,animationData.v)){\\r\\n                iterateLayers(animationData.layers);\\r\\n                if(animationData.assets){\\r\\n                    var i, len = animationData.assets.length;\\r\\n                    for(i=0;i<len;i+=1){\\r\\n                        if(animationData.assets[i].layers){\\r\\n                            iterateLayers(animationData.assets[i].layers);\\r\\n\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        };\\r\\n    }());\\r\\n\\r\\n    var checkShapes = (function(){\\r\\n        var minimumVersion = [4,4,18];\\r\\n\\r\\n\\r\\n\\r\\n        function completeShapes(arr){\\r\\n            var i, len = arr.length;\\r\\n            var j, jLen;\\r\\n            var hasPaths = false;\\r\\n            for(i=len-1;i>=0;i-=1){\\r\\n                if(arr[i].ty == 'sh'){\\r\\n                    if(arr[i].ks.k.i){\\r\\n                        arr[i].ks.k.c = arr[i].closed;\\r\\n                    }else{\\r\\n                        jLen = arr[i].ks.k.length;\\r\\n                        for(j=0;j<jLen;j+=1){\\r\\n                            if(arr[i].ks.k[j].s){\\r\\n                                arr[i].ks.k[j].s[0].c = arr[i].closed;\\r\\n                            }\\r\\n                            if(arr[i].ks.k[j].e){\\r\\n                                arr[i].ks.k[j].e[0].c = arr[i].closed;\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    hasPaths = true;\\r\\n                }else if(arr[i].ty == 'gr'){\\r\\n                    completeShapes(arr[i].it);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        function iterateLayers(layers){\\r\\n            var layerData;\\r\\n            var i, len = layers.length;\\r\\n            var j, jLen, k, kLen;\\r\\n            for(i=0;i<len;i+=1){\\r\\n                layerData = layers[i];\\r\\n                if(layerData.hasMask){\\r\\n                    var maskProps = layerData.masksProperties;\\r\\n                    jLen = maskProps.length;\\r\\n                    for(j=0;j<jLen;j+=1){\\r\\n                        if(maskProps[j].pt.k.i){\\r\\n                            maskProps[j].pt.k.c = maskProps[j].cl;\\r\\n                        }else{\\r\\n                            kLen = maskProps[j].pt.k.length;\\r\\n                            for(k=0;k<kLen;k+=1){\\r\\n                                if(maskProps[j].pt.k[k].s){\\r\\n                                    maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;\\r\\n                                }\\r\\n                                if(maskProps[j].pt.k[k].e){\\r\\n                                    maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;\\r\\n                                }\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n                if(layerData.ty === 4){\\r\\n                    completeShapes(layerData.shapes);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return function (animationData){\\r\\n            if(checkVersion(minimumVersion,animationData.v)){\\r\\n                iterateLayers(animationData.layers);\\r\\n                if(animationData.assets){\\r\\n                    var i, len = animationData.assets.length;\\r\\n                    for(i=0;i<len;i+=1){\\r\\n                        if(animationData.assets[i].layers){\\r\\n                            iterateLayers(animationData.assets[i].layers);\\r\\n\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        };\\r\\n    }());\\r\\n\\r\\n    function completeData(animationData, fontManager){\\r\\n        if(animationData.__complete){\\r\\n            return;\\r\\n        }\\r\\n        checkColors(animationData);\\r\\n        checkText(animationData);\\r\\n        checkChars(animationData);\\r\\n        checkShapes(animationData);\\r\\n        completeLayers(animationData.layers, animationData.assets, fontManager);\\r\\n        animationData.__complete = true;\\r\\n        //blitAnimation(animationData, animationData.assets, fontManager);\\r\\n    }\\r\\n\\r\\n    function completeText(data, fontManager){\\r\\n        if(data.t.a.length === 0 && !('m' in data.t.p)){\\r\\n            data.singleShape = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    var moduleOb = {};\\r\\n    moduleOb.completeData = completeData;\\r\\n\\r\\n    return moduleOb;\\r\\n}\\r\\n\\r\\nvar dataManager = dataFunctionManager();\\nvar FontManager = (function(){\\r\\n\\r\\n    var maxWaitingTime = 5000;\\r\\n    var emptyChar = {\\r\\n        w: 0,\\r\\n        size:0,\\r\\n        shapes:[]\\r\\n    };\\r\\n    var combinedCharacters = [];\\r\\n    //Hindi characters\\r\\n    combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366\\r\\n    , 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379\\r\\n    , 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);\\r\\n\\r\\n    function setUpNode(font, family){\\r\\n        var parentNode = createTag('span');\\r\\n        parentNode.style.fontFamily    = family;\\r\\n        var node = createTag('span');\\r\\n        // Characters that vary significantly among different fonts\\r\\n        node.innerHTML = 'giItT1WQy@!-/#';\\r\\n        // Visible - so we can measure it - but not on the screen\\r\\n        parentNode.style.position      = 'absolute';\\r\\n        parentNode.style.left          = '-10000px';\\r\\n        parentNode.style.top           = '-10000px';\\r\\n        // Large font size makes even subtle changes obvious\\r\\n        parentNode.style.fontSize      = '300px';\\r\\n        // Reset any font properties\\r\\n        parentNode.style.fontVariant   = 'normal';\\r\\n        parentNode.style.fontStyle     = 'normal';\\r\\n        parentNode.style.fontWeight    = 'normal';\\r\\n        parentNode.style.letterSpacing = '0';\\r\\n        parentNode.appendChild(node);\\r\\n        document.body.appendChild(parentNode);\\r\\n\\r\\n        // Remember width with no applied web font\\r\\n        var width = node.offsetWidth;\\r\\n        node.style.fontFamily = font + ', '+family;\\r\\n        return {node:node, w:width, parent:parentNode};\\r\\n    }\\r\\n\\r\\n    function checkLoadedFonts() {\\r\\n        var i, len = this.fonts.length;\\r\\n        var node, w;\\r\\n        var loadedCount = len;\\r\\n        for(i=0;i<len; i+= 1){\\r\\n            if(this.fonts[i].loaded){\\r\\n                loadedCount -= 1;\\r\\n                continue;\\r\\n            }\\r\\n            if(this.fonts[i].fOrigin === 't' || this.fonts[i].origin === 2){\\r\\n                if(window.Typekit && window.Typekit.load && this.typekitLoaded === 0){\\r\\n                    this.typekitLoaded = 1;\\r\\n                    try{window.Typekit.load({\\r\\n                        async: true,\\r\\n                        active: function() {\\r\\n                            this.typekitLoaded = 2;\\r\\n                        }.bind(this)\\r\\n                    });}catch(e){}\\r\\n                }\\r\\n                if(this.typekitLoaded === 2) {\\r\\n                    this.fonts[i].loaded = true;\\r\\n                }\\r\\n            } else if(this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0){\\r\\n                this.fonts[i].loaded = true;\\r\\n            } else{\\r\\n                node = this.fonts[i].monoCase.node;\\r\\n                w = this.fonts[i].monoCase.w;\\r\\n                if(node.offsetWidth !== w){\\r\\n                    loadedCount -= 1;\\r\\n                    this.fonts[i].loaded = true;\\r\\n                }else{\\r\\n                    node = this.fonts[i].sansCase.node;\\r\\n                    w = this.fonts[i].sansCase.w;\\r\\n                    if(node.offsetWidth !== w){\\r\\n                        loadedCount -= 1;\\r\\n                        this.fonts[i].loaded = true;\\r\\n                    }\\r\\n                }\\r\\n                if(this.fonts[i].loaded){\\r\\n                    this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);\\r\\n                    this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime){\\r\\n            setTimeout(this.checkLoadedFonts.bind(this),20);\\r\\n        }else{\\r\\n            setTimeout(function(){this.isLoaded = true;}.bind(this),0);\\r\\n\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function createHelper(def, fontData){\\r\\n        var tHelper = createNS('text');\\r\\n        tHelper.style.fontSize = '100px';\\r\\n        //tHelper.style.fontFamily = fontData.fFamily;\\r\\n        tHelper.setAttribute('font-family', fontData.fFamily);\\r\\n        tHelper.setAttribute('font-style', fontData.fStyle);\\r\\n        tHelper.setAttribute('font-weight', fontData.fWeight);\\r\\n        tHelper.textContent = '1';\\r\\n        if(fontData.fClass){\\r\\n            tHelper.style.fontFamily = 'inherit';\\r\\n            tHelper.className = fontData.fClass;\\r\\n        } else {\\r\\n            tHelper.style.fontFamily = fontData.fFamily;\\r\\n        }\\r\\n        def.appendChild(tHelper);\\r\\n        var tCanvasHelper = createTag('canvas').getContext('2d');\\r\\n        tCanvasHelper.font = fontData.fWeight + ' ' + fontData.fStyle + ' 100px '+ fontData.fFamily;\\r\\n        //tCanvasHelper.font = ' 100px '+ fontData.fFamily;\\r\\n        return tHelper;\\r\\n    }\\r\\n\\r\\n    function addFonts(fontData, defs){\\r\\n        if(!fontData){\\r\\n            this.isLoaded = true;\\r\\n            return;\\r\\n        }\\r\\n        if(this.chars){\\r\\n            this.isLoaded = true;\\r\\n            this.fonts = fontData.list;\\r\\n            return;\\r\\n        }\\r\\n\\r\\n\\r\\n        var fontArr = fontData.list;\\r\\n        var i, len = fontArr.length;\\r\\n        var _pendingFonts = len;\\r\\n        for(i=0; i<len; i+= 1){\\r\\n            fontArr[i].loaded = false;\\r\\n            fontArr[i].monoCase = setUpNode(fontArr[i].fFamily,'monospace');\\r\\n            fontArr[i].sansCase = setUpNode(fontArr[i].fFamily,'sans-serif');\\r\\n            if(!fontArr[i].fPath) {\\r\\n                fontArr[i].loaded = true;\\r\\n                _pendingFonts -= 1;\\r\\n            }else if(fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3){\\r\\n                var s = createTag('style');\\r\\n                s.type = \\\"text/css\\\";\\r\\n                s.innerHTML = \\\"@font-face {\\\" + \\\"font-family: \\\"+fontArr[i].fFamily+\\\"; font-style: normal; src: url('\\\"+fontArr[i].fPath+\\\"');}\\\";\\r\\n                defs.appendChild(s);\\r\\n            } else if(fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1){\\r\\n                var l = createTag('link');\\r\\n                l.type = \\\"text/css\\\";\\r\\n                l.rel = \\\"stylesheet\\\";\\r\\n                l.href = fontArr[i].fPath;\\r\\n                document.body.appendChild(l);\\r\\n            } else if(fontArr[i].fOrigin === 't' || fontArr[i].origin === 2){\\r\\n                var sc = createTag('script');\\r\\n                sc.setAttribute('src',fontArr[i].fPath);\\r\\n                defs.appendChild(sc);\\r\\n            }\\r\\n            fontArr[i].helper = createHelper(defs,fontArr[i]);\\r\\n            fontArr[i].cache = {};\\r\\n            this.fonts.push(fontArr[i]);\\r\\n        }\\r\\n        if (_pendingFonts === 0) {\\r\\n            this.isLoaded = true;\\r\\n        } else {\\r\\n            //On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.\\r\\n            //Adding this timeout seems to fix it\\r\\n           setTimeout(this.checkLoadedFonts.bind(this), 100);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function addChars(chars){\\r\\n        if(!chars){\\r\\n            return;\\r\\n        }\\r\\n        if(!this.chars){\\r\\n            this.chars = [];\\r\\n        }\\r\\n        var i, len = chars.length;\\r\\n        var j, jLen = this.chars.length, found;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            j = 0;\\r\\n            found = false;\\r\\n            while(j<jLen){\\r\\n                if(this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch){\\r\\n                    found = true;\\r\\n                }\\r\\n                j += 1;\\r\\n            }\\r\\n            if(!found){\\r\\n                this.chars.push(chars[i]);\\r\\n                jLen += 1;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getCharData(char, style, font){\\r\\n        var i = 0, len = this.chars.length;\\r\\n        while( i < len) {\\r\\n            if(this.chars[i].ch === char && this.chars[i].style === style && this.chars[i].fFamily === font){\\r\\n                return this.chars[i];\\r\\n            }\\r\\n            i+= 1;\\r\\n        }\\r\\n        if(console && console.warn) {\\r\\n            console.warn('Missing character from exported characters list: ', char, style, font);\\r\\n        }\\r\\n        return emptyChar;\\r\\n    }\\r\\n\\r\\n    function measureText(char, fontName, size) {\\r\\n        var fontData = this.getFontByName(fontName);\\r\\n        var index = char.charCodeAt(0);\\r\\n        if(!fontData.cache[index + 1]) {\\r\\n            var tHelper = fontData.helper;\\r\\n            //Canvas version\\r\\n            //fontData.cache[index] = tHelper.measureText(char).width / 100;\\r\\n            //SVG version\\r\\n            //console.log(tHelper.getBBox().width)\\r\\n            /*tHelper.textContent = '|' + char + '|';\\r\\n            var doubleSize = tHelper.getComputedTextLength();\\r\\n            tHelper.textContent = '||';\\r\\n            var singleSize = tHelper.getComputedTextLength();\\r\\n            fontData.cache[index + 1] = (doubleSize - singleSize)/100;*/\\r\\n           \\r\\n            tHelper.textContent = char;\\r\\n            fontData.cache[index + 1] = (tHelper.getComputedTextLength())/100;\\r\\n        }\\r\\n        return fontData.cache[index + 1] * size;\\r\\n    }\\r\\n\\r\\n    function getFontByName(name){\\r\\n        var i = 0, len = this.fonts.length;\\r\\n        while(i<len){\\r\\n            if(this.fonts[i].fName === name) {\\r\\n                return this.fonts[i];\\r\\n            }\\r\\n            i += 1;\\r\\n        }\\r\\n        return this.fonts[0];\\r\\n    }\\r\\n\\r\\n    function getCombinedCharacterCodes() {\\r\\n        return combinedCharacters;\\r\\n    }\\r\\n\\r\\n    function loaded() {\\r\\n        return this.isLoaded;\\r\\n    }\\r\\n\\r\\n    var Font = function(){\\r\\n        this.fonts = [];\\r\\n        this.chars = null;\\r\\n        this.typekitLoaded = 0;\\r\\n        this.isLoaded = false;\\r\\n        this.initTime = Date.now();\\r\\n    };\\r\\n    //TODO: for now I'm adding these methods to the Class and not the prototype. Think of a better way to implement it. \\r\\n    Font.getCombinedCharacterCodes = getCombinedCharacterCodes;\\r\\n\\r\\n    Font.prototype.addChars = addChars;\\r\\n    Font.prototype.addFonts = addFonts;\\r\\n    Font.prototype.getCharData = getCharData;\\r\\n    Font.prototype.getFontByName = getFontByName;\\r\\n    Font.prototype.measureText = measureText;\\r\\n    Font.prototype.checkLoadedFonts = checkLoadedFonts;\\r\\n    Font.prototype.loaded = loaded;\\r\\n\\r\\n    return Font;\\r\\n\\r\\n}());\\nvar PropertyFactory = (function(){\\r\\n\\r\\n    var initFrame = initialDefaultFrame;\\r\\n    var math_abs = Math.abs;\\r\\n\\r\\n    function interpolateValue(frameNum, caching) {\\r\\n        var offsetTime = this.offsetTime;\\r\\n        var newValue;\\r\\n        if (this.propType === 'multidimensional') {\\r\\n            newValue = createTypedArray('float32', this.pv.length);\\r\\n        }\\r\\n        var iterationIndex = caching.lastIndex;\\r\\n        var i = iterationIndex;\\r\\n        var len = this.keyframes.length - 1, flag = true;\\r\\n        var keyData, nextKeyData;\\r\\n\\r\\n        while (flag) {\\r\\n            keyData = this.keyframes[i];\\r\\n            nextKeyData = this.keyframes[i + 1];\\r\\n            if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime){\\r\\n                if(keyData.h){\\r\\n                    keyData = nextKeyData;\\r\\n                }\\r\\n                iterationIndex = 0;\\r\\n                break;\\r\\n            }\\r\\n            if ((nextKeyData.t - offsetTime) > frameNum){\\r\\n                iterationIndex = i;\\r\\n                break;\\r\\n            }\\r\\n            if (i < len - 1){\\r\\n                i += 1;\\r\\n            } else {\\r\\n                iterationIndex = 0;\\r\\n                flag = false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        var k, kLen, perc, jLen, j, fnc;\\r\\n        var nextKeyTime = nextKeyData.t - offsetTime;\\r\\n        var keyTime = keyData.t - offsetTime;\\r\\n        if (keyData.to) {\\r\\n            if (!keyData.bezierData) {\\r\\n                bez.buildBezierData(keyData);\\r\\n            }\\r\\n            var bezierData = keyData.bezierData;\\r\\n            if (frameNum >= nextKeyTime || frameNum < keyTime) {\\r\\n                var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;\\r\\n                kLen = bezierData.points[ind].point.length;\\r\\n                for (k = 0; k < kLen; k += 1) {\\r\\n                    newValue[k] = bezierData.points[ind].point[k];\\r\\n                }\\r\\n                // caching._lastBezierData = null;\\r\\n            } else {\\r\\n                if (keyData.__fnct) {\\r\\n                    fnc = keyData.__fnct;\\r\\n                } else {\\r\\n                    fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;\\r\\n                    keyData.__fnct = fnc;\\r\\n                }\\r\\n                perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));\\r\\n                var distanceInLine = bezierData.segmentLength*perc;\\r\\n\\r\\n                var segmentPerc;\\r\\n                var addedLength =  (caching.lastFrame < frameNum && caching._lastBezierData === bezierData) ? caching._lastAddedLength : 0;\\r\\n                j =  (caching.lastFrame < frameNum && caching._lastBezierData === bezierData) ? caching._lastPoint : 0;\\r\\n                flag = true;\\r\\n                jLen = bezierData.points.length;\\r\\n                while (flag) {\\r\\n                    addedLength += bezierData.points[j].partialLength;\\r\\n                    if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {\\r\\n                        kLen = bezierData.points[j].point.length;\\r\\n                        for (k = 0; k < kLen; k += 1) {\\r\\n                            newValue[k] = bezierData.points[j].point[k];\\r\\n                        }\\r\\n                        break;\\r\\n                    } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {\\r\\n                        segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;\\r\\n                        kLen = bezierData.points[j].point.length;\\r\\n                        for (k = 0; k < kLen; k += 1) {\\r\\n                            newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;\\r\\n                        }\\r\\n                        break;\\r\\n                    }\\r\\n                    if (j < jLen - 1){\\r\\n                        j += 1;\\r\\n                    } else {\\r\\n                        flag = false;\\r\\n                    }\\r\\n                }\\r\\n                caching._lastPoint = j;\\r\\n                caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;\\r\\n                caching._lastBezierData = bezierData;\\r\\n            }\\r\\n        } else {\\r\\n            var outX, outY, inX, inY, keyValue;\\r\\n            len = keyData.s.length;\\r\\n            if (this.sh && keyData.h !== 1) {\\r\\n                if (frameNum >= nextKeyTime) {\\r\\n                    newValue[0] = keyData.e[0];\\r\\n                    newValue[1] = keyData.e[1];\\r\\n                    newValue[2] = keyData.e[2];\\r\\n                } else if (frameNum <= keyTime) {\\r\\n                    newValue[0] = keyData.s[0];\\r\\n                    newValue[1] = keyData.s[1];\\r\\n                    newValue[2] = keyData.s[2];\\r\\n                } else {\\r\\n                    var quatStart = createQuaternion(keyData.s);\\r\\n                    var quatEnd = createQuaternion(keyData.e);\\r\\n                    var time = (frameNum - keyTime) / (nextKeyTime - keyTime);\\r\\n                    quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));\\r\\n                }\\r\\n                \\r\\n            } else {\\r\\n                for(i = 0; i < len; i += 1) {\\r\\n                    if (keyData.h !== 1) {\\r\\n                        if (frameNum >= nextKeyTime) {\\r\\n                            perc = 1;\\r\\n                        } else if(frameNum < keyTime) {\\r\\n                            perc = 0;\\r\\n                        } else {\\r\\n                            if(keyData.o.x.constructor === Array) {\\r\\n                                if (!keyData.__fnct) {\\r\\n                                    keyData.__fnct = [];\\r\\n                                }\\r\\n                                if (!keyData.__fnct[i]) {\\r\\n                                    outX = keyData.o.x[i] || keyData.o.x[0];\\r\\n                                    outY = keyData.o.y[i] || keyData.o.y[0];\\r\\n                                    inX = keyData.i.x[i] || keyData.i.x[0];\\r\\n                                    inY = keyData.i.y[i] || keyData.i.y[0];\\r\\n                                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;\\r\\n                                    keyData.__fnct[i] = fnc;\\r\\n                                } else {\\r\\n                                    fnc = keyData.__fnct[i];\\r\\n                                }\\r\\n                            } else {\\r\\n                                if (!keyData.__fnct) {\\r\\n                                    outX = keyData.o.x;\\r\\n                                    outY = keyData.o.y;\\r\\n                                    inX = keyData.i.x;\\r\\n                                    inY = keyData.i.y;\\r\\n                                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;\\r\\n                                    keyData.__fnct = fnc;\\r\\n                                } else {\\r\\n                                    fnc = keyData.__fnct;\\r\\n                                }\\r\\n                            }\\r\\n                            perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime ));\\r\\n                        }\\r\\n                    }\\r\\n\\r\\n                    keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (keyData.e[i] - keyData.s[i]) * perc;\\r\\n\\r\\n                    if (len === 1) {\\r\\n                        newValue = keyValue;\\r\\n                    } else {\\r\\n                        newValue[i] = keyValue;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        caching.lastIndex = iterationIndex;\\r\\n        return newValue;\\r\\n    }\\r\\n\\r\\n    //based on @Toji's https://github.com/toji/gl-matrix/\\r\\n    function slerp(a, b, t) {\\r\\n        var out = [];\\r\\n        var ax = a[0], ay = a[1], az = a[2], aw = a[3],\\r\\n        bx = b[0], by = b[1], bz = b[2], bw = b[3]\\r\\n\\r\\n        var omega, cosom, sinom, scale0, scale1;\\r\\n\\r\\n        cosom = ax * bx + ay * by + az * bz + aw * bw;\\r\\n        if (cosom < 0.0) {\\r\\n            cosom = -cosom;\\r\\n            bx = -bx;\\r\\n            by = -by;\\r\\n            bz = -bz;\\r\\n            bw = -bw;\\r\\n        }\\r\\n        if ((1.0 - cosom) > 0.000001) {\\r\\n            omega = Math.acos(cosom);\\r\\n            sinom = Math.sin(omega);\\r\\n            scale0 = Math.sin((1.0 - t) * omega) / sinom;\\r\\n            scale1 = Math.sin(t * omega) / sinom;\\r\\n        } else {\\r\\n            scale0 = 1.0 - t;\\r\\n            scale1 = t;\\r\\n        }\\r\\n        out[0] = scale0 * ax + scale1 * bx;\\r\\n        out[1] = scale0 * ay + scale1 * by;\\r\\n        out[2] = scale0 * az + scale1 * bz;\\r\\n        out[3] = scale0 * aw + scale1 * bw;\\r\\n\\r\\n        return out;\\r\\n    }\\r\\n\\r\\n    function quaternionToEuler(out, quat) {\\r\\n        var qx = quat[0];\\r\\n        var qy = quat[1];\\r\\n        var qz = quat[2];\\r\\n        var qw = quat[3];\\r\\n        var heading = Math.atan2(2*qy*qw-2*qx*qz , 1 - 2*qy*qy - 2*qz*qz)\\r\\n        var attitude = Math.asin(2*qx*qy + 2*qz*qw) \\r\\n        var bank = Math.atan2(2*qx*qw-2*qy*qz , 1 - 2*qx*qx - 2*qz*qz);\\r\\n        out[0] = heading/degToRads;\\r\\n        out[1] = attitude/degToRads;\\r\\n        out[2] = bank/degToRads;\\r\\n    }\\r\\n\\r\\n    function createQuaternion(values) {\\r\\n        var heading = values[0] * degToRads;\\r\\n        var attitude = values[1] * degToRads;\\r\\n        var bank = values[2] * degToRads;\\r\\n        var c1 = Math.cos(heading / 2);\\r\\n        var c2 = Math.cos(attitude / 2);\\r\\n        var c3 = Math.cos(bank / 2);\\r\\n        var s1 = Math.sin(heading / 2);\\r\\n        var s2 = Math.sin(attitude / 2);\\r\\n        var s3 = Math.sin(bank / 2);\\r\\n        var w = c1 * c2 * c3 - s1 * s2 * s3;\\r\\n        var x = s1 * s2 * c3 + c1 * c2 * s3;\\r\\n        var y = s1 * c2 * c3 + c1 * s2 * s3;\\r\\n        var z = c1 * s2 * c3 - s1 * c2 * s3;\\r\\n\\r\\n        return [x,y,z,w];\\r\\n    }\\r\\n\\r\\n    function getValueAtCurrentTime(){\\r\\n        var frameNum = this.comp.renderedFrame - this.offsetTime;\\r\\n        var initTime = this.keyframes[0].t - this.offsetTime;\\r\\n        var endTime = this.keyframes[this.keyframes.length- 1].t-this.offsetTime;\\r\\n        if(!(frameNum === this._caching.lastFrame || (this._caching.lastFrame !== initFrame && ((this._caching.lastFrame >= endTime && frameNum >= endTime) || (this._caching.lastFrame < initTime && frameNum < initTime))))){\\r\\n            if(this._caching.lastFrame >= frameNum) {\\r\\n                this._caching._lastBezierData = null;\\r\\n                this._caching.lastIndex = 0;\\r\\n            }\\r\\n\\r\\n            var renderResult = this.interpolateValue(frameNum, this._caching);\\r\\n            this.pv = renderResult;\\r\\n        }\\r\\n        this._caching.lastFrame = frameNum;\\r\\n        return this.pv;\\r\\n    }\\r\\n\\r\\n    function setVValue(val) {\\r\\n        var multipliedValue;\\r\\n        if(this.propType === 'unidimensional') {\\r\\n            multipliedValue = val * this.mult;\\r\\n            if(math_abs(this.v - multipliedValue) > 0.00001) {\\r\\n                this.v = multipliedValue;\\r\\n                this._mdf = true;\\r\\n            }\\r\\n        } else {\\r\\n            var i = 0, len = this.v.length;\\r\\n            while (i < len) {\\r\\n                multipliedValue = val[i] * this.mult;\\r\\n                if (math_abs(this.v[i] - multipliedValue) > 0.00001) {\\r\\n                    this.v[i] = multipliedValue;\\r\\n                    this._mdf = true;\\r\\n                }\\r\\n                i += 1;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function processEffectsSequence() {\\r\\n        if(this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {\\r\\n            return;\\r\\n        }        \\r\\n        if(this.lock) {\\r\\n            this.setVValue(this.pv);\\r\\n            return;\\r\\n        }\\r\\n        this.lock = true;\\r\\n        this._mdf = this._isFirstFrame;\\r\\n        var multipliedValue;\\r\\n        var i, len = this.effectsSequence.length;\\r\\n        var finalValue = this.kf ? this.pv : this.data.k;\\r\\n        for(i = 0; i < len; i += 1) {\\r\\n            finalValue = this.effectsSequence[i](finalValue);\\r\\n        }\\r\\n        this.setVValue(finalValue);\\r\\n        this._isFirstFrame = false;\\r\\n        this.lock = false;\\r\\n        this.frameId = this.elem.globalData.frameId;\\r\\n    }\\r\\n\\r\\n    function addEffect(effectFunction) {\\r\\n        this.effectsSequence.push(effectFunction);\\r\\n        this.container.addDynamicProperty(this);\\r\\n    }\\r\\n\\r\\n    function ValueProperty(elem, data, mult, container){\\r\\n        this.propType = 'unidimensional';\\r\\n        this.mult = mult || 1;\\r\\n        this.data = data;\\r\\n        this.v = mult ? data.k * mult : data.k;\\r\\n        this.pv = data.k;\\r\\n        this._mdf = false;\\r\\n        this.elem = elem;\\r\\n        this.container = container;\\r\\n        this.comp = elem.comp;\\r\\n        this.k = false;\\r\\n        this.kf = false;\\r\\n        this.vel = 0;\\r\\n        this.effectsSequence = [];\\r\\n        this._isFirstFrame = true;\\r\\n        this.getValue = processEffectsSequence;\\r\\n        this.setVValue = setVValue;\\r\\n        this.addEffect = addEffect;\\r\\n    }\\r\\n\\r\\n    function MultiDimensionalProperty(elem, data, mult, container) {\\r\\n        this.propType = 'multidimensional';\\r\\n        this.mult = mult || 1;\\r\\n        this.data = data;\\r\\n        this._mdf = false;\\r\\n        this.elem = elem;\\r\\n        this.container = container;\\r\\n        this.comp = elem.comp;\\r\\n        this.k = false;\\r\\n        this.kf = false;\\r\\n        this.frameId = -1;\\r\\n        var i, len = data.k.length;\\r\\n        this.v = createTypedArray('float32', len);\\r\\n        this.pv = createTypedArray('float32', len);\\r\\n        var arr = createTypedArray('float32', len);\\r\\n        this.vel = createTypedArray('float32', len);\\r\\n        for (i = 0; i < len; i += 1) {\\r\\n            this.v[i] = data.k[i] * this.mult;\\r\\n            this.pv[i] = data.k[i];\\r\\n        }\\r\\n        this._isFirstFrame = true;\\r\\n        this.effectsSequence = [];\\r\\n        this.getValue = processEffectsSequence;\\r\\n        this.setVValue = setVValue;\\r\\n        this.addEffect = addEffect;\\r\\n    }\\r\\n\\r\\n    function KeyframedValueProperty(elem, data, mult, container) {\\r\\n        this.propType = 'unidimensional';\\r\\n        this.keyframes = data.k;\\r\\n        this.offsetTime = elem.data.st;\\r\\n        this.frameId = -1;\\r\\n        this._caching = {lastFrame: initFrame, lastIndex: 0, value: 0, _lastBezierData: null};\\r\\n        this.k = true;\\r\\n        this.kf = true;\\r\\n        this.data = data;\\r\\n        this.mult = mult || 1;\\r\\n        this.elem = elem;\\r\\n        this.container = container;\\r\\n        this.comp = elem.comp;\\r\\n        this.v = initFrame;\\r\\n        this.pv = initFrame;\\r\\n        this._isFirstFrame = true;\\r\\n        this.getValue = processEffectsSequence;\\r\\n        this.setVValue = setVValue;\\r\\n        this.interpolateValue = interpolateValue;\\r\\n        this.effectsSequence = [getValueAtCurrentTime.bind(this)];\\r\\n        this.addEffect = addEffect;\\r\\n    }\\r\\n\\r\\n    function KeyframedMultidimensionalProperty(elem, data, mult, container){\\r\\n        this.propType = 'multidimensional';\\r\\n        var i, len = data.k.length;\\r\\n        var s, e,to,ti;\\r\\n        for (i = 0; i < len - 1; i += 1) {\\r\\n            if (data.k[i].to && data.k[i].s && data.k[i].e) {\\r\\n                s = data.k[i].s;\\r\\n                e = data.k[i].e;\\r\\n                to = data.k[i].to;\\r\\n                ti = data.k[i].ti;\\r\\n                if((s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0],s[1],e[0],e[1],s[0] + to[0],s[1] + to[1]) && bez.pointOnLine2D(s[0],s[1],e[0],e[1],e[0] + ti[0],e[1] + ti[1])) || (s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0],s[1],s[2],e[0],e[1],e[2],s[0] + to[0],s[1] + to[1],s[2] + to[2]) && bez.pointOnLine3D(s[0],s[1],s[2],e[0],e[1],e[2],e[0] + ti[0],e[1] + ti[1],e[2] + ti[2]))){\\r\\n                    data.k[i].to = null;\\r\\n                    data.k[i].ti = null;\\r\\n                }\\r\\n                if(s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {\\r\\n                    if(s.length === 2 || (s[2] === e[2] && to[2] === 0 && ti[2] === 0)) {\\r\\n                        data.k[i].to = null;\\r\\n                        data.k[i].ti = null;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        this.effectsSequence = [getValueAtCurrentTime.bind(this)];\\r\\n        this.keyframes = data.k;\\r\\n        this.offsetTime = elem.data.st;\\r\\n        this.k = true;\\r\\n        this.kf = true;\\r\\n        this._isFirstFrame = true;\\r\\n        this.mult = mult || 1;\\r\\n        this.elem = elem;\\r\\n        this.container = container;\\r\\n        this.comp = elem.comp;\\r\\n        this.getValue = processEffectsSequence;\\r\\n        this.setVValue = setVValue;\\r\\n        this.interpolateValue = interpolateValue;\\r\\n        this.frameId = -1;\\r\\n        var arrLen = data.k[0].s.length;\\r\\n        this.v = createTypedArray('float32', arrLen);\\r\\n        this.pv = createTypedArray('float32', arrLen);\\r\\n        for (i = 0; i < arrLen; i += 1) {\\r\\n            this.v[i] = initFrame;\\r\\n            this.pv[i] = initFrame;\\r\\n        }\\r\\n        this._caching={lastFrame:initFrame,lastIndex:0,value:createTypedArray('float32', arrLen)};\\r\\n        this.addEffect = addEffect;\\r\\n    }\\r\\n\\r\\n    function getProp(elem,data,type, mult, container) {\\r\\n        var p;\\r\\n        if(data.a === 0){\\r\\n            if(type === 0) {\\r\\n                p = new ValueProperty(elem,data,mult, container);\\r\\n            } else {\\r\\n                p = new MultiDimensionalProperty(elem,data, mult, container);\\r\\n            }\\r\\n        } else if(data.a === 1){\\r\\n            if(type === 0) {\\r\\n                p = new KeyframedValueProperty(elem,data,mult, container);\\r\\n            } else {\\r\\n                p = new KeyframedMultidimensionalProperty(elem,data, mult, container);\\r\\n            }\\r\\n        } else if(!data.k.length){\\r\\n            p = new ValueProperty(elem,data, mult, container);\\r\\n        }else if(typeof(data.k[0]) === 'number'){\\r\\n            p = new MultiDimensionalProperty(elem,data, mult, container);\\r\\n        }else{\\r\\n            switch(type){\\r\\n                case 0:\\r\\n                    p = new KeyframedValueProperty(elem,data,mult, container);\\r\\n                    break;\\r\\n                case 1:\\r\\n                    p = new KeyframedMultidimensionalProperty(elem,data,mult, container);\\r\\n                    break;\\r\\n            }\\r\\n        }\\r\\n        if(p.effectsSequence.length){\\r\\n            container.addDynamicProperty(p);\\r\\n        }\\r\\n        return p;\\r\\n    }\\r\\n\\r\\n    var ob = {\\r\\n        getProp: getProp\\r\\n    };\\r\\n    return ob;\\r\\n}());\\nvar TransformPropertyFactory = (function() {\\r\\n\\r\\n    function applyToMatrix(mat) {\\r\\n        var _mdf = this._mdf;\\r\\n        this.iterateDynamicProperties();\\r\\n        this._mdf = this._mdf || _mdf;\\r\\n        if (this.a) {\\r\\n            mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\\r\\n        }\\r\\n        if (this.s) {\\r\\n            mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\\r\\n        }\\r\\n        if (this.sk) {\\r\\n            mat.skewFromAxis(-this.sk.v, this.sa.v);\\r\\n        }\\r\\n        if (this.r) {\\r\\n            mat.rotate(-this.r.v);\\r\\n        } else {\\r\\n            mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\\r\\n        }\\r\\n        if (this.data.p.s) {\\r\\n            if (this.data.p.z) {\\r\\n                mat.translate(this.px.v, this.py.v, -this.pz.v);\\r\\n            } else {\\r\\n                mat.translate(this.px.v, this.py.v, 0);\\r\\n            }\\r\\n        } else {\\r\\n            mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);\\r\\n        }\\r\\n    }\\r\\n    function processKeys(forceRender){\\r\\n        if (this.elem.globalData.frameId === this.frameId) {\\r\\n            return;\\r\\n        }\\r\\n        if(this._isDirty) {\\r\\n            this.precalculateMatrix();\\r\\n            this._isDirty = false;\\r\\n        }\\r\\n\\r\\n        this.iterateDynamicProperties();\\r\\n\\r\\n        if (this._mdf || forceRender) {\\r\\n            this.v.cloneFromProps(this.pre.props);\\r\\n            if (this.appliedTransformations < 1) {\\r\\n                this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\\r\\n            }\\r\\n            if(this.appliedTransformations < 2) {\\r\\n                this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\\r\\n            }\\r\\n            if (this.sk && this.appliedTransformations < 3) {\\r\\n                this.v.skewFromAxis(-this.sk.v, this.sa.v);\\r\\n            }\\r\\n            if (this.r && this.appliedTransformations < 4) {\\r\\n                this.v.rotate(-this.r.v);\\r\\n            } else if (!this.r && this.appliedTransformations < 4){\\r\\n                this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\\r\\n            }\\r\\n            if (this.autoOriented) {\\r\\n                var v1,v2, frameRate = this.elem.globalData.frameRate;\\r\\n                if(this.p && this.p.keyframes && this.p.getValueAtTime) {\\r\\n                    if (this.p._caching.lastFrame+this.p.offsetTime <= this.p.keyframes[0].t) {\\r\\n                        v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate,0);\\r\\n                        v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);\\r\\n                    } else if(this.p._caching.lastFrame+this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {\\r\\n                        v1 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t / frameRate), 0);\\r\\n                        v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.01) / frameRate, 0);\\r\\n                    } else {\\r\\n                        v1 = this.p.pv;\\r\\n                        v2 = this.p.getValueAtTime((this.p._caching.lastFrame+this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);\\r\\n                    }\\r\\n                } else if(this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {\\r\\n                    v1 = [];\\r\\n                    v2 = [];\\r\\n                    var px = this.px, py = this.py, frameRate;\\r\\n                    if (px._caching.lastFrame+px.offsetTime <= px.keyframes[0].t) {\\r\\n                        v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate,0);\\r\\n                        v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate,0);\\r\\n                        v2[0] = px.getValueAtTime((px.keyframes[0].t) / frameRate,0);\\r\\n                        v2[1] = py.getValueAtTime((py.keyframes[0].t) / frameRate,0);\\r\\n                    } else if(px._caching.lastFrame+px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {\\r\\n                        v1[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t / frameRate),0);\\r\\n                        v1[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t / frameRate),0);\\r\\n                        v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate,0);\\r\\n                        v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate,0);\\r\\n                    } else {\\r\\n                        v1 = [px.pv, py.pv];\\r\\n                        v2[0] = px.getValueAtTime((px._caching.lastFrame+px.offsetTime - 0.01) / frameRate,px.offsetTime);\\r\\n                        v2[1] = py.getValueAtTime((py._caching.lastFrame+py.offsetTime - 0.01) / frameRate,py.offsetTime);\\r\\n                    }\\r\\n                }\\r\\n                this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));\\r\\n            }\\r\\n            if(this.data.p.s){\\r\\n                if(this.data.p.z) {\\r\\n                    this.v.translate(this.px.v, this.py.v, -this.pz.v);\\r\\n                } else {\\r\\n                    this.v.translate(this.px.v, this.py.v, 0);\\r\\n                }\\r\\n            }else{\\r\\n                this.v.translate(this.p.v[0],this.p.v[1],-this.p.v[2]);\\r\\n            }\\r\\n        }\\r\\n        this.frameId = this.elem.globalData.frameId;\\r\\n    }\\r\\n\\r\\n    function precalculateMatrix() {\\r\\n        if(!this.a.k) {\\r\\n            this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\\r\\n            this.appliedTransformations = 1;\\r\\n        } else {\\r\\n            return;\\r\\n        }\\r\\n        if(!this.s.effectsSequence.length) {\\r\\n            this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\\r\\n            this.appliedTransformations = 2;\\r\\n        } else {\\r\\n            return;\\r\\n        }\\r\\n        if(this.sk) {\\r\\n            if(!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {\\r\\n                this.pre.skewFromAxis(-this.sk.v, this.sa.v);\\r\\n            this.appliedTransformations = 3;\\r\\n            } else {\\r\\n                return;\\r\\n            }\\r\\n        }\\r\\n        if (this.r) {\\r\\n            if(!this.r.effectsSequence.length) {\\r\\n                this.pre.rotate(-this.r.v);\\r\\n                this.appliedTransformations = 4;\\r\\n            } else {\\r\\n                return;\\r\\n            }\\r\\n        } else if(!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {\\r\\n            this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\\r\\n            this.appliedTransformations = 4;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function autoOrient(){\\r\\n        //\\r\\n        //var prevP = this.getValueAtTime();\\r\\n    }\\r\\n\\r\\n    function addDynamicProperty(prop) {\\r\\n        this._addDynamicProperty(prop);\\r\\n        this.elem.addDynamicProperty(prop);\\r\\n        this._isDirty = true;\\r\\n    }\\r\\n\\r\\n    function TransformProperty(elem,data,container){\\r\\n        this.elem = elem;\\r\\n        this.frameId = -1;\\r\\n        this.propType = 'transform';\\r\\n        this.data = data;\\r\\n        this.v = new Matrix();\\r\\n        //Precalculated matrix with non animated properties\\r\\n        this.pre = new Matrix();\\r\\n        this.appliedTransformations = 0;\\r\\n        this.initDynamicPropertyContainer(container || elem);\\r\\n        if(data.p.s){\\r\\n            this.px = PropertyFactory.getProp(elem,data.p.x,0,0,this);\\r\\n            this.py = PropertyFactory.getProp(elem,data.p.y,0,0,this);\\r\\n            if(data.p.z){\\r\\n                this.pz = PropertyFactory.getProp(elem,data.p.z,0,0,this);\\r\\n            }\\r\\n        }else{\\r\\n            this.p = PropertyFactory.getProp(elem,data.p,1,0,this);\\r\\n        }\\r\\n        if(data.r) {\\r\\n            this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);\\r\\n        } else if(data.rx) {\\r\\n            this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);\\r\\n            this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);\\r\\n            this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);\\r\\n            if(data.or.k[0].ti) {\\r\\n                var i, len = data.or.k.length;\\r\\n                for(i=0;i<len;i+=1) {\\r\\n                    data.or.k[i].to = data.or.k[i].ti = null;\\r\\n                }\\r\\n            }\\r\\n            this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this);\\r\\n            //sh Indicates it needs to be capped between -180 and 180\\r\\n            this.or.sh = true;\\r\\n        }\\r\\n        if(data.sk){\\r\\n            this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);\\r\\n            this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);\\r\\n        }\\r\\n        if(data.a) {\\r\\n            this.a = PropertyFactory.getProp(elem,data.a,1,0,this);\\r\\n        }\\r\\n        if(data.s) {\\r\\n            this.s = PropertyFactory.getProp(elem,data.s,1,0.01,this);\\r\\n        }\\r\\n        // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.\\r\\n        if(data.o){\\r\\n            this.o = PropertyFactory.getProp(elem,data.o,0,0.01,elem);\\r\\n        } else {\\r\\n            this.o = {_mdf:false,v:1};\\r\\n        }\\r\\n        this._isDirty = true;\\r\\n        if(!this.dynamicProperties.length){\\r\\n            this.getValue(true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    TransformProperty.prototype = {\\r\\n        applyToMatrix: applyToMatrix,\\r\\n        getValue: processKeys,\\r\\n        precalculateMatrix: precalculateMatrix,\\r\\n        autoOrient: autoOrient\\r\\n    }\\r\\n\\r\\n    extendPrototype([DynamicPropertyContainer], TransformProperty);\\r\\n    TransformProperty.prototype.addDynamicProperty = addDynamicProperty;\\r\\n    TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;\\r\\n\\r\\n    function getTransformProperty(elem,data,container){\\r\\n        return new TransformProperty(elem,data,container);\\r\\n    }\\r\\n\\r\\n    return {\\r\\n        getTransformProperty: getTransformProperty\\r\\n    };\\r\\n\\r\\n}());\\nfunction ShapePath(){\\r\\n\\tthis.c = false;\\r\\n\\tthis._length = 0;\\r\\n\\tthis._maxLength = 8;\\r\\n\\tthis.v = createSizedArray(this._maxLength);\\r\\n\\tthis.o = createSizedArray(this._maxLength);\\r\\n\\tthis.i = createSizedArray(this._maxLength);\\r\\n}\\r\\n\\r\\nShapePath.prototype.setPathData = function(closed, len) {\\r\\n\\tthis.c = closed;\\r\\n\\tthis.setLength(len);\\r\\n\\tvar i = 0;\\r\\n\\twhile(i < len){\\r\\n\\t\\tthis.v[i] = point_pool.newElement();\\r\\n\\t\\tthis.o[i] = point_pool.newElement();\\r\\n\\t\\tthis.i[i] = point_pool.newElement();\\r\\n\\t\\ti += 1;\\r\\n\\t}\\r\\n};\\r\\n\\r\\nShapePath.prototype.setLength = function(len) {\\r\\n\\twhile(this._maxLength < len) {\\r\\n\\t\\tthis.doubleArrayLength();\\r\\n\\t}\\r\\n\\tthis._length = len;\\r\\n};\\r\\n\\r\\nShapePath.prototype.doubleArrayLength = function() {\\r\\n\\tthis.v = this.v.concat(createSizedArray(this._maxLength));\\r\\n\\tthis.i = this.i.concat(createSizedArray(this._maxLength));\\r\\n\\tthis.o = this.o.concat(createSizedArray(this._maxLength));\\r\\n\\tthis._maxLength *= 2;\\r\\n};\\r\\n\\r\\nShapePath.prototype.setXYAt = function(x, y, type, pos, replace) {\\r\\n\\tvar arr;\\r\\n\\tthis._length = Math.max(this._length, pos + 1);\\r\\n\\tif(this._length >= this._maxLength) {\\r\\n\\t\\tthis.doubleArrayLength();\\r\\n\\t}\\r\\n\\tswitch(type){\\r\\n\\t\\tcase 'v':\\r\\n\\t\\t\\tarr = this.v;\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase 'i':\\r\\n\\t\\t\\tarr = this.i;\\r\\n\\t\\t\\tbreak;\\r\\n\\t\\tcase 'o':\\r\\n\\t\\t\\tarr = this.o;\\r\\n\\t\\t\\tbreak;\\r\\n\\t}\\r\\n\\tif(!arr[pos] || (arr[pos] && !replace)){\\r\\n\\t\\tarr[pos] = point_pool.newElement();\\r\\n\\t}\\r\\n\\tarr[pos][0] = x;\\r\\n\\tarr[pos][1] = y;\\r\\n};\\r\\n\\r\\nShapePath.prototype.setTripleAt = function(vX,vY,oX,oY,iX,iY,pos, replace) {\\r\\n\\tthis.setXYAt(vX,vY,'v',pos, replace);\\r\\n\\tthis.setXYAt(oX,oY,'o',pos, replace);\\r\\n\\tthis.setXYAt(iX,iY,'i',pos, replace);\\r\\n};\\r\\n\\r\\nShapePath.prototype.reverse = function() {\\r\\n\\tvar newPath = new ShapePath();\\r\\n\\tnewPath.setPathData(this.c, this._length);\\r\\n\\tvar vertices = this.v, outPoints = this.o, inPoints = this.i;\\r\\n\\tvar init = 0;\\r\\n\\tif (this.c) {\\r\\n\\t\\tnewPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);\\r\\n        init = 1;\\r\\n    }\\r\\n    var cnt = this._length - 1;\\r\\n    var len = this._length;\\r\\n\\r\\n    var i;\\r\\n    for (i = init; i < len; i += 1) {\\r\\n    \\tnewPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);\\r\\n        cnt -= 1;\\r\\n    }\\r\\n    return newPath;\\r\\n};\\nvar ShapePropertyFactory = (function(){\\r\\n\\r\\n    var initFrame = -999999;\\r\\n\\r\\n    function interpolateShape(frameNum, previousValue, caching) {\\r\\n        var iterationIndex = caching.lastIndex;\\r\\n        var keyPropS,keyPropE,isHold, j, k, jLen, kLen, perc, vertexValue;\\r\\n        var kf = this.keyframes;\\r\\n        if(frameNum < kf[0].t-this.offsetTime){\\r\\n            keyPropS = kf[0].s[0];\\r\\n            isHold = true;\\r\\n            iterationIndex = 0;\\r\\n        }else if(frameNum >= kf[kf.length - 1].t-this.offsetTime){\\r\\n            if(kf[kf.length - 2].h === 1){\\r\\n                keyPropS = kf[kf.length - 1].s[0];\\r\\n            }else{\\r\\n                keyPropS = kf[kf.length - 2].e[0];\\r\\n            }\\r\\n            isHold = true;\\r\\n        }else{\\r\\n            var i = iterationIndex;\\r\\n            var len = kf.length- 1,flag = true,keyData,nextKeyData;\\r\\n            while(flag){\\r\\n                keyData = kf[i];\\r\\n                nextKeyData = kf[i+1];\\r\\n                if((nextKeyData.t - this.offsetTime) > frameNum){\\r\\n                    break;\\r\\n                }\\r\\n                if(i < len - 1){\\r\\n                    i += 1;\\r\\n                }else{\\r\\n                    flag = false;\\r\\n                }\\r\\n            }\\r\\n            isHold = keyData.h === 1;\\r\\n            iterationIndex = i;\\r\\n            if(!isHold){\\r\\n                if(frameNum >= nextKeyData.t-this.offsetTime){\\r\\n                    perc = 1;\\r\\n                }else if(frameNum < keyData.t-this.offsetTime){\\r\\n                    perc = 0;\\r\\n                }else{\\r\\n                    var fnc;\\r\\n                    if(keyData.__fnct){\\r\\n                        fnc = keyData.__fnct;\\r\\n                    }else{\\r\\n                        fnc = BezierFactory.getBezierEasing(keyData.o.x,keyData.o.y,keyData.i.x,keyData.i.y).get;\\r\\n                        keyData.__fnct = fnc;\\r\\n                    }\\r\\n                    perc = fnc((frameNum-(keyData.t-this.offsetTime))/((nextKeyData.t-this.offsetTime)-(keyData.t-this.offsetTime)));\\r\\n                }\\r\\n                keyPropE = keyData.e[0];\\r\\n            }\\r\\n            keyPropS = keyData.s[0];\\r\\n        }\\r\\n        jLen = previousValue._length;\\r\\n        kLen = keyPropS.i[0].length;\\r\\n        caching.lastIndex = iterationIndex;\\r\\n\\r\\n        for(j=0;j<jLen;j+=1){\\r\\n            for(k=0;k<kLen;k+=1){\\r\\n                vertexValue = isHold ? keyPropS.i[j][k] :  keyPropS.i[j][k]+(keyPropE.i[j][k]-keyPropS.i[j][k])*perc;\\r\\n                previousValue.i[j][k] = vertexValue;\\r\\n                vertexValue = isHold ? keyPropS.o[j][k] :  keyPropS.o[j][k]+(keyPropE.o[j][k]-keyPropS.o[j][k])*perc;\\r\\n                previousValue.o[j][k] = vertexValue;\\r\\n                vertexValue = isHold ? keyPropS.v[j][k] :  keyPropS.v[j][k]+(keyPropE.v[j][k]-keyPropS.v[j][k])*perc;\\r\\n                previousValue.v[j][k] = vertexValue;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function interpolateShapeCurrentTime(){\\r\\n        var frameNum = this.comp.renderedFrame - this.offsetTime;\\r\\n        var initTime = this.keyframes[0].t - this.offsetTime;\\r\\n        var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;\\r\\n        var lastFrame = this._caching.lastFrame;\\r\\n        if(!(lastFrame !== initFrame && ((lastFrame < initTime && frameNum < initTime) || (lastFrame > endTime && frameNum > endTime)))){\\r\\n            ////\\r\\n            this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;\\r\\n            this.interpolateShape(frameNum, this.pv, this._caching);\\r\\n            ////\\r\\n        }\\r\\n        this._caching.lastFrame = frameNum;\\r\\n        return this.pv;\\r\\n    }\\r\\n\\r\\n    function resetShape(){\\r\\n        this.paths = this.localShapeCollection;\\r\\n    }\\r\\n\\r\\n    function shapesEqual(shape1, shape2) {\\r\\n        if(shape1._length !== shape2._length || shape1.c !== shape2.c){\\r\\n            return false;\\r\\n        }\\r\\n        var i, len = shape1._length;\\r\\n        for(i = 0; i < len; i += 1) {\\r\\n            if(shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1] || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1] || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]){\\r\\n                return false;\\r\\n            }\\r\\n        }\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function processEffectsSequence() {\\r\\n        if(this.lock || this.elem.globalData.frameId === this.frameId) {\\r\\n            return;\\r\\n        }\\r\\n        this.lock = true;\\r\\n        this.frameId = this.elem.globalData.frameId;\\r\\n        this._mdf = false;\\r\\n        var finalValue = this.kf ? this.pv : this.data.ks ? this.data.ks.k : this.data.pt.k;\\r\\n        var i, len = this.effectsSequence.length;\\r\\n        for(i = 0; i < len; i += 1) {\\r\\n            finalValue = this.effectsSequence[i](finalValue);\\r\\n        }\\r\\n        if(!shapesEqual(this.v, finalValue)) {\\r\\n            this.v = shape_pool.clone(finalValue);\\r\\n            this.localShapeCollection.releaseShapes();\\r\\n            this.localShapeCollection.addShape(this.v);\\r\\n            this._mdf = true;\\r\\n            this.paths = this.localShapeCollection;\\r\\n        }\\r\\n        this.lock = false;\\r\\n    };\\r\\n\\r\\n    function ShapeProperty(elem, data, type){\\r\\n        this.propType = 'shape';\\r\\n        this.comp = elem.comp;\\r\\n        this.container = elem;\\r\\n        this.elem = elem;\\r\\n        this.data = data;\\r\\n        this.k = false;\\r\\n        this.kf = false;\\r\\n        this._mdf = false;\\r\\n        var pathData = type === 3 ? data.pt.k : data.ks.k;\\r\\n        this.v = shape_pool.clone(pathData);\\r\\n        this.pv = shape_pool.clone(this.v);\\r\\n        this.localShapeCollection = shapeCollection_pool.newShapeCollection();\\r\\n        this.paths = this.localShapeCollection;\\r\\n        this.paths.addShape(this.v);\\r\\n        this.reset = resetShape;\\r\\n        this.effectsSequence = [];\\r\\n    }\\r\\n\\r\\n    function addEffect(effectFunction) {\\r\\n        this.effectsSequence.push(effectFunction);\\r\\n        this.container.addDynamicProperty(this);\\r\\n    }\\r\\n\\r\\n    ShapeProperty.prototype.interpolateShape = interpolateShape;\\r\\n    ShapeProperty.prototype.getValue = processEffectsSequence;\\r\\n    ShapeProperty.prototype.getValue = processEffectsSequence;\\r\\n    ShapeProperty.prototype.addEffect = addEffect;\\r\\n\\r\\n    function KeyframedShapeProperty(elem,data,type){\\r\\n        this.propType = 'shape';\\r\\n        this.comp = elem.comp;\\r\\n        this.elem = elem;\\r\\n        this.container = elem;\\r\\n        this.offsetTime = elem.data.st;\\r\\n        this.keyframes = type === 3 ? data.pt.k : data.ks.k;\\r\\n        this.k = true;\\r\\n        this.kf = true;\\r\\n        var i, len = this.keyframes[0].s[0].i.length;\\r\\n        var jLen = this.keyframes[0].s[0].i[0].length;\\r\\n        this.v = shape_pool.newElement();\\r\\n        this.v.setPathData(this.keyframes[0].s[0].c, len);\\r\\n        this.pv = shape_pool.clone(this.v);\\r\\n        this.localShapeCollection = shapeCollection_pool.newShapeCollection();\\r\\n        this.paths = this.localShapeCollection;\\r\\n        this.paths.addShape(this.v);\\r\\n        this.lastFrame = initFrame;\\r\\n        this.reset = resetShape;\\r\\n        this._caching = {lastFrame: initFrame, lastIndex: 0};\\r\\n        this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];\\r\\n    }\\r\\n    KeyframedShapeProperty.prototype.getValue = processEffectsSequence;\\r\\n    KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;\\r\\n    KeyframedShapeProperty.prototype.addEffect = addEffect;\\r\\n\\r\\n    var EllShapeProperty = (function(){\\r\\n\\r\\n        var cPoint = roundCorner;\\r\\n\\r\\n        function EllShapeProperty(elem,data) {\\r\\n            /*this.v = {\\r\\n                v: createSizedArray(4),\\r\\n                i: createSizedArray(4),\\r\\n                o: createSizedArray(4),\\r\\n                c: true\\r\\n            };*/\\r\\n            this.v = shape_pool.newElement();\\r\\n            this.v.setPathData(true, 4);\\r\\n            this.localShapeCollection = shapeCollection_pool.newShapeCollection();\\r\\n            this.paths = this.localShapeCollection;\\r\\n            this.localShapeCollection.addShape(this.v);\\r\\n            this.d = data.d;\\r\\n            this.elem = elem;\\r\\n            this.comp = elem.comp;\\r\\n            this.frameId = -1;\\r\\n            this.initDynamicPropertyContainer(elem);\\r\\n            this.p = PropertyFactory.getProp(elem,data.p,1,0,this);\\r\\n            this.s = PropertyFactory.getProp(elem,data.s,1,0,this);\\r\\n            if(this.dynamicProperties.length){\\r\\n                this.k = true;\\r\\n            }else{\\r\\n                this.k = false;\\r\\n                this.convertEllToPath();\\r\\n            }\\r\\n        };\\r\\n\\r\\n        EllShapeProperty.prototype = {\\r\\n            reset: resetShape,\\r\\n            getValue: function (){\\r\\n                if(this.elem.globalData.frameId === this.frameId){\\r\\n                    return;\\r\\n                }\\r\\n                this.frameId = this.elem.globalData.frameId;\\r\\n                this.iterateDynamicProperties();\\r\\n\\r\\n                if(this._mdf){\\r\\n                    this.convertEllToPath();\\r\\n                }\\r\\n            },\\r\\n            convertEllToPath: function() {\\r\\n                var p0 = this.p.v[0], p1 = this.p.v[1], s0 = this.s.v[0]/2, s1 = this.s.v[1]/2;\\r\\n                var _cw = this.d !== 3;\\r\\n                var _v = this.v;\\r\\n                _v.v[0][0] = p0;\\r\\n                _v.v[0][1] = p1 - s1;\\r\\n                _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;\\r\\n                _v.v[1][1] = p1;\\r\\n                _v.v[2][0] = p0;\\r\\n                _v.v[2][1] = p1 + s1;\\r\\n                _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;\\r\\n                _v.v[3][1] = p1;\\r\\n                _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;\\r\\n                _v.i[0][1] = p1 - s1;\\r\\n                _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;\\r\\n                _v.i[1][1] = p1 - s1 * cPoint;\\r\\n                _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;\\r\\n                _v.i[2][1] = p1 + s1;\\r\\n                _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;\\r\\n                _v.i[3][1] = p1 + s1 * cPoint;\\r\\n                _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;\\r\\n                _v.o[0][1] = p1 - s1;\\r\\n                _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;\\r\\n                _v.o[1][1] = p1 + s1 * cPoint;\\r\\n                _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;\\r\\n                _v.o[2][1] = p1 + s1;\\r\\n                _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;\\r\\n                _v.o[3][1] = p1 - s1 * cPoint;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        extendPrototype([DynamicPropertyContainer], EllShapeProperty);\\r\\n\\r\\n        return EllShapeProperty;\\r\\n    }());\\r\\n\\r\\n    var StarShapeProperty = (function() {\\r\\n\\r\\n        function StarShapeProperty(elem,data) {\\r\\n            this.v = shape_pool.newElement();\\r\\n            this.v.setPathData(true, 0);\\r\\n            this.elem = elem;\\r\\n            this.comp = elem.comp;\\r\\n            this.data = data;\\r\\n            this.frameId = -1;\\r\\n            this.d = data.d;\\r\\n            this.initDynamicPropertyContainer(elem);\\r\\n            if(data.sy === 1){\\r\\n                this.ir = PropertyFactory.getProp(elem,data.ir,0,0,this);\\r\\n                this.is = PropertyFactory.getProp(elem,data.is,0,0.01,this);\\r\\n                this.convertToPath = this.convertStarToPath;\\r\\n            } else {\\r\\n                this.convertToPath = this.convertPolygonToPath;\\r\\n            }\\r\\n            this.pt = PropertyFactory.getProp(elem,data.pt,0,0,this);\\r\\n            this.p = PropertyFactory.getProp(elem,data.p,1,0,this);\\r\\n            this.r = PropertyFactory.getProp(elem,data.r,0,degToRads,this);\\r\\n            this.or = PropertyFactory.getProp(elem,data.or,0,0,this);\\r\\n            this.os = PropertyFactory.getProp(elem,data.os,0,0.01,this);\\r\\n            this.localShapeCollection = shapeCollection_pool.newShapeCollection();\\r\\n            this.localShapeCollection.addShape(this.v);\\r\\n            this.paths = this.localShapeCollection;\\r\\n            if(this.dynamicProperties.length){\\r\\n                this.k = true;\\r\\n            }else{\\r\\n                this.k = false;\\r\\n                this.convertToPath();\\r\\n            }\\r\\n        };\\r\\n\\r\\n        StarShapeProperty.prototype = {\\r\\n            reset: resetShape,\\r\\n            getValue: function() {\\r\\n                if(this.elem.globalData.frameId === this.frameId){\\r\\n                    return;\\r\\n                }\\r\\n                this.frameId = this.elem.globalData.frameId;\\r\\n                this.iterateDynamicProperties();\\r\\n                if(this._mdf){\\r\\n                    this.convertToPath();\\r\\n                }\\r\\n            },\\r\\n            convertStarToPath: function() {\\r\\n                var numPts = Math.floor(this.pt.v)*2;\\r\\n                var angle = Math.PI*2/numPts;\\r\\n                /*this.v.v.length = numPts;\\r\\n                this.v.i.length = numPts;\\r\\n                this.v.o.length = numPts;*/\\r\\n                var longFlag = true;\\r\\n                var longRad = this.or.v;\\r\\n                var shortRad = this.ir.v;\\r\\n                var longRound = this.os.v;\\r\\n                var shortRound = this.is.v;\\r\\n                var longPerimSegment = 2*Math.PI*longRad/(numPts*2);\\r\\n                var shortPerimSegment = 2*Math.PI*shortRad/(numPts*2);\\r\\n                var i, rad,roundness,perimSegment, currentAng = -Math.PI/ 2;\\r\\n                currentAng += this.r.v;\\r\\n                var dir = this.data.d === 3 ? -1 : 1;\\r\\n                this.v._length = 0;\\r\\n                for(i=0;i<numPts;i+=1){\\r\\n                    rad = longFlag ? longRad : shortRad;\\r\\n                    roundness = longFlag ? longRound : shortRound;\\r\\n                    perimSegment = longFlag ? longPerimSegment : shortPerimSegment;\\r\\n                    var x = rad * Math.cos(currentAng);\\r\\n                    var y = rad * Math.sin(currentAng);\\r\\n                    var ox = x === 0 && y === 0 ? 0 : y/Math.sqrt(x*x + y*y);\\r\\n                    var oy = x === 0 && y === 0 ? 0 : -x/Math.sqrt(x*x + y*y);\\r\\n                    x +=  + this.p.v[0];\\r\\n                    y +=  + this.p.v[1];\\r\\n                    this.v.setTripleAt(x,y,x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir,x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir, i, true);\\r\\n\\r\\n                    /*this.v.v[i] = [x,y];\\r\\n                    this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];\\r\\n                    this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];\\r\\n                    this.v._length = numPts;*/\\r\\n                    longFlag = !longFlag;\\r\\n                    currentAng += angle*dir;\\r\\n                }\\r\\n            },\\r\\n            convertPolygonToPath: function() {\\r\\n                var numPts = Math.floor(this.pt.v);\\r\\n                var angle = Math.PI*2/numPts;\\r\\n                var rad = this.or.v;\\r\\n                var roundness = this.os.v;\\r\\n                var perimSegment = 2*Math.PI*rad/(numPts*4);\\r\\n                var i, currentAng = -Math.PI/ 2;\\r\\n                var dir = this.data.d === 3 ? -1 : 1;\\r\\n                currentAng += this.r.v;\\r\\n                this.v._length = 0;\\r\\n                for(i=0;i<numPts;i+=1){\\r\\n                    var x = rad * Math.cos(currentAng);\\r\\n                    var y = rad * Math.sin(currentAng);\\r\\n                    var ox = x === 0 && y === 0 ? 0 : y/Math.sqrt(x*x + y*y);\\r\\n                    var oy = x === 0 && y === 0 ? 0 : -x/Math.sqrt(x*x + y*y);\\r\\n                    x +=  + this.p.v[0];\\r\\n                    y +=  + this.p.v[1];\\r\\n                    this.v.setTripleAt(x,y,x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir,x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir, i, true);\\r\\n                    currentAng += angle*dir;\\r\\n                }\\r\\n                this.paths.length = 0;\\r\\n                this.paths[0] = this.v;\\r\\n            }\\r\\n\\r\\n        }\\r\\n        extendPrototype([DynamicPropertyContainer], StarShapeProperty);\\r\\n\\r\\n        return StarShapeProperty;\\r\\n    }());\\r\\n\\r\\n    var RectShapeProperty = (function() {\\r\\n\\r\\n         function RectShapeProperty(elem,data) {\\r\\n            this.v = shape_pool.newElement();\\r\\n            this.v.c = true;\\r\\n            this.localShapeCollection = shapeCollection_pool.newShapeCollection();\\r\\n            this.localShapeCollection.addShape(this.v);\\r\\n            this.paths = this.localShapeCollection;\\r\\n            this.elem = elem;\\r\\n            this.comp = elem.comp;\\r\\n            this.frameId = -1;\\r\\n            this.d = data.d;\\r\\n            this.initDynamicPropertyContainer(elem);\\r\\n            this.p = PropertyFactory.getProp(elem,data.p,1,0,this);\\r\\n            this.s = PropertyFactory.getProp(elem,data.s,1,0,this);\\r\\n            this.r = PropertyFactory.getProp(elem,data.r,0,0,this);\\r\\n            if(this.dynamicProperties.length){\\r\\n                this.k = true;\\r\\n            }else{\\r\\n                this.k = false;\\r\\n                this.convertRectToPath();\\r\\n            }\\r\\n        };\\r\\n\\r\\n        RectShapeProperty.prototype = {\\r\\n            convertRectToPath: function (){\\r\\n                var p0 = this.p.v[0], p1 = this.p.v[1], v0 = this.s.v[0]/2, v1 = this.s.v[1]/2;\\r\\n                var round = bm_min(v0,v1,this.r.v);\\r\\n                var cPoint = round*(1-roundCorner);\\r\\n                this.v._length = 0;\\r\\n\\r\\n                if(this.d === 2 || this.d === 1) {\\r\\n                    this.v.setTripleAt(p0+v0, p1-v1+round,p0+v0, p1-v1+round,p0+v0,p1-v1+cPoint,0, true);\\r\\n                    this.v.setTripleAt(p0+v0, p1+v1-round,p0+v0, p1+v1-cPoint,p0+v0, p1+v1-round,1, true);\\r\\n                    if(round!== 0){\\r\\n                        this.v.setTripleAt(p0+v0-round, p1+v1,p0+v0-round,p1+v1,p0+v0-cPoint,p1+v1,2, true);\\r\\n                        this.v.setTripleAt(p0-v0+round,p1+v1,p0-v0+cPoint,p1+v1,p0-v0+round,p1+v1,3, true);\\r\\n                        this.v.setTripleAt(p0-v0,p1+v1-round,p0-v0,p1+v1-round,p0-v0,p1+v1-cPoint,4, true);\\r\\n                        this.v.setTripleAt(p0-v0,p1-v1+round,p0-v0,p1-v1+cPoint,p0-v0,p1-v1+round,5, true);\\r\\n                        this.v.setTripleAt(p0-v0+round,p1-v1,p0-v0+round,p1-v1,p0-v0+cPoint,p1-v1,6, true);\\r\\n                        this.v.setTripleAt(p0+v0-round,p1-v1,p0+v0-cPoint,p1-v1,p0+v0-round,p1-v1,7, true);\\r\\n                    } else {\\r\\n                        this.v.setTripleAt(p0-v0,p1+v1,p0-v0+cPoint,p1+v1,p0-v0,p1+v1,2);\\r\\n                        this.v.setTripleAt(p0-v0,p1-v1,p0-v0,p1-v1+cPoint,p0-v0,p1-v1,3);\\r\\n                    }\\r\\n                }else{\\r\\n                    this.v.setTripleAt(p0+v0,p1-v1+round,p0+v0,p1-v1+cPoint,p0+v0,p1-v1+round,0, true);\\r\\n                    if(round!== 0){\\r\\n                        this.v.setTripleAt(p0+v0-round,p1-v1,p0+v0-round,p1-v1,p0+v0-cPoint,p1-v1,1, true);\\r\\n                        this.v.setTripleAt(p0-v0+round,p1-v1,p0-v0+cPoint,p1-v1,p0-v0+round,p1-v1,2, true);\\r\\n                        this.v.setTripleAt(p0-v0,p1-v1+round,p0-v0,p1-v1+round,p0-v0,p1-v1+cPoint,3, true);\\r\\n                        this.v.setTripleAt(p0-v0,p1+v1-round,p0-v0,p1+v1-cPoint,p0-v0,p1+v1-round,4, true);\\r\\n                        this.v.setTripleAt(p0-v0+round,p1+v1,p0-v0+round,p1+v1,p0-v0+cPoint,p1+v1,5, true);\\r\\n                        this.v.setTripleAt(p0+v0-round,p1+v1,p0+v0-cPoint,p1+v1,p0+v0-round,p1+v1,6, true);\\r\\n                        this.v.setTripleAt(p0+v0,p1+v1-round,p0+v0,p1+v1-round,p0+v0,p1+v1-cPoint,7, true);\\r\\n                    } else {\\r\\n                        this.v.setTripleAt(p0-v0,p1-v1,p0-v0+cPoint,p1-v1,p0-v0,p1-v1,1, true);\\r\\n                        this.v.setTripleAt(p0-v0,p1+v1,p0-v0,p1+v1-cPoint,p0-v0,p1+v1,2, true);\\r\\n                        this.v.setTripleAt(p0+v0,p1+v1,p0+v0-cPoint,p1+v1,p0+v0,p1+v1,3, true);\\r\\n\\r\\n                    }\\r\\n                }\\r\\n            },\\r\\n            getValue: function(frameNum){\\r\\n                if(this.elem.globalData.frameId === this.frameId){\\r\\n                    return;\\r\\n                }\\r\\n                this.frameId = this.elem.globalData.frameId;\\r\\n                this.iterateDynamicProperties();\\r\\n                if(this._mdf){\\r\\n                    this.convertRectToPath();\\r\\n                }\\r\\n\\r\\n            },\\r\\n            reset: resetShape\\r\\n        }\\r\\n        extendPrototype([DynamicPropertyContainer], RectShapeProperty);\\r\\n\\r\\n        return RectShapeProperty;\\r\\n    }());\\r\\n\\r\\n    function getShapeProp(elem,data,type){\\r\\n        var prop;\\r\\n        if(type === 3 || type === 4){\\r\\n            var dataProp = type === 3 ? data.pt : data.ks;\\r\\n            var keys = dataProp.k;\\r\\n            if(dataProp.a === 1 || keys.length){\\r\\n                prop = new KeyframedShapeProperty(elem, data, type);\\r\\n            }else{\\r\\n                prop = new ShapeProperty(elem, data, type);\\r\\n            }\\r\\n        }else if(type === 5){\\r\\n            prop = new RectShapeProperty(elem, data);\\r\\n        }else if(type === 6){\\r\\n            prop = new EllShapeProperty(elem, data);\\r\\n        }else if(type === 7){\\r\\n            prop = new StarShapeProperty(elem, data);\\r\\n        }\\r\\n        if(prop.k){\\r\\n            elem.addDynamicProperty(prop);\\r\\n        }\\r\\n        return prop;\\r\\n    }\\r\\n\\r\\n    function getConstructorFunction() {\\r\\n        return ShapeProperty;\\r\\n    }\\r\\n\\r\\n    function getKeyframedConstructorFunction() {\\r\\n        return KeyframedShapeProperty;\\r\\n    }\\r\\n\\r\\n    var ob = {};\\r\\n    ob.getShapeProp = getShapeProp;\\r\\n    ob.getConstructorFunction = getConstructorFunction;\\r\\n    ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;\\r\\n    return ob;\\r\\n}());\\nvar ShapeModifiers = (function(){\\r\\n    var ob = {};\\r\\n    var modifiers = {};\\r\\n    ob.registerModifier = registerModifier;\\r\\n    ob.getModifier = getModifier;\\r\\n\\r\\n    function registerModifier(nm,factory){\\r\\n        if(!modifiers[nm]){\\r\\n            modifiers[nm] = factory;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getModifier(nm,elem, data){\\r\\n        return new modifiers[nm](elem, data);\\r\\n    }\\r\\n\\r\\n    return ob;\\r\\n}());\\r\\n\\r\\nfunction ShapeModifier(){}\\r\\nShapeModifier.prototype.initModifierProperties = function(){};\\r\\nShapeModifier.prototype.addShapeToModifier = function(){};\\r\\nShapeModifier.prototype.addShape = function(data){\\r\\n    if(!this.closed){\\r\\n        var shapeData = {shape:data.sh, data: data, localShapeCollection:shapeCollection_pool.newShapeCollection()};\\r\\n        this.shapes.push(shapeData);\\r\\n        this.addShapeToModifier(shapeData);\\r\\n        if(this._isAnimated) {\\r\\n            data.setAsAnimated();\\r\\n        }\\r\\n    }\\r\\n};\\r\\nShapeModifier.prototype.init = function(elem,data){\\r\\n    this.shapes = [];\\r\\n    this.elem = elem;\\r\\n    this.initDynamicPropertyContainer(elem);\\r\\n    this.initModifierProperties(elem,data);\\r\\n    this.frameId = initialDefaultFrame;\\r\\n    this.closed = false;\\r\\n    this.k = false;\\r\\n    if(this.dynamicProperties.length){\\r\\n        this.k = true;\\r\\n    }else{\\r\\n        this.getValue(true);\\r\\n    }\\r\\n};\\r\\nShapeModifier.prototype.processKeys = function(){\\r\\n    if(this.elem.globalData.frameId === this.frameId){\\r\\n        return;\\r\\n    }\\r\\n    this.frameId = this.elem.globalData.frameId;\\r\\n    this.iterateDynamicProperties();\\r\\n};\\r\\n\\r\\nextendPrototype([DynamicPropertyContainer], ShapeModifier);\\nfunction TrimModifier(){\\r\\n}\\r\\nextendPrototype([ShapeModifier], TrimModifier);\\r\\nTrimModifier.prototype.initModifierProperties = function(elem, data) {\\r\\n    this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);\\r\\n    this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);\\r\\n    this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);\\r\\n    this.sValue = 0;\\r\\n    this.eValue = 0;\\r\\n    this.getValue = this.processKeys;\\r\\n    this.m = data.m;\\r\\n    this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;\\r\\n};\\r\\n\\r\\nTrimModifier.prototype.addShapeToModifier = function(shapeData){\\r\\n    shapeData.pathsData = [];\\r\\n};\\r\\n\\r\\nTrimModifier.prototype.calculateShapeEdges = function(s, e, shapeLength, addedLength, totalModifierLength) {\\r\\n    var segments = [];\\r\\n    if (e <= 1) {\\r\\n        segments.push({\\r\\n            s: s,\\r\\n            e: e\\r\\n        });\\r\\n    } else if (s >= 1) {\\r\\n        segments.push({\\r\\n            s: s - 1,\\r\\n            e: e - 1\\r\\n        });\\r\\n    } else {\\r\\n        segments.push({\\r\\n            s: s,\\r\\n            e: 1\\r\\n        });\\r\\n        segments.push({\\r\\n            s: 0,\\r\\n            e: e - 1\\r\\n        });\\r\\n    }\\r\\n    var shapeSegments = [];\\r\\n    var i, len = segments.length, segmentOb;\\r\\n    for (i = 0; i < len; i += 1) {\\r\\n        segmentOb = segments[i];\\r\\n        if (segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength) {\\r\\n            \\r\\n        } else {\\r\\n            var shapeS, shapeE;\\r\\n            if (segmentOb.s * totalModifierLength <= addedLength) {\\r\\n                shapeS = 0;\\r\\n            } else {\\r\\n                shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;\\r\\n            }\\r\\n            if(segmentOb.e * totalModifierLength >= addedLength + shapeLength) {\\r\\n                shapeE = 1;\\r\\n            } else {\\r\\n                shapeE = ((segmentOb.e * totalModifierLength - addedLength) / shapeLength);\\r\\n            }\\r\\n            shapeSegments.push([shapeS, shapeE]);\\r\\n        }\\r\\n    }\\r\\n    if (!shapeSegments.length) {\\r\\n        shapeSegments.push([0, 0]);\\r\\n    }\\r\\n    return shapeSegments;\\r\\n};\\r\\n\\r\\nTrimModifier.prototype.releasePathsData = function(pathsData) {\\r\\n    var i, len = pathsData.length;\\r\\n    for (i = 0; i < len; i += 1) {\\r\\n        segments_length_pool.release(pathsData[i]);\\r\\n    }\\r\\n    pathsData.length = 0;\\r\\n    return pathsData;\\r\\n};\\r\\n\\r\\nTrimModifier.prototype.processShapes = function(_isFirstFrame) {\\r\\n    var s, e;\\r\\n    if (this._mdf || _isFirstFrame) {\\r\\n        var o = (this.o.v % 360) / 360;\\r\\n        if (o < 0) {\\r\\n            o += 1;\\r\\n        }\\r\\n        s = this.s.v + o;\\r\\n        e = this.e.v + o;\\r\\n        if (s === e) {\\r\\n\\r\\n        }\\r\\n        if (s > e) {\\r\\n            var _s = s;\\r\\n            s = e;\\r\\n            e = _s;\\r\\n        }\\r\\n        s = Math.round(s*1000)/1000;\\r\\n        e = Math.round(e*1000)/1000;\\r\\n        this.sValue = s;\\r\\n        this.eValue = e;\\r\\n    } else {\\r\\n        s = this.sValue;\\r\\n        e = this.eValue;\\r\\n    }\\r\\n    var shapePaths;\\r\\n    var i, len = this.shapes.length, j, jLen;\\r\\n    var pathsData, pathData, totalShapeLength, totalModifierLength = 0;\\r\\n\\r\\n    if (e === s) {\\r\\n        for (i = 0; i < len; i += 1) {\\r\\n            this.shapes[i].localShapeCollection.releaseShapes();\\r\\n            this.shapes[i].shape._mdf = true;\\r\\n            this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;\\r\\n        }\\r\\n    } else if (!((e === 1 && s === 0) || (e===0 && s === 1))){\\r\\n        var segments = [], shapeData, localShapeCollection;\\r\\n        for (i = 0; i < len; i += 1) {\\r\\n            shapeData = this.shapes[i];\\r\\n            // if shape hasn't changed and trim properties haven't changed, cached previous path can be used\\r\\n            if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {\\r\\n                shapeData.shape.paths = shapeData.localShapeCollection;\\r\\n            } else {\\r\\n                shapePaths = shapeData.shape.paths;\\r\\n                jLen = shapePaths._length;\\r\\n                totalShapeLength = 0;\\r\\n                if (!shapeData.shape._mdf && shapeData.pathsData.length) {\\r\\n                    totalShapeLength = shapeData.totalShapeLength;\\r\\n                } else {\\r\\n                    pathsData = this.releasePathsData(shapeData.pathsData);\\r\\n                    for (j = 0; j < jLen; j += 1) {\\r\\n                        pathData = bez.getSegmentsLength(shapePaths.shapes[j]);\\r\\n                        pathsData.push(pathData);\\r\\n                        totalShapeLength += pathData.totalLength;\\r\\n                    }\\r\\n                    shapeData.totalShapeLength = totalShapeLength;\\r\\n                    shapeData.pathsData = pathsData;\\r\\n                }\\r\\n\\r\\n                totalModifierLength += totalShapeLength;\\r\\n                shapeData.shape._mdf = true;\\r\\n            }\\r\\n        }\\r\\n        var shapeS = s, shapeE = e, addedLength = 0, edges;\\r\\n        for (i = len - 1; i >= 0; i -= 1) {\\r\\n            shapeData = this.shapes[i];\\r\\n            if (shapeData.shape._mdf) {\\r\\n                localShapeCollection = shapeData.localShapeCollection;\\r\\n                localShapeCollection.releaseShapes();\\r\\n                //if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group\\r\\n                if (this.m === 2 && len > 1) {\\r\\n                    edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);\\r\\n                    addedLength += shapeData.totalShapeLength;\\r\\n                } else {\\r\\n                    edges = [[shapeS, shapeE]];\\r\\n                }\\r\\n                jLen = edges.length;\\r\\n                for (j = 0; j < jLen; j += 1) {\\r\\n                    shapeS = edges[j][0];\\r\\n                    shapeE = edges[j][1];\\r\\n                    segments.length = 0;\\r\\n                    if (shapeE <= 1) {\\r\\n                        segments.push({\\r\\n                            s:shapeData.totalShapeLength * shapeS,\\r\\n                            e:shapeData.totalShapeLength * shapeE\\r\\n                        });\\r\\n                    } else if (shapeS >= 1) {\\r\\n                        segments.push({\\r\\n                            s:shapeData.totalShapeLength * (shapeS - 1),\\r\\n                            e:shapeData.totalShapeLength * (shapeE - 1)\\r\\n                        });\\r\\n                    } else {\\r\\n                        segments.push({\\r\\n                            s:shapeData.totalShapeLength * shapeS,\\r\\n                            e:shapeData.totalShapeLength\\r\\n                        });\\r\\n                        segments.push({\\r\\n                            s:0,\\r\\n                            e:shapeData.totalShapeLength * (shapeE - 1)\\r\\n                        });\\r\\n                    }\\r\\n                    var newShapesData = this.addShapes(shapeData,segments[0]);\\r\\n                    if (segments[0].s !== segments[0].e) {\\r\\n                        if (segments.length > 1) {\\r\\n                            var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];\\r\\n                            if (lastShapeInCollection.c) {\\r\\n                                var lastShape = newShapesData.pop();\\r\\n                                this.addPaths(newShapesData, localShapeCollection);\\r\\n                                newShapesData = this.addShapes(shapeData, segments[1], lastShape);\\r\\n                            } else {\\r\\n                                this.addPaths(newShapesData, localShapeCollection);\\r\\n                                newShapesData = this.addShapes(shapeData, segments[1]);\\r\\n                            }\\r\\n                        } \\r\\n                        this.addPaths(newShapesData, localShapeCollection);\\r\\n                    }\\r\\n                    \\r\\n                }\\r\\n                shapeData.shape.paths = localShapeCollection;\\r\\n            }\\r\\n        }\\r\\n    } else if (this._mdf) {\\r\\n        for (i = 0; i < len; i += 1) {\\r\\n            //Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.\\r\\n            //Don't remove this even if it's losing cached info.\\r\\n            this.shapes[i].pathsData.length = 0;\\r\\n            this.shapes[i].shape._mdf = true;\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nTrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {\\r\\n    var i, len = newPaths.length;\\r\\n    for (i = 0; i < len; i += 1) {\\r\\n        localShapeCollection.addShape(newPaths[i]);\\r\\n    }\\r\\n};\\r\\n\\r\\nTrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {\\r\\n    shapePath.setXYAt(pt2[0], pt2[1], 'o', pos);\\r\\n    shapePath.setXYAt(pt3[0], pt3[1], 'i', pos + 1);\\r\\n    if(newShape){\\r\\n        shapePath.setXYAt(pt1[0], pt1[1], 'v', pos);\\r\\n    }\\r\\n    shapePath.setXYAt(pt4[0], pt4[1], 'v', pos + 1);\\r\\n};\\r\\n\\r\\nTrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {\\r\\n    shapePath.setXYAt(points[1], points[5], 'o', pos);\\r\\n    shapePath.setXYAt(points[2], points[6], 'i', pos + 1);\\r\\n    if(newShape){\\r\\n        shapePath.setXYAt(points[0], points[4], 'v', pos);\\r\\n    }\\r\\n    shapePath.setXYAt(points[3], points[7], 'v', pos + 1);\\r\\n};\\r\\n\\r\\nTrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {\\r\\n    var pathsData = shapeData.pathsData;\\r\\n    var shapePaths = shapeData.shape.paths.shapes;\\r\\n    var i, len = shapeData.shape.paths._length, j, jLen;\\r\\n    var addedLength = 0;\\r\\n    var currentLengthData,segmentCount;\\r\\n    var lengths;\\r\\n    var segment;\\r\\n    var shapes = [];\\r\\n    var initPos;\\r\\n    var newShape = true;\\r\\n    if (!shapePath) {\\r\\n        shapePath = shape_pool.newElement();\\r\\n        segmentCount = 0;\\r\\n        initPos = 0;\\r\\n    } else {\\r\\n        segmentCount = shapePath._length;\\r\\n        initPos = shapePath._length;\\r\\n    }\\r\\n    shapes.push(shapePath);\\r\\n    for (i = 0; i < len; i += 1) {\\r\\n        lengths = pathsData[i].lengths;\\r\\n        shapePath.c = shapePaths[i].c;\\r\\n        jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;\\r\\n        for (j = 1; j < jLen; j +=1) {\\r\\n            currentLengthData = lengths[j-1];\\r\\n            if (addedLength + currentLengthData.addedLength < shapeSegment.s) {\\r\\n                addedLength += currentLengthData.addedLength;\\r\\n                shapePath.c = false;\\r\\n            } else if(addedLength > shapeSegment.e) {\\r\\n                shapePath.c = false;\\r\\n                break;\\r\\n            } else {\\r\\n                if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {\\r\\n                    this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);\\r\\n                    newShape = false;\\r\\n                } else {\\r\\n                    segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength)/currentLengthData.addedLength,(shapeSegment.e - addedLength)/currentLengthData.addedLength, lengths[j-1]);\\r\\n                    this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);\\r\\n                    // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);\\r\\n                    newShape = false;\\r\\n                    shapePath.c = false;\\r\\n                }\\r\\n                addedLength += currentLengthData.addedLength;\\r\\n                segmentCount += 1;\\r\\n            }\\r\\n        }\\r\\n        if (shapePaths[i].c && lengths.length) {\\r\\n            currentLengthData = lengths[j - 1];\\r\\n            if (addedLength <= shapeSegment.e) {\\r\\n                var segmentLength = lengths[j - 1].addedLength;\\r\\n                if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {\\r\\n                    this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);\\r\\n                    newShape = false;\\r\\n                } else {\\r\\n                    segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);\\r\\n                    this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);\\r\\n                    // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);\\r\\n                    newShape = false;\\r\\n                    shapePath.c = false;\\r\\n                }\\r\\n            } else {\\r\\n                shapePath.c = false;\\r\\n            }\\r\\n            addedLength += currentLengthData.addedLength;\\r\\n            segmentCount += 1;\\r\\n        }\\r\\n        if (shapePath._length) {\\r\\n            shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], 'i', initPos);\\r\\n            shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1],'o', shapePath._length - 1);\\r\\n        }\\r\\n        if (addedLength > shapeSegment.e) {\\r\\n            break;\\r\\n        }\\r\\n        if (i < len - 1) {\\r\\n            shapePath = shape_pool.newElement();\\r\\n            newShape = true;\\r\\n            shapes.push(shapePath);\\r\\n            segmentCount = 0;\\r\\n        }\\r\\n    }\\r\\n    return shapes;\\r\\n};\\r\\n\\r\\n\\r\\nShapeModifiers.registerModifier('tm', TrimModifier);\\nfunction RoundCornersModifier(){}\\r\\nextendPrototype([ShapeModifier],RoundCornersModifier);\\r\\nRoundCornersModifier.prototype.initModifierProperties = function(elem,data){\\r\\n    this.getValue = this.processKeys;\\r\\n    this.rd = PropertyFactory.getProp(elem,data.r,0,null,this);\\r\\n    this._isAnimated = !!this.rd.effectsSequence.length;\\r\\n};\\r\\n\\r\\nRoundCornersModifier.prototype.processPath = function(path, round){\\r\\n    var cloned_path = shape_pool.newElement();\\r\\n    cloned_path.c = path.c;\\r\\n    var i, len = path._length;\\r\\n    var currentV,currentI,currentO,closerV, newV,newO,newI,distance,newPosPerc,index = 0;\\r\\n    var vX,vY,oX,oY,iX,iY;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        currentV = path.v[i];\\r\\n        currentO = path.o[i];\\r\\n        currentI = path.i[i];\\r\\n        if(currentV[0]===currentO[0] && currentV[1]===currentO[1] && currentV[0]===currentI[0] && currentV[1]===currentI[1]){\\r\\n            if((i===0 || i === len - 1) && !path.c){\\r\\n                cloned_path.setTripleAt(currentV[0],currentV[1],currentO[0],currentO[1],currentI[0],currentI[1],index);\\r\\n                /*cloned_path.v[index] = currentV;\\r\\n                cloned_path.o[index] = currentO;\\r\\n                cloned_path.i[index] = currentI;*/\\r\\n                index += 1;\\r\\n            } else {\\r\\n                if(i===0){\\r\\n                    closerV = path.v[len-1];\\r\\n                } else {\\r\\n                    closerV = path.v[i-1];\\r\\n                }\\r\\n                distance = Math.sqrt(Math.pow(currentV[0]-closerV[0],2)+Math.pow(currentV[1]-closerV[1],2));\\r\\n                newPosPerc = distance ? Math.min(distance/2,round)/distance : 0;\\r\\n                vX = iX = currentV[0]+(closerV[0]-currentV[0])*newPosPerc;\\r\\n                vY = iY = currentV[1]-(currentV[1]-closerV[1])*newPosPerc;\\r\\n                oX = vX-(vX-currentV[0])*roundCorner;\\r\\n                oY = vY-(vY-currentV[1])*roundCorner;\\r\\n                cloned_path.setTripleAt(vX,vY,oX,oY,iX,iY,index);\\r\\n                index += 1;\\r\\n\\r\\n                if(i === len - 1){\\r\\n                    closerV = path.v[0];\\r\\n                } else {\\r\\n                    closerV = path.v[i+1];\\r\\n                }\\r\\n                distance = Math.sqrt(Math.pow(currentV[0]-closerV[0],2)+Math.pow(currentV[1]-closerV[1],2));\\r\\n                newPosPerc = distance ? Math.min(distance/2,round)/distance : 0;\\r\\n                vX = oX = currentV[0]+(closerV[0]-currentV[0])*newPosPerc;\\r\\n                vY = oY = currentV[1]+(closerV[1]-currentV[1])*newPosPerc;\\r\\n                iX = vX-(vX-currentV[0])*roundCorner;\\r\\n                iY = vY-(vY-currentV[1])*roundCorner;\\r\\n                cloned_path.setTripleAt(vX,vY,oX,oY,iX,iY,index);\\r\\n                index += 1;\\r\\n            }\\r\\n        } else {\\r\\n            cloned_path.setTripleAt(path.v[i][0],path.v[i][1],path.o[i][0],path.o[i][1],path.i[i][0],path.i[i][1],index);\\r\\n            index += 1;\\r\\n        }\\r\\n    }\\r\\n    return cloned_path;\\r\\n};\\r\\n\\r\\nRoundCornersModifier.prototype.processShapes = function(_isFirstFrame){\\r\\n    var shapePaths;\\r\\n    var i, len = this.shapes.length;\\r\\n    var j, jLen;\\r\\n    var rd = this.rd.v;\\r\\n\\r\\n    if(rd !== 0){\\r\\n        var shapeData, newPaths, localShapeCollection;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            shapeData = this.shapes[i];\\r\\n            newPaths = shapeData.shape.paths;\\r\\n            localShapeCollection = shapeData.localShapeCollection;\\r\\n            if(!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)){\\r\\n                localShapeCollection.releaseShapes();\\r\\n                shapeData.shape._mdf = true;\\r\\n                shapePaths = shapeData.shape.paths.shapes;\\r\\n                jLen = shapeData.shape.paths._length;\\r\\n                for(j=0;j<jLen;j+=1){\\r\\n                    localShapeCollection.addShape(this.processPath(shapePaths[j],rd));\\r\\n                }\\r\\n            }\\r\\n            shapeData.shape.paths = shapeData.localShapeCollection;\\r\\n        }\\r\\n\\r\\n    }\\r\\n    if(!this.dynamicProperties.length){\\r\\n        this._mdf = false;\\r\\n    }\\r\\n};\\r\\n\\r\\nShapeModifiers.registerModifier('rd',RoundCornersModifier);\\nfunction RepeaterModifier(){}\\r\\nextendPrototype([ShapeModifier], RepeaterModifier);\\r\\n\\r\\nRepeaterModifier.prototype.initModifierProperties = function(elem,data){\\r\\n    this.getValue = this.processKeys;\\r\\n    this.c = PropertyFactory.getProp(elem,data.c,0,null,this);\\r\\n    this.o = PropertyFactory.getProp(elem,data.o,0,null,this);\\r\\n    this.tr = TransformPropertyFactory.getTransformProperty(elem,data.tr,this);\\r\\n    this.so = PropertyFactory.getProp(elem,data.tr.so,0,0.01,this);\\r\\n    this.eo = PropertyFactory.getProp(elem,data.tr.eo,0,0.01,this);\\r\\n    this.data = data;\\r\\n    if(!this.dynamicProperties.length){\\r\\n        this.getValue(true);\\r\\n    }\\r\\n    this._isAnimated = !!this.dynamicProperties.length;\\r\\n    this.pMatrix = new Matrix();\\r\\n    this.rMatrix = new Matrix();\\r\\n    this.sMatrix = new Matrix();\\r\\n    this.tMatrix = new Matrix();\\r\\n    this.matrix = new Matrix();\\r\\n};\\r\\n\\r\\nRepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform, perc, inv){\\r\\n    var dir = inv ? -1 : 1;\\r\\n    var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);\\r\\n    var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);\\r\\n    pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);\\r\\n    rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);\\r\\n    rMatrix.rotate(-transform.r.v * dir * perc);\\r\\n    rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);\\r\\n    sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);\\r\\n    sMatrix.scale(inv ? 1/scaleX : scaleX, inv ? 1/scaleY : scaleY);\\r\\n    sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);\\r\\n};\\r\\n\\r\\nRepeaterModifier.prototype.init = function(elem, arr, pos, elemsData) {\\r\\n    this.elem = elem;\\r\\n    this.arr = arr;\\r\\n    this.pos = pos;\\r\\n    this.elemsData = elemsData;\\r\\n    this._currentCopies = 0;\\r\\n    this._elements = [];\\r\\n    this._groups = [];\\r\\n    this.frameId = -1;\\r\\n    this.initDynamicPropertyContainer(elem);\\r\\n    this.initModifierProperties(elem,arr[pos]);\\r\\n    var cont = 0;\\r\\n    while(pos>0){\\r\\n        pos -= 1;\\r\\n        //this._elements.unshift(arr.splice(pos,1)[0]);\\r\\n        this._elements.unshift(arr[pos]);\\r\\n        cont += 1;\\r\\n    }\\r\\n    if(this.dynamicProperties.length){\\r\\n        this.k = true;\\r\\n    }else{\\r\\n        this.getValue(true);\\r\\n    }\\r\\n};\\r\\n\\r\\nRepeaterModifier.prototype.resetElements = function(elements){\\r\\n    var i, len = elements.length;\\r\\n    for(i = 0; i < len; i += 1) {\\r\\n        elements[i]._processed = false;\\r\\n        if(elements[i].ty === 'gr'){\\r\\n            this.resetElements(elements[i].it);\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nRepeaterModifier.prototype.cloneElements = function(elements){\\r\\n    var i, len = elements.length;\\r\\n    var newElements = JSON.parse(JSON.stringify(elements));\\r\\n    this.resetElements(newElements);\\r\\n    return newElements;\\r\\n};\\r\\n\\r\\nRepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {\\r\\n    var i, len = elements.length;\\r\\n    for(i = 0; i < len ; i += 1) {\\r\\n        elements[i]._render = renderFlag;\\r\\n        if(elements[i].ty === 'gr') {\\r\\n            this.changeGroupRender(elements[i].it, renderFlag);\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nRepeaterModifier.prototype.processShapes = function(_isFirstFrame) {\\r\\n    var items, itemsTransform, i, dir, cont;\\r\\n    if(this._mdf || _isFirstFrame){\\r\\n        var copies = Math.ceil(this.c.v);\\r\\n        if(this._groups.length < copies){\\r\\n            while(this._groups.length < copies){\\r\\n                var group = {\\r\\n                    it:this.cloneElements(this._elements),\\r\\n                    ty:'gr'\\r\\n                };\\r\\n                group.it.push({\\\"a\\\":{\\\"a\\\":0,\\\"ix\\\":1,\\\"k\\\":[0,0]},\\\"nm\\\":\\\"Transform\\\",\\\"o\\\":{\\\"a\\\":0,\\\"ix\\\":7,\\\"k\\\":100},\\\"p\\\":{\\\"a\\\":0,\\\"ix\\\":2,\\\"k\\\":[0,0]},\\\"r\\\":{\\\"a\\\":1,\\\"ix\\\":6,\\\"k\\\":[{s:0,e:0,t:0},{s:0,e:0,t:1}]},\\\"s\\\":{\\\"a\\\":0,\\\"ix\\\":3,\\\"k\\\":[100,100]},\\\"sa\\\":{\\\"a\\\":0,\\\"ix\\\":5,\\\"k\\\":0},\\\"sk\\\":{\\\"a\\\":0,\\\"ix\\\":4,\\\"k\\\":0},\\\"ty\\\":\\\"tr\\\"});\\r\\n                \\r\\n                this.arr.splice(0,0,group);\\r\\n                this._groups.splice(0,0,group);\\r\\n                this._currentCopies += 1;\\r\\n            }\\r\\n            this.elem.reloadShapes();\\r\\n        }\\r\\n        cont = 0;\\r\\n        var renderFlag;\\r\\n        for(i = 0; i  <= this._groups.length - 1; i += 1){\\r\\n            renderFlag = cont < copies;\\r\\n            this._groups[i]._render = renderFlag;\\r\\n            this.changeGroupRender(this._groups[i].it, renderFlag);\\r\\n            cont += 1;\\r\\n        }\\r\\n        \\r\\n        this._currentCopies = copies;\\r\\n        ////\\r\\n\\r\\n        var offset = this.o.v;\\r\\n        var offsetModulo = offset%1;\\r\\n        var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);\\r\\n        var k;\\r\\n        var tMat = this.tr.v.props;\\r\\n        var pProps = this.pMatrix.props;\\r\\n        var rProps = this.rMatrix.props;\\r\\n        var sProps = this.sMatrix.props;\\r\\n        this.pMatrix.reset();\\r\\n        this.rMatrix.reset();\\r\\n        this.sMatrix.reset();\\r\\n        this.tMatrix.reset();\\r\\n        this.matrix.reset();\\r\\n        var iteration = 0;\\r\\n\\r\\n        if(offset > 0) {\\r\\n            while(iteration<roundOffset){\\r\\n                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);\\r\\n                iteration += 1;\\r\\n            }\\r\\n            if(offsetModulo){\\r\\n                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);\\r\\n                iteration += offsetModulo;\\r\\n            }\\r\\n        } else if(offset < 0) {\\r\\n            while(iteration>roundOffset){\\r\\n                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);\\r\\n                iteration -= 1;\\r\\n            }\\r\\n            if(offsetModulo){\\r\\n                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, - offsetModulo, true);\\r\\n                iteration -= offsetModulo;\\r\\n            }\\r\\n        }\\r\\n        i = this.data.m === 1 ? 0 : this._currentCopies - 1;\\r\\n        dir = this.data.m === 1 ? 1 : -1;\\r\\n        cont = this._currentCopies;\\r\\n        var j, jLen;\\r\\n        while(cont){\\r\\n            items = this.elemsData[i].it;\\r\\n            itemsTransform = items[items.length - 1].transform.mProps.v.props;\\r\\n            jLen = itemsTransform.length;\\r\\n            items[items.length - 1].transform.mProps._mdf = true;\\r\\n            items[items.length - 1].transform.op._mdf = true;\\r\\n            items[items.length - 1].transform.op.v = this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));\\r\\n            if(iteration !== 0){\\r\\n                if((i !== 0 && dir === 1) || (i !== this._currentCopies - 1 && dir === -1)){\\r\\n                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);\\r\\n                }\\r\\n                this.matrix.transform(rProps[0],rProps[1],rProps[2],rProps[3],rProps[4],rProps[5],rProps[6],rProps[7],rProps[8],rProps[9],rProps[10],rProps[11],rProps[12],rProps[13],rProps[14],rProps[15]);\\r\\n                this.matrix.transform(sProps[0],sProps[1],sProps[2],sProps[3],sProps[4],sProps[5],sProps[6],sProps[7],sProps[8],sProps[9],sProps[10],sProps[11],sProps[12],sProps[13],sProps[14],sProps[15]);\\r\\n                this.matrix.transform(pProps[0],pProps[1],pProps[2],pProps[3],pProps[4],pProps[5],pProps[6],pProps[7],pProps[8],pProps[9],pProps[10],pProps[11],pProps[12],pProps[13],pProps[14],pProps[15]);\\r\\n                \\r\\n                for(j=0;j<jLen;j+=1) {\\r\\n                    itemsTransform[j] = this.matrix.props[j];\\r\\n                }\\r\\n                this.matrix.reset();\\r\\n            } else {\\r\\n                this.matrix.reset();\\r\\n                for(j=0;j<jLen;j+=1) {\\r\\n                    itemsTransform[j] = this.matrix.props[j];\\r\\n                }\\r\\n            }\\r\\n            iteration += 1;\\r\\n            cont -= 1;\\r\\n            i += dir;\\r\\n        }\\r\\n    } else {\\r\\n        cont = this._currentCopies;\\r\\n        i = 0;\\r\\n        dir = 1;\\r\\n        while(cont){\\r\\n            items = this.elemsData[i].it;\\r\\n            itemsTransform = items[items.length - 1].transform.mProps.v.props;\\r\\n            items[items.length - 1].transform.mProps._mdf = false;\\r\\n            items[items.length - 1].transform.op._mdf = false;\\r\\n            cont -= 1;\\r\\n            i += dir;\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nRepeaterModifier.prototype.addShape = function(){};\\r\\n\\r\\nShapeModifiers.registerModifier('rp',RepeaterModifier);\\nfunction ShapeCollection(){\\r\\n\\tthis._length = 0;\\r\\n\\tthis._maxLength = 4;\\r\\n\\tthis.shapes = createSizedArray(this._maxLength);\\r\\n}\\r\\n\\r\\nShapeCollection.prototype.addShape = function(shapeData){\\r\\n\\tif(this._length === this._maxLength){\\r\\n\\t\\tthis.shapes = this.shapes.concat(createSizedArray(this._maxLength));\\r\\n\\t\\tthis._maxLength *= 2;\\r\\n\\t}\\r\\n\\tthis.shapes[this._length] = shapeData;\\r\\n\\tthis._length += 1;\\r\\n};\\r\\n\\r\\nShapeCollection.prototype.releaseShapes = function(){\\r\\n\\tvar i;\\r\\n\\tfor(i = 0; i < this._length; i += 1) {\\r\\n\\t\\tshape_pool.release(this.shapes[i]);\\r\\n\\t}\\r\\n\\tthis._length = 0;\\r\\n};\\nfunction DashProperty(elem, data, renderer, container) {\\r\\n    this.elem = elem;\\r\\n    this.frameId = -1;\\r\\n    this.dataProps = createSizedArray(data.length);\\r\\n    this.renderer = renderer;\\r\\n    this.k = false;\\r\\n    this.dashStr = '';\\r\\n    this.dashArray = createTypedArray('float32',  data.length ? data.length - 1 : 0);\\r\\n    this.dashoffset = createTypedArray('float32',  1);\\r\\n    this.initDynamicPropertyContainer(container);\\r\\n    var i, len = data.length || 0, prop;\\r\\n    for(i = 0; i < len; i += 1) {\\r\\n        prop = PropertyFactory.getProp(elem,data[i].v,0, 0, this);\\r\\n        this.k = prop.k || this.k;\\r\\n        this.dataProps[i] = {n:data[i].n,p:prop};\\r\\n    }\\r\\n    if(!this.k){\\r\\n        this.getValue(true);\\r\\n    }\\r\\n    this._isAnimated = this.k;\\r\\n}\\r\\n\\r\\nDashProperty.prototype.getValue = function(forceRender) {\\r\\n    if(this.elem.globalData.frameId === this.frameId && !forceRender){\\r\\n        return;\\r\\n    }\\r\\n    this.frameId = this.elem.globalData.frameId;\\r\\n    this.iterateDynamicProperties();\\r\\n    this._mdf = this._mdf || forceRender;\\r\\n    if (this._mdf) {\\r\\n        var i = 0, len = this.dataProps.length;\\r\\n        if(this.renderer === 'svg') {\\r\\n            this.dashStr = '';\\r\\n        }\\r\\n        for(i=0;i<len;i+=1){\\r\\n            if(this.dataProps[i].n != 'o'){\\r\\n                if(this.renderer === 'svg') {\\r\\n                    this.dashStr += ' ' + this.dataProps[i].p.v;\\r\\n                }else{\\r\\n                    this.dashArray[i] = this.dataProps[i].p.v;\\r\\n                }\\r\\n            }else{\\r\\n                this.dashoffset[0] = this.dataProps[i].p.v;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n};\\r\\nextendPrototype([DynamicPropertyContainer], DashProperty);\\nfunction GradientProperty(elem,data,container){\\r\\n    this.data = data;\\r\\n    this.c = createTypedArray('uint8c', data.p*4);\\r\\n    var cLength = data.k.k[0].s ? (data.k.k[0].s.length - data.p*4) : data.k.k.length - data.p*4;\\r\\n    this.o = createTypedArray('float32', cLength);\\r\\n    this._cmdf = false;\\r\\n    this._omdf = false;\\r\\n    this._collapsable = this.checkCollapsable();\\r\\n    this._hasOpacity = cLength;\\r\\n    this.initDynamicPropertyContainer(container);\\r\\n    this.prop = PropertyFactory.getProp(elem,data.k,1,null,this);\\r\\n    this.k = this.prop.k;\\r\\n    this.getValue(true);\\r\\n}\\r\\n\\r\\nGradientProperty.prototype.comparePoints = function(values, points) {\\r\\n    var i = 0, len = this.o.length/2, diff;\\r\\n    while(i < len) {\\r\\n        diff = Math.abs(values[i*4] - values[points*4 + i*2]);\\r\\n        if(diff > 0.01){\\r\\n            return false;\\r\\n        }\\r\\n        i += 1;\\r\\n    }\\r\\n    return true;\\r\\n};\\r\\n\\r\\nGradientProperty.prototype.checkCollapsable = function() {\\r\\n    if (this.o.length/2 !== this.c.length/4) {\\r\\n        return false;\\r\\n    }\\r\\n    if (this.data.k.k[0].s) {\\r\\n        var i = 0, len = this.data.k.k.length;\\r\\n        while (i < len) {\\r\\n            if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {\\r\\n                return false;\\r\\n            }\\r\\n            i += 1;\\r\\n        }\\r\\n    } else if(!this.comparePoints(this.data.k.k, this.data.p)) {\\r\\n        return false;\\r\\n    }\\r\\n    return true;\\r\\n};\\r\\n\\r\\nGradientProperty.prototype.getValue = function(forceRender){\\r\\n    this.prop.getValue();\\r\\n    this._mdf = false;\\r\\n    this._cmdf = false;\\r\\n    this._omdf = false;\\r\\n    if(this.prop._mdf || forceRender){\\r\\n        var i, len = this.data.p*4;\\r\\n        var mult, val;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            mult = i%4 === 0 ? 100 : 255;\\r\\n            val = Math.round(this.prop.v[i]*mult);\\r\\n            if(this.c[i] !== val){\\r\\n                this.c[i] = val;\\r\\n                this._cmdf = !forceRender;\\r\\n            }\\r\\n        }\\r\\n        if(this.o.length){\\r\\n            len = this.prop.v.length;\\r\\n            for(i=this.data.p*4;i<len;i+=1){\\r\\n                mult = i%2 === 0 ? 100 : 1;\\r\\n                val = i%2 === 0 ?  Math.round(this.prop.v[i]*100):this.prop.v[i];\\r\\n                if(this.o[i-this.data.p*4] !== val){\\r\\n                    this.o[i-this.data.p*4] = val;\\r\\n                    this._omdf = !forceRender;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        this._mdf = !forceRender;\\r\\n    }\\r\\n};\\r\\n\\r\\nextendPrototype([DynamicPropertyContainer], GradientProperty);\\nvar buildShapeString = function(pathNodes, length, closed, mat) {\\r\\n\\tif(length === 0) {\\r\\n            return '';\\r\\n        }\\r\\n        var _o = pathNodes.o;\\r\\n        var _i = pathNodes.i;\\r\\n        var _v = pathNodes.v;\\r\\n        var i, shapeString = \\\" M\\\" + mat.applyToPointStringified(_v[0][0], _v[0][1]);\\r\\n        for(i = 1; i < length; i += 1) {\\r\\n            shapeString += \\\" C\\\" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + \\\" \\\" + mat.applyToPointStringified(_i[i][0], _i[i][1]) + \\\" \\\" + mat.applyToPointStringified(_v[i][0], _v[i][1]);\\r\\n        }\\r\\n        if (closed && length) {\\r\\n            shapeString += \\\" C\\\" + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + \\\" \\\" + mat.applyToPointStringified(_i[0][0], _i[0][1]) + \\\" \\\" + mat.applyToPointStringified(_v[0][0], _v[0][1]);\\r\\n            shapeString += 'z';\\r\\n        }\\r\\n        return shapeString;\\r\\n}\\nvar ImagePreloader = (function(){\\r\\n\\r\\n    var proxyImage = (function(){\\r\\n        var canvas = createTag('canvas');\\r\\n        canvas.width = 1;\\r\\n        canvas.height = 1;\\r\\n        var ctx = canvas.getContext('2d');\\r\\n        ctx.fillStyle = '#FF0000';\\r\\n        ctx.fillRect(0, 0, 1, 1);\\r\\n        return canvas;\\r\\n    }())\\r\\n\\r\\n    function imageLoaded(){\\r\\n        this.loadedAssets += 1;\\r\\n        if(this.loadedAssets === this.totalImages){\\r\\n            if(this.imagesLoadedCb) {\\r\\n                this.imagesLoadedCb(null);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getAssetsPath(assetData, assetsPath, original_path) {\\r\\n        var path = '';\\r\\n        if (assetData.e) {\\r\\n            path = assetData.p;\\r\\n        } else if(assetsPath) {\\r\\n            var imagePath = assetData.p;\\r\\n            if (imagePath.indexOf('images/') !== -1) {\\r\\n                imagePath = imagePath.split('/')[1];\\r\\n            }\\r\\n            path = assetsPath + imagePath;\\r\\n        } else {\\r\\n            path = original_path;\\r\\n            path += assetData.u ? assetData.u : '';\\r\\n            path += assetData.p;\\r\\n        }\\r\\n        return path;\\r\\n    }\\r\\n\\r\\n    function createImageData(assetData) {\\r\\n        var path = getAssetsPath(assetData, this.assetsPath, this.path);\\r\\n        var img = createTag('img');\\r\\n        img.crossOrigin = 'anonymous';\\r\\n        img.addEventListener('load', this._imageLoaded.bind(this), false);\\r\\n        img.addEventListener('error', function() {\\r\\n            ob.img = proxyImage;\\r\\n            this._imageLoaded();\\r\\n        }.bind(this), false);\\r\\n        img.src = path;\\r\\n        var ob = {\\r\\n            img: img,\\r\\n            assetData: assetData\\r\\n        }\\r\\n        return ob;\\r\\n    }\\r\\n\\r\\n    function loadAssets(assets, cb){\\r\\n        this.imagesLoadedCb = cb;\\r\\n        var i, len = assets.length;\\r\\n        for (i = 0; i < len; i += 1) {\\r\\n            if(!assets[i].layers){\\r\\n                this.totalImages += 1;\\r\\n                this.images.push(this._createImageData(assets[i]));\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setPath(path){\\r\\n        this.path = path || '';\\r\\n    }\\r\\n\\r\\n    function setAssetsPath(path){\\r\\n        this.assetsPath = path || '';\\r\\n    }\\r\\n\\r\\n    function getImage(assetData) {\\r\\n        var i = 0, len = this.images.length;\\r\\n        while (i < len) {\\r\\n            if (this.images[i].assetData === assetData) {\\r\\n                return this.images[i].img;\\r\\n            }\\r\\n            i += 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function destroy() {\\r\\n        this.imagesLoadedCb = null;\\r\\n        this.images.length = 0;\\r\\n    }\\r\\n\\r\\n    function loaded() {\\r\\n        return this.totalImages === this.loadedAssets;\\r\\n    }\\r\\n\\r\\n    return function ImagePreloader(){\\r\\n        this.loadAssets = loadAssets;\\r\\n        this.setAssetsPath = setAssetsPath;\\r\\n        this.setPath = setPath;\\r\\n        this.loaded = loaded;\\r\\n        this.destroy = destroy;\\r\\n        this.getImage = getImage;\\r\\n        this._createImageData = createImageData;\\r\\n        this._imageLoaded = imageLoaded;\\r\\n        this.assetsPath = '';\\r\\n        this.path = '';\\r\\n        this.totalImages = 0;\\r\\n        this.loadedAssets = 0;\\r\\n        this.imagesLoadedCb = null;\\r\\n        this.images = [];\\r\\n    };\\r\\n}());\\nvar featureSupport = (function(){\\r\\n\\tvar ob = {\\r\\n\\t\\tmaskType: true\\r\\n\\t};\\r\\n\\tif (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\\\\/\\\\d./i.test(navigator.userAgent)) {\\r\\n\\t   ob.maskType = false;\\r\\n\\t}\\r\\n\\treturn ob;\\r\\n}());\\nvar filtersFactory = (function(){\\r\\n\\tvar ob = {};\\r\\n\\tob.createFilter = createFilter;\\r\\n\\tob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;\\r\\n\\r\\n\\tfunction createFilter(filId){\\r\\n        \\tvar fil = createNS('filter');\\r\\n        \\tfil.setAttribute('id',filId);\\r\\n                fil.setAttribute('filterUnits','objectBoundingBox');\\r\\n                fil.setAttribute('x','0%');\\r\\n                fil.setAttribute('y','0%');\\r\\n                fil.setAttribute('width','100%');\\r\\n                fil.setAttribute('height','100%');\\r\\n                return fil;\\r\\n\\t}\\r\\n\\r\\n\\tfunction createAlphaToLuminanceFilter(){\\r\\n                var feColorMatrix = createNS('feColorMatrix');\\r\\n                feColorMatrix.setAttribute('type','matrix');\\r\\n                feColorMatrix.setAttribute('color-interpolation-filters','sRGB');\\r\\n                feColorMatrix.setAttribute('values','0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');\\r\\n                return feColorMatrix;\\r\\n\\t}\\r\\n\\r\\n\\treturn ob;\\r\\n}());\\nvar assetLoader = (function(){\\r\\n\\r\\n\\tfunction formatResponse(xhr) {\\r\\n\\t\\tif(xhr.response && typeof xhr.response === 'object') {\\r\\n\\t\\t\\treturn xhr.response;\\r\\n\\t\\t} else if(xhr.response && typeof xhr.response === 'string') {\\r\\n\\t\\t\\treturn JSON.parse(xhr.response);\\r\\n\\t\\t} else if(xhr.responseText) {\\r\\n\\t\\t\\treturn JSON.parse(xhr.response);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction loadAsset(path, callback, errorCallback) {\\r\\n\\t\\tvar response;\\r\\n\\t\\tvar xhr = new XMLHttpRequest();\\r\\n\\t\\txhr.open('GET', path, true);\\r\\n\\t\\t// set responseType after calling open or IE will break.\\r\\n\\t\\txhr.responseType = \\\"json\\\";\\r\\n\\t    xhr.send();\\r\\n\\t    xhr.onreadystatechange = function () {\\r\\n\\t        if (xhr.readyState == 4) {\\r\\n\\t            if(xhr.status == 200){\\r\\n\\t            \\tresponse = formatResponse(xhr);\\r\\n\\t            \\tcallback(response);\\r\\n\\t            }else{\\r\\n\\t                try{\\r\\n\\t            \\t\\tresponse = formatResponse(xhr);\\r\\n\\t            \\t\\tcallback(response);\\r\\n\\t                }catch(err){\\r\\n\\t                \\tif(errorCallback) {\\r\\n\\t                \\t\\terrorCallback(err);\\r\\n\\t                \\t}\\r\\n\\t                }\\r\\n\\t            }\\r\\n\\t        }\\r\\n\\t    };\\r\\n\\t}\\r\\n\\treturn {\\r\\n\\t\\tload: loadAsset\\r\\n\\t}\\r\\n}())\\r\\n\\nfunction TextAnimatorProperty(textData, renderType, elem){\\r\\n    this._isFirstFrame = true;\\r\\n\\tthis._hasMaskedPath = false;\\r\\n\\tthis._frameId = -1;\\r\\n\\tthis._textData = textData;\\r\\n\\tthis._renderType = renderType;\\r\\n    this._elem = elem;\\r\\n\\tthis._animatorsData = createSizedArray(this._textData.a.length);\\r\\n\\tthis._pathData = {};\\r\\n\\tthis._moreOptions = {\\r\\n\\t\\talignment: {}\\r\\n\\t};\\r\\n\\tthis.renderedLetters = [];\\r\\n    this.lettersChangedFlag = false;\\r\\n    this.initDynamicPropertyContainer(elem);\\r\\n\\r\\n}\\r\\n\\r\\nTextAnimatorProperty.prototype.searchProperties = function(){\\r\\n    var i, len = this._textData.a.length, animatorProps;\\r\\n    var getProp = PropertyFactory.getProp;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        animatorProps = this._textData.a[i];\\r\\n        this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);\\r\\n    }\\r\\n    if(this._textData.p && 'm' in this._textData.p){\\r\\n        this._pathData = {\\r\\n            f: getProp(this._elem,this._textData.p.f,0,0,this),\\r\\n            l: getProp(this._elem,this._textData.p.l,0,0,this),\\r\\n            r: this._textData.p.r,\\r\\n            m: this._elem.maskManager.getMaskProperty(this._textData.p.m)\\r\\n        };\\r\\n        this._hasMaskedPath = true;\\r\\n    } else {\\r\\n        this._hasMaskedPath = false;\\r\\n    }\\r\\n    this._moreOptions.alignment = getProp(this._elem,this._textData.m.a,1,0,this);\\r\\n};\\r\\n\\r\\nTextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag){\\r\\n    this.lettersChangedFlag = lettersChangedFlag;\\r\\n    if(!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {\\r\\n        return;\\r\\n    }\\r\\n    this._isFirstFrame = false;\\r\\n    var alignment = this._moreOptions.alignment.v;\\r\\n    var animators = this._animatorsData;\\r\\n    var textData = this._textData;\\r\\n    var matrixHelper = this.mHelper;\\r\\n    var renderType = this._renderType;\\r\\n    var renderedLettersCount = this.renderedLetters.length;\\r\\n    var data = this.data;\\r\\n    var xPos,yPos;\\r\\n    var i, len;\\r\\n    var letters = documentData.l, pathInfo, currentLength, currentPoint, segmentLength, flag, pointInd, segmentInd, prevPoint, points, segments, partialLength, totalLength, perc, tanAngle, mask;\\r\\n    if(this._hasMaskedPath) {\\r\\n        mask = this._pathData.m;\\r\\n        if(!this._pathData.n || this._pathData._mdf){\\r\\n            var paths = mask.v;\\r\\n            if(this._pathData.r){\\r\\n                paths = paths.reverse();\\r\\n            }\\r\\n            // TODO: release bezier data cached from previous pathInfo: this._pathData.pi\\r\\n            pathInfo = {\\r\\n                tLength: 0,\\r\\n                segments: []\\r\\n            };\\r\\n            len = paths._length - 1;\\r\\n            var pathData;\\r\\n            totalLength = 0;\\r\\n            for (i = 0; i < len; i += 1) {\\r\\n                pathData = {\\r\\n                    s: paths.v[i],\\r\\n                    e: paths.v[i + 1],\\r\\n                    to: [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]],\\r\\n                    ti: [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]\\r\\n                };\\r\\n                bez.buildBezierData(pathData);\\r\\n                pathInfo.tLength += pathData.bezierData.segmentLength;\\r\\n                pathInfo.segments.push(pathData);\\r\\n                totalLength += pathData.bezierData.segmentLength;\\r\\n            }\\r\\n            i = len;\\r\\n            if (mask.v.c) {\\r\\n                pathData = {\\r\\n                    s: paths.v[i],\\r\\n                    e: paths.v[0],\\r\\n                    to: [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]],\\r\\n                    ti: [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]\\r\\n                };\\r\\n                bez.buildBezierData(pathData);\\r\\n                pathInfo.tLength += pathData.bezierData.segmentLength;\\r\\n                pathInfo.segments.push(pathData);\\r\\n                totalLength += pathData.bezierData.segmentLength;\\r\\n            }\\r\\n            this._pathData.pi = pathInfo;\\r\\n        }\\r\\n        pathInfo = this._pathData.pi;\\r\\n\\r\\n        currentLength = this._pathData.f.v;\\r\\n        segmentInd = 0;\\r\\n        pointInd = 1;\\r\\n        segmentLength = 0;\\r\\n        flag = true;\\r\\n        segments = pathInfo.segments;\\r\\n        if (currentLength < 0 && mask.v.c) {\\r\\n            if (pathInfo.tLength < Math.abs(currentLength)) {\\r\\n                currentLength = -Math.abs(currentLength) % pathInfo.tLength;\\r\\n            }\\r\\n            segmentInd = segments.length - 1;\\r\\n            points = segments[segmentInd].bezierData.points;\\r\\n            pointInd = points.length - 1;\\r\\n            while (currentLength < 0) {\\r\\n                currentLength += points[pointInd].partialLength;\\r\\n                pointInd -= 1;\\r\\n                if (pointInd < 0) {\\r\\n                    segmentInd -= 1;\\r\\n                    points = segments[segmentInd].bezierData.points;\\r\\n                    pointInd = points.length - 1;\\r\\n                }\\r\\n            }\\r\\n\\r\\n        }\\r\\n        points = segments[segmentInd].bezierData.points;\\r\\n        prevPoint = points[pointInd - 1];\\r\\n        currentPoint = points[pointInd];\\r\\n        partialLength = currentPoint.partialLength;\\r\\n    }\\r\\n\\r\\n\\r\\n    len = letters.length;\\r\\n    xPos = 0;\\r\\n    yPos = 0;\\r\\n    var yOff = documentData.finalSize * 1.2 * 0.714;\\r\\n    var firstLine = true;\\r\\n    var animatorProps, animatorSelector;\\r\\n    var j, jLen;\\r\\n    var letterValue;\\r\\n\\r\\n    jLen = animators.length;\\r\\n    var lastLetter;\\r\\n\\r\\n    var mult, ind = -1, offf, xPathPos, yPathPos;\\r\\n    var initPathPos = currentLength,initSegmentInd = segmentInd, initPointInd = pointInd, currentLine = -1;\\r\\n    var elemOpacity;\\r\\n    var sc,sw,fc,k;\\r\\n    var lineLength = 0;\\r\\n    var letterSw, letterSc, letterFc, letterM = '', letterP = this.defaultPropsArray, letterO;\\r\\n\\r\\n    //\\r\\n    if(documentData.j === 2 || documentData.j === 1) {\\r\\n        var animatorJustifyOffset = 0;\\r\\n        var animatorFirstCharOffset = 0;\\r\\n        var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;\\r\\n        var lastIndex = 0;\\r\\n        var isNewLine = true;\\r\\n\\r\\n        for (i = 0; i < len; i += 1) {\\r\\n            if (letters[i].n) {\\r\\n                if(animatorJustifyOffset) {\\r\\n                    animatorJustifyOffset += animatorFirstCharOffset;\\r\\n                }\\r\\n                while (lastIndex < i) {\\r\\n                    letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;\\r\\n                    lastIndex += 1;\\r\\n                }\\r\\n                animatorJustifyOffset = 0;\\r\\n                isNewLine = true;\\r\\n            } else {\\r\\n                for (j = 0; j < jLen; j += 1) {\\r\\n                    animatorProps = animators[j].a;\\r\\n                    if (animatorProps.t.propType) {\\r\\n                        if (isNewLine && documentData.j === 2) {\\r\\n                            animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;\\r\\n                        }\\r\\n                        animatorSelector = animators[j].s;\\r\\n                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\\r\\n                        if (mult.length) {\\r\\n                            animatorJustifyOffset += animatorProps.t.v*mult[0] * justifyOffsetMult;\\r\\n                        } else {\\r\\n                            animatorJustifyOffset += animatorProps.t.v*mult * justifyOffsetMult;\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n                isNewLine = false;\\r\\n            }\\r\\n        }\\r\\n        if(animatorJustifyOffset) {\\r\\n            animatorJustifyOffset += animatorFirstCharOffset;\\r\\n        }\\r\\n        while(lastIndex < i) {\\r\\n            letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;\\r\\n            lastIndex += 1;\\r\\n        }\\r\\n    }\\r\\n    //\\r\\n\\r\\n    for( i = 0; i < len; i += 1) {\\r\\n\\r\\n        matrixHelper.reset();\\r\\n        elemOpacity = 1;\\r\\n        if(letters[i].n) {\\r\\n            xPos = 0;\\r\\n            yPos += documentData.yOffset;\\r\\n            yPos += firstLine ? 1 : 0;\\r\\n            currentLength = initPathPos ;\\r\\n            firstLine = false;\\r\\n            lineLength = 0;\\r\\n            if(this._hasMaskedPath) {\\r\\n                segmentInd = initSegmentInd;\\r\\n                pointInd = initPointInd;\\r\\n                points = segments[segmentInd].bezierData.points;\\r\\n                prevPoint = points[pointInd - 1];\\r\\n                currentPoint = points[pointInd];\\r\\n                partialLength = currentPoint.partialLength;\\r\\n                segmentLength = 0;\\r\\n            }\\r\\n            letterO = letterSw = letterFc = letterM = '';\\r\\n            letterP = this.defaultPropsArray;\\r\\n        }else{\\r\\n            if(this._hasMaskedPath) {\\r\\n                if(currentLine !== letters[i].line){\\r\\n                    switch(documentData.j){\\r\\n                        case 1:\\r\\n                            currentLength += totalLength - documentData.lineWidths[letters[i].line];\\r\\n                            break;\\r\\n                        case 2:\\r\\n                            currentLength += (totalLength - documentData.lineWidths[letters[i].line])/2;\\r\\n                            break;\\r\\n                    }\\r\\n                    currentLine = letters[i].line;\\r\\n                }\\r\\n                if (ind !== letters[i].ind) {\\r\\n                    if (letters[ind]) {\\r\\n                        currentLength += letters[ind].extra;\\r\\n                    }\\r\\n                    currentLength += letters[i].an / 2;\\r\\n                    ind = letters[i].ind;\\r\\n                }\\r\\n                currentLength += alignment[0] * letters[i].an / 200;\\r\\n                var animatorOffset = 0;\\r\\n                for (j = 0; j < jLen; j += 1) {\\r\\n                    animatorProps = animators[j].a;\\r\\n                    if (animatorProps.p.propType) {\\r\\n                        animatorSelector = animators[j].s;\\r\\n                        mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);\\r\\n                        if(mult.length){\\r\\n                            animatorOffset += animatorProps.p.v[0] * mult[0];\\r\\n                        } else{\\r\\n                            animatorOffset += animatorProps.p.v[0] * mult;\\r\\n                        }\\r\\n\\r\\n                    }\\r\\n                    if (animatorProps.a.propType) {\\r\\n                        animatorSelector = animators[j].s;\\r\\n                        mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);\\r\\n                        if(mult.length){\\r\\n                            animatorOffset += animatorProps.a.v[0] * mult[0];\\r\\n                        } else{\\r\\n                            animatorOffset += animatorProps.a.v[0] * mult;\\r\\n                        }\\r\\n\\r\\n                    }\\r\\n                }\\r\\n                flag = true;\\r\\n                while (flag) {\\r\\n                    if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {\\r\\n                        perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;\\r\\n                        xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;\\r\\n                        yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;\\r\\n                        matrixHelper.translate(-alignment[0]*letters[i].an/200, -(alignment[1] * yOff / 100));\\r\\n                        flag = false;\\r\\n                    } else if (points) {\\r\\n                        segmentLength += currentPoint.partialLength;\\r\\n                        pointInd += 1;\\r\\n                        if (pointInd >= points.length) {\\r\\n                            pointInd = 0;\\r\\n                            segmentInd += 1;\\r\\n                            if (!segments[segmentInd]) {\\r\\n                                if (mask.v.c) {\\r\\n                                    pointInd = 0;\\r\\n                                    segmentInd = 0;\\r\\n                                    points = segments[segmentInd].bezierData.points;\\r\\n                                } else {\\r\\n                                    segmentLength -= currentPoint.partialLength;\\r\\n                                    points = null;\\r\\n                                }\\r\\n                            } else {\\r\\n                                points = segments[segmentInd].bezierData.points;\\r\\n                            }\\r\\n                        }\\r\\n                        if (points) {\\r\\n                            prevPoint = currentPoint;\\r\\n                            currentPoint = points[pointInd];\\r\\n                            partialLength = currentPoint.partialLength;\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n                offf = letters[i].an / 2 - letters[i].add;\\r\\n                matrixHelper.translate(-offf, 0, 0);\\r\\n            } else {\\r\\n                offf = letters[i].an/2 - letters[i].add;\\r\\n                matrixHelper.translate(-offf,0,0);\\r\\n\\r\\n                // Grouping alignment\\r\\n                matrixHelper.translate(-alignment[0]*letters[i].an/200, -alignment[1]*yOff/100, 0);\\r\\n            }\\r\\n\\r\\n            lineLength += letters[i].l/2;\\r\\n            for(j=0;j<jLen;j+=1){\\r\\n                animatorProps = animators[j].a;\\r\\n                if (animatorProps.t.propType) {\\r\\n                    animatorSelector = animators[j].s;\\r\\n                    mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);\\r\\n                    //This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean \\\"isNewLine\\\"\\r\\n                    if(xPos !== 0 || documentData.j !== 0) {\\r\\n                        if(this._hasMaskedPath) {\\r\\n                            if(mult.length) {\\r\\n                                currentLength += animatorProps.t.v*mult[0];\\r\\n                            } else {\\r\\n                                currentLength += animatorProps.t.v*mult;\\r\\n                            }\\r\\n                        }else{\\r\\n                            if(mult.length) {\\r\\n                                xPos += animatorProps.t.v*mult[0];\\r\\n                            } else {\\r\\n                                xPos += animatorProps.t.v*mult;\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            lineLength += letters[i].l/2;\\r\\n            if(documentData.strokeWidthAnim) {\\r\\n                sw = documentData.sw || 0;\\r\\n            }\\r\\n            if(documentData.strokeColorAnim) {\\r\\n                if(documentData.sc){\\r\\n                    sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];\\r\\n                }else{\\r\\n                    sc = [0,0,0];\\r\\n                }\\r\\n            }\\r\\n            if(documentData.fillColorAnim && documentData.fc) {\\r\\n                fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];\\r\\n            }\\r\\n            for(j=0;j<jLen;j+=1){\\r\\n                animatorProps = animators[j].a;\\r\\n                if (animatorProps.a.propType) {\\r\\n                    animatorSelector = animators[j].s;\\r\\n                    mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);\\r\\n\\r\\n                    if(mult.length){\\r\\n                        matrixHelper.translate(-animatorProps.a.v[0]*mult[0], -animatorProps.a.v[1]*mult[1], animatorProps.a.v[2]*mult[2]);\\r\\n                    } else {\\r\\n                        matrixHelper.translate(-animatorProps.a.v[0]*mult, -animatorProps.a.v[1]*mult, animatorProps.a.v[2]*mult);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            for(j=0;j<jLen;j+=1){\\r\\n                animatorProps = animators[j].a;\\r\\n                if (animatorProps.s.propType) {\\r\\n                    animatorSelector = animators[j].s;\\r\\n                    mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);\\r\\n                    if(mult.length){\\r\\n                        matrixHelper.scale(1+((animatorProps.s.v[0]-1)*mult[0]),1+((animatorProps.s.v[1]-1)*mult[1]),1);\\r\\n                    } else {\\r\\n                        matrixHelper.scale(1+((animatorProps.s.v[0]-1)*mult),1+((animatorProps.s.v[1]-1)*mult),1);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            for(j=0;j<jLen;j+=1) {\\r\\n                animatorProps = animators[j].a;\\r\\n                animatorSelector = animators[j].s;\\r\\n                mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);\\r\\n                if (animatorProps.sk.propType) {\\r\\n                    if(mult.length) {\\r\\n                        matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);\\r\\n                    } else {\\r\\n                        matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);\\r\\n                    }\\r\\n                }\\r\\n                if (animatorProps.r.propType) {\\r\\n                    if(mult.length) {\\r\\n                        matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);\\r\\n                    } else {\\r\\n                        matrixHelper.rotateZ(-animatorProps.r.v * mult);\\r\\n                    }\\r\\n                }\\r\\n                if (animatorProps.ry.propType) {\\r\\n\\r\\n                    if(mult.length) {\\r\\n                        matrixHelper.rotateY(animatorProps.ry.v*mult[1]);\\r\\n                    }else{\\r\\n                        matrixHelper.rotateY(animatorProps.ry.v*mult);\\r\\n                    }\\r\\n                }\\r\\n                if (animatorProps.rx.propType) {\\r\\n                    if(mult.length) {\\r\\n                        matrixHelper.rotateX(animatorProps.rx.v*mult[0]);\\r\\n                    } else {\\r\\n                        matrixHelper.rotateX(animatorProps.rx.v*mult);\\r\\n                    }\\r\\n                }\\r\\n                if (animatorProps.o.propType) {\\r\\n                    if(mult.length) {\\r\\n                        elemOpacity += ((animatorProps.o.v)*mult[0] - elemOpacity)*mult[0];\\r\\n                    } else {\\r\\n                        elemOpacity += ((animatorProps.o.v)*mult - elemOpacity)*mult;\\r\\n                    }\\r\\n                }\\r\\n                if (documentData.strokeWidthAnim && animatorProps.sw.propType) {\\r\\n                    if(mult.length) {\\r\\n                        sw += animatorProps.sw.v*mult[0];\\r\\n                    } else {\\r\\n                        sw += animatorProps.sw.v*mult;\\r\\n                    }\\r\\n                }\\r\\n                if (documentData.strokeColorAnim && animatorProps.sc.propType) {\\r\\n                    for(k=0;k<3;k+=1){\\r\\n                        if(mult.length) {\\r\\n                            sc[k] = sc[k] + (animatorProps.sc.v[k] - sc[k])*mult[0];\\r\\n                        } else {\\r\\n                            sc[k] = sc[k] + (animatorProps.sc.v[k] - sc[k])*mult;\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n                if (documentData.fillColorAnim && documentData.fc) {\\r\\n                    if(animatorProps.fc.propType){\\r\\n                        for(k=0;k<3;k+=1){\\r\\n                            if(mult.length) {\\r\\n                                fc[k] = fc[k] + (animatorProps.fc.v[k] - fc[k])*mult[0];\\r\\n                            } else {\\r\\n                                fc[k] = fc[k] + (animatorProps.fc.v[k] - fc[k])*mult;\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    if(animatorProps.fh.propType){\\r\\n                        if(mult.length) {\\r\\n                            fc = addHueToRGB(fc,animatorProps.fh.v*mult[0]);\\r\\n                        } else {\\r\\n                            fc = addHueToRGB(fc,animatorProps.fh.v*mult);\\r\\n                        }\\r\\n                    }\\r\\n                    if(animatorProps.fs.propType){\\r\\n                        if(mult.length) {\\r\\n                            fc = addSaturationToRGB(fc,animatorProps.fs.v*mult[0]);\\r\\n                        } else {\\r\\n                            fc = addSaturationToRGB(fc,animatorProps.fs.v*mult);\\r\\n                        }\\r\\n                    }\\r\\n                    if(animatorProps.fb.propType){\\r\\n                        if(mult.length) {\\r\\n                            fc = addBrightnessToRGB(fc,animatorProps.fb.v*mult[0]);\\r\\n                        } else {\\r\\n                            fc = addBrightnessToRGB(fc,animatorProps.fb.v*mult);\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            for(j=0;j<jLen;j+=1){\\r\\n                animatorProps = animators[j].a;\\r\\n\\r\\n                if (animatorProps.p.propType) {\\r\\n                    animatorSelector = animators[j].s;\\r\\n                    mult = animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);\\r\\n                    if(this._hasMaskedPath) {\\r\\n                        if(mult.length) {\\r\\n                            matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);\\r\\n                        } else {\\r\\n                            matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);\\r\\n                        }\\r\\n                    }else{\\r\\n                        if(mult.length) {\\r\\n                            matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);\\r\\n                        } else {\\r\\n                            matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);\\r\\n                        \\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            if(documentData.strokeWidthAnim){\\r\\n                letterSw = sw < 0 ? 0 : sw;\\r\\n            }\\r\\n            if(documentData.strokeColorAnim){\\r\\n                letterSc = 'rgb('+Math.round(sc[0]*255)+','+Math.round(sc[1]*255)+','+Math.round(sc[2]*255)+')';\\r\\n            }\\r\\n            if(documentData.fillColorAnim && documentData.fc){\\r\\n                letterFc = 'rgb('+Math.round(fc[0]*255)+','+Math.round(fc[1]*255)+','+Math.round(fc[2]*255)+')';\\r\\n            }\\r\\n\\r\\n            if(this._hasMaskedPath) {\\r\\n                matrixHelper.translate(0,-documentData.ls);\\r\\n\\r\\n                matrixHelper.translate(0, alignment[1]*yOff/100 + yPos,0);\\r\\n                if (textData.p.p) {\\r\\n                    tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);\\r\\n                    var rot = Math.atan(tanAngle) * 180 / Math.PI;\\r\\n                    if (currentPoint.point[0] < prevPoint.point[0]) {\\r\\n                        rot += 180;\\r\\n                    }\\r\\n                    matrixHelper.rotate(-rot * Math.PI / 180);\\r\\n                }\\r\\n                matrixHelper.translate(xPathPos, yPathPos, 0);\\r\\n                currentLength -= alignment[0]*letters[i].an/200;\\r\\n                if(letters[i+1] && ind !== letters[i+1].ind){\\r\\n                    currentLength += letters[i].an / 2;\\r\\n                    currentLength += documentData.tr/1000*documentData.finalSize;\\r\\n                }\\r\\n            }else{\\r\\n\\r\\n                matrixHelper.translate(xPos,yPos,0);\\r\\n\\r\\n                if(documentData.ps){\\r\\n                    //matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);\\r\\n                    matrixHelper.translate(documentData.ps[0],documentData.ps[1] + documentData.ascent,0);\\r\\n                }\\r\\n                switch(documentData.j){\\r\\n                    case 1:\\r\\n                        matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]),0,0);\\r\\n                        break;\\r\\n                    case 2:\\r\\n                        matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line])/2,0,0);\\r\\n                        break;\\r\\n                }\\r\\n                matrixHelper.translate(0,-documentData.ls);\\r\\n                matrixHelper.translate(offf,0,0);\\r\\n                matrixHelper.translate(alignment[0]*letters[i].an/200,alignment[1]*yOff/100,0);\\r\\n                xPos += letters[i].l + documentData.tr/1000*documentData.finalSize;\\r\\n            }\\r\\n            if(renderType === 'html'){\\r\\n                letterM = matrixHelper.toCSS();\\r\\n            }else if(renderType === 'svg'){\\r\\n                letterM = matrixHelper.to2dCSS();\\r\\n            }else{\\r\\n                letterP = [matrixHelper.props[0],matrixHelper.props[1],matrixHelper.props[2],matrixHelper.props[3],matrixHelper.props[4],matrixHelper.props[5],matrixHelper.props[6],matrixHelper.props[7],matrixHelper.props[8],matrixHelper.props[9],matrixHelper.props[10],matrixHelper.props[11],matrixHelper.props[12],matrixHelper.props[13],matrixHelper.props[14],matrixHelper.props[15]];\\r\\n            }\\r\\n            letterO = elemOpacity;\\r\\n        }\\r\\n\\r\\n        if(renderedLettersCount <= i) {\\r\\n            letterValue = new LetterProps(letterO,letterSw,letterSc,letterFc,letterM,letterP);\\r\\n            this.renderedLetters.push(letterValue);\\r\\n            renderedLettersCount += 1;\\r\\n            this.lettersChangedFlag = true;\\r\\n        } else {\\r\\n            letterValue = this.renderedLetters[i];\\r\\n            this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nTextAnimatorProperty.prototype.getValue = function(){\\r\\n\\tif(this._elem.globalData.frameId === this._frameId){\\r\\n        return;\\r\\n    }\\r\\n    this._frameId = this._elem.globalData.frameId;\\r\\n    this.iterateDynamicProperties();\\r\\n};\\r\\n\\r\\nTextAnimatorProperty.prototype.mHelper = new Matrix();\\r\\nTextAnimatorProperty.prototype.defaultPropsArray = [];\\r\\nextendPrototype([DynamicPropertyContainer], TextAnimatorProperty);\\nfunction TextAnimatorDataProperty(elem, animatorProps, container) {\\r\\n\\tvar defaultData = {propType:false};\\r\\n\\tvar getProp = PropertyFactory.getProp;\\r\\n\\tvar textAnimator_animatables = animatorProps.a;\\r\\n\\tthis.a = {\\r\\n\\t\\tr: textAnimator_animatables.r ? getProp(elem, textAnimator_animatables.r, 0, degToRads, container) : defaultData,\\r\\n\\t\\trx: textAnimator_animatables.rx ? getProp(elem, textAnimator_animatables.rx, 0, degToRads, container) : defaultData,\\r\\n\\t\\try: textAnimator_animatables.ry ? getProp(elem, textAnimator_animatables.ry, 0, degToRads, container) : defaultData,\\r\\n\\t\\tsk: textAnimator_animatables.sk ? getProp(elem, textAnimator_animatables.sk, 0, degToRads, container) : defaultData,\\r\\n\\t\\tsa: textAnimator_animatables.sa ? getProp(elem, textAnimator_animatables.sa, 0, degToRads, container) : defaultData,\\r\\n\\t\\ts: textAnimator_animatables.s ? getProp(elem, textAnimator_animatables.s, 1, 0.01, container) : defaultData,\\r\\n\\t\\ta: textAnimator_animatables.a ? getProp(elem, textAnimator_animatables.a, 1, 0, container) : defaultData,\\r\\n\\t\\to: textAnimator_animatables.o ? getProp(elem, textAnimator_animatables.o, 0, 0.01, container) : defaultData,\\r\\n\\t\\tp: textAnimator_animatables.p ? getProp(elem,textAnimator_animatables.p, 1, 0, container) : defaultData,\\r\\n\\t\\tsw: textAnimator_animatables.sw ? getProp(elem, textAnimator_animatables.sw, 0, 0, container) : defaultData,\\r\\n\\t\\tsc: textAnimator_animatables.sc ? getProp(elem, textAnimator_animatables.sc, 1, 0, container) : defaultData,\\r\\n\\t\\tfc: textAnimator_animatables.fc ? getProp(elem, textAnimator_animatables.fc, 1, 0, container) : defaultData,\\r\\n\\t\\tfh: textAnimator_animatables.fh ? getProp(elem, textAnimator_animatables.fh, 0, 0, container) : defaultData,\\r\\n\\t\\tfs: textAnimator_animatables.fs ? getProp(elem, textAnimator_animatables.fs, 0, 0.01, container) : defaultData,\\r\\n\\t\\tfb: textAnimator_animatables.fb ? getProp(elem, textAnimator_animatables.fb, 0, 0.01, container) : defaultData,\\r\\n\\t\\tt: textAnimator_animatables.t ? getProp(elem, textAnimator_animatables.t, 0, 0, container) : defaultData\\r\\n\\t};\\r\\n\\r\\n\\tthis.s = TextSelectorProp.getTextSelectorProp(elem,animatorProps.s, container);\\r\\n    this.s.t = animatorProps.s.t;\\r\\n}\\nfunction LetterProps(o, sw, sc, fc, m, p){\\r\\n    this.o = o;\\r\\n    this.sw = sw;\\r\\n    this.sc = sc;\\r\\n    this.fc = fc;\\r\\n    this.m = m;\\r\\n    this.p = p;\\r\\n    this._mdf = {\\r\\n    \\to: true,\\r\\n    \\tsw: !!sw,\\r\\n    \\tsc: !!sc,\\r\\n    \\tfc: !!fc,\\r\\n    \\tm: true,\\r\\n    \\tp: true\\r\\n    };\\r\\n}\\r\\n\\r\\nLetterProps.prototype.update = function(o, sw, sc, fc, m, p) {\\r\\n\\tthis._mdf.o = false;\\r\\n\\tthis._mdf.sw = false;\\r\\n\\tthis._mdf.sc = false;\\r\\n\\tthis._mdf.fc = false;\\r\\n\\tthis._mdf.m = false;\\r\\n\\tthis._mdf.p = false;\\r\\n\\tvar updated = false;\\r\\n\\r\\n\\tif(this.o !== o) {\\r\\n\\t\\tthis.o = o;\\r\\n\\t\\tthis._mdf.o = true;\\r\\n\\t\\tupdated = true;\\r\\n\\t}\\r\\n\\tif(this.sw !== sw) {\\r\\n\\t\\tthis.sw = sw;\\r\\n\\t\\tthis._mdf.sw = true;\\r\\n\\t\\tupdated = true;\\r\\n\\t}\\r\\n\\tif(this.sc !== sc) {\\r\\n\\t\\tthis.sc = sc;\\r\\n\\t\\tthis._mdf.sc = true;\\r\\n\\t\\tupdated = true;\\r\\n\\t}\\r\\n\\tif(this.fc !== fc) {\\r\\n\\t\\tthis.fc = fc;\\r\\n\\t\\tthis._mdf.fc = true;\\r\\n\\t\\tupdated = true;\\r\\n\\t}\\r\\n\\tif(this.m !== m) {\\r\\n\\t\\tthis.m = m;\\r\\n\\t\\tthis._mdf.m = true;\\r\\n\\t\\tupdated = true;\\r\\n\\t}\\r\\n\\tif(p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {\\r\\n\\t\\tthis.p = p;\\r\\n\\t\\tthis._mdf.p = true;\\r\\n\\t\\tupdated = true;\\r\\n\\t}\\r\\n\\treturn updated;\\r\\n};\\nfunction TextProperty(elem, data){\\r\\n\\tthis._frameId = initialDefaultFrame;\\r\\n\\tthis.pv = '';\\r\\n\\tthis.v = '';\\r\\n\\tthis.kf = false;\\r\\n\\tthis._isFirstFrame = true;\\r\\n\\tthis._mdf = false;\\r\\n    this.data = data;\\r\\n\\tthis.elem = elem;\\r\\n    this.comp = this.elem.comp;\\r\\n\\tthis.keysIndex = 0;\\r\\n    this.canResize = false;\\r\\n    this.minimumFontSize = 1;\\r\\n    this.effectsSequence = [];\\r\\n\\tthis.currentData = {\\r\\n\\t\\tascent: 0,\\r\\n        boxWidth: this.defaultBoxWidth,\\r\\n        f: '',\\r\\n        fStyle: '',\\r\\n        fWeight: '',\\r\\n        fc: '',\\r\\n        j: '',\\r\\n        justifyOffset: '',\\r\\n        l: [],\\r\\n        lh: 0,\\r\\n        lineWidths: [],\\r\\n        ls: '',\\r\\n        of: '',\\r\\n        s: '',\\r\\n        sc: '',\\r\\n        sw: 0,\\r\\n        t: 0,\\r\\n        tr: 0,\\r\\n        sz:0,\\r\\n        ps:null,\\r\\n        fillColorAnim: false,\\r\\n        strokeColorAnim: false,\\r\\n        strokeWidthAnim: false,\\r\\n        yOffset: 0,\\r\\n        finalSize:0,\\r\\n        finalText:[],\\r\\n        finalLineHeight: 0,\\r\\n        __complete: false\\r\\n\\r\\n\\t};\\r\\n    this.copyData(this.currentData, this.data.d.k[0].s);\\r\\n\\r\\n    if(!this.searchProperty()) {\\r\\n        this.completeTextData(this.currentData);\\r\\n    }\\r\\n}\\r\\n\\r\\nTextProperty.prototype.defaultBoxWidth = [0,0];\\r\\n\\r\\nTextProperty.prototype.copyData = function(obj, data) {\\r\\n    for(var s in data) {\\r\\n        if(data.hasOwnProperty(s)) {\\r\\n            obj[s] = data[s];\\r\\n        }\\r\\n    }\\r\\n    return obj;\\r\\n}\\r\\n\\r\\nTextProperty.prototype.setCurrentData = function(data){\\r\\n    if(!data.__complete) {\\r\\n        this.completeTextData(data);\\r\\n    }\\r\\n    this.currentData = data;\\r\\n    this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;\\r\\n    this._mdf = true;\\r\\n};\\r\\n\\r\\nTextProperty.prototype.searchProperty = function() {\\r\\n    return this.searchKeyframes();\\r\\n};\\r\\n\\r\\nTextProperty.prototype.searchKeyframes = function() {\\r\\n    this.kf = this.data.d.k.length > 1;\\r\\n    if(this.kf) {\\r\\n        this.addEffect(this.getKeyframeValue.bind(this));\\r\\n    }\\r\\n    return this.kf;\\r\\n}\\r\\n\\r\\nTextProperty.prototype.addEffect = function(effectFunction) {\\r\\n\\tthis.effectsSequence.push(effectFunction);\\r\\n    this.elem.addDynamicProperty(this);\\r\\n};\\r\\n\\r\\nTextProperty.prototype.getValue = function(_finalValue) {\\r\\n    if((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {\\r\\n        return;\\r\\n    }\\r\\n    var currentValue = this.currentData;\\r\\n    var currentIndex = this.keysIndex;\\r\\n    if(this.lock) {\\r\\n        this.setCurrentData(this.currentData, currentTextValue);\\r\\n        return;\\r\\n    }\\r\\n    this.lock = true;\\r\\n    this._mdf = false;\\r\\n    var multipliedValue;\\r\\n    var i, len = this.effectsSequence.length;\\r\\n    var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;\\r\\n    for(i = 0; i < len; i += 1) {\\r\\n        //Checking if index changed to prevent creating a new object every time the expression updates.\\r\\n        if(currentIndex !== this.keysIndex) {\\r\\n            finalValue = this.effectsSequence[i](finalValue, finalValue.t);\\r\\n        } else {\\r\\n            finalValue = this.effectsSequence[i](this.currentData, finalValue.t);\\r\\n        }\\r\\n    }\\r\\n    if(currentValue !== finalValue) {\\r\\n        this.setCurrentData(finalValue);\\r\\n    }\\r\\n    this.pv = this.v = this.currentData;\\r\\n    this.lock = false;\\r\\n    this.frameId = this.elem.globalData.frameId;\\r\\n}\\r\\n\\r\\nTextProperty.prototype.getKeyframeValue = function() {\\r\\n    var textKeys = this.data.d.k, textDocumentData;\\r\\n    var frameNum = this.elem.comp.renderedFrame;\\r\\n    var i = 0, len = textKeys.length;\\r\\n    while(i <= len - 1) {\\r\\n        textDocumentData = textKeys[i].s;\\r\\n        if(i === len - 1 || textKeys[i+1].t > frameNum){\\r\\n            break;\\r\\n        }\\r\\n        i += 1;\\r\\n    }\\r\\n    if(this.keysIndex !== i) {\\r\\n        this.keysIndex = i;\\r\\n    }\\r\\n    return this.data.d.k[this.keysIndex].s;\\r\\n};\\r\\n\\r\\nTextProperty.prototype.buildFinalText = function(text) {\\r\\n    var combinedCharacters = FontManager.getCombinedCharacterCodes();\\r\\n    var charactersArray = [];\\r\\n    var i = 0, len = text.length;\\r\\n    while (i < len) {\\r\\n        if (combinedCharacters.indexOf(text.charCodeAt(i)) !== -1) {\\r\\n            charactersArray[charactersArray.length - 1] += text.charAt(i);\\r\\n        } else {\\r\\n            charactersArray.push(text.charAt(i));\\r\\n        }\\r\\n        i += 1;\\r\\n    }\\r\\n    return charactersArray;\\r\\n}\\r\\n\\r\\nTextProperty.prototype.completeTextData = function(documentData) {\\r\\n    documentData.__complete = true;\\r\\n    var fontManager = this.elem.globalData.fontManager;\\r\\n    var data = this.data;\\r\\n    var letters = [];\\r\\n    var i, len;\\r\\n    var newLineFlag, index = 0, val;\\r\\n    var anchorGrouping = data.m.g;\\r\\n    var currentSize = 0, currentPos = 0, currentLine = 0, lineWidths = [];\\r\\n    var lineWidth = 0;\\r\\n    var maxLineWidth = 0;\\r\\n    var j, jLen;\\r\\n    var fontData = fontManager.getFontByName(documentData.f);\\r\\n    var charData, cLength = 0;\\r\\n    var styles = fontData.fStyle ? fontData.fStyle.split(' ') : [];\\r\\n\\r\\n    var fWeight = 'normal', fStyle = 'normal';\\r\\n    len = styles.length;\\r\\n    var styleName;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        styleName = styles[i].toLowerCase();\\r\\n        switch(styleName) {\\r\\n            case 'italic':\\r\\n            fStyle = 'italic';\\r\\n            break;\\r\\n            case 'bold':\\r\\n            fWeight = '700';\\r\\n            break;\\r\\n            case 'black':\\r\\n            fWeight = '900';\\r\\n            break;\\r\\n            case 'medium':\\r\\n            fWeight = '500';\\r\\n            break;\\r\\n            case 'regular':\\r\\n            case 'normal':\\r\\n            fWeight = '400';\\r\\n            break;\\r\\n            case 'light':\\r\\n            case 'thin':\\r\\n            fWeight = '200';\\r\\n            break;\\r\\n        }\\r\\n    }\\r\\n    documentData.fWeight = fontData.fWeight || fWeight;\\r\\n    documentData.fStyle = fStyle;\\r\\n    len = documentData.t.length;\\r\\n    documentData.finalSize = documentData.s;\\r\\n    documentData.finalText = this.buildFinalText(documentData.t);\\r\\n    documentData.finalLineHeight = documentData.lh;\\r\\n    var trackingOffset = documentData.tr/1000*documentData.finalSize;\\r\\n    var charCode;\\r\\n    if(documentData.sz){\\r\\n        var flag = true;\\r\\n        var boxWidth = documentData.sz[0];\\r\\n        var boxHeight = documentData.sz[1];\\r\\n        var currentHeight, finalText;\\r\\n        while(flag) {\\r\\n            finalText = this.buildFinalText(documentData.t);\\r\\n            charCode = finalText[i].charCodeAt(0);\\r\\n            currentHeight = 0;\\r\\n            lineWidth = 0;\\r\\n            len = finalText.length;\\r\\n            trackingOffset = documentData.tr/1000*documentData.finalSize;\\r\\n            var lastSpaceIndex = -1;\\r\\n            for(i=0;i<len;i+=1){\\r\\n                newLineFlag = false;\\r\\n                if(finalText[i] === ' '){\\r\\n                    lastSpaceIndex = i;\\r\\n                }else if(charCode === 13 || charCode === 3){\\r\\n                    lineWidth = 0;\\r\\n                    newLineFlag = true;\\r\\n                    currentHeight += documentData.finalLineHeight || documentData.finalSize*1.2;\\r\\n                }\\r\\n                if(fontManager.chars){\\r\\n                    charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);\\r\\n                    cLength = newLineFlag ? 0 : charData.w*documentData.finalSize/100;\\r\\n                }else{\\r\\n                    //tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;\\r\\n                    cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);\\r\\n                }\\r\\n                if(lineWidth + cLength > boxWidth && finalText[i] !== ' '){\\r\\n                    if(lastSpaceIndex === -1){\\r\\n                        len += 1;\\r\\n                    } else {\\r\\n                        i = lastSpaceIndex;\\r\\n                    }\\r\\n                    currentHeight += documentData.finalLineHeight || documentData.finalSize*1.2;\\r\\n                    finalText.splice(i, lastSpaceIndex === i ? 1 : 0,\\\"\\\\r\\\");\\r\\n                    //finalText = finalText.substr(0,i) + \\\"\\\\r\\\" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);\\r\\n                    lastSpaceIndex = -1;\\r\\n                    lineWidth = 0;\\r\\n                }else {\\r\\n                    lineWidth += cLength;\\r\\n                    lineWidth += trackingOffset;\\r\\n                }\\r\\n            }\\r\\n            currentHeight += fontData.ascent*documentData.finalSize/100;\\r\\n            if(this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {\\r\\n                documentData.finalSize -= 1;\\r\\n                documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;\\r\\n            } else {\\r\\n                documentData.finalText = finalText;\\r\\n                len = documentData.finalText.length;\\r\\n                flag = false;\\r\\n            }\\r\\n        }\\r\\n\\r\\n    }\\r\\n    lineWidth = - trackingOffset;\\r\\n    cLength = 0;\\r\\n    var uncollapsedSpaces = 0;\\r\\n    var currentChar;\\r\\n    for (i = 0;i < len ;i += 1) {\\r\\n        newLineFlag = false;\\r\\n        currentChar = documentData.finalText[i];\\r\\n        charCode = currentChar.charCodeAt(0);\\r\\n        if (currentChar === ' '){\\r\\n            val = '\\\\u00A0';\\r\\n        } else if (charCode === 13 || charCode === 3) {\\r\\n            uncollapsedSpaces = 0;\\r\\n            lineWidths.push(lineWidth);\\r\\n            maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;\\r\\n            lineWidth = - 2 * trackingOffset;\\r\\n            val = '';\\r\\n            newLineFlag = true;\\r\\n            currentLine += 1;\\r\\n        }else{\\r\\n            val = documentData.finalText[i];\\r\\n        }\\r\\n        if(fontManager.chars){\\r\\n            charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);\\r\\n            cLength = newLineFlag ? 0 : charData.w*documentData.finalSize/100;\\r\\n        }else{\\r\\n            //var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);\\r\\n            //tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;\\r\\n            cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);\\r\\n        }\\r\\n\\r\\n        //\\r\\n        if(currentChar === ' '){\\r\\n            uncollapsedSpaces += cLength + trackingOffset;\\r\\n        } else {\\r\\n            lineWidth += cLength + trackingOffset + uncollapsedSpaces;\\r\\n            uncollapsedSpaces = 0;\\r\\n        }\\r\\n        letters.push({l:cLength,an:cLength,add:currentSize,n:newLineFlag, anIndexes:[], val: val, line: currentLine, animatorJustifyOffset: 0});\\r\\n        if(anchorGrouping == 2){\\r\\n            currentSize += cLength;\\r\\n            if(val === '' || val === '\\\\u00A0' || i === len - 1){\\r\\n                if(val === '' || val === '\\\\u00A0'){\\r\\n                    currentSize -= cLength;\\r\\n                }\\r\\n                while(currentPos<=i){\\r\\n                    letters[currentPos].an = currentSize;\\r\\n                    letters[currentPos].ind = index;\\r\\n                    letters[currentPos].extra = cLength;\\r\\n                    currentPos += 1;\\r\\n                }\\r\\n                index += 1;\\r\\n                currentSize = 0;\\r\\n            }\\r\\n        }else if(anchorGrouping == 3){\\r\\n            currentSize += cLength;\\r\\n            if(val === '' || i === len - 1){\\r\\n                if(val === ''){\\r\\n                    currentSize -= cLength;\\r\\n                }\\r\\n                while(currentPos<=i){\\r\\n                    letters[currentPos].an = currentSize;\\r\\n                    letters[currentPos].ind = index;\\r\\n                    letters[currentPos].extra = cLength;\\r\\n                    currentPos += 1;\\r\\n                }\\r\\n                currentSize = 0;\\r\\n                index += 1;\\r\\n            }\\r\\n        }else{\\r\\n            letters[index].ind = index;\\r\\n            letters[index].extra = 0;\\r\\n            index += 1;\\r\\n        }\\r\\n    }\\r\\n    documentData.l = letters;\\r\\n    maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;\\r\\n    lineWidths.push(lineWidth);\\r\\n    if(documentData.sz){\\r\\n        documentData.boxWidth = documentData.sz[0];\\r\\n        documentData.justifyOffset = 0;\\r\\n    }else{\\r\\n        documentData.boxWidth = maxLineWidth;\\r\\n        switch(documentData.j){\\r\\n            case 1:\\r\\n                documentData.justifyOffset = - documentData.boxWidth;\\r\\n                break;\\r\\n            case 2:\\r\\n                documentData.justifyOffset = - documentData.boxWidth/2;\\r\\n                break;\\r\\n            default:\\r\\n                documentData.justifyOffset = 0;\\r\\n        }\\r\\n    }\\r\\n    documentData.lineWidths = lineWidths;\\r\\n\\r\\n    var animators = data.a, animatorData, letterData;\\r\\n    jLen = animators.length;\\r\\n    var based, ind, indexes = [];\\r\\n    for(j=0;j<jLen;j+=1){\\r\\n        animatorData = animators[j];\\r\\n        if(animatorData.a.sc){\\r\\n            documentData.strokeColorAnim = true;\\r\\n        }\\r\\n        if(animatorData.a.sw){\\r\\n            documentData.strokeWidthAnim = true;\\r\\n        }\\r\\n        if(animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb){\\r\\n            documentData.fillColorAnim = true;\\r\\n        }\\r\\n        ind = 0;\\r\\n        based = animatorData.s.b;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            letterData = letters[i];\\r\\n            letterData.anIndexes[j] = ind;\\r\\n            if((based == 1 && letterData.val !== '') || (based == 2 && letterData.val !== '' && letterData.val !== '\\\\u00A0') || (based == 3 && (letterData.n || letterData.val == '\\\\u00A0' || i == len - 1)) || (based == 4 && (letterData.n || i == len - 1))){\\r\\n                if(animatorData.s.rn === 1){\\r\\n                    indexes.push(ind);\\r\\n                }\\r\\n                ind += 1;\\r\\n            }\\r\\n        }\\r\\n        data.a[j].s.totalChars = ind;\\r\\n        var currentInd = -1, newInd;\\r\\n        if(animatorData.s.rn === 1){\\r\\n            for(i = 0; i < len; i += 1){\\r\\n                letterData = letters[i];\\r\\n                if(currentInd != letterData.anIndexes[j]){\\r\\n                    currentInd = letterData.anIndexes[j];\\r\\n                    newInd = indexes.splice(Math.floor(Math.random()*indexes.length),1)[0];\\r\\n                }\\r\\n                letterData.anIndexes[j] = newInd;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    documentData.yOffset = documentData.finalLineHeight || documentData.finalSize*1.2;\\r\\n    documentData.ls = documentData.ls || 0;\\r\\n    documentData.ascent = fontData.ascent*documentData.finalSize/100;\\r\\n};\\r\\n\\r\\nTextProperty.prototype.updateDocumentData = function(newData, index) {\\r\\n\\tindex = index === undefined ? this.keysIndex : index;\\r\\n    var dData = this.copyData({}, this.data.d.k[index].s);\\r\\n    dData = this.copyData(dData, newData);\\r\\n    this.data.d.k[index].s = dData;\\r\\n    this.recalculate(index);\\r\\n    this.elem.addDynamicProperty(this);\\r\\n};\\r\\n\\r\\nTextProperty.prototype.recalculate = function(index) {\\r\\n    var dData = this.data.d.k[index].s;\\r\\n    dData.__complete = false;\\r\\n    this.keysIndex = 0;\\r\\n    this._isFirstFrame = true;\\r\\n    this.getValue(dData);\\r\\n}\\r\\n\\r\\nTextProperty.prototype.canResizeFont = function(_canResize) {\\r\\n    this.canResize = _canResize;\\r\\n    this.recalculate(this.keysIndex);\\r\\n    this.elem.addDynamicProperty(this);\\r\\n};\\r\\n\\r\\nTextProperty.prototype.setMinimumFontSize = function(_fontValue) {\\r\\n    this.minimumFontSize = Math.floor(_fontValue) || 1;\\r\\n    this.recalculate(this.keysIndex);\\r\\n    this.elem.addDynamicProperty(this);\\r\\n};\\r\\n\\nvar TextSelectorProp = (function(){\\r\\n    var max = Math.max;\\r\\n    var min = Math.min;\\r\\n    var floor = Math.floor;\\r\\n\\r\\n    function TextSelectorProp(elem,data){\\r\\n        this._currentTextLength = -1;\\r\\n        this.k = false;\\r\\n        this.data = data;\\r\\n        this.elem = elem;\\r\\n        this.comp = elem.comp;\\r\\n        this.finalS = 0;\\r\\n        this.finalE = 0;\\r\\n        this.initDynamicPropertyContainer(elem);\\r\\n        this.s = PropertyFactory.getProp(elem,data.s || {k:0},0,0,this);\\r\\n        if('e' in data){\\r\\n            this.e = PropertyFactory.getProp(elem,data.e,0,0,this);\\r\\n        }else{\\r\\n            this.e = {v:100};\\r\\n        }\\r\\n        this.o = PropertyFactory.getProp(elem,data.o || {k:0},0,0,this);\\r\\n        this.xe = PropertyFactory.getProp(elem,data.xe || {k:0},0,0,this);\\r\\n        this.ne = PropertyFactory.getProp(elem,data.ne || {k:0},0,0,this);\\r\\n        this.a = PropertyFactory.getProp(elem,data.a,0,0.01,this);\\r\\n        if(!this.dynamicProperties.length){\\r\\n            this.getValue();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    TextSelectorProp.prototype = {\\r\\n        getMult: function(ind) {\\r\\n            if(this._currentTextLength !== this.elem.textProperty.currentData.l.length) {\\r\\n                this.getValue();\\r\\n            }\\r\\n            //var easer = bez.getEasingCurve(this.ne.v/100,0,1-this.xe.v/100,1);\\r\\n            var easer = BezierFactory.getBezierEasing(this.ne.v/100,0,1-this.xe.v/100,1).get;\\r\\n            var mult = 0;\\r\\n            var s = this.finalS;\\r\\n            var e = this.finalE;\\r\\n            var type = this.data.sh;\\r\\n            if(type == 2){\\r\\n                if(e === s){\\r\\n                    mult = ind >= e ? 1 : 0;\\r\\n                }else{\\r\\n                    mult = max(0,min(0.5/(e-s) + (ind-s)/(e-s),1));\\r\\n                }\\r\\n                mult = easer(mult);\\r\\n            }else if(type == 3){\\r\\n                if(e === s){\\r\\n                    mult = ind >= e ? 0 : 1;\\r\\n                }else{\\r\\n                    mult = 1 - max(0,min(0.5/(e-s) + (ind-s)/(e-s),1));\\r\\n                }\\r\\n\\r\\n                mult = easer(mult);\\r\\n            }else if(type == 4){\\r\\n                if(e === s){\\r\\n                    mult = 0;\\r\\n                }else{\\r\\n                    mult = max(0,min(0.5/(e-s) + (ind-s)/(e-s),1));\\r\\n                    if(mult<0.5){\\r\\n                        mult *= 2;\\r\\n                    }else{\\r\\n                        mult = 1 - 2*(mult-0.5);\\r\\n                    }\\r\\n                }\\r\\n                mult = easer(mult);\\r\\n            }else if(type == 5){\\r\\n                if(e === s){\\r\\n                    mult = 0;\\r\\n                }else{\\r\\n                    var tot = e - s;\\r\\n                    /*ind += 0.5;\\r\\n                    mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind;*/\\r\\n                    ind = min(max(0,ind+0.5-s),e-s);\\r\\n                    var x = -tot/2+ind;\\r\\n                    var a = tot/2;\\r\\n                    mult = Math.sqrt(1 - (x*x)/(a*a));\\r\\n                }\\r\\n                mult = easer(mult);\\r\\n            }else if(type == 6){\\r\\n                if(e === s){\\r\\n                    mult = 0;\\r\\n                }else{\\r\\n                    ind = min(max(0,ind+0.5-s),e-s);\\r\\n                    mult = (1+(Math.cos((Math.PI+Math.PI*2*(ind)/(e-s)))))/2;\\r\\n                    /*\\r\\n                     ind = Math.min(Math.max(s,ind),e-1);\\r\\n                     mult = (1+(Math.cos((Math.PI+Math.PI*2*(ind-s)/(e-1-s)))))/2;\\r\\n                     mult = Math.max(mult,(1/(e-1-s))/(e-1-s));*/\\r\\n                }\\r\\n                mult = easer(mult);\\r\\n            }else {\\r\\n                if(ind >= floor(s)){\\r\\n                    if(ind-s < 0){\\r\\n                        mult = 1 - (s - ind);\\r\\n                    }else{\\r\\n                        mult = max(0,min(e-ind,1));\\r\\n                    }\\r\\n                }\\r\\n                mult = easer(mult);\\r\\n            }\\r\\n            return mult*this.a.v;\\r\\n        },\\r\\n        getValue: function(newCharsFlag) {\\r\\n            this.iterateDynamicProperties();\\r\\n            this._mdf = newCharsFlag || this._mdf;\\r\\n            this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;\\r\\n            if(newCharsFlag && this.data.r === 2) {\\r\\n                this.e.v = this._currentTextLength;\\r\\n            }\\r\\n            var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;\\r\\n            var o = this.o.v/divisor;\\r\\n            var s = this.s.v/divisor + o;\\r\\n            var e = (this.e.v/divisor) + o;\\r\\n            if(s>e){\\r\\n                var _s = s;\\r\\n                s = e;\\r\\n                e = _s;\\r\\n            }\\r\\n            this.finalS = s;\\r\\n            this.finalE = e;\\r\\n        }\\r\\n    }\\r\\n    extendPrototype([DynamicPropertyContainer], TextSelectorProp);\\r\\n\\r\\n    function getTextSelectorProp(elem, data,arr) {\\r\\n        return new TextSelectorProp(elem, data, arr);\\r\\n    }\\r\\n\\r\\n    return {\\r\\n        getTextSelectorProp: getTextSelectorProp\\r\\n    };\\r\\n}());\\r\\n\\r\\n    \\nvar pool_factory = (function() {\\r\\n\\treturn function(initialLength, _create, _release, _clone) {\\r\\n\\r\\n\\t\\tvar _length = 0;\\r\\n\\t\\tvar _maxLength = initialLength;\\r\\n\\t\\tvar pool = createSizedArray(_maxLength);\\r\\n\\r\\n\\t\\tvar ob = {\\r\\n\\t\\t\\tnewElement: newElement,\\r\\n\\t\\t\\trelease: release\\r\\n\\t\\t};\\r\\n\\r\\n\\t\\tfunction newElement(){\\r\\n\\t\\t\\tvar element;\\r\\n\\t\\t\\tif(_length){\\r\\n\\t\\t\\t\\t_length -= 1;\\r\\n\\t\\t\\t\\telement = pool[_length];\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\telement = _create();\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\treturn element;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction release(element) {\\r\\n\\t\\t\\tif(_length === _maxLength) {\\r\\n\\t\\t\\t\\tpool = pooling.double(pool);\\r\\n\\t\\t\\t\\t_maxLength = _maxLength*2;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tif (_release) {\\r\\n\\t\\t\\t\\t_release(element);\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\tpool[_length] = element;\\r\\n\\t\\t\\t_length += 1;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tfunction clone() {\\r\\n\\t\\t\\tvar clonedElement = newElement();\\r\\n\\t\\t\\treturn _clone(clonedElement);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn ob;\\r\\n\\t};\\r\\n}());\\r\\n\\nvar pooling = (function(){\\r\\n\\r\\n\\tfunction double(arr){\\r\\n\\t\\treturn arr.concat(createSizedArray(arr.length));\\r\\n\\t}\\r\\n\\r\\n\\treturn {\\r\\n\\t\\tdouble: double\\r\\n\\t};\\r\\n}());\\nvar point_pool = (function(){\\r\\n\\r\\n\\tfunction create() {\\r\\n\\t\\treturn createTypedArray('float32', 2);\\r\\n\\t}\\r\\n\\treturn pool_factory(8, create);\\r\\n}());\\nvar shape_pool = (function(){\\r\\n\\r\\n\\tfunction create() {\\r\\n\\t\\treturn new ShapePath();\\r\\n\\t}\\r\\n\\r\\n\\tfunction release(shapePath) {\\r\\n\\t\\tvar len = shapePath._length, i;\\r\\n\\t\\tfor(i = 0; i < len; i += 1) {\\r\\n\\t\\t\\tpoint_pool.release(shapePath.v[i]);\\r\\n\\t\\t\\tpoint_pool.release(shapePath.i[i]);\\r\\n\\t\\t\\tpoint_pool.release(shapePath.o[i]);\\r\\n\\t\\t\\tshapePath.v[i] = null;\\r\\n\\t\\t\\tshapePath.i[i] = null;\\r\\n\\t\\t\\tshapePath.o[i] = null;\\r\\n\\t\\t}\\r\\n\\t\\tshapePath._length = 0;\\r\\n\\t\\tshapePath.c = false;\\r\\n\\t}\\r\\n\\r\\n\\tfunction clone(shape) {\\r\\n\\t\\tvar cloned = factory.newElement();\\r\\n\\t\\tvar i, len = shape._length === undefined ? shape.v.length : shape._length;\\r\\n\\t\\tcloned.setLength(len);\\r\\n\\t\\tcloned.c = shape.c;\\r\\n\\t\\tvar pt;\\r\\n\\t\\t\\r\\n\\t\\tfor(i = 0; i < len; i += 1) {\\r\\n\\t\\t\\tcloned.setTripleAt(shape.v[i][0],shape.v[i][1],shape.o[i][0],shape.o[i][1],shape.i[i][0],shape.i[i][1], i);\\r\\n\\t\\t}\\r\\n\\t\\treturn cloned;\\r\\n\\t}\\r\\n\\r\\n\\tvar factory = pool_factory(4, create, release);\\r\\n\\tfactory.clone = clone;\\r\\n\\r\\n\\treturn factory;\\r\\n}());\\nvar shapeCollection_pool = (function(){\\r\\n\\tvar ob = {\\r\\n\\t\\tnewShapeCollection: newShapeCollection,\\r\\n\\t\\trelease: release\\r\\n\\t};\\r\\n\\r\\n\\tvar _length = 0;\\r\\n\\tvar _maxLength = 4;\\r\\n\\tvar pool = createSizedArray(_maxLength);\\r\\n\\r\\n\\tfunction newShapeCollection(){\\r\\n\\t\\tvar shapeCollection;\\r\\n\\t\\tif(_length){\\r\\n\\t\\t\\t_length -= 1;\\r\\n\\t\\t\\tshapeCollection = pool[_length];\\r\\n\\t\\t} else {\\r\\n\\t\\t\\tshapeCollection = new ShapeCollection();\\r\\n\\t\\t}\\r\\n\\t\\treturn shapeCollection;\\r\\n\\t}\\r\\n\\r\\n\\tfunction release(shapeCollection) {\\r\\n\\t\\tvar i, len = shapeCollection._length;\\r\\n\\t\\tfor(i = 0; i < len; i += 1) {\\r\\n\\t\\t\\tshape_pool.release(shapeCollection.shapes[i]);\\r\\n\\t\\t}\\r\\n\\t\\tshapeCollection._length = 0;\\r\\n\\r\\n\\t\\tif(_length === _maxLength) {\\r\\n\\t\\t\\tpool = pooling.double(pool);\\r\\n\\t\\t\\t_maxLength = _maxLength*2;\\r\\n\\t\\t}\\r\\n\\t\\tpool[_length] = shapeCollection;\\r\\n\\t\\t_length += 1;\\r\\n\\t}\\r\\n\\r\\n\\treturn ob;\\r\\n}());\\nvar segments_length_pool = (function(){\\r\\n\\r\\n\\tfunction create() {\\r\\n\\t\\treturn {\\r\\n\\t\\t\\tlengths: [],\\r\\n\\t\\t\\ttotalLength: 0\\r\\n\\t\\t};\\r\\n\\t}\\r\\n\\r\\n\\tfunction release(element) {\\r\\n\\t\\tvar i, len = element.lengths.length;\\r\\n\\t\\tfor(i=0;i<len;i+=1) {\\r\\n\\t\\t\\tbezier_length_pool.release(element.lengths[i]);\\r\\n\\t\\t}\\r\\n\\t\\telement.lengths.length = 0;\\r\\n\\t}\\r\\n\\r\\n\\treturn pool_factory(8, create, release);\\r\\n}());\\nvar bezier_length_pool = (function(){\\r\\n\\r\\n\\tfunction create() {\\r\\n\\t\\treturn {\\r\\n            addedLength: 0,\\r\\n            percents: createTypedArray('float32', defaultCurveSegments),\\r\\n            lengths: createTypedArray('float32', defaultCurveSegments),\\r\\n        };\\r\\n\\t}\\r\\n\\treturn pool_factory(8, create);\\r\\n}());\\nfunction BaseRenderer(){}\\r\\nBaseRenderer.prototype.checkLayers = function(num){\\r\\n    var i, len = this.layers.length, data;\\r\\n    this.completeLayers = true;\\r\\n    for (i = len - 1; i >= 0; i--) {\\r\\n        if (!this.elements[i]) {\\r\\n            data = this.layers[i];\\r\\n            if(data.ip - data.st <= (num - this.layers[i].st) && data.op - data.st > (num - this.layers[i].st))\\r\\n            {\\r\\n                this.buildItem(i);\\r\\n            }\\r\\n        }\\r\\n        this.completeLayers = this.elements[i] ? this.completeLayers:false;\\r\\n    }\\r\\n    this.checkPendingElements();\\r\\n};\\r\\n\\r\\nBaseRenderer.prototype.createItem = function(layer){\\r\\n    switch(layer.ty){\\r\\n        case 2:\\r\\n            return this.createImage(layer);\\r\\n        case 0:\\r\\n            return this.createComp(layer);\\r\\n        case 1:\\r\\n            return this.createSolid(layer);\\r\\n        case 3:\\r\\n            return this.createNull(layer);\\r\\n        case 4:\\r\\n            return this.createShape(layer);\\r\\n        case 5:\\r\\n            return this.createText(layer);\\r\\n        case 13:\\r\\n            return this.createCamera(layer);\\r\\n    }\\r\\n    return this.createNull(layer);\\r\\n};\\r\\n\\r\\nBaseRenderer.prototype.createCamera = function(){\\r\\n    throw new Error('You\\\\'re using a 3d camera. Try the html renderer.');\\r\\n};\\r\\n\\r\\nBaseRenderer.prototype.buildAllItems = function(){\\r\\n    var i, len = this.layers.length;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        this.buildItem(i);\\r\\n    }\\r\\n    this.checkPendingElements();\\r\\n};\\r\\n\\r\\nBaseRenderer.prototype.includeLayers = function(newLayers){\\r\\n    this.completeLayers = false;\\r\\n    var i, len = newLayers.length;\\r\\n    var j, jLen = this.layers.length;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        j = 0;\\r\\n        while(j<jLen){\\r\\n            if(this.layers[j].id == newLayers[i].id){\\r\\n                this.layers[j] = newLayers[i];\\r\\n                break;\\r\\n            }\\r\\n            j += 1;\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nBaseRenderer.prototype.setProjectInterface = function(pInterface){\\r\\n    this.globalData.projectInterface = pInterface;\\r\\n};\\r\\n\\r\\nBaseRenderer.prototype.initItems = function(){\\r\\n    if(!this.globalData.progressiveLoad){\\r\\n        this.buildAllItems();\\r\\n    }\\r\\n};\\r\\nBaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy) {\\r\\n    var elements = this.elements;\\r\\n    var layers = this.layers;\\r\\n    var i=0, len = layers.length;\\r\\n    while (i < len) {\\r\\n        if (layers[i].ind == parentName) {\\r\\n            if (!elements[i] || elements[i] === true) {\\r\\n                this.buildItem(i);\\r\\n                this.addPendingElement(element);\\r\\n            } else {\\r\\n                hierarchy.push(elements[i]);\\r\\n                elements[i].setAsParent();\\r\\n                if(layers[i].parent !== undefined) {\\r\\n                    this.buildElementParenting(element, layers[i].parent, hierarchy);\\r\\n                } else {\\r\\n                    element.setHierarchy(hierarchy);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        i += 1;\\r\\n    }\\r\\n};\\r\\n\\r\\nBaseRenderer.prototype.addPendingElement = function(element){\\r\\n    this.pendingElements.push(element);\\r\\n};\\r\\n\\r\\nBaseRenderer.prototype.searchExtraCompositions = function(assets){\\r\\n    var i, len = assets.length;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        if(assets[i].xt){\\r\\n            var comp = this.createComp(assets[i]);\\r\\n            comp.initExpressions();\\r\\n            this.globalData.projectInterface.registerComposition(comp);\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nBaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {\\r\\n    this.globalData.fontManager = new FontManager();\\r\\n    this.globalData.fontManager.addChars(animData.chars);\\r\\n    this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);\\r\\n    this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);\\r\\n    this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);\\r\\n    this.globalData.imageLoader = this.animationItem.imagePreloader;\\r\\n    this.globalData.frameId = 0;\\r\\n    this.globalData.frameRate = animData.fr;\\r\\n    this.globalData.nm = animData.nm;\\r\\n    this.globalData.compSize = {\\r\\n        w: animData.w,\\r\\n        h: animData.h\\r\\n    }\\r\\n}\\nfunction SVGRenderer(animationItem, config){\\r\\n    this.animationItem = animationItem;\\r\\n    this.layers = null;\\r\\n    this.renderedFrame = -1;\\r\\n    this.svgElement = createNS('svg');\\r\\n    var defs = createNS( 'defs');\\r\\n    this.svgElement.appendChild(defs);\\r\\n    var maskElement = createNS('g');\\r\\n    this.svgElement.appendChild(maskElement);\\r\\n    this.layerElement = maskElement;\\r\\n    this.renderConfig = {\\r\\n        preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',\\r\\n        imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',\\r\\n        progressiveLoad: (config && config.progressiveLoad) || false,\\r\\n        hideOnTransparent: (config && config.hideOnTransparent === false) ? false : true,\\r\\n        viewBoxOnly: (config && config.viewBoxOnly) || false,\\r\\n        viewBoxSize: (config && config.viewBoxSize) || false,\\r\\n        className: (config && config.className) || ''\\r\\n    };\\r\\n    this.globalData = {\\r\\n        _mdf: false,\\r\\n        frameNum: -1,\\r\\n        defs: defs,\\r\\n        renderConfig: this.renderConfig\\r\\n    };\\r\\n    this.elements = [];\\r\\n    this.pendingElements = [];\\r\\n    this.destroyed = false;\\r\\n    this.rendererType = 'svg';\\r\\n\\r\\n}\\r\\n\\r\\nextendPrototype([BaseRenderer],SVGRenderer);\\r\\n\\r\\nSVGRenderer.prototype.createNull = function (data) {\\r\\n    return new NullElement(data,this.globalData,this);\\r\\n};\\r\\n\\r\\nSVGRenderer.prototype.createShape = function (data) {\\r\\n    return new SVGShapeElement(data,this.globalData,this);\\r\\n};\\r\\n\\r\\nSVGRenderer.prototype.createText = function (data) {\\r\\n    return new SVGTextElement(data,this.globalData,this);\\r\\n\\r\\n};\\r\\n\\r\\nSVGRenderer.prototype.createImage = function (data) {\\r\\n    return new IImageElement(data,this.globalData,this);\\r\\n};\\r\\n\\r\\nSVGRenderer.prototype.createComp = function (data) {\\r\\n    return new SVGCompElement(data,this.globalData,this);\\r\\n\\r\\n};\\r\\n\\r\\nSVGRenderer.prototype.createSolid = function (data) {\\r\\n    return new ISolidElement(data,this.globalData,this);\\r\\n};\\r\\n\\r\\nSVGRenderer.prototype.configAnimation = function(animData){\\r\\n    this.svgElement.setAttribute('xmlns','http://www.w3.org/2000/svg');\\r\\n    if(this.renderConfig.viewBoxSize) {\\r\\n        this.svgElement.setAttribute('viewBox',this.renderConfig.viewBoxSize);\\r\\n    } else {\\r\\n        this.svgElement.setAttribute('viewBox','0 0 '+animData.w+' '+animData.h);\\r\\n    }\\r\\n\\r\\n    if(!this.renderConfig.viewBoxOnly) {\\r\\n        this.svgElement.setAttribute('width',animData.w);\\r\\n        this.svgElement.setAttribute('height',animData.h);\\r\\n        this.svgElement.style.width = '100%';\\r\\n        this.svgElement.style.height = '100%';\\r\\n        this.svgElement.style.transform = 'translate3d(0,0,0)';\\r\\n    }\\r\\n    if(this.renderConfig.className) {\\r\\n        this.svgElement.setAttribute('class', this.renderConfig.className);\\r\\n    }\\r\\n    this.svgElement.setAttribute('preserveAspectRatio',this.renderConfig.preserveAspectRatio);\\r\\n    //this.layerElement.style.transform = 'translate3d(0,0,0)';\\r\\n    //this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = \\\"0px 0px 0px\\\";\\r\\n    this.animationItem.wrapper.appendChild(this.svgElement);\\r\\n    //Mask animation\\r\\n    var defs = this.globalData.defs;\\r\\n\\r\\n    this.setupGlobalData(animData, defs);\\r\\n    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;\\r\\n    this.data = animData;\\r\\n\\r\\n    var maskElement = createNS( 'clipPath');\\r\\n    var rect = createNS('rect');\\r\\n    rect.setAttribute('width',animData.w);\\r\\n    rect.setAttribute('height',animData.h);\\r\\n    rect.setAttribute('x',0);\\r\\n    rect.setAttribute('y',0);\\r\\n    var maskId = 'animationMask_'+randomString(10);\\r\\n    maskElement.setAttribute('id', maskId);\\r\\n    maskElement.appendChild(rect);\\r\\n    this.layerElement.setAttribute(\\\"clip-path\\\", \\\"url(\\\" + locationHref + \\\"#\\\"+maskId+\\\")\\\");\\r\\n\\r\\n    defs.appendChild(maskElement);\\r\\n    this.layers = animData.layers;\\r\\n    this.elements = createSizedArray(animData.layers.length);\\r\\n};\\r\\n\\r\\n\\r\\nSVGRenderer.prototype.destroy = function () {\\r\\n    this.animationItem.wrapper.innerHTML = '';\\r\\n    this.layerElement = null;\\r\\n    this.globalData.defs = null;\\r\\n    var i, len = this.layers ? this.layers.length : 0;\\r\\n    for (i = 0; i < len; i++) {\\r\\n        if(this.elements[i]){\\r\\n            this.elements[i].destroy();\\r\\n        }\\r\\n    }\\r\\n    this.elements.length = 0;\\r\\n    this.destroyed = true;\\r\\n    this.animationItem = null;\\r\\n};\\r\\n\\r\\nSVGRenderer.prototype.updateContainerSize = function () {\\r\\n};\\r\\n\\r\\nSVGRenderer.prototype.buildItem  = function(pos){\\r\\n    var elements = this.elements;\\r\\n    if(elements[pos] || this.layers[pos].ty == 99){\\r\\n        return;\\r\\n    }\\r\\n    elements[pos] = true;\\r\\n    var element = this.createItem(this.layers[pos]);\\r\\n\\r\\n    elements[pos] = element;\\r\\n    if(expressionsPlugin){\\r\\n        if(this.layers[pos].ty === 0){\\r\\n            this.globalData.projectInterface.registerComposition(element);\\r\\n        }\\r\\n        element.initExpressions();\\r\\n    }\\r\\n    this.appendElementInPos(element,pos);\\r\\n    if(this.layers[pos].tt){\\r\\n        if(!this.elements[pos - 1] || this.elements[pos - 1] === true){\\r\\n            this.buildItem(pos - 1);\\r\\n            this.addPendingElement(element);\\r\\n        } else {\\r\\n            element.setMatte(elements[pos - 1].layerId);\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nSVGRenderer.prototype.checkPendingElements  = function(){\\r\\n    while(this.pendingElements.length){\\r\\n        var element = this.pendingElements.pop();\\r\\n        element.checkParenting();\\r\\n        if(element.data.tt){\\r\\n            var i = 0, len = this.elements.length;\\r\\n            while(i<len){\\r\\n                if(this.elements[i] === element){\\r\\n                    element.setMatte(this.elements[i - 1].layerId);\\r\\n                    break;\\r\\n                }\\r\\n                i += 1;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nSVGRenderer.prototype.renderFrame = function(num){\\r\\n    if(this.renderedFrame === num || this.destroyed){\\r\\n        return;\\r\\n    }\\r\\n    if(num === null){\\r\\n        num = this.renderedFrame;\\r\\n    }else{\\r\\n        this.renderedFrame = num;\\r\\n    }\\r\\n    // console.log('-------');\\r\\n    // console.log('FRAME ',num);\\r\\n    this.globalData.frameNum = num;\\r\\n    this.globalData.frameId += 1;\\r\\n    this.globalData.projectInterface.currentFrame = num;\\r\\n    this.globalData._mdf = false;\\r\\n    var i, len = this.layers.length;\\r\\n    if(!this.completeLayers){\\r\\n        this.checkLayers(num);\\r\\n    }\\r\\n    for (i = len - 1; i >= 0; i--) {\\r\\n        if(this.completeLayers || this.elements[i]){\\r\\n            this.elements[i].prepareFrame(num - this.layers[i].st);\\r\\n        }\\r\\n    }\\r\\n    if(this.globalData._mdf) {\\r\\n        for (i = 0; i < len; i += 1) {\\r\\n            if(this.completeLayers || this.elements[i]){\\r\\n                this.elements[i].renderFrame();\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nSVGRenderer.prototype.appendElementInPos = function(element, pos){\\r\\n    var newElement = element.getBaseElement();\\r\\n    if(!newElement){\\r\\n        return;\\r\\n    }\\r\\n    var i = 0;\\r\\n    var nextElement;\\r\\n    while(i<pos){\\r\\n        if(this.elements[i] && this.elements[i]!== true && this.elements[i].getBaseElement()){\\r\\n            nextElement = this.elements[i].getBaseElement();\\r\\n        }\\r\\n        i += 1;\\r\\n    }\\r\\n    if(nextElement){\\r\\n        this.layerElement.insertBefore(newElement, nextElement);\\r\\n    } else {\\r\\n        this.layerElement.appendChild(newElement);\\r\\n    }\\r\\n};\\r\\n\\r\\nSVGRenderer.prototype.hide = function(){\\r\\n    this.layerElement.style.display = 'none';\\r\\n};\\r\\n\\r\\nSVGRenderer.prototype.show = function(){\\r\\n    this.layerElement.style.display = 'block';\\r\\n};\\r\\n\\nfunction MaskElement(data,element,globalData) {\\r\\n    this.data = data;\\r\\n    this.element = element;\\r\\n    this.globalData = globalData;\\r\\n    this.storedData = [];\\r\\n    this.masksProperties = this.data.masksProperties || [];\\r\\n    this.maskElement = null;\\r\\n    var defs = this.globalData.defs;\\r\\n    var i, len = this.masksProperties ? this.masksProperties.length : 0;\\r\\n    this.viewData = createSizedArray(len);\\r\\n    this.solidPath = '';\\r\\n\\r\\n\\r\\n    var path, properties = this.masksProperties;\\r\\n    var count = 0;\\r\\n    var currentMasks = [];\\r\\n    var j, jLen;\\r\\n    var layerId = randomString(10);\\r\\n    var rect, expansor, feMorph,x;\\r\\n    var maskType = 'clipPath', maskRef = 'clip-path';\\r\\n    for (i = 0; i < len; i++) {\\r\\n\\r\\n        if((properties[i].mode !== 'a' && properties[i].mode !== 'n')|| properties[i].inv || properties[i].o.k !== 100){\\r\\n            maskType = 'mask';\\r\\n            maskRef = 'mask';\\r\\n        }\\r\\n\\r\\n        if((properties[i].mode == 's' || properties[i].mode == 'i') && count === 0){\\r\\n            rect = createNS( 'rect');\\r\\n            rect.setAttribute('fill', '#ffffff');\\r\\n            rect.setAttribute('width', this.element.comp.data.w || 0);\\r\\n            rect.setAttribute('height', this.element.comp.data.h || 0);\\r\\n            currentMasks.push(rect);\\r\\n        } else {\\r\\n            rect = null;\\r\\n        }\\r\\n\\r\\n        path = createNS( 'path');\\r\\n        if(properties[i].mode == 'n') {\\r\\n            // TODO move this to a factory or to a constructor\\r\\n            this.viewData[i] = {\\r\\n                op: PropertyFactory.getProp(this.element,properties[i].o,0,0.01,this.element),\\r\\n                prop: ShapePropertyFactory.getShapeProp(this.element,properties[i],3),\\r\\n                elem: path,\\r\\n                lastPath: ''\\r\\n            };\\r\\n            defs.appendChild(path);\\r\\n            continue;\\r\\n        }\\r\\n        count += 1;\\r\\n\\r\\n        path.setAttribute('fill', properties[i].mode === 's' ? '#000000':'#ffffff');\\r\\n        path.setAttribute('clip-rule','nonzero');\\r\\n        var filterID;\\r\\n\\r\\n        if (properties[i].x.k !== 0) {\\r\\n            maskType = 'mask';\\r\\n            maskRef = 'mask';\\r\\n            x = PropertyFactory.getProp(this.element,properties[i].x,0,null,this.element);\\r\\n            filterID = 'fi_'+randomString(10);\\r\\n            expansor = createNS('filter');\\r\\n            expansor.setAttribute('id',filterID);\\r\\n            feMorph = createNS('feMorphology');\\r\\n            feMorph.setAttribute('operator','dilate');\\r\\n            feMorph.setAttribute('in','SourceGraphic');\\r\\n            feMorph.setAttribute('radius','0');\\r\\n            expansor.appendChild(feMorph);\\r\\n            defs.appendChild(expansor);\\r\\n            path.setAttribute('stroke', properties[i].mode === 's' ? '#000000':'#ffffff');\\r\\n        } else {\\r\\n            feMorph = null;\\r\\n            x = null;\\r\\n        }\\r\\n\\r\\n        // TODO move this to a factory or to a constructor\\r\\n        this.storedData[i] = {\\r\\n             elem: path,\\r\\n             x: x,\\r\\n             expan: feMorph,\\r\\n            lastPath: '',\\r\\n            lastOperator:'',\\r\\n            filterId:filterID,\\r\\n            lastRadius:0\\r\\n        };\\r\\n        if(properties[i].mode == 'i'){\\r\\n            jLen = currentMasks.length;\\r\\n            var g = createNS('g');\\r\\n            for(j=0;j<jLen;j+=1){\\r\\n                g.appendChild(currentMasks[j]);\\r\\n            }\\r\\n            var mask = createNS('mask');\\r\\n            mask.setAttribute('mask-type','alpha');\\r\\n            mask.setAttribute('id',layerId+'_'+count);\\r\\n            mask.appendChild(path);\\r\\n            defs.appendChild(mask);\\r\\n            g.setAttribute('mask','url(' + locationHref + '#'+layerId+'_'+count+')');\\r\\n\\r\\n            currentMasks.length = 0;\\r\\n            currentMasks.push(g);\\r\\n        }else{\\r\\n            currentMasks.push(path);\\r\\n        }\\r\\n        if(properties[i].inv && !this.solidPath){\\r\\n            this.solidPath = this.createLayerSolidPath();\\r\\n        }\\r\\n        // TODO move this to a factory or to a constructor\\r\\n        this.viewData[i] = {\\r\\n            elem: path,\\r\\n            lastPath: '',\\r\\n            op: PropertyFactory.getProp(this.element,properties[i].o,0,0.01,this.element),\\r\\n            prop:ShapePropertyFactory.getShapeProp(this.element,properties[i],3),\\r\\n            invRect: rect\\r\\n        };\\r\\n        if(!this.viewData[i].prop.k){\\r\\n            this.drawPath(properties[i],this.viewData[i].prop.v,this.viewData[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    this.maskElement = createNS( maskType);\\r\\n\\r\\n    len = currentMasks.length;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        this.maskElement.appendChild(currentMasks[i]);\\r\\n    }\\r\\n\\r\\n    if(count > 0){\\r\\n        this.maskElement.setAttribute('id', layerId);\\r\\n        this.element.maskedElement.setAttribute(maskRef, \\\"url(\\\" + locationHref + \\\"#\\\" + layerId + \\\")\\\");\\r\\n        defs.appendChild(this.maskElement);\\r\\n    }\\r\\n    if (this.viewData.length) {\\r\\n        this.element.addRenderableComponent(this);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\nMaskElement.prototype.getMaskProperty = function(pos){\\r\\n    return this.viewData[pos].prop;\\r\\n};\\r\\n\\r\\nMaskElement.prototype.renderFrame = function (isFirstFrame) {\\r\\n    var finalMat = this.element.finalTransform.mat;\\r\\n    var i, len = this.masksProperties.length;\\r\\n    for (i = 0; i < len; i++) {\\r\\n        if(this.viewData[i].prop._mdf || isFirstFrame){\\r\\n            this.drawPath(this.masksProperties[i],this.viewData[i].prop.v,this.viewData[i]);\\r\\n        }\\r\\n        if(this.viewData[i].op._mdf || isFirstFrame){\\r\\n            this.viewData[i].elem.setAttribute('fill-opacity',this.viewData[i].op.v);\\r\\n        }\\r\\n        if(this.masksProperties[i].mode !== 'n'){\\r\\n            if(this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)){\\r\\n                this.viewData[i].invRect.setAttribute('x', -finalMat.props[12]);\\r\\n                this.viewData[i].invRect.setAttribute('y', -finalMat.props[13]);\\r\\n            }\\r\\n            if(this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)){\\r\\n                var feMorph = this.storedData[i].expan;\\r\\n                if(this.storedData[i].x.v < 0){\\r\\n                    if(this.storedData[i].lastOperator !== 'erode'){\\r\\n                        this.storedData[i].lastOperator = 'erode';\\r\\n                        this.storedData[i].elem.setAttribute('filter','url(' + locationHref + '#'+this.storedData[i].filterId+')');\\r\\n                    }\\r\\n                    feMorph.setAttribute('radius',-this.storedData[i].x.v);\\r\\n                }else{\\r\\n                    if(this.storedData[i].lastOperator !== 'dilate'){\\r\\n                        this.storedData[i].lastOperator = 'dilate';\\r\\n                        this.storedData[i].elem.setAttribute('filter',null);\\r\\n                    }\\r\\n                    this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v*2);\\r\\n\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nMaskElement.prototype.getMaskelement = function () {\\r\\n    return this.maskElement;\\r\\n};\\r\\n\\r\\nMaskElement.prototype.createLayerSolidPath = function(){\\r\\n    var path = 'M0,0 ';\\r\\n    path += ' h' + this.globalData.compSize.w ;\\r\\n    path += ' v' + this.globalData.compSize.h ;\\r\\n    path += ' h-' + this.globalData.compSize.w ;\\r\\n    path += ' v-' + this.globalData.compSize.h + ' ';\\r\\n    return path;\\r\\n};\\r\\n\\r\\nMaskElement.prototype.drawPath = function(pathData,pathNodes,viewData){\\r\\n    var pathString = \\\" M\\\"+pathNodes.v[0][0]+','+pathNodes.v[0][1];\\r\\n    var i, len;\\r\\n    len = pathNodes._length;\\r\\n    for(i=1;i<len;i+=1){\\r\\n        //pathString += \\\" C\\\"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + \\\" \\\"+pathNodes.i[i][0]+','+pathNodes.i[i][1] + \\\" \\\"+pathNodes.v[i][0]+','+pathNodes.v[i][1];\\r\\n        pathString += \\\" C\\\"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + \\\" \\\"+pathNodes.i[i][0]+','+pathNodes.i[i][1] + \\\" \\\"+pathNodes.v[i][0]+','+pathNodes.v[i][1];\\r\\n    }\\r\\n        //pathString += \\\" C\\\"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + \\\" \\\"+pathNodes.i[0][0]+','+pathNodes.i[0][1] + \\\" \\\"+pathNodes.v[0][0]+','+pathNodes.v[0][1];\\r\\n    if(pathNodes.c && len > 1){\\r\\n        pathString += \\\" C\\\"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + \\\" \\\"+pathNodes.i[0][0]+','+pathNodes.i[0][1] + \\\" \\\"+pathNodes.v[0][0]+','+pathNodes.v[0][1];\\r\\n    }\\r\\n    //pathNodes.__renderedString = pathString;\\r\\n\\r\\n    if(viewData.lastPath !== pathString){\\r\\n        var pathShapeValue = '';\\r\\n        if(viewData.elem){\\r\\n            if(pathNodes.c){\\r\\n                pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;\\r\\n            }\\r\\n            viewData.elem.setAttribute('d',pathShapeValue);\\r\\n        }\\r\\n        viewData.lastPath = pathString;\\r\\n    }\\r\\n};\\r\\n\\r\\nMaskElement.prototype.destroy = function(){\\r\\n    this.element = null;\\r\\n    this.globalData = null;\\r\\n    this.maskElement = null;\\r\\n    this.data = null;\\r\\n    this.masksProperties = null;\\r\\n};\\r\\n\\n/**\\r\\n * @file \\r\\n * Handles AE's layer parenting property.\\r\\n *\\r\\n */\\r\\n\\r\\nfunction HierarchyElement(){}\\r\\n\\r\\nHierarchyElement.prototype = {\\r\\n\\t/**\\r\\n     * @function \\r\\n     * Initializes hierarchy properties\\r\\n     *\\r\\n     */\\r\\n\\tinitHierarchy: function() {\\r\\n\\t\\t//element's parent list\\r\\n\\t    this.hierarchy = [];\\r\\n\\t    //if element is parent of another layer _isParent will be true\\r\\n\\t    this._isParent = false;\\r\\n\\t    this.checkParenting();\\r\\n\\t},\\r\\n\\t/**\\r\\n     * @function \\r\\n     * Sets layer's hierarchy.\\r\\n     * @param {array} hierarch\\r\\n     * layer's parent list\\r\\n     *\\r\\n     */ \\r\\n\\tsetHierarchy: function(hierarchy){\\r\\n\\t    this.hierarchy = hierarchy;\\r\\n\\t},\\r\\n\\t/**\\r\\n     * @function \\r\\n     * Sets layer as parent.\\r\\n     *\\r\\n     */ \\r\\n\\tsetAsParent: function() {\\r\\n\\t    this._isParent = true;\\r\\n\\t},\\r\\n\\t/**\\r\\n     * @function \\r\\n     * Searches layer's parenting chain\\r\\n     *\\r\\n     */ \\r\\n\\tcheckParenting: function(){\\r\\n\\t    if (this.data.parent !== undefined){\\r\\n\\t        this.comp.buildElementParenting(this, this.data.parent, []);\\r\\n\\t    }\\r\\n\\t}\\r\\n};\\n/**\\r\\n * @file \\r\\n * Handles element's layer frame update.\\r\\n * Checks layer in point and out point\\r\\n *\\r\\n */\\r\\n\\r\\nfunction FrameElement(){}\\r\\n\\r\\nFrameElement.prototype = {\\r\\n    /**\\r\\n     * @function \\r\\n     * Initializes frame related properties.\\r\\n     *\\r\\n     */\\r\\n    initFrame: function(){\\r\\n        //set to true when inpoint is rendered\\r\\n        this._isFirstFrame = false;\\r\\n        //list of animated properties\\r\\n        this.dynamicProperties = [];\\r\\n        // If layer has been modified in current tick this will be true\\r\\n        this._mdf = false;\\r\\n    },\\r\\n    /**\\r\\n     * @function \\r\\n     * Calculates all dynamic values\\r\\n     *\\r\\n     * @param {number} num\\r\\n     * current frame number in Layer's time\\r\\n     * @param {boolean} isVisible\\r\\n     * if layers is currently in range\\r\\n     * \\r\\n     */\\r\\n    prepareProperties: function(num, isVisible) {\\r\\n        var i, len = this.dynamicProperties.length;\\r\\n        for (i = 0;i < len; i += 1) {\\r\\n            if (isVisible || (this._isParent && this.dynamicProperties[i].propType === 'transform')) {\\r\\n                this.dynamicProperties[i].getValue();\\r\\n                if (this.dynamicProperties[i]._mdf) {\\r\\n                    this.globalData._mdf = true;\\r\\n                    this._mdf = true;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    },\\r\\n    addDynamicProperty: function(prop) {\\r\\n        if(this.dynamicProperties.indexOf(prop) === -1) {\\r\\n            this.dynamicProperties.push(prop);\\r\\n        }\\r\\n    }\\r\\n};\\nfunction TransformElement(){}\\r\\n\\r\\nTransformElement.prototype = {\\r\\n    initTransform: function() {\\r\\n        this.finalTransform = {\\r\\n            mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {o:0},\\r\\n            _matMdf: false,\\r\\n            _opMdf: false,\\r\\n            mat: new Matrix()\\r\\n        };\\r\\n        if (this.data.ao) {\\r\\n            this.finalTransform.mProp.autoOriented = true;\\r\\n        }\\r\\n\\r\\n        //TODO: check TYPE 11: Guided elements\\r\\n        if (this.data.ty !== 11) {\\r\\n            //this.createElements();\\r\\n        }\\r\\n    },\\r\\n    renderTransform: function() {\\r\\n\\r\\n        this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;\\r\\n        this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;\\r\\n\\r\\n        if (this.hierarchy) {\\r\\n            var mat;\\r\\n            var finalMat = this.finalTransform.mat;\\r\\n            var i = 0, len = this.hierarchy.length;\\r\\n            //Checking if any of the transformation matrices in the hierarchy chain has changed.\\r\\n            if (!this.finalTransform._matMdf) {\\r\\n                while (i < len) {\\r\\n                    if (this.hierarchy[i].finalTransform.mProp._mdf) {\\r\\n                        this.finalTransform._matMdf = true;\\r\\n                        break;\\r\\n                    }\\r\\n                    i += 1;\\r\\n                }\\r\\n            }\\r\\n            \\r\\n            if (this.finalTransform._matMdf) {\\r\\n                mat = this.finalTransform.mProp.v.props;\\r\\n                finalMat.cloneFromProps(mat);\\r\\n                for (i = 0; i < len; i += 1) {\\r\\n                    mat = this.hierarchy[i].finalTransform.mProp.v.props;\\r\\n                    finalMat.transform(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5], mat[6], mat[7], mat[8], mat[9], mat[10], mat[11], mat[12], mat[13], mat[14], mat[15]);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    },\\r\\n    globalToLocal: function(pt) {\\r\\n        var transforms = [];\\r\\n        transforms.push(this.finalTransform);\\r\\n        var flag = true;\\r\\n        var comp = this.comp;\\r\\n        while (flag) {\\r\\n            if (comp.finalTransform) {\\r\\n                if (comp.data.hasMask) {\\r\\n                    transforms.splice(0, 0, comp.finalTransform);\\r\\n                }\\r\\n                comp = comp.comp;\\r\\n            } else {\\r\\n                flag = false;\\r\\n            }\\r\\n        }\\r\\n        var i, len = transforms.length,ptNew;\\r\\n        for (i = 0; i < len; i += 1) {\\r\\n            ptNew = transforms[i].mat.applyToPointArray(0, 0, 0);\\r\\n            //ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);\\r\\n            pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];\\r\\n        }\\r\\n        return pt;\\r\\n    },\\r\\n    mHelper: new Matrix()\\r\\n};\\nfunction RenderableElement(){\\r\\n\\r\\n}\\r\\n\\r\\nRenderableElement.prototype = {\\r\\n    initRenderable: function() {\\r\\n        //layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange\\r\\n        this.isInRange = false;\\r\\n        //layer's display state\\r\\n        this.hidden = false;\\r\\n        // If layer's transparency equals 0, it can be hidden\\r\\n        this.isTransparent = false;\\r\\n        //list of animated components\\r\\n        this.renderableComponents = [];\\r\\n    },\\r\\n    addRenderableComponent: function(component) {\\r\\n        if(this.renderableComponents.indexOf(component) === -1) {\\r\\n            this.renderableComponents.push(component);\\r\\n        }\\r\\n    },\\r\\n    removeRenderableComponent: function(component) {\\r\\n        if(this.renderableComponents.indexOf(component) !== -1) {\\r\\n            this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);\\r\\n        }\\r\\n    },\\r\\n    prepareRenderableFrame: function(num) {\\r\\n        this.checkLayerLimits(num);\\r\\n    },\\r\\n    checkTransparency: function(){\\r\\n        if(this.finalTransform.mProp.o.v <= 0) {\\r\\n            if(!this.isTransparent && this.globalData.renderConfig.hideOnTransparent){\\r\\n                this.isTransparent = true;\\r\\n                this.hide();\\r\\n            }\\r\\n        } else if(this.isTransparent) {\\r\\n            this.isTransparent = false;\\r\\n            this.show();\\r\\n        }\\r\\n    },\\r\\n    /**\\r\\n     * @function \\r\\n     * Initializes frame related properties.\\r\\n     *\\r\\n     * @param {number} num\\r\\n     * current frame number in Layer's time\\r\\n     * \\r\\n     */\\r\\n    checkLayerLimits: function(num) {\\r\\n        if(this.data.ip - this.data.st <= num && this.data.op - this.data.st > num)\\r\\n        {\\r\\n            if(this.isInRange !== true){\\r\\n                this.globalData._mdf = true;\\r\\n                this._mdf = true;\\r\\n                this.isInRange = true;\\r\\n                this.show();\\r\\n            }\\r\\n        } else {\\r\\n            if(this.isInRange !== false){\\r\\n                this.globalData._mdf = true;\\r\\n                this.isInRange = false;\\r\\n                this.hide();\\r\\n            }\\r\\n        }\\r\\n    },\\r\\n    renderRenderable: function() {\\r\\n        var i, len = this.renderableComponents.length;\\r\\n        for(i = 0; i < len; i += 1) {\\r\\n            this.renderableComponents[i].renderFrame(this._isFirstFrame);\\r\\n        }\\r\\n        /*this.maskManager.renderFrame(this.finalTransform.mat);\\r\\n        this.renderableEffectsManager.renderFrame(this._isFirstFrame);*/\\r\\n    },\\r\\n    sourceRectAtTime: function(){\\r\\n        return {\\r\\n            top:0,\\r\\n            left:0,\\r\\n            width:100,\\r\\n            height:100\\r\\n        };\\r\\n    },\\r\\n    getLayerSize: function(){\\r\\n        if(this.data.ty === 5){\\r\\n            return {w:this.data.textData.width,h:this.data.textData.height};\\r\\n        }else{\\r\\n            return {w:this.data.width,h:this.data.height};\\r\\n        }\\r\\n    }\\r\\n};\\nfunction RenderableDOMElement() {}\\r\\n\\r\\n(function(){\\r\\n    var _prototype = {\\r\\n        initElement: function(data,globalData,comp) {\\r\\n            this.initFrame();\\r\\n            this.initBaseData(data, globalData, comp);\\r\\n            this.initTransform(data, globalData, comp);\\r\\n            this.initHierarchy();\\r\\n            this.initRenderable();\\r\\n            this.initRendererElement();\\r\\n            this.createContainerElements();\\r\\n            this.createRenderableComponents();\\r\\n            this.createContent();\\r\\n            this.hide();\\r\\n        },\\r\\n        hide: function(){\\r\\n            if (!this.hidden && (!this.isInRange || this.isTransparent)) {\\r\\n                var elem = this.baseElement || this.layerElement;\\r\\n                elem.style.display = 'none';\\r\\n                this.hidden = true;\\r\\n            }\\r\\n        },\\r\\n        show: function(){\\r\\n            if (this.isInRange && !this.isTransparent){\\r\\n                if (!this.data.hd) {\\r\\n                    var elem = this.baseElement || this.layerElement;\\r\\n                    elem.style.display = 'block';\\r\\n                }\\r\\n                this.hidden = false;\\r\\n                this._isFirstFrame = true;\\r\\n            }\\r\\n        },\\r\\n        renderFrame: function() {\\r\\n            //If it is exported as hidden (data.hd === true) no need to render\\r\\n            //If it is not visible no need to render\\r\\n            if (this.data.hd || this.hidden) {\\r\\n                return;\\r\\n            }\\r\\n            this.renderTransform();\\r\\n            this.renderRenderable();\\r\\n            this.renderElement();\\r\\n            this.renderInnerContent();\\r\\n            if (this._isFirstFrame) {\\r\\n                this._isFirstFrame = false;\\r\\n            }\\r\\n        },\\r\\n        renderInnerContent: function() {},\\r\\n        prepareFrame: function(num) {\\r\\n            this._mdf = false;\\r\\n            this.prepareRenderableFrame(num);\\r\\n            this.prepareProperties(num, this.isInRange);\\r\\n            this.checkTransparency();\\r\\n        },\\r\\n        destroy: function(){\\r\\n            this.innerElem =  null;\\r\\n            this.destroyBaseElement();\\r\\n        }\\r\\n    };\\r\\n    extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);\\r\\n}());\\nfunction ProcessedElement(element, position) {\\r\\n\\tthis.elem = element;\\r\\n\\tthis.pos = position;\\r\\n}\\nfunction SVGStyleData(data, level) {\\r\\n\\tthis.data = data;\\r\\n\\tthis.type = data.ty;\\r\\n\\tthis.d = '';\\r\\n\\tthis.lvl = level;\\r\\n\\tthis._mdf = false;\\r\\n\\tthis.closed = data.hd === true;\\r\\n\\tthis.pElem = createNS('path');\\r\\n\\tthis.msElem = null;\\r\\n}\\r\\n\\r\\nSVGStyleData.prototype.reset = function() {\\r\\n\\tthis.d = '';\\r\\n\\tthis._mdf = false;\\r\\n};\\nfunction SVGShapeData(transformers, level, shape) {\\r\\n    this.caches = [];\\r\\n    this.styles = [];\\r\\n    this.transformers = transformers;\\r\\n    this.lStr = '';\\r\\n    this.sh = shape;\\r\\n    this.lvl = level;\\r\\n    //TODO find if there are some cases where _isAnimated can be false. \\r\\n    // For now, since shapes add up with other shapes. They have to be calculated every time.\\r\\n    // One way of finding out is checking if all styles associated to this shape depend only of this shape\\r\\n    this._isAnimated = !!shape.k;\\r\\n    // TODO: commenting this for now since all shapes are animated\\r\\n    var i = 0, len = transformers.length;\\r\\n    while(i < len) {\\r\\n    \\tif(transformers[i].mProps.dynamicProperties.length) {\\r\\n    \\t\\tthis._isAnimated = true;\\r\\n    \\t\\tbreak;\\r\\n    \\t}\\r\\n    \\ti += 1;\\r\\n    }\\r\\n}\\r\\n\\r\\nSVGShapeData.prototype.setAsAnimated = function() {\\r\\n    this._isAnimated = true;\\r\\n}\\nfunction SVGTransformData(mProps, op, container) {\\r\\n\\tthis.transform = {\\r\\n\\t\\tmProps: mProps,\\r\\n\\t\\top: op,\\r\\n\\t\\tcontainer: container\\r\\n\\t};\\r\\n\\tthis.elements = [];\\r\\n    this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;\\r\\n}\\nfunction SVGStrokeStyleData(elem, data, styleOb){\\r\\n\\tthis.initDynamicPropertyContainer(elem);\\r\\n\\tthis.getValue = this.iterateDynamicProperties;\\r\\n\\tthis.o = PropertyFactory.getProp(elem,data.o,0,0.01,this);\\r\\n\\tthis.w = PropertyFactory.getProp(elem,data.w,0,null,this);\\r\\n\\tthis.d = new DashProperty(elem,data.d||{},'svg',this);\\r\\n\\tthis.c = PropertyFactory.getProp(elem,data.c,1,255,this);\\r\\n\\tthis.style = styleOb;\\r\\n    this._isAnimated = !!this._isAnimated;\\r\\n}\\r\\n\\r\\nextendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);\\nfunction SVGFillStyleData(elem, data, styleOb){\\r\\n\\tthis.initDynamicPropertyContainer(elem);\\r\\n\\tthis.getValue = this.iterateDynamicProperties;\\r\\n\\tthis.o = PropertyFactory.getProp(elem,data.o,0,0.01,this);\\r\\n\\tthis.c = PropertyFactory.getProp(elem,data.c,1,255,this);\\r\\n\\tthis.style = styleOb;\\r\\n}\\r\\n\\r\\nextendPrototype([DynamicPropertyContainer], SVGFillStyleData);\\nfunction SVGGradientFillStyleData(elem, data, styleOb){\\r\\n    this.initDynamicPropertyContainer(elem);\\r\\n    this.getValue = this.iterateDynamicProperties;\\r\\n    this.initGradientData(elem, data, styleOb);\\r\\n}\\r\\n\\r\\nSVGGradientFillStyleData.prototype.initGradientData = function(elem, data, styleOb){\\r\\n    this.o = PropertyFactory.getProp(elem,data.o,0,0.01,this);\\r\\n    this.s = PropertyFactory.getProp(elem,data.s,1,null,this);\\r\\n    this.e = PropertyFactory.getProp(elem,data.e,1,null,this);\\r\\n    this.h = PropertyFactory.getProp(elem,data.h||{k:0},0,0.01,this);\\r\\n    this.a = PropertyFactory.getProp(elem,data.a||{k:0},0,degToRads,this);\\r\\n    this.g = new GradientProperty(elem,data.g,this);\\r\\n    this.style = styleOb;\\r\\n    this.stops = [];\\r\\n    this.setGradientData(styleOb.pElem, data);\\r\\n    this.setGradientOpacity(data, styleOb);\\r\\n    this._isAnimated = !!this._isAnimated;\\r\\n\\r\\n};\\r\\n\\r\\nSVGGradientFillStyleData.prototype.setGradientData = function(pathElement,data){\\r\\n\\r\\n    var gradientId = 'gr_'+randomString(10);\\r\\n    var gfill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');\\r\\n    gfill.setAttribute('id',gradientId);\\r\\n    gfill.setAttribute('spreadMethod','pad');\\r\\n    gfill.setAttribute('gradientUnits','userSpaceOnUse');\\r\\n    var stops = [];\\r\\n    var stop, j, jLen;\\r\\n    jLen = data.g.p*4;\\r\\n    for(j=0;j<jLen;j+=4){\\r\\n        stop = createNS('stop');\\r\\n        gfill.appendChild(stop);\\r\\n        stops.push(stop);\\r\\n    }\\r\\n    pathElement.setAttribute( data.ty === 'gf' ? 'fill':'stroke','url(#'+gradientId+')');\\r\\n    \\r\\n    this.gf = gfill;\\r\\n    this.cst = stops;\\r\\n};\\r\\n\\r\\nSVGGradientFillStyleData.prototype.setGradientOpacity = function(data, styleOb){\\r\\n    if(this.g._hasOpacity && !this.g._collapsable){\\r\\n        var stop, j, jLen;\\r\\n        var mask = createNS(\\\"mask\\\");\\r\\n        var maskElement = createNS( 'path');\\r\\n        mask.appendChild(maskElement);\\r\\n        var opacityId = 'op_'+randomString(10);\\r\\n        var maskId = 'mk_'+randomString(10);\\r\\n        mask.setAttribute('id',maskId);\\r\\n        var opFill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');\\r\\n        opFill.setAttribute('id',opacityId);\\r\\n        opFill.setAttribute('spreadMethod','pad');\\r\\n        opFill.setAttribute('gradientUnits','userSpaceOnUse');\\r\\n        jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;\\r\\n        var stops = this.stops;\\r\\n        for(j=data.g.p*4;j<jLen;j+=2){\\r\\n            stop = createNS('stop');\\r\\n            stop.setAttribute('stop-color','rgb(255,255,255)');\\r\\n            opFill.appendChild(stop);\\r\\n            stops.push(stop);\\r\\n        }\\r\\n        maskElement.setAttribute( data.ty === 'gf' ? 'fill':'stroke','url(#'+opacityId+')');\\r\\n        this.of = opFill;\\r\\n        this.ms = mask;\\r\\n        this.ost = stops;\\r\\n        this.maskId = maskId;\\r\\n        styleOb.msElem = maskElement;\\r\\n    }\\r\\n};\\r\\n\\r\\nextendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);\\nfunction SVGGradientStrokeStyleData(elem, data, styleOb){\\r\\n\\tthis.initDynamicPropertyContainer(elem);\\r\\n\\tthis.getValue = this.iterateDynamicProperties;\\r\\n\\tthis.w = PropertyFactory.getProp(elem,data.w,0,null,this);\\r\\n\\tthis.d = new DashProperty(elem,data.d||{},'svg',this);\\r\\n    this.initGradientData(elem, data, styleOb);\\r\\n    this._isAnimated = !!this._isAnimated;\\r\\n}\\r\\n\\r\\nextendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);\\nfunction ShapeGroupData() {\\r\\n\\tthis.it = [];\\r\\n    this.prevViewData = [];\\r\\n    this.gr = createNS('g');\\r\\n}\\nvar SVGElementsRenderer = (function() {\\r\\n\\tvar _identityMatrix = new Matrix();\\r\\n\\tvar _matrixHelper = new Matrix();\\r\\n\\r\\n\\tvar ob = {\\r\\n\\t\\tcreateRenderFunction: createRenderFunction\\r\\n\\t}\\r\\n\\r\\n\\tfunction createRenderFunction(data) {\\r\\n\\t    var ty = data.ty;\\r\\n\\t    switch(data.ty) {\\r\\n\\t        case 'fl':\\r\\n\\t        return renderFill;\\r\\n\\t        case 'gf':\\r\\n\\t        return renderGradient;\\r\\n\\t        case 'gs':\\r\\n\\t        return renderGradientStroke;\\r\\n\\t        case 'st':\\r\\n\\t        return renderStroke;\\r\\n\\t        case 'sh':\\r\\n\\t        case 'el':\\r\\n\\t        case 'rc':\\r\\n\\t        case 'sr':\\r\\n\\t        return renderPath;\\r\\n\\t        case 'tr':\\r\\n\\t        return renderContentTransform;\\r\\n\\t    }\\r\\n\\t}\\r\\n\\r\\n\\tfunction renderContentTransform(styleData, itemData, isFirstFrame) {\\r\\n\\t    if(isFirstFrame || itemData.transform.op._mdf){\\r\\n\\t        itemData.transform.container.setAttribute('opacity',itemData.transform.op.v);\\r\\n\\t    }\\r\\n\\t    if(isFirstFrame || itemData.transform.mProps._mdf){\\r\\n\\t        itemData.transform.container.setAttribute('transform',itemData.transform.mProps.v.to2dCSS());\\r\\n\\t    }\\r\\n\\t}\\r\\n\\r\\n\\tfunction renderPath(styleData, itemData, isFirstFrame) {\\r\\n\\t    var j, jLen,pathStringTransformed,redraw,pathNodes,l, lLen = itemData.styles.length;\\r\\n\\t    var lvl = itemData.lvl;\\r\\n\\t    var paths, mat, props, iterations, k;\\r\\n\\t    for(l=0;l<lLen;l+=1){\\r\\n\\t        redraw = itemData.sh._mdf || isFirstFrame;\\r\\n\\t        if(itemData.styles[l].lvl < lvl){\\r\\n\\t            mat = _matrixHelper.reset();\\r\\n\\t            iterations = lvl - itemData.styles[l].lvl;\\r\\n\\t            k = itemData.transformers.length-1;\\r\\n\\t            while(!redraw && iterations > 0) {\\r\\n\\t                redraw = itemData.transformers[k].mProps._mdf || redraw;\\r\\n\\t                iterations --;\\r\\n\\t                k --;\\r\\n\\t            }\\r\\n\\t            if(redraw) {\\r\\n\\t                iterations = lvl - itemData.styles[l].lvl;\\r\\n\\t                k = itemData.transformers.length-1;\\r\\n\\t                while(iterations > 0) {\\r\\n\\t                    props = itemData.transformers[k].mProps.v.props;\\r\\n\\t                    mat.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);\\r\\n\\t                    iterations --;\\r\\n\\t                    k --;\\r\\n\\t                }\\r\\n\\t            }\\r\\n\\t        } else {\\r\\n\\t            mat = _identityMatrix;\\r\\n\\t        }\\r\\n\\t        paths = itemData.sh.paths;\\r\\n\\t        jLen = paths._length;\\r\\n\\t        if(redraw){\\r\\n\\t            pathStringTransformed = '';\\r\\n\\t            for(j=0;j<jLen;j+=1){\\r\\n\\t                pathNodes = paths.shapes[j];\\r\\n\\t                if(pathNodes && pathNodes._length){\\r\\n\\t                    pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);\\r\\n\\t                }\\r\\n\\t            }\\r\\n\\t            itemData.caches[l] = pathStringTransformed;\\r\\n\\t        } else {\\r\\n\\t            pathStringTransformed = itemData.caches[l];\\r\\n\\t        }\\r\\n\\t        itemData.styles[l].d += styleData.hd === true ? '' : pathStringTransformed;\\r\\n\\t        itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;\\r\\n\\t    }\\r\\n\\t}\\r\\n\\r\\n\\tfunction renderFill (styleData,itemData, isFirstFrame){\\r\\n\\t    var styleElem = itemData.style;\\r\\n\\r\\n\\t    if(itemData.c._mdf || isFirstFrame){\\r\\n\\t        styleElem.pElem.setAttribute('fill','rgb('+bm_floor(itemData.c.v[0])+','+bm_floor(itemData.c.v[1])+','+bm_floor(itemData.c.v[2])+')');\\r\\n\\t    }\\r\\n\\t    if(itemData.o._mdf || isFirstFrame){\\r\\n\\t        styleElem.pElem.setAttribute('fill-opacity',itemData.o.v);\\r\\n\\t    }\\r\\n\\t};\\r\\n\\r\\n\\tfunction renderGradientStroke (styleData, itemData, isFirstFrame) {\\r\\n\\t    renderGradient(styleData, itemData, isFirstFrame);\\r\\n\\t    renderStroke(styleData, itemData, isFirstFrame);\\r\\n\\t}\\r\\n\\r\\n\\tfunction renderGradient(styleData, itemData, isFirstFrame) {\\r\\n\\t    var gfill = itemData.gf;\\r\\n\\t    var hasOpacity = itemData.g._hasOpacity;\\r\\n\\t    var pt1 = itemData.s.v, pt2 = itemData.e.v;\\r\\n\\r\\n\\t    if (itemData.o._mdf || isFirstFrame) {\\r\\n\\t        var attr = styleData.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity';\\r\\n\\t        itemData.style.pElem.setAttribute(attr, itemData.o.v);\\r\\n\\t    }\\r\\n\\t    if (itemData.s._mdf || isFirstFrame) {\\r\\n\\t        var attr1 = styleData.t === 1 ? 'x1' : 'cx';\\r\\n\\t        var attr2 = attr1 === 'x1' ? 'y1' : 'cy';\\r\\n\\t        gfill.setAttribute(attr1, pt1[0]);\\r\\n\\t        gfill.setAttribute(attr2, pt1[1]);\\r\\n\\t        if (hasOpacity && !itemData.g._collapsable) {\\r\\n\\t            itemData.of.setAttribute(attr1, pt1[0]);\\r\\n\\t            itemData.of.setAttribute(attr2, pt1[1]);\\r\\n\\t        }\\r\\n\\t    }\\r\\n\\t    var stops, i, len, stop;\\r\\n\\t    if (itemData.g._cmdf || isFirstFrame) {\\r\\n\\t        stops = itemData.cst;\\r\\n\\t        var cValues = itemData.g.c;\\r\\n\\t        len = stops.length;\\r\\n\\t        for (i = 0; i < len; i += 1){\\r\\n\\t            stop = stops[i];\\r\\n\\t            stop.setAttribute('offset', cValues[i * 4] + '%');\\r\\n\\t            stop.setAttribute('stop-color','rgb('+ cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ','+cValues[i * 4 + 3] + ')');\\r\\n\\t        }\\r\\n\\t    }\\r\\n\\t    if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {\\r\\n\\t        var oValues = itemData.g.o;\\r\\n\\t        if(itemData.g._collapsable) {\\r\\n\\t            stops = itemData.cst;\\r\\n\\t        } else {\\r\\n\\t            stops = itemData.ost;\\r\\n\\t        }\\r\\n\\t        len = stops.length;\\r\\n\\t        for (i = 0; i < len; i += 1) {\\r\\n\\t            stop = stops[i];\\r\\n\\t            if(!itemData.g._collapsable) {\\r\\n\\t                stop.setAttribute('offset', oValues[i * 2] + '%');\\r\\n\\t            }\\r\\n\\t            stop.setAttribute('stop-opacity', oValues[i * 2 + 1]);\\r\\n\\t        }\\r\\n\\t    }\\r\\n\\t    if (styleData.t === 1) {\\r\\n\\t        if (itemData.e._mdf  || isFirstFrame) {\\r\\n\\t            gfill.setAttribute('x2', pt2[0]);\\r\\n\\t            gfill.setAttribute('y2', pt2[1]);\\r\\n\\t            if (hasOpacity && !itemData.g._collapsable) {\\r\\n\\t                itemData.of.setAttribute('x2', pt2[0]);\\r\\n\\t                itemData.of.setAttribute('y2', pt2[1]);\\r\\n\\t            }\\r\\n\\t        }\\r\\n\\t    } else {\\r\\n\\t        var rad;\\r\\n\\t        if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {\\r\\n\\t            rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\\r\\n\\t            gfill.setAttribute('r', rad);\\r\\n\\t            if(hasOpacity && !itemData.g._collapsable){\\r\\n\\t                itemData.of.setAttribute('r', rad);\\r\\n\\t            }\\r\\n\\t        }\\r\\n\\t        if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {\\r\\n\\t            if (!rad) {\\r\\n\\t                rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\\r\\n\\t            }\\r\\n\\t            var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);\\r\\n\\r\\n\\t            var percent = itemData.h.v >= 1 ? 0.99 : itemData.h.v <= -1 ? -0.99: itemData.h.v;\\r\\n\\t            var dist = rad * percent;\\r\\n\\t            var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];\\r\\n\\t            var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];\\r\\n\\t            gfill.setAttribute('fx', x);\\r\\n\\t            gfill.setAttribute('fy', y);\\r\\n\\t            if (hasOpacity && !itemData.g._collapsable) {\\r\\n\\t                itemData.of.setAttribute('fx', x);\\r\\n\\t                itemData.of.setAttribute('fy', y);\\r\\n\\t            }\\r\\n\\t        }\\r\\n\\t        //gfill.setAttribute('fy','200');\\r\\n\\t    }\\r\\n\\t};\\r\\n\\r\\n\\tfunction renderStroke(styleData, itemData, isFirstFrame) {\\r\\n\\t    var styleElem = itemData.style;\\r\\n\\t    var d = itemData.d;\\r\\n\\t    if (d && (d._mdf || isFirstFrame) && d.dashStr) {\\r\\n\\t        styleElem.pElem.setAttribute('stroke-dasharray', d.dashStr);\\r\\n\\t        styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset[0]);\\r\\n\\t    }\\r\\n\\t    if(itemData.c && (itemData.c._mdf || isFirstFrame)){\\r\\n\\t        styleElem.pElem.setAttribute('stroke','rgb(' + bm_floor(itemData.c.v[0]) + ',' + bm_floor(itemData.c.v[1]) + ',' + bm_floor(itemData.c.v[2]) + ')');\\r\\n\\t    }\\r\\n\\t    if(itemData.o._mdf || isFirstFrame){\\r\\n\\t        styleElem.pElem.setAttribute('stroke-opacity', itemData.o.v);\\r\\n\\t    }\\r\\n\\t    if(itemData.w._mdf || isFirstFrame){\\r\\n\\t        styleElem.pElem.setAttribute('stroke-width', itemData.w.v);\\r\\n\\t        if(styleElem.msElem){\\r\\n\\t            styleElem.msElem.setAttribute('stroke-width', itemData.w.v);\\r\\n\\t        }\\r\\n\\t    }\\r\\n\\t};\\r\\n\\r\\n\\treturn ob;\\r\\n}())\\nfunction ShapeTransformManager() {\\r\\n\\tthis.sequences = {};\\r\\n\\tthis.sequenceList = [];\\r\\n    this.transform_key_count = 0;\\r\\n}\\r\\n\\r\\nShapeTransformManager.prototype = {\\r\\n\\taddTransformSequence: function(transforms) {\\r\\n\\t\\tvar i, len = transforms.length;\\r\\n\\t\\tvar key = '_';\\r\\n\\t\\tfor(i = 0; i < len; i += 1) {\\r\\n\\t\\t\\tkey += transforms[i].transform.key + '_';\\r\\n\\t\\t}\\r\\n\\t\\tvar sequence = this.sequences[key];\\r\\n\\t\\tif(!sequence) {\\r\\n\\t\\t\\tsequence = {\\r\\n\\t\\t\\t\\ttransforms: [].concat(transforms),\\r\\n\\t\\t\\t\\tfinalTransform: new Matrix(),\\r\\n\\t\\t\\t\\t_mdf: false\\r\\n\\t\\t\\t};\\r\\n\\t\\t\\tthis.sequences[key] = sequence;\\r\\n\\t\\t\\tthis.sequenceList.push(sequence);\\r\\n\\t\\t}\\r\\n\\t\\treturn sequence;\\r\\n\\t},\\r\\n\\tprocessSequence: function(sequence, isFirstFrame) {\\r\\n\\t\\tvar i = 0, len = sequence.transforms.length, _mdf = isFirstFrame;\\r\\n\\t\\twhile (i < len && !isFirstFrame) {\\r\\n\\t\\t\\tif (sequence.transforms[i].transform.mProps._mdf) {\\r\\n\\t\\t\\t\\t_mdf = true;\\r\\n\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t}\\r\\n\\t\\t\\ti += 1\\r\\n\\t\\t}\\r\\n\\t\\tif (_mdf) {\\r\\n\\t\\t\\tvar props;\\r\\n\\t\\t\\tsequence.finalTransform.reset();\\r\\n\\t\\t\\tfor (i = len - 1; i >= 0; i -= 1) {\\r\\n\\t\\t        props = sequence.transforms[i].transform.mProps.v.props;\\r\\n\\t\\t        sequence.finalTransform.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\tsequence._mdf = _mdf;\\r\\n\\t\\t\\r\\n\\t},\\r\\n\\tprocessSequences: function(isFirstFrame) {\\r\\n\\t\\tvar i, len = this.sequenceList.length;\\r\\n\\t\\tfor (i = 0; i < len; i += 1) {\\r\\n\\t\\t\\tthis.processSequence(this.sequenceList[i], isFirstFrame);\\r\\n\\t\\t}\\r\\n\\r\\n\\t},\\r\\n\\tgetNewKey: function() {\\r\\n\\t\\treturn '_' + this.transform_key_count++;\\r\\n\\t}\\r\\n}\\nfunction BaseElement(){\\r\\n}\\r\\n\\r\\nBaseElement.prototype = {\\r\\n    checkMasks: function(){\\r\\n        if(!this.data.hasMask){\\r\\n            return false;\\r\\n        }\\r\\n        var i = 0, len = this.data.masksProperties.length;\\r\\n        while(i<len) {\\r\\n            if((this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false)) {\\r\\n                return true;\\r\\n            }\\r\\n            i += 1;\\r\\n        }\\r\\n        return false;\\r\\n    },\\r\\n    initExpressions: function(){\\r\\n        this.layerInterface = LayerExpressionInterface(this);\\r\\n        if(this.data.hasMask && this.maskManager) {\\r\\n            this.layerInterface.registerMaskInterface(this.maskManager);\\r\\n        }\\r\\n        var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this,this.layerInterface);\\r\\n        this.layerInterface.registerEffectsInterface(effectsInterface);\\r\\n\\r\\n        if(this.data.ty === 0 || this.data.xt){\\r\\n            this.compInterface = CompExpressionInterface(this);\\r\\n        } else if(this.data.ty === 4){\\r\\n            this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData,this.itemsData,this.layerInterface);\\r\\n            this.layerInterface.content = this.layerInterface.shapeInterface;\\r\\n        } else if(this.data.ty === 5){\\r\\n            this.layerInterface.textInterface = TextExpressionInterface(this);\\r\\n            this.layerInterface.text = this.layerInterface.textInterface;\\r\\n        }\\r\\n    },\\r\\n    blendModeEnums: {\\r\\n        1:'multiply',\\r\\n        2:'screen',\\r\\n        3:'overlay',\\r\\n        4:'darken',\\r\\n        5:'lighten',\\r\\n        6:'color-dodge',\\r\\n        7:'color-burn',\\r\\n        8:'hard-light',\\r\\n        9:'soft-light',\\r\\n        10:'difference',\\r\\n        11:'exclusion',\\r\\n        12:'hue',\\r\\n        13:'saturation',\\r\\n        14:'color',\\r\\n        15:'luminosity'\\r\\n    },\\r\\n    getBlendMode: function(){\\r\\n        return this.blendModeEnums[this.data.bm] || '';\\r\\n    },\\r\\n    setBlendMode: function(){\\r\\n        var blendModeValue = this.getBlendMode();\\r\\n        var elem = this.baseElement || this.layerElement;\\r\\n\\r\\n        elem.style['mix-blend-mode'] = blendModeValue;\\r\\n    },\\r\\n    initBaseData: function(data, globalData, comp){\\r\\n        this.globalData = globalData;\\r\\n        this.comp = comp;\\r\\n        this.data = data;\\r\\n        this.layerId = 'ly_'+randomString(10);\\r\\n        \\r\\n        //Stretch factor for old animations missing this property.\\r\\n        if(!this.data.sr){\\r\\n            this.data.sr = 1;\\r\\n        }\\r\\n        // effects manager\\r\\n        this.effectsManager = new EffectsManager(this.data,this,this.dynamicProperties);\\r\\n        \\r\\n    },\\r\\n    getType: function(){\\r\\n        return this.type;\\r\\n    }\\r\\n}\\nfunction NullElement(data,globalData,comp){\\r\\n    this.initFrame();\\r\\n\\tthis.initBaseData(data, globalData, comp);\\r\\n    this.initFrame();\\r\\n    this.initTransform(data, globalData, comp);\\r\\n    this.initHierarchy();\\r\\n}\\r\\n\\r\\nNullElement.prototype.prepareFrame = function(num) {\\r\\n    this.prepareProperties(num, true);\\r\\n};\\r\\n\\r\\nNullElement.prototype.renderFrame = function() {\\r\\n};\\r\\n\\r\\nNullElement.prototype.getBaseElement = function() {\\r\\n\\treturn null;\\r\\n};\\r\\n\\r\\nNullElement.prototype.destroy = function() {\\r\\n};\\r\\n\\r\\nNullElement.prototype.sourceRectAtTime = function() {\\r\\n};\\r\\n\\r\\nNullElement.prototype.hide = function() {\\r\\n};\\r\\n\\r\\nextendPrototype([BaseElement,TransformElement,HierarchyElement,FrameElement], NullElement);\\r\\n\\nfunction SVGBaseElement(){\\r\\n}\\r\\n\\r\\nSVGBaseElement.prototype = {\\r\\n    initRendererElement: function() {\\r\\n        this.layerElement = createNS('g');\\r\\n    },\\r\\n    createContainerElements: function(){\\r\\n        this.matteElement = createNS('g');\\r\\n        this.transformedElement = this.layerElement;\\r\\n        this.maskedElement = this.layerElement;\\r\\n        this._sizeChanged = false;\\r\\n        var layerElementParent = null;\\r\\n        //If this layer acts as a mask for the following layer\\r\\n        var filId, fil, gg;\\r\\n        if (this.data.td) {\\r\\n            if (this.data.td == 3 || this.data.td == 1) {\\r\\n                var masker = createNS('mask');\\r\\n                masker.setAttribute('id', this.layerId);\\r\\n                masker.setAttribute('mask-type', this.data.td == 3 ? 'luminance' : 'alpha');\\r\\n                masker.appendChild(this.layerElement);\\r\\n                layerElementParent = masker;\\r\\n                this.globalData.defs.appendChild(masker);\\r\\n                // This is only for IE and Edge when mask if of type alpha\\r\\n                if (!featureSupport.maskType && this.data.td == 1) {\\r\\n                    masker.setAttribute('mask-type', 'luminance');\\r\\n                    filId = randomString(10);\\r\\n                    fil = filtersFactory.createFilter(filId);\\r\\n                    this.globalData.defs.appendChild(fil);\\r\\n                    fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());\\r\\n                    gg = createNS('g');\\r\\n                    gg.appendChild(this.layerElement);\\r\\n                    layerElementParent = gg;\\r\\n                    masker.appendChild(gg);\\r\\n                    gg.setAttribute('filter','url(' + locationHref + '#' + filId + ')');\\r\\n                }\\r\\n            } else if(this.data.td == 2) {\\r\\n                var maskGroup = createNS('mask');\\r\\n                maskGroup.setAttribute('id', this.layerId);\\r\\n                maskGroup.setAttribute('mask-type','alpha');\\r\\n                var maskGrouper = createNS('g');\\r\\n                maskGroup.appendChild(maskGrouper);\\r\\n                filId = randomString(10);\\r\\n                fil = filtersFactory.createFilter(filId);\\r\\n                ////\\r\\n\\r\\n                var feColorMatrix = createNS('feColorMatrix');\\r\\n                feColorMatrix.setAttribute('type', 'matrix');\\r\\n                feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');\\r\\n                feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 -1 1');\\r\\n                fil.appendChild(feColorMatrix);\\r\\n\\r\\n                ////\\r\\n                /*var feCTr = createNS('feComponentTransfer');\\r\\n                feCTr.setAttribute('in','SourceGraphic');\\r\\n                fil.appendChild(feCTr);\\r\\n                var feFunc = createNS('feFuncA');\\r\\n                feFunc.setAttribute('type','table');\\r\\n                feFunc.setAttribute('tableValues','1.0 0.0');\\r\\n                feCTr.appendChild(feFunc);*/\\r\\n                this.globalData.defs.appendChild(fil);\\r\\n                var alphaRect = createNS('rect');\\r\\n                alphaRect.setAttribute('width',  this.comp.data.w);\\r\\n                alphaRect.setAttribute('height', this.comp.data.h);\\r\\n                alphaRect.setAttribute('x','0');\\r\\n                alphaRect.setAttribute('y','0');\\r\\n                alphaRect.setAttribute('fill','#ffffff');\\r\\n                alphaRect.setAttribute('opacity','0');\\r\\n                maskGrouper.setAttribute('filter', 'url(' + locationHref + '#'+filId+')');\\r\\n                maskGrouper.appendChild(alphaRect);\\r\\n                maskGrouper.appendChild(this.layerElement);\\r\\n                layerElementParent = maskGrouper;\\r\\n                if (!featureSupport.maskType) {\\r\\n                    maskGroup.setAttribute('mask-type', 'luminance');\\r\\n                    fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());\\r\\n                    gg = createNS('g');\\r\\n                    maskGrouper.appendChild(alphaRect);\\r\\n                    gg.appendChild(this.layerElement);\\r\\n                    layerElementParent = gg;\\r\\n                    maskGrouper.appendChild(gg);\\r\\n                }\\r\\n                this.globalData.defs.appendChild(maskGroup);\\r\\n            }\\r\\n        } else if (this.data.tt) {\\r\\n            this.matteElement.appendChild(this.layerElement);\\r\\n            layerElementParent = this.matteElement;\\r\\n            this.baseElement = this.matteElement;\\r\\n        } else {\\r\\n            this.baseElement = this.layerElement;\\r\\n        }\\r\\n        if (this.data.ln) {\\r\\n            this.layerElement.setAttribute('id', this.data.ln);\\r\\n        }\\r\\n        if (this.data.cl) {\\r\\n            this.layerElement.setAttribute('class', this.data.cl);\\r\\n        }\\r\\n        //Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped\\r\\n        if (this.data.ty === 0 && !this.data.hd) {\\r\\n            var cp = createNS( 'clipPath');\\r\\n            var pt = createNS('path');\\r\\n            pt.setAttribute('d','M0,0 L' + this.data.w + ',0' + ' L' + this.data.w + ',' + this.data.h + ' L0,' + this.data.h + 'z');\\r\\n            var clipId = 'cp_'+randomString(8);\\r\\n            cp.setAttribute('id',clipId);\\r\\n            cp.appendChild(pt);\\r\\n            this.globalData.defs.appendChild(cp);\\r\\n\\r\\n            if (this.checkMasks()) {\\r\\n                var cpGroup = createNS('g');\\r\\n                cpGroup.setAttribute('clip-path','url(' + locationHref + '#'+clipId + ')');\\r\\n                cpGroup.appendChild(this.layerElement);\\r\\n                this.transformedElement = cpGroup;\\r\\n                if (layerElementParent) {\\r\\n                    layerElementParent.appendChild(this.transformedElement);\\r\\n                } else {\\r\\n                    this.baseElement = this.transformedElement;\\r\\n                }\\r\\n            } else {\\r\\n                this.layerElement.setAttribute('clip-path','url(' + locationHref + '#'+clipId+')');\\r\\n            }\\r\\n            \\r\\n        }\\r\\n        if (this.data.bm !== 0) {\\r\\n            this.setBlendMode();\\r\\n        }\\r\\n\\r\\n    },\\r\\n    renderElement: function() {\\r\\n        if (this.finalTransform._matMdf) {\\r\\n            this.transformedElement.setAttribute('transform', this.finalTransform.mat.to2dCSS());\\r\\n        }\\r\\n        if (this.finalTransform._opMdf) {\\r\\n            this.transformedElement.setAttribute('opacity', this.finalTransform.mProp.o.v);\\r\\n        }\\r\\n    },\\r\\n    destroyBaseElement: function() {\\r\\n        this.layerElement = null;\\r\\n        this.matteElement = null;\\r\\n        this.maskManager.destroy();\\r\\n    },\\r\\n    getBaseElement: function() {\\r\\n        if (this.data.hd) {\\r\\n            return null;\\r\\n        }\\r\\n        return this.baseElement;\\r\\n    },\\r\\n    createRenderableComponents: function() {\\r\\n        this.maskManager = new MaskElement(this.data, this, this.globalData);\\r\\n        this.renderableEffectsManager = new SVGEffects(this);\\r\\n    },\\r\\n    setMatte: function(id) {\\r\\n        if (!this.matteElement) {\\r\\n            return;\\r\\n        }\\r\\n        this.matteElement.setAttribute(\\\"mask\\\", \\\"url(\\\" + locationHref + \\\"#\\\" + id + \\\")\\\");\\r\\n    }\\r\\n};\\nfunction IShapeElement(){\\r\\n}\\r\\n\\r\\nIShapeElement.prototype = {\\r\\n    addShapeToModifiers: function(data) {\\r\\n        var i, len = this.shapeModifiers.length;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            this.shapeModifiers[i].addShape(data);\\r\\n        }\\r\\n    },\\r\\n    isShapeInAnimatedModifiers: function(data) {\\r\\n        var i = 0, len = this.shapeModifiers.length;\\r\\n        while(i < len) {\\r\\n            if(this.shapeModifiers[i].isAnimatedWithShape(data)) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    },\\r\\n    renderModifiers: function() {\\r\\n        if(!this.shapeModifiers.length){\\r\\n            return;\\r\\n        }\\r\\n        var i, len = this.shapes.length;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            this.shapes[i].sh.reset();\\r\\n        }\\r\\n\\r\\n        len = this.shapeModifiers.length;\\r\\n        for(i=len-1;i>=0;i-=1){\\r\\n            this.shapeModifiers[i].processShapes(this._isFirstFrame);\\r\\n        }\\r\\n    },\\r\\n    lcEnum: {\\r\\n        '1': 'butt',\\r\\n        '2': 'round',\\r\\n        '3': 'square'\\r\\n    },\\r\\n    ljEnum: {\\r\\n        '1': 'miter',\\r\\n        '2': 'round',\\r\\n        '3': 'bevel'\\r\\n    },\\r\\n    searchProcessedElement: function(elem){\\r\\n        var elements = this.processedElements;\\r\\n        var i = 0, len = elements.length;\\r\\n        while(i < len){\\r\\n            if(elements[i].elem === elem){\\r\\n                return elements[i].pos;\\r\\n            }\\r\\n            i += 1;\\r\\n        }\\r\\n        return 0;\\r\\n    },\\r\\n    addProcessedElement: function(elem, pos){\\r\\n        var elements = this.processedElements;\\r\\n        var i = elements.length;\\r\\n        while(i){\\r\\n            i -= 1;\\r\\n            if(elements[i].elem === elem){\\r\\n                elements[i].pos = pos;\\r\\n                return;\\r\\n            }\\r\\n        }\\r\\n        elements.push(new ProcessedElement(elem, pos));\\r\\n    },\\r\\n    prepareFrame: function(num) {\\r\\n        this.prepareRenderableFrame(num);\\r\\n        this.prepareProperties(num, this.isInRange);\\r\\n    }\\r\\n};\\nfunction ITextElement(){\\r\\n}\\r\\n\\r\\nITextElement.prototype.initElement = function(data,globalData,comp){\\r\\n    this.lettersChangedFlag = true;\\r\\n    this.initFrame();\\r\\n    this.initBaseData(data, globalData, comp);\\r\\n    this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);\\r\\n    this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);\\r\\n    this.initTransform(data, globalData, comp);\\r\\n    this.initHierarchy();\\r\\n    this.initRenderable();\\r\\n    this.initRendererElement();\\r\\n    this.createContainerElements();\\r\\n    this.createRenderableComponents();\\r\\n    this.createContent();\\r\\n    this.hide();\\r\\n    this.textAnimator.searchProperties(this.dynamicProperties);\\r\\n};\\r\\n\\r\\nITextElement.prototype.prepareFrame = function(num) {\\r\\n    this._mdf = false;\\r\\n    this.prepareRenderableFrame(num);\\r\\n    this.prepareProperties(num, this.isInRange);\\r\\n    if(this.textProperty._mdf || this.textProperty._isFirstFrame) {\\r\\n        this.buildNewText();\\r\\n        this.textProperty._isFirstFrame = false;\\r\\n        this.textProperty._mdf = false;\\r\\n    }\\r\\n};\\r\\n\\r\\nITextElement.prototype.createPathShape = function(matrixHelper, shapes) {\\r\\n    var j,jLen = shapes.length;\\r\\n    var k, kLen, pathNodes;\\r\\n    var shapeStr = '';\\r\\n    for(j=0;j<jLen;j+=1){\\r\\n        pathNodes = shapes[j].ks.k;\\r\\n        shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);\\r\\n    }\\r\\n    return shapeStr;\\r\\n};\\r\\n\\r\\nITextElement.prototype.updateDocumentData = function(newData, index) {\\r\\n    this.textProperty.updateDocumentData(newData, index);\\r\\n};\\r\\n\\r\\nITextElement.prototype.canResizeFont = function(_canResize) {\\r\\n    this.textProperty.canResizeFont(_canResize);\\r\\n};\\r\\n\\r\\nITextElement.prototype.setMinimumFontSize = function(_fontSize) {\\r\\n    this.textProperty.setMinimumFontSize(_fontSize);\\r\\n};\\r\\n\\r\\nITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {\\r\\n    if(documentData.ps){\\r\\n        matrixHelper.translate(documentData.ps[0],documentData.ps[1] + documentData.ascent,0);\\r\\n    }\\r\\n    matrixHelper.translate(0,-documentData.ls,0);\\r\\n    switch(documentData.j){\\r\\n        case 1:\\r\\n            matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]),0,0);\\r\\n            break;\\r\\n        case 2:\\r\\n            matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber] )/2,0,0);\\r\\n            break;\\r\\n    }\\r\\n    matrixHelper.translate(xPos, yPos, 0);\\r\\n};\\r\\n\\r\\n\\r\\nITextElement.prototype.buildColor = function(colorData) {\\r\\n    return 'rgb(' + Math.round(colorData[0]*255) + ',' + Math.round(colorData[1]*255) + ',' + Math.round(colorData[2]*255) + ')';\\r\\n};\\r\\n\\r\\nITextElement.prototype.emptyProp = new LetterProps();\\r\\n\\r\\nITextElement.prototype.destroy = function(){\\r\\n    \\r\\n};\\nfunction ICompElement(){}\\r\\n\\r\\nextendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);\\r\\n\\r\\nICompElement.prototype.initElement = function(data,globalData,comp) {\\r\\n    this.initFrame();\\r\\n    this.initBaseData(data, globalData, comp);\\r\\n    this.initTransform(data, globalData, comp);\\r\\n    this.initRenderable();\\r\\n    this.initHierarchy();\\r\\n    this.initRendererElement();\\r\\n    this.createContainerElements();\\r\\n    this.createRenderableComponents();\\r\\n    if(this.data.xt || !globalData.progressiveLoad){\\r\\n        this.buildAllItems();\\r\\n    }\\r\\n    this.hide();\\r\\n};\\r\\n\\r\\n/*ICompElement.prototype.hide = function(){\\r\\n    if(!this.hidden){\\r\\n        this.hideElement();\\r\\n        var i,len = this.elements.length;\\r\\n        for( i = 0; i < len; i+=1 ){\\r\\n            if(this.elements[i]){\\r\\n                this.elements[i].hide();\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n};*/\\r\\n\\r\\nICompElement.prototype.prepareFrame = function(num){\\r\\n    this._mdf = false;\\r\\n    this.prepareRenderableFrame(num);\\r\\n    this.prepareProperties(num, this.isInRange);\\r\\n    if(!this.isInRange && !this.data.xt){\\r\\n        return;\\r\\n    }\\r\\n\\r\\n    if (!this.tm._placeholder) {\\r\\n        var timeRemapped = this.tm.v;\\r\\n        if(timeRemapped === this.data.op){\\r\\n            timeRemapped = this.data.op - 1;\\r\\n        }\\r\\n        this.renderedFrame = timeRemapped;\\r\\n    } else {\\r\\n        this.renderedFrame = num/this.data.sr;\\r\\n    }\\r\\n    var i,len = this.elements.length;\\r\\n    if(!this.completeLayers){\\r\\n        this.checkLayers(this.renderedFrame);\\r\\n    }\\r\\n    //This iteration needs to be backwards because of how expressions connect between each other\\r\\n    for( i = len - 1; i >= 0; i -= 1 ){\\r\\n        if(this.completeLayers || this.elements[i]){\\r\\n            this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);\\r\\n            if(this.elements[i]._mdf) {\\r\\n                this._mdf = true;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nICompElement.prototype.renderInnerContent = function() {\\r\\n    var i,len = this.layers.length;\\r\\n    for( i = 0; i < len; i += 1 ){\\r\\n        if(this.completeLayers || this.elements[i]){\\r\\n            this.elements[i].renderFrame();\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nICompElement.prototype.setElements = function(elems){\\r\\n    this.elements = elems;\\r\\n};\\r\\n\\r\\nICompElement.prototype.getElements = function(){\\r\\n    return this.elements;\\r\\n};\\r\\n\\r\\nICompElement.prototype.destroyElements = function(){\\r\\n    var i,len = this.layers.length;\\r\\n    for( i = 0; i < len; i+=1 ){\\r\\n        if(this.elements[i]){\\r\\n            this.elements[i].destroy();\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nICompElement.prototype.destroy = function(){\\r\\n    this.destroyElements();\\r\\n    this.destroyBaseElement();\\r\\n};\\r\\n\\nfunction IImageElement(data,globalData,comp){\\r\\n    this.assetData = globalData.getAssetData(data.refId);\\r\\n    this.initElement(data,globalData,comp);\\r\\n}\\r\\n\\r\\nextendPrototype([BaseElement,TransformElement,SVGBaseElement,HierarchyElement,FrameElement,RenderableDOMElement], IImageElement);\\r\\n\\r\\nIImageElement.prototype.createContent = function(){\\r\\n\\r\\n    var assetPath = this.globalData.getAssetsPath(this.assetData);\\r\\n\\r\\n    this.innerElem = createNS('image');\\r\\n    this.innerElem.setAttribute('width',this.assetData.w+\\\"px\\\");\\r\\n    this.innerElem.setAttribute('height',this.assetData.h+\\\"px\\\");\\r\\n    this.innerElem.setAttribute('preserveAspectRatio',this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);\\r\\n    this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink','href',assetPath);\\r\\n    \\r\\n    this.layerElement.appendChild(this.innerElem);\\r\\n};\\r\\n\\nfunction ISolidElement(data,globalData,comp){\\r\\n    this.initElement(data,globalData,comp);\\r\\n}\\r\\nextendPrototype([IImageElement], ISolidElement);\\r\\n\\r\\nISolidElement.prototype.createContent = function(){\\r\\n\\r\\n    var rect = createNS('rect');\\r\\n    ////rect.style.width = this.data.sw;\\r\\n    ////rect.style.height = this.data.sh;\\r\\n    ////rect.style.fill = this.data.sc;\\r\\n    rect.setAttribute('width',this.data.sw);\\r\\n    rect.setAttribute('height',this.data.sh);\\r\\n    rect.setAttribute('fill',this.data.sc);\\r\\n    this.layerElement.appendChild(rect);\\r\\n};\\nfunction SVGCompElement(data,globalData,comp){\\r\\n    this.layers = data.layers;\\r\\n    this.supports3d = true;\\r\\n    this.completeLayers = false;\\r\\n    this.pendingElements = [];\\r\\n    this.elements = this.layers ? createSizedArray(this.layers.length) : [];\\r\\n    //this.layerElement = createNS('g');\\r\\n    this.initElement(data,globalData,comp);\\r\\n    this.tm = data.tm ? PropertyFactory.getProp(this,data.tm,0,globalData.frameRate,this) : {_placeholder:true};\\r\\n}\\r\\n\\r\\nextendPrototype([SVGRenderer, ICompElement, SVGBaseElement], SVGCompElement);\\nfunction SVGTextElement(data,globalData,comp){\\r\\n    this.textSpans = [];\\r\\n    this.renderType = 'svg';\\r\\n    this.initElement(data,globalData,comp);\\r\\n}\\r\\n\\r\\nextendPrototype([BaseElement,TransformElement,SVGBaseElement,HierarchyElement,FrameElement,RenderableDOMElement,ITextElement], SVGTextElement);\\r\\n\\r\\nSVGTextElement.prototype.createContent = function(){\\r\\n\\r\\n    if (this.data.singleShape && !this.globalData.fontManager.chars) {\\r\\n        this.textContainer = createNS('text');\\r\\n    }\\r\\n};\\r\\n\\r\\nSVGTextElement.prototype.buildTextContents = function(textArray) {\\r\\n    var i = 0, len = textArray.length;\\r\\n    var textContents = [], currentTextContent = '';\\r\\n    while (i < len) {\\r\\n        if(textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {\\r\\n            textContents.push(currentTextContent);\\r\\n            currentTextContent = '';\\r\\n        } else {\\r\\n            currentTextContent += textArray[i];\\r\\n        }\\r\\n        i += 1;\\r\\n    }\\r\\n    textContents.push(currentTextContent);\\r\\n    return textContents;\\r\\n}\\r\\n\\r\\nSVGTextElement.prototype.buildNewText = function(){\\r\\n    var i, len;\\r\\n\\r\\n    var documentData = this.textProperty.currentData;\\r\\n    this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);\\r\\n    if(documentData.fc) {\\r\\n        this.layerElement.setAttribute('fill', this.buildColor(documentData.fc));\\r\\n    }else{\\r\\n        this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');\\r\\n    }\\r\\n    if(documentData.sc){\\r\\n        this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc));\\r\\n        this.layerElement.setAttribute('stroke-width', documentData.sw);\\r\\n    }\\r\\n    this.layerElement.setAttribute('font-size', documentData.finalSize);\\r\\n    var fontData = this.globalData.fontManager.getFontByName(documentData.f);\\r\\n    if(fontData.fClass){\\r\\n        this.layerElement.setAttribute('class',fontData.fClass);\\r\\n    } else {\\r\\n        this.layerElement.setAttribute('font-family', fontData.fFamily);\\r\\n        var fWeight = documentData.fWeight, fStyle = documentData.fStyle;\\r\\n        this.layerElement.setAttribute('font-style', fStyle);\\r\\n        this.layerElement.setAttribute('font-weight', fWeight);\\r\\n    }\\r\\n\\r\\n    var letters = documentData.l || [];\\r\\n    var usesGlyphs = !!this.globalData.fontManager.chars;\\r\\n    len = letters.length;\\r\\n\\r\\n    var tSpan;\\r\\n    var matrixHelper = this.mHelper;\\r\\n    var shapes, shapeStr = '', singleShape = this.data.singleShape;\\r\\n    var xPos = 0, yPos = 0, firstLine = true;\\r\\n    var trackingOffset = documentData.tr/1000*documentData.finalSize;\\r\\n    if(singleShape && !usesGlyphs && !documentData.sz) {\\r\\n        var tElement = this.textContainer;\\r\\n        var justify = 'start';\\r\\n        switch(documentData.j) {\\r\\n            case 1:\\r\\n                justify = 'end';\\r\\n                break;\\r\\n            case 2:\\r\\n                justify = 'middle';\\r\\n                break;\\r\\n        }\\r\\n        tElement.setAttribute('text-anchor',justify);\\r\\n        tElement.setAttribute('letter-spacing',trackingOffset);\\r\\n        var textContent = this.buildTextContents(documentData.finalText);\\r\\n        len = textContent.length;\\r\\n        yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;\\r\\n        for ( i = 0; i < len; i += 1) {\\r\\n            tSpan = this.textSpans[i] || createNS('tspan');\\r\\n            tSpan.textContent = textContent[i];\\r\\n            tSpan.setAttribute('x', 0);\\r\\n            tSpan.setAttribute('y', yPos);\\r\\n            tSpan.style.display = 'inherit';\\r\\n            tElement.appendChild(tSpan);\\r\\n            this.textSpans[i] = tSpan;\\r\\n            yPos += documentData.finalLineHeight;\\r\\n        }\\r\\n        \\r\\n        this.layerElement.appendChild(tElement);\\r\\n    } else {\\r\\n        var cachedSpansLength = this.textSpans.length;\\r\\n        var shapeData, charData;\\r\\n        for (i = 0; i < len; i += 1) {\\r\\n            if(!usesGlyphs || !singleShape || i === 0){\\r\\n                tSpan = cachedSpansLength > i ? this.textSpans[i] : createNS(usesGlyphs?'path':'text');\\r\\n                if (cachedSpansLength <= i) {\\r\\n                    tSpan.setAttribute('stroke-linecap', 'butt');\\r\\n                    tSpan.setAttribute('stroke-linejoin','round');\\r\\n                    tSpan.setAttribute('stroke-miterlimit','4');\\r\\n                    this.textSpans[i] = tSpan;\\r\\n                    this.layerElement.appendChild(tSpan);\\r\\n                }\\r\\n                tSpan.style.display = 'inherit';\\r\\n            }\\r\\n            \\r\\n            matrixHelper.reset();\\r\\n            matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);\\r\\n            if (singleShape) {\\r\\n                if(letters[i].n) {\\r\\n                    xPos = -trackingOffset;\\r\\n                    yPos += documentData.yOffset;\\r\\n                    yPos += firstLine ? 1 : 0;\\r\\n                    firstLine = false;\\r\\n                }\\r\\n                this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);\\r\\n                xPos += letters[i].l || 0;\\r\\n                //xPos += letters[i].val === ' ' ? 0 : trackingOffset;\\r\\n                xPos += trackingOffset;\\r\\n            }\\r\\n            if(usesGlyphs) {\\r\\n                charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\\r\\n                shapeData = charData && charData.data || {};\\r\\n                shapes = shapeData.shapes ? shapeData.shapes[0].it : [];\\r\\n                if(!singleShape){\\r\\n                    tSpan.setAttribute('d',this.createPathShape(matrixHelper,shapes));\\r\\n                } else {\\r\\n                    shapeStr += this.createPathShape(matrixHelper,shapes);\\r\\n                }\\r\\n            } else {\\r\\n                if(singleShape) {\\r\\n                    tSpan.setAttribute(\\\"transform\\\", \\\"translate(\\\" + matrixHelper.props[12] + \\\",\\\" + matrixHelper.props[13] + \\\")\\\");\\r\\n                }\\r\\n                tSpan.textContent = letters[i].val;\\r\\n                tSpan.setAttributeNS(\\\"http://www.w3.org/XML/1998/namespace\\\", \\\"xml:space\\\",\\\"preserve\\\");\\r\\n            }\\r\\n            //\\r\\n        }\\r\\n        if (singleShape && tSpan) {\\r\\n            tSpan.setAttribute('d',shapeStr);\\r\\n        }\\r\\n    }\\r\\n    while (i < this.textSpans.length){\\r\\n        this.textSpans[i].style.display = 'none';\\r\\n        i += 1;\\r\\n    }\\r\\n    \\r\\n    this._sizeChanged = true;\\r\\n};\\r\\n\\r\\nSVGTextElement.prototype.sourceRectAtTime = function(time){\\r\\n    this.prepareFrame(this.comp.renderedFrame - this.data.st);\\r\\n    this.renderInnerContent();\\r\\n    if(this._sizeChanged){\\r\\n        this._sizeChanged = false;\\r\\n        var textBox = this.layerElement.getBBox();\\r\\n        this.bbox = {\\r\\n            top: textBox.y,\\r\\n            left: textBox.x,\\r\\n            width: textBox.width,\\r\\n            height: textBox.height\\r\\n        };\\r\\n    }\\r\\n    return this.bbox;\\r\\n};\\r\\n\\r\\nSVGTextElement.prototype.renderInnerContent = function(){\\r\\n\\r\\n    if(!this.data.singleShape){\\r\\n        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\\r\\n        if(this.lettersChangedFlag || this.textAnimator.lettersChangedFlag){\\r\\n            this._sizeChanged = true;\\r\\n            var  i,len;\\r\\n            var renderedLetters = this.textAnimator.renderedLetters;\\r\\n\\r\\n            var letters = this.textProperty.currentData.l;\\r\\n\\r\\n            len = letters.length;\\r\\n            var renderedLetter, textSpan;\\r\\n            for(i=0;i<len;i+=1){\\r\\n                if(letters[i].n){\\r\\n                    continue;\\r\\n                }\\r\\n                renderedLetter = renderedLetters[i];\\r\\n                textSpan = this.textSpans[i];\\r\\n                if(renderedLetter._mdf.m) {\\r\\n                    textSpan.setAttribute('transform',renderedLetter.m);\\r\\n                }\\r\\n                if(renderedLetter._mdf.o) {\\r\\n                    textSpan.setAttribute('opacity',renderedLetter.o);\\r\\n                }\\r\\n                if(renderedLetter._mdf.sw){\\r\\n                    textSpan.setAttribute('stroke-width',renderedLetter.sw);\\r\\n                }\\r\\n                if(renderedLetter._mdf.sc){\\r\\n                    textSpan.setAttribute('stroke',renderedLetter.sc);\\r\\n                }\\r\\n                if(renderedLetter._mdf.fc){\\r\\n                    textSpan.setAttribute('fill',renderedLetter.fc);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n};\\nfunction SVGShapeElement(data,globalData,comp){\\r\\n    //List of drawable elements\\r\\n    this.shapes = [];\\r\\n    // Full shape data\\r\\n    this.shapesData = data.shapes;\\r\\n    //List of styles that will be applied to shapes\\r\\n    this.stylesList = [];\\r\\n    //List of modifiers that will be applied to shapes\\r\\n    this.shapeModifiers = [];\\r\\n    //List of items in shape tree\\r\\n    this.itemsData = [];\\r\\n    //List of items in previous shape tree\\r\\n    this.processedElements = [];\\r\\n    // List of animated components\\r\\n    this.animatedContents = [];\\r\\n    this.initElement(data,globalData,comp);\\r\\n    //Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\\r\\n    // List of elements that have been created\\r\\n    this.prevViewData = [];\\r\\n    //Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\\r\\n}\\r\\n\\r\\nextendPrototype([BaseElement,TransformElement,SVGBaseElement,IShapeElement,HierarchyElement,FrameElement,RenderableDOMElement], SVGShapeElement);\\r\\n\\r\\nSVGShapeElement.prototype.initSecondaryElement = function() {\\r\\n};\\r\\n\\r\\nSVGShapeElement.prototype.identityMatrix = new Matrix();\\r\\n\\r\\nSVGShapeElement.prototype.buildExpressionInterface = function(){};\\r\\n\\r\\nSVGShapeElement.prototype.createContent = function(){\\r\\n    this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,this.layerElement, 0, [], true);\\r\\n    this.filterUniqueShapes();\\r\\n};\\r\\n\\r\\n/*\\r\\nThis method searches for multiple shapes that affect a single element and one of them is animated\\r\\n*/\\r\\nSVGShapeElement.prototype.filterUniqueShapes = function(){\\r\\n    var i, len = this.shapes.length, shape;\\r\\n    var j, jLen = this.stylesList.length;\\r\\n    var style, count = 0;\\r\\n    var tempShapes = [];\\r\\n    var areAnimated = false;\\r\\n    for(j = 0; j < jLen; j += 1) {\\r\\n        style = this.stylesList[j];\\r\\n        areAnimated = false;\\r\\n        tempShapes.length = 0;\\r\\n        for(i = 0; i < len; i += 1) {\\r\\n            shape = this.shapes[i];\\r\\n            if(shape.styles.indexOf(style) !== -1) {\\r\\n                tempShapes.push(shape);\\r\\n                areAnimated = shape._isAnimated || areAnimated;\\r\\n            }\\r\\n        }\\r\\n        if(tempShapes.length > 1 && areAnimated) {\\r\\n            this.setShapesAsAnimated(tempShapes);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nSVGShapeElement.prototype.setShapesAsAnimated = function(shapes){\\r\\n    var i, len = shapes.length;\\r\\n    for(i = 0; i < len; i += 1) {\\r\\n        shapes[i].setAsAnimated();\\r\\n    }\\r\\n}\\r\\n\\r\\nSVGShapeElement.prototype.createStyleElement = function(data, level){\\r\\n    //TODO: prevent drawing of hidden styles\\r\\n    var elementData;\\r\\n    var styleOb = new SVGStyleData(data, level);\\r\\n\\r\\n    var pathElement = styleOb.pElem;\\r\\n    if(data.ty === 'st') {\\r\\n        elementData = new SVGStrokeStyleData(this, data, styleOb);\\r\\n    } else if(data.ty === 'fl') {\\r\\n        elementData = new SVGFillStyleData(this, data, styleOb);\\r\\n    } else if(data.ty === 'gf' || data.ty === 'gs') {\\r\\n        var gradientConstructor = data.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;\\r\\n        elementData = new gradientConstructor(this, data, styleOb);\\r\\n        this.globalData.defs.appendChild(elementData.gf);\\r\\n        if (elementData.maskId) {\\r\\n            this.globalData.defs.appendChild(elementData.ms);\\r\\n            this.globalData.defs.appendChild(elementData.of);\\r\\n            pathElement.setAttribute('mask','url(#' + elementData.maskId + ')');\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    if(data.ty === 'st' || data.ty === 'gs') {\\r\\n        pathElement.setAttribute('stroke-linecap', this.lcEnum[data.lc] || 'round');\\r\\n        pathElement.setAttribute('stroke-linejoin',this.ljEnum[data.lj] || 'round');\\r\\n        pathElement.setAttribute('fill-opacity','0');\\r\\n        if(data.lj === 1) {\\r\\n            pathElement.setAttribute('stroke-miterlimit',data.ml);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if(data.r === 2) {\\r\\n        pathElement.setAttribute('fill-rule', 'evenodd');\\r\\n    }\\r\\n\\r\\n    if(data.ln){\\r\\n        pathElement.setAttribute('id',data.ln);\\r\\n    }\\r\\n    if(data.cl){\\r\\n        pathElement.setAttribute('class',data.cl);\\r\\n    }\\r\\n    this.stylesList.push(styleOb);\\r\\n    this.addToAnimatedContents(data, elementData);\\r\\n    return elementData;\\r\\n};\\r\\n\\r\\nSVGShapeElement.prototype.createGroupElement = function(data) {\\r\\n    var elementData = new ShapeGroupData();\\r\\n    if(data.ln){\\r\\n        elementData.gr.setAttribute('id',data.ln);\\r\\n    }\\r\\n    return elementData;\\r\\n};\\r\\n\\r\\nSVGShapeElement.prototype.createTransformElement = function(data, container) {\\r\\n    var transformProperty = TransformPropertyFactory.getTransformProperty(this,data,this);\\r\\n    var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);\\r\\n    this.addToAnimatedContents(data, elementData);\\r\\n    return elementData;\\r\\n};\\r\\n\\r\\nSVGShapeElement.prototype.createShapeElement = function(data, ownTransformers, level) {\\r\\n    var ty = 4;\\r\\n    if(data.ty === 'rc'){\\r\\n        ty = 5;\\r\\n    }else if(data.ty === 'el'){\\r\\n        ty = 6;\\r\\n    }else if(data.ty === 'sr'){\\r\\n        ty = 7;\\r\\n    }\\r\\n    var shapeProperty = ShapePropertyFactory.getShapeProp(this,data,ty,this);\\r\\n    var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);\\r\\n    this.shapes.push(elementData);\\r\\n    this.addShapeToModifiers(elementData);\\r\\n    this.addToAnimatedContents(data, elementData);\\r\\n    return elementData;\\r\\n};\\r\\n\\r\\nSVGShapeElement.prototype.addToAnimatedContents = function(data, element) {\\r\\n    var i = 0, len = this.animatedContents.length;\\r\\n    while(i < len) {\\r\\n        if(this.animatedContents[i].element === element) {\\r\\n            return;\\r\\n        }\\r\\n        i += 1;\\r\\n    }\\r\\n    this.animatedContents.push({\\r\\n        fn: SVGElementsRenderer.createRenderFunction(data),\\r\\n        element: element,\\r\\n        data: data\\r\\n    });\\r\\n};\\r\\n\\r\\nSVGShapeElement.prototype.setElementStyles = function(elementData){\\r\\n    var arr = elementData.styles;\\r\\n    var j, jLen = this.stylesList.length;\\r\\n    for (j = 0; j < jLen; j += 1) {\\r\\n        if (!this.stylesList[j].closed) {\\r\\n            arr.push(this.stylesList[j]);\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nSVGShapeElement.prototype.reloadShapes = function(){\\r\\n    this._isFirstFrame = true;\\r\\n    var i, len = this.itemsData.length;\\r\\n    for( i = 0; i < len; i += 1) {\\r\\n        this.prevViewData[i] = this.itemsData[i];\\r\\n    }\\r\\n    this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,this.layerElement, 0, [], true);\\r\\n    this.filterUniqueShapes();\\r\\n    len = this.dynamicProperties.length;\\r\\n    for(i = 0; i < len; i += 1) {\\r\\n        this.dynamicProperties[i].getValue();\\r\\n    }\\r\\n    this.renderModifiers();\\r\\n};\\r\\n\\r\\nSVGShapeElement.prototype.searchShapes = function(arr,itemsData,prevViewData,container, level, transformers, render){\\r\\n    var ownTransformers = [].concat(transformers);\\r\\n    var i, len = arr.length - 1;\\r\\n    var j, jLen;\\r\\n    var ownStyles = [], ownModifiers = [], styleOb, currentTransform, modifier, processedPos;\\r\\n    for(i=len;i>=0;i-=1){\\r\\n        processedPos = this.searchProcessedElement(arr[i]);\\r\\n        if(!processedPos){\\r\\n            arr[i]._render = render;\\r\\n        } else {\\r\\n            itemsData[i] = prevViewData[processedPos - 1];\\r\\n        }\\r\\n        if(arr[i].ty == 'fl' || arr[i].ty == 'st' || arr[i].ty == 'gf' || arr[i].ty == 'gs'){\\r\\n            if(!processedPos){\\r\\n                itemsData[i] = this.createStyleElement(arr[i], level);\\r\\n            } else {\\r\\n                itemsData[i].style.closed = false;\\r\\n            }\\r\\n            if(arr[i]._render){\\r\\n                container.appendChild(itemsData[i].style.pElem);\\r\\n            }\\r\\n            ownStyles.push(itemsData[i].style);\\r\\n        }else if(arr[i].ty == 'gr'){\\r\\n            if(!processedPos){\\r\\n                itemsData[i] = this.createGroupElement(arr[i]);\\r\\n            } else {\\r\\n                jLen = itemsData[i].it.length;\\r\\n                for(j=0;j<jLen;j+=1){\\r\\n                    itemsData[i].prevViewData[j] = itemsData[i].it[j];\\r\\n                }\\r\\n            }\\r\\n            this.searchShapes(arr[i].it,itemsData[i].it,itemsData[i].prevViewData,itemsData[i].gr, level + 1, ownTransformers, render);\\r\\n            if(arr[i]._render){\\r\\n                container.appendChild(itemsData[i].gr);\\r\\n            }\\r\\n        }else if(arr[i].ty == 'tr'){\\r\\n            if(!processedPos){\\r\\n                itemsData[i] = this.createTransformElement(arr[i], container);\\r\\n            }\\r\\n            currentTransform = itemsData[i].transform;\\r\\n            ownTransformers.push(currentTransform);\\r\\n        }else if(arr[i].ty == 'sh' || arr[i].ty == 'rc' || arr[i].ty == 'el' || arr[i].ty == 'sr'){\\r\\n            if(!processedPos){\\r\\n                itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);\\r\\n            }\\r\\n            this.setElementStyles(itemsData[i]);\\r\\n\\r\\n        }else if(arr[i].ty == 'tm' || arr[i].ty == 'rd' || arr[i].ty == 'ms'){\\r\\n            if(!processedPos){\\r\\n                modifier = ShapeModifiers.getModifier(arr[i].ty);\\r\\n                modifier.init(this,arr[i]);\\r\\n                itemsData[i] = modifier;\\r\\n                this.shapeModifiers.push(modifier);\\r\\n            } else {\\r\\n                modifier = itemsData[i];\\r\\n                modifier.closed = false;\\r\\n            }\\r\\n            ownModifiers.push(modifier);\\r\\n        }else if(arr[i].ty == 'rp'){\\r\\n            if(!processedPos){\\r\\n                modifier = ShapeModifiers.getModifier(arr[i].ty);\\r\\n                itemsData[i] = modifier;\\r\\n                modifier.init(this,arr,i,itemsData);\\r\\n                this.shapeModifiers.push(modifier);\\r\\n                render = false;\\r\\n            }else{\\r\\n                modifier = itemsData[i];\\r\\n                modifier.closed = true;\\r\\n            }\\r\\n            ownModifiers.push(modifier);\\r\\n        }\\r\\n        this.addProcessedElement(arr[i], i + 1);\\r\\n    }\\r\\n    len = ownStyles.length;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        ownStyles[i].closed = true;\\r\\n    }\\r\\n    len = ownModifiers.length;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        ownModifiers[i].closed = true;\\r\\n    }\\r\\n};\\r\\n\\r\\nSVGShapeElement.prototype.renderInnerContent = function() {\\r\\n    this.renderModifiers();\\r\\n    var i, len = this.stylesList.length;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        this.stylesList[i].reset();\\r\\n    }\\r\\n    this.renderShape();\\r\\n\\r\\n    for (i = 0; i < len; i += 1) {\\r\\n        if (this.stylesList[i]._mdf || this._isFirstFrame) {\\r\\n            if(this.stylesList[i].msElem){\\r\\n                this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d);\\r\\n                //Adding M0 0 fixes same mask bug on all browsers\\r\\n                this.stylesList[i].d = 'M0 0' + this.stylesList[i].d;\\r\\n            }\\r\\n            this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d || 'M0 0');\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nSVGShapeElement.prototype.renderShape = function() {\\r\\n    var i, len = this.animatedContents.length;\\r\\n    var animatedContent;\\r\\n    for(i = 0; i < len; i += 1) {\\r\\n        animatedContent = this.animatedContents[i];\\r\\n        if((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {\\r\\n            animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nSVGShapeElement.prototype.destroy = function(){\\r\\n    this.destroyBaseElement();\\r\\n    this.shapesData = null;\\r\\n    this.itemsData = null;\\r\\n};\\r\\n\\nfunction SVGTintFilter(filter, filterManager){\\r\\n    this.filterManager = filterManager;\\r\\n    var feColorMatrix = createNS('feColorMatrix');\\r\\n    feColorMatrix.setAttribute('type','matrix');\\r\\n    feColorMatrix.setAttribute('color-interpolation-filters','linearRGB');\\r\\n    feColorMatrix.setAttribute('values','0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');\\r\\n    feColorMatrix.setAttribute('result','f1');\\r\\n    filter.appendChild(feColorMatrix);\\r\\n    feColorMatrix = createNS('feColorMatrix');\\r\\n    feColorMatrix.setAttribute('type','matrix');\\r\\n    feColorMatrix.setAttribute('color-interpolation-filters','sRGB');\\r\\n    feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');\\r\\n    feColorMatrix.setAttribute('result','f2');\\r\\n    filter.appendChild(feColorMatrix);\\r\\n    this.matrixFilter = feColorMatrix;\\r\\n    if(filterManager.effectElements[2].p.v !== 100 || filterManager.effectElements[2].p.k){\\r\\n        var feMerge = createNS('feMerge');\\r\\n        filter.appendChild(feMerge);\\r\\n        var feMergeNode;\\r\\n        feMergeNode = createNS('feMergeNode');\\r\\n        feMergeNode.setAttribute('in','SourceGraphic');\\r\\n        feMerge.appendChild(feMergeNode);\\r\\n        feMergeNode = createNS('feMergeNode');\\r\\n        feMergeNode.setAttribute('in','f2');\\r\\n        feMerge.appendChild(feMergeNode);\\r\\n    }\\r\\n}\\r\\n\\r\\nSVGTintFilter.prototype.renderFrame = function(forceRender){\\r\\n    if(forceRender || this.filterManager._mdf){\\r\\n        var colorBlack = this.filterManager.effectElements[0].p.v;\\r\\n        var colorWhite = this.filterManager.effectElements[1].p.v;\\r\\n        var opacity = this.filterManager.effectElements[2].p.v/100;\\r\\n        this.matrixFilter.setAttribute('values',(colorWhite[0]- colorBlack[0])+' 0 0 0 '+ colorBlack[0] +' '+ (colorWhite[1]- colorBlack[1]) +' 0 0 0 '+ colorBlack[1] +' '+ (colorWhite[2]- colorBlack[2]) +' 0 0 0 '+ colorBlack[2] +' 0 0 0 ' + opacity + ' 0');\\r\\n    }\\r\\n};\\nfunction SVGFillFilter(filter, filterManager){\\r\\n    this.filterManager = filterManager;\\r\\n    var feColorMatrix = createNS('feColorMatrix');\\r\\n    feColorMatrix.setAttribute('type','matrix');\\r\\n    feColorMatrix.setAttribute('color-interpolation-filters','sRGB');\\r\\n    feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');\\r\\n    filter.appendChild(feColorMatrix);\\r\\n    this.matrixFilter = feColorMatrix;\\r\\n}\\r\\nSVGFillFilter.prototype.renderFrame = function(forceRender){\\r\\n    if(forceRender || this.filterManager._mdf){\\r\\n        var color = this.filterManager.effectElements[2].p.v;\\r\\n        var opacity = this.filterManager.effectElements[6].p.v;\\r\\n        this.matrixFilter.setAttribute('values','0 0 0 0 '+color[0]+' 0 0 0 0 '+color[1]+' 0 0 0 0 '+color[2]+' 0 0 0 '+opacity+' 0');\\r\\n    }\\r\\n};\\nfunction SVGStrokeEffect(elem, filterManager){\\r\\n    this.initialized = false;\\r\\n    this.filterManager = filterManager;\\r\\n    this.elem = elem;\\r\\n    this.paths = [];\\r\\n}\\r\\n\\r\\nSVGStrokeEffect.prototype.initialize = function(){\\r\\n\\r\\n    var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;\\r\\n    var path,groupPath, i, len;\\r\\n    if(this.filterManager.effectElements[1].p.v === 1){\\r\\n        len = this.elem.maskManager.masksProperties.length;\\r\\n        i = 0;\\r\\n    } else {\\r\\n        i = this.filterManager.effectElements[0].p.v - 1;\\r\\n        len = i + 1;\\r\\n    }\\r\\n    groupPath = createNS('g'); \\r\\n    groupPath.setAttribute('fill','none');\\r\\n    groupPath.setAttribute('stroke-linecap','round');\\r\\n    groupPath.setAttribute('stroke-dashoffset',1);\\r\\n    for(i;i<len;i+=1){\\r\\n        path = createNS('path');\\r\\n        groupPath.appendChild(path);\\r\\n        this.paths.push({p:path,m:i});\\r\\n    }\\r\\n    if(this.filterManager.effectElements[10].p.v === 3){\\r\\n        var mask = createNS('mask');\\r\\n        var id = 'stms_' + randomString(10);\\r\\n        mask.setAttribute('id',id);\\r\\n        mask.setAttribute('mask-type','alpha');\\r\\n        mask.appendChild(groupPath);\\r\\n        this.elem.globalData.defs.appendChild(mask);\\r\\n        var g = createNS('g');\\r\\n        g.setAttribute('mask','url(' + locationHref + '#'+id+')');\\r\\n        if(elemChildren[0]){\\r\\n            g.appendChild(elemChildren[0]);\\r\\n        }\\r\\n        this.elem.layerElement.appendChild(g);\\r\\n        this.masker = mask;\\r\\n        groupPath.setAttribute('stroke','#fff');\\r\\n    } else if(this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2){\\r\\n        if(this.filterManager.effectElements[10].p.v === 2){\\r\\n            elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;\\r\\n            while(elemChildren.length){\\r\\n                this.elem.layerElement.removeChild(elemChildren[0]);\\r\\n            }\\r\\n        }\\r\\n        this.elem.layerElement.appendChild(groupPath);\\r\\n        this.elem.layerElement.removeAttribute('mask');\\r\\n        groupPath.setAttribute('stroke','#fff');\\r\\n    }\\r\\n    this.initialized = true;\\r\\n    this.pathMasker = groupPath;\\r\\n};\\r\\n\\r\\nSVGStrokeEffect.prototype.renderFrame = function(forceRender){\\r\\n    if(!this.initialized){\\r\\n        this.initialize();\\r\\n    }\\r\\n    var i, len = this.paths.length;\\r\\n    var mask, path;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        if(this.paths[i].m === -1) {\\r\\n            continue;\\r\\n        }\\r\\n        mask = this.elem.maskManager.viewData[this.paths[i].m];\\r\\n        path = this.paths[i].p;\\r\\n        if(forceRender || this.filterManager._mdf || mask.prop._mdf){\\r\\n            path.setAttribute('d',mask.lastPath);\\r\\n        }\\r\\n        if(forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf){\\r\\n            var dasharrayValue;\\r\\n            if(this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100){\\r\\n                var s = Math.min(this.filterManager.effectElements[7].p.v,this.filterManager.effectElements[8].p.v)/100;\\r\\n                var e = Math.max(this.filterManager.effectElements[7].p.v,this.filterManager.effectElements[8].p.v)/100;\\r\\n                var l = path.getTotalLength();\\r\\n                dasharrayValue = '0 0 0 ' + l*s + ' ';\\r\\n                var lineLength = l*(e-s);\\r\\n                var segment = 1+this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v/100;\\r\\n                var units = Math.floor(lineLength/segment);\\r\\n                var j;\\r\\n                for(j=0;j<units;j+=1){\\r\\n                    dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v/100 + ' ';\\r\\n                }\\r\\n                dasharrayValue += '0 ' + l*10 + ' 0 0';\\r\\n            } else {\\r\\n                dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v/100;\\r\\n            }\\r\\n            path.setAttribute('stroke-dasharray',dasharrayValue);\\r\\n        }\\r\\n    }\\r\\n    if(forceRender || this.filterManager.effectElements[4].p._mdf){\\r\\n        this.pathMasker.setAttribute('stroke-width',this.filterManager.effectElements[4].p.v*2);\\r\\n    }\\r\\n    \\r\\n    if(forceRender || this.filterManager.effectElements[6].p._mdf){\\r\\n        this.pathMasker.setAttribute('opacity',this.filterManager.effectElements[6].p.v);\\r\\n    }\\r\\n    if(this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2){\\r\\n        if(forceRender || this.filterManager.effectElements[3].p._mdf){\\r\\n            var color = this.filterManager.effectElements[3].p.v;\\r\\n            this.pathMasker.setAttribute('stroke','rgb('+bm_floor(color[0]*255)+','+bm_floor(color[1]*255)+','+bm_floor(color[2]*255)+')');\\r\\n        }\\r\\n    }\\r\\n};\\nfunction SVGTritoneFilter(filter, filterManager){\\r\\n    this.filterManager = filterManager;\\r\\n    var feColorMatrix = createNS('feColorMatrix');\\r\\n    feColorMatrix.setAttribute('type','matrix');\\r\\n    feColorMatrix.setAttribute('color-interpolation-filters','linearRGB');\\r\\n    feColorMatrix.setAttribute('values','0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');\\r\\n    feColorMatrix.setAttribute('result','f1');\\r\\n    filter.appendChild(feColorMatrix);\\r\\n    var feComponentTransfer = createNS('feComponentTransfer');\\r\\n    feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');\\r\\n    filter.appendChild(feComponentTransfer);\\r\\n    this.matrixFilter = feComponentTransfer;\\r\\n    var feFuncR = createNS('feFuncR');\\r\\n    feFuncR.setAttribute('type','table');\\r\\n    feComponentTransfer.appendChild(feFuncR);\\r\\n    this.feFuncR = feFuncR;\\r\\n    var feFuncG = createNS('feFuncG');\\r\\n    feFuncG.setAttribute('type','table');\\r\\n    feComponentTransfer.appendChild(feFuncG);\\r\\n    this.feFuncG = feFuncG;\\r\\n    var feFuncB = createNS('feFuncB');\\r\\n    feFuncB.setAttribute('type','table');\\r\\n    feComponentTransfer.appendChild(feFuncB);\\r\\n    this.feFuncB = feFuncB;\\r\\n}\\r\\n\\r\\nSVGTritoneFilter.prototype.renderFrame = function(forceRender){\\r\\n    if(forceRender || this.filterManager._mdf){\\r\\n        var color1 = this.filterManager.effectElements[0].p.v;\\r\\n        var color2 = this.filterManager.effectElements[1].p.v;\\r\\n        var color3 = this.filterManager.effectElements[2].p.v;\\r\\n        var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0];\\r\\n        var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1];\\r\\n        var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2];\\r\\n        this.feFuncR.setAttribute('tableValues', tableR);\\r\\n        this.feFuncG.setAttribute('tableValues', tableG);\\r\\n        this.feFuncB.setAttribute('tableValues', tableB);\\r\\n        //var opacity = this.filterManager.effectElements[2].p.v/100;\\r\\n        //this.matrixFilter.setAttribute('values',(colorWhite[0]- colorBlack[0])+' 0 0 0 '+ colorBlack[0] +' '+ (colorWhite[1]- colorBlack[1]) +' 0 0 0 '+ colorBlack[1] +' '+ (colorWhite[2]- colorBlack[2]) +' 0 0 0 '+ colorBlack[2] +' 0 0 0 ' + opacity + ' 0');\\r\\n    }\\r\\n};\\nfunction SVGProLevelsFilter(filter, filterManager){\\r\\n    this.filterManager = filterManager;\\r\\n    var effectElements = this.filterManager.effectElements;\\r\\n    var feComponentTransfer = createNS('feComponentTransfer');\\r\\n    var feFuncR, feFuncG, feFuncB;\\r\\n    \\r\\n    if(effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1){\\r\\n        this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);\\r\\n    }\\r\\n    if(effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1){\\r\\n        this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);\\r\\n    }\\r\\n    if(effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1){\\r\\n        this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);\\r\\n    }\\r\\n    if(effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1){\\r\\n        this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);\\r\\n    }\\r\\n    \\r\\n    if(this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA){\\r\\n        feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');\\r\\n        filter.appendChild(feComponentTransfer);\\r\\n        feComponentTransfer = createNS('feComponentTransfer');\\r\\n    }\\r\\n\\r\\n    if(effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1){\\r\\n\\r\\n        feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');\\r\\n        filter.appendChild(feComponentTransfer);\\r\\n        this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);\\r\\n        this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);\\r\\n        this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);\\r\\n    }\\r\\n}\\r\\n\\r\\nSVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {\\r\\n    var feFunc = createNS(type);\\r\\n    feFunc.setAttribute('type','table');\\r\\n    feComponentTransfer.appendChild(feFunc);\\r\\n    return feFunc;\\r\\n};\\r\\n\\r\\nSVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {\\r\\n    var cnt = 0;\\r\\n    var segments = 256;\\r\\n    var perc;\\r\\n    var min = Math.min(inputBlack, inputWhite);\\r\\n    var max = Math.max(inputBlack, inputWhite);\\r\\n    var table = Array.call(null,{length:segments});\\r\\n    var colorValue;\\r\\n    var pos = 0;\\r\\n    var outputDelta = outputWhite - outputBlack; \\r\\n    var inputDelta = inputWhite - inputBlack; \\r\\n    while(cnt <= 256) {\\r\\n        perc = cnt/256;\\r\\n        if(perc <= min){\\r\\n            colorValue = inputDelta < 0 ? outputWhite : outputBlack;\\r\\n        } else if(perc >= max){\\r\\n            colorValue = inputDelta < 0 ? outputBlack : outputWhite;\\r\\n        } else {\\r\\n            colorValue = (outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma));\\r\\n        }\\r\\n        table[pos++] = colorValue;\\r\\n        cnt += 256/(segments-1);\\r\\n    }\\r\\n    return table.join(' ');\\r\\n};\\r\\n\\r\\nSVGProLevelsFilter.prototype.renderFrame = function(forceRender){\\r\\n    if(forceRender || this.filterManager._mdf){\\r\\n        var val, cnt, perc, bezier;\\r\\n        var effectElements = this.filterManager.effectElements;\\r\\n        if(this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)){\\r\\n            val = this.getTableValue(effectElements[3].p.v,effectElements[4].p.v,effectElements[5].p.v,effectElements[6].p.v,effectElements[7].p.v);\\r\\n            this.feFuncRComposed.setAttribute('tableValues',val);\\r\\n            this.feFuncGComposed.setAttribute('tableValues',val);\\r\\n            this.feFuncBComposed.setAttribute('tableValues',val);\\r\\n        }\\r\\n\\r\\n\\r\\n        if(this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)){\\r\\n            val = this.getTableValue(effectElements[10].p.v,effectElements[11].p.v,effectElements[12].p.v,effectElements[13].p.v,effectElements[14].p.v);\\r\\n            this.feFuncR.setAttribute('tableValues',val);\\r\\n        }\\r\\n\\r\\n        if(this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)){\\r\\n            val = this.getTableValue(effectElements[17].p.v,effectElements[18].p.v,effectElements[19].p.v,effectElements[20].p.v,effectElements[21].p.v);\\r\\n            this.feFuncG.setAttribute('tableValues',val);\\r\\n        }\\r\\n\\r\\n        if(this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)){\\r\\n            val = this.getTableValue(effectElements[24].p.v,effectElements[25].p.v,effectElements[26].p.v,effectElements[27].p.v,effectElements[28].p.v);\\r\\n            this.feFuncB.setAttribute('tableValues',val);\\r\\n        }\\r\\n\\r\\n        if(this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)){\\r\\n            val = this.getTableValue(effectElements[31].p.v,effectElements[32].p.v,effectElements[33].p.v,effectElements[34].p.v,effectElements[35].p.v);\\r\\n            this.feFuncA.setAttribute('tableValues',val);\\r\\n        }\\r\\n        \\r\\n    }\\r\\n};\\nfunction SVGDropShadowEffect(filter, filterManager){\\r\\n    filter.setAttribute('x','-100%');\\r\\n    filter.setAttribute('y','-100%');\\r\\n    filter.setAttribute('width','400%');\\r\\n    filter.setAttribute('height','400%');\\r\\n    this.filterManager = filterManager;\\r\\n\\r\\n    var feGaussianBlur = createNS('feGaussianBlur');\\r\\n    feGaussianBlur.setAttribute('in','SourceAlpha');\\r\\n    feGaussianBlur.setAttribute('result','drop_shadow_1');\\r\\n    feGaussianBlur.setAttribute('stdDeviation','0');\\r\\n    this.feGaussianBlur = feGaussianBlur;\\r\\n    filter.appendChild(feGaussianBlur);\\r\\n\\r\\n    var feOffset = createNS('feOffset');\\r\\n    feOffset.setAttribute('dx','25');\\r\\n    feOffset.setAttribute('dy','0');\\r\\n    feOffset.setAttribute('in','drop_shadow_1');\\r\\n    feOffset.setAttribute('result','drop_shadow_2');\\r\\n    this.feOffset = feOffset;\\r\\n    filter.appendChild(feOffset);\\r\\n    var feFlood = createNS('feFlood');\\r\\n    feFlood.setAttribute('flood-color','#00ff00');\\r\\n    feFlood.setAttribute('flood-opacity','1');\\r\\n    feFlood.setAttribute('result','drop_shadow_3');\\r\\n    this.feFlood = feFlood;\\r\\n    filter.appendChild(feFlood);\\r\\n\\r\\n    var feComposite = createNS('feComposite');\\r\\n    feComposite.setAttribute('in','drop_shadow_3');\\r\\n    feComposite.setAttribute('in2','drop_shadow_2');\\r\\n    feComposite.setAttribute('operator','in');\\r\\n    feComposite.setAttribute('result','drop_shadow_4');\\r\\n    filter.appendChild(feComposite);\\r\\n\\r\\n\\r\\n    var feMerge = createNS('feMerge');\\r\\n    filter.appendChild(feMerge);\\r\\n    var feMergeNode;\\r\\n    feMergeNode = createNS('feMergeNode');\\r\\n    feMerge.appendChild(feMergeNode);\\r\\n    feMergeNode = createNS('feMergeNode');\\r\\n    feMergeNode.setAttribute('in','SourceGraphic');\\r\\n    this.feMergeNode = feMergeNode;\\r\\n    this.feMerge = feMerge;\\r\\n    this.originalNodeAdded = false;\\r\\n    feMerge.appendChild(feMergeNode);\\r\\n}\\r\\n\\r\\nSVGDropShadowEffect.prototype.renderFrame = function(forceRender){\\r\\n    if(forceRender || this.filterManager._mdf){\\r\\n        if(forceRender || this.filterManager.effectElements[4].p._mdf){\\r\\n            this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);\\r\\n        }\\r\\n        if(forceRender || this.filterManager.effectElements[0].p._mdf){\\r\\n            var col = this.filterManager.effectElements[0].p.v;\\r\\n            this.feFlood.setAttribute('flood-color',rgbToHex(Math.round(col[0]*255),Math.round(col[1]*255),Math.round(col[2]*255)));\\r\\n        }\\r\\n        if(forceRender || this.filterManager.effectElements[1].p._mdf){\\r\\n            this.feFlood.setAttribute('flood-opacity',this.filterManager.effectElements[1].p.v/255);\\r\\n        }\\r\\n        if(forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf){\\r\\n            var distance = this.filterManager.effectElements[3].p.v;\\r\\n            var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;\\r\\n            var x = distance * Math.cos(angle);\\r\\n            var y = distance * Math.sin(angle);\\r\\n            this.feOffset.setAttribute('dx', x);\\r\\n            this.feOffset.setAttribute('dy', y);\\r\\n        }\\r\\n        /*if(forceRender || this.filterManager.effectElements[5].p._mdf){\\r\\n            if(this.filterManager.effectElements[5].p.v === 1 && this.originalNodeAdded) {\\r\\n                this.feMerge.removeChild(this.feMergeNode);\\r\\n                this.originalNodeAdded = false;\\r\\n            } else if(this.filterManager.effectElements[5].p.v === 0 && !this.originalNodeAdded) {\\r\\n                this.feMerge.appendChild(this.feMergeNode);\\r\\n                this.originalNodeAdded = true;\\r\\n            }\\r\\n        }*/\\r\\n    }\\r\\n};\\nvar _svgMatteSymbols = [];\\r\\nvar _svgMatteMaskCounter = 0;\\r\\n\\r\\nfunction SVGMatte3Effect(filterElem, filterManager, elem){\\r\\n    this.initialized = false;\\r\\n    this.filterManager = filterManager;\\r\\n    this.filterElem = filterElem;\\r\\n    this.elem = elem;\\r\\n    elem.matteElement = createNS('g');\\r\\n    elem.matteElement.appendChild(elem.layerElement);\\r\\n    elem.matteElement.appendChild(elem.transformedElement);\\r\\n    elem.baseElement = elem.matteElement;\\r\\n}\\r\\n\\r\\nSVGMatte3Effect.prototype.findSymbol = function(mask) {\\r\\n    var i = 0, len = _svgMatteSymbols.length;\\r\\n    while(i < len) {\\r\\n        if(_svgMatteSymbols[i] === mask) {\\r\\n            return _svgMatteSymbols[i];\\r\\n        }\\r\\n        i += 1;\\r\\n    }\\r\\n    return null;\\r\\n};\\r\\n\\r\\nSVGMatte3Effect.prototype.replaceInParent = function(mask, symbolId) {\\r\\n    var parentNode = mask.layerElement.parentNode;\\r\\n    if(!parentNode) {\\r\\n        return;\\r\\n    }\\r\\n    var children = parentNode.children;\\r\\n    var i = 0, len = children.length;\\r\\n    while (i < len) {\\r\\n        if (children[i] === mask.layerElement) {\\r\\n            break;\\r\\n        }\\r\\n        i += 1;\\r\\n    }\\r\\n    var nextChild;\\r\\n    if (i <= len - 2) {\\r\\n        nextChild = children[i + 1];\\r\\n    }\\r\\n    var useElem = createNS('use');\\r\\n    useElem.setAttribute('href', '#' + symbolId);\\r\\n    if(nextChild) {\\r\\n        parentNode.insertBefore(useElem, nextChild);\\r\\n    } else {\\r\\n        parentNode.appendChild(useElem);\\r\\n    }\\r\\n};\\r\\n\\r\\nSVGMatte3Effect.prototype.setElementAsMask = function(elem, mask) {\\r\\n    if(!this.findSymbol(mask)) {\\r\\n        var symbolId = 'matte_' + randomString(5) + '_' + _svgMatteMaskCounter++;\\r\\n        var masker = createNS('mask');\\r\\n        masker.setAttribute('id', mask.layerId);\\r\\n        masker.setAttribute('mask-type', 'alpha');\\r\\n        _svgMatteSymbols.push(mask);\\r\\n        var defs = elem.globalData.defs;\\r\\n        defs.appendChild(masker);\\r\\n        var symbol = createNS('symbol');\\r\\n        symbol.setAttribute('id', symbolId);\\r\\n        this.replaceInParent(mask, symbolId);\\r\\n        symbol.appendChild(mask.layerElement);\\r\\n        defs.appendChild(symbol);\\r\\n        var useElem = createNS('use');\\r\\n        useElem.setAttribute('href', '#' + symbolId);\\r\\n        masker.appendChild(useElem);\\r\\n        mask.data.hd = false;\\r\\n        mask.show();\\r\\n    }\\r\\n    elem.setMatte(mask.layerId);\\r\\n};\\r\\n\\r\\nSVGMatte3Effect.prototype.initialize = function() {\\r\\n    var ind = this.filterManager.effectElements[0].p.v;\\r\\n    var i = 0, len = this.elem.comp.elements.length;\\r\\n    while (i < len) {\\r\\n    \\tif (this.elem.comp.elements[i].data.ind === ind) {\\r\\n    \\t\\tthis.setElementAsMask(this.elem, this.elem.comp.elements[i]);\\r\\n    \\t}\\r\\n    \\ti += 1;\\r\\n    }\\r\\n    this.initialized = true;\\r\\n};\\r\\n\\r\\nSVGMatte3Effect.prototype.renderFrame = function() {\\r\\n\\tif(!this.initialized) {\\r\\n\\t\\tthis.initialize();\\r\\n\\t}\\r\\n};\\nfunction SVGEffects(elem){\\r\\n    var i, len = elem.data.ef ? elem.data.ef.length : 0;\\r\\n    var filId = randomString(10);\\r\\n    var fil = filtersFactory.createFilter(filId);\\r\\n    var count = 0;\\r\\n    this.filters = [];\\r\\n    var filterManager;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        filterManager = null;\\r\\n        if(elem.data.ef[i].ty === 20){\\r\\n            count += 1;\\r\\n            filterManager = new SVGTintFilter(fil, elem.effectsManager.effectElements[i]);\\r\\n        }else if(elem.data.ef[i].ty === 21){\\r\\n            count += 1;\\r\\n            filterManager = new SVGFillFilter(fil, elem.effectsManager.effectElements[i]);\\r\\n        }else if(elem.data.ef[i].ty === 22){\\r\\n            filterManager = new SVGStrokeEffect(elem, elem.effectsManager.effectElements[i]);\\r\\n        }else if(elem.data.ef[i].ty === 23){\\r\\n            count += 1;\\r\\n            filterManager = new SVGTritoneFilter(fil, elem.effectsManager.effectElements[i]);\\r\\n        }else if(elem.data.ef[i].ty === 24){\\r\\n            count += 1;\\r\\n            filterManager = new SVGProLevelsFilter(fil, elem.effectsManager.effectElements[i]);\\r\\n        }else if(elem.data.ef[i].ty === 25){\\r\\n            count += 1;\\r\\n            filterManager = new SVGDropShadowEffect(fil, elem.effectsManager.effectElements[i]);\\r\\n        }else if(elem.data.ef[i].ty === 28){\\r\\n            //count += 1;\\r\\n            filterManager = new SVGMatte3Effect(fil, elem.effectsManager.effectElements[i], elem);\\r\\n        }\\r\\n        if(filterManager) {\\r\\n            this.filters.push(filterManager);\\r\\n        }\\r\\n    }\\r\\n    if(count){\\r\\n        elem.globalData.defs.appendChild(fil);\\r\\n        elem.layerElement.setAttribute('filter','url(' + locationHref + '#'+filId+')');\\r\\n    }\\r\\n    if (this.filters.length) {\\r\\n        elem.addRenderableComponent(this);\\r\\n    }\\r\\n}\\r\\n\\r\\nSVGEffects.prototype.renderFrame = function(_isFirstFrame){\\r\\n    var i, len = this.filters.length;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        this.filters[i].renderFrame(_isFirstFrame);\\r\\n    }\\r\\n};\\nvar animationManager = (function(){\\r\\n    var moduleOb = {};\\r\\n    var registeredAnimations = [];\\r\\n    var initTime = 0;\\r\\n    var len = 0;\\r\\n    var playingAnimationsNum = 0;\\r\\n    var _stopped = true;\\r\\n    var _isFrozen = false;\\r\\n\\r\\n    function removeElement(ev){\\r\\n        var i = 0;\\r\\n        var animItem = ev.target;\\r\\n        while(i<len) {\\r\\n            if (registeredAnimations[i].animation === animItem) {\\r\\n                registeredAnimations.splice(i, 1);\\r\\n                i -= 1;\\r\\n                len -= 1;\\r\\n                if(!animItem.isPaused){\\r\\n                    subtractPlayingCount();\\r\\n                }\\r\\n            }\\r\\n            i += 1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function registerAnimation(element, animationData){\\r\\n        if(!element){\\r\\n            return null;\\r\\n        }\\r\\n        var i=0;\\r\\n        while(i<len){\\r\\n            if(registeredAnimations[i].elem == element && registeredAnimations[i].elem !== null ){\\r\\n                return registeredAnimations[i].animation;\\r\\n            }\\r\\n            i+=1;\\r\\n        }\\r\\n        var animItem = new AnimationItem();\\r\\n        setupAnimation(animItem, element);\\r\\n        animItem.setData(element, animationData);\\r\\n        return animItem;\\r\\n    }\\r\\n\\r\\n    function getRegisteredAnimations() {\\r\\n        var i, len = registeredAnimations.length;\\r\\n        var animations = [];\\r\\n        for(i = 0; i < len; i += 1) {\\r\\n            animations.push(registeredAnimations[i].animation);\\r\\n        }\\r\\n        return animations;\\r\\n    }\\r\\n\\r\\n    function addPlayingCount(){\\r\\n        playingAnimationsNum += 1;\\r\\n        activate();\\r\\n    }\\r\\n\\r\\n    function subtractPlayingCount(){\\r\\n        playingAnimationsNum -= 1;\\r\\n    }\\r\\n\\r\\n    function setupAnimation(animItem, element){\\r\\n        animItem.addEventListener('destroy',removeElement);\\r\\n        animItem.addEventListener('_active',addPlayingCount);\\r\\n        animItem.addEventListener('_idle',subtractPlayingCount);\\r\\n        registeredAnimations.push({elem: element,animation:animItem});\\r\\n        len += 1;\\r\\n    }\\r\\n\\r\\n    function loadAnimation(params){\\r\\n        var animItem = new AnimationItem();\\r\\n        setupAnimation(animItem, null);\\r\\n        animItem.setParams(params);\\r\\n        return animItem;\\r\\n    }\\r\\n\\r\\n\\r\\n    function setSpeed(val,animation){\\r\\n        var i;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            registeredAnimations[i].animation.setSpeed(val, animation);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setDirection(val, animation){\\r\\n        var i;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            registeredAnimations[i].animation.setDirection(val, animation);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function play(animation){\\r\\n        var i;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            registeredAnimations[i].animation.play(animation);\\r\\n        }\\r\\n    }\\r\\n    function resume(nowTime) {\\r\\n        var elapsedTime = nowTime - initTime;\\r\\n        var i;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            registeredAnimations[i].animation.advanceTime(elapsedTime);\\r\\n        }\\r\\n        initTime = nowTime;\\r\\n        if(playingAnimationsNum && !_isFrozen) {\\r\\n            window.requestAnimationFrame(resume);\\r\\n        } else {\\r\\n            _stopped = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function first(nowTime){\\r\\n        initTime = nowTime;\\r\\n        window.requestAnimationFrame(resume);\\r\\n    }\\r\\n\\r\\n    function pause(animation) {\\r\\n        var i;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            registeredAnimations[i].animation.pause(animation);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function goToAndStop(value,isFrame,animation) {\\r\\n        var i;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            registeredAnimations[i].animation.goToAndStop(value,isFrame,animation);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function stop(animation) {\\r\\n        var i;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            registeredAnimations[i].animation.stop(animation);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function togglePause(animation) {\\r\\n        var i;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            registeredAnimations[i].animation.togglePause(animation);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function destroy(animation) {\\r\\n        var i;\\r\\n        for(i=(len-1);i>=0;i-=1){\\r\\n            registeredAnimations[i].animation.destroy(animation);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function searchAnimations(animationData, standalone, renderer){\\r\\n        var animElements = [].concat([].slice.call(document.getElementsByClassName('lottie')),\\r\\n                  [].slice.call(document.getElementsByClassName('bodymovin')));\\r\\n        var i, len = animElements.length;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            if(renderer){\\r\\n                animElements[i].setAttribute('data-bm-type',renderer);\\r\\n            }\\r\\n            registerAnimation(animElements[i], animationData);\\r\\n        }\\r\\n        if(standalone && len === 0){\\r\\n            if(!renderer){\\r\\n                renderer = 'svg';\\r\\n            }\\r\\n            var body = document.getElementsByTagName('body')[0];\\r\\n            body.innerHTML = '';\\r\\n            var div = createTag('div');\\r\\n            div.style.width = '100%';\\r\\n            div.style.height = '100%';\\r\\n            div.setAttribute('data-bm-type',renderer);\\r\\n            body.appendChild(div);\\r\\n            registerAnimation(div, animationData);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function resize(){\\r\\n        var i;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            registeredAnimations[i].animation.resize();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function activate(){\\r\\n        if(!_isFrozen && playingAnimationsNum){\\r\\n            if(_stopped) {\\r\\n                window.requestAnimationFrame(first);\\r\\n                _stopped = false;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function freeze() {\\r\\n        _isFrozen = true;\\r\\n    }\\r\\n\\r\\n    function unfreeze() {\\r\\n        _isFrozen = false;\\r\\n        activate();\\r\\n    }\\r\\n\\r\\n    moduleOb.registerAnimation = registerAnimation;\\r\\n    moduleOb.loadAnimation = loadAnimation;\\r\\n    moduleOb.setSpeed = setSpeed;\\r\\n    moduleOb.setDirection = setDirection;\\r\\n    moduleOb.play = play;\\r\\n    moduleOb.pause = pause;\\r\\n    moduleOb.stop = stop;\\r\\n    moduleOb.togglePause = togglePause;\\r\\n    moduleOb.searchAnimations = searchAnimations;\\r\\n    moduleOb.resize = resize;\\r\\n    //moduleOb.start = start;\\r\\n    moduleOb.goToAndStop = goToAndStop;\\r\\n    moduleOb.destroy = destroy;\\r\\n    moduleOb.freeze = freeze;\\r\\n    moduleOb.unfreeze = unfreeze;\\r\\n    moduleOb.getRegisteredAnimations = getRegisteredAnimations;\\r\\n    return moduleOb;\\r\\n}());\\r\\n\\nvar AnimationItem = function () {\\r\\n    this._cbs = [];\\r\\n    this.name = '';\\r\\n    this.path = '';\\r\\n    this.isLoaded = false;\\r\\n    this.currentFrame = 0;\\r\\n    this.currentRawFrame = 0;\\r\\n    this.totalFrames = 0;\\r\\n    this.frameRate = 0;\\r\\n    this.frameMult = 0;\\r\\n    this.playSpeed = 1;\\r\\n    this.playDirection = 1;\\r\\n    this.playCount = 0;\\r\\n    this.animationData = {};\\r\\n    this.assets = [];\\r\\n    this.isPaused = true;\\r\\n    this.autoplay = false;\\r\\n    this.loop = true;\\r\\n    this.renderer = null;\\r\\n    this.animationID = randomString(10);\\r\\n    this.assetsPath = '';\\r\\n    this.timeCompleted = 0;\\r\\n    this.segmentPos = 0;\\r\\n    this.subframeEnabled = subframeEnabled;\\r\\n    this.segments = [];\\r\\n    this._idle = true;\\r\\n    this._completedLoop = false;\\r\\n    this.projectInterface = ProjectInterface();\\r\\n    this.imagePreloader = new ImagePreloader();\\r\\n};\\r\\n\\r\\nextendPrototype([BaseEvent], AnimationItem);\\r\\n\\r\\nAnimationItem.prototype.setParams = function(params) {\\r\\n    if(params.context){\\r\\n        this.context = params.context;\\r\\n    }\\r\\n    if(params.wrapper || params.container){\\r\\n        this.wrapper = params.wrapper || params.container;\\r\\n    }\\r\\n    var animType = params.animType ? params.animType : params.renderer ? params.renderer : 'svg';\\r\\n    switch(animType){\\r\\n        case 'canvas':\\r\\n            this.renderer = new CanvasRenderer(this, params.rendererSettings);\\r\\n            break;\\r\\n        case 'svg':\\r\\n            this.renderer = new SVGRenderer(this, params.rendererSettings);\\r\\n            break;\\r\\n        default:\\r\\n            this.renderer = new HybridRenderer(this, params.rendererSettings);\\r\\n            break;\\r\\n    }\\r\\n    this.renderer.setProjectInterface(this.projectInterface);\\r\\n    this.animType = animType;\\r\\n\\r\\n    if(params.loop === '' || params.loop === null){\\r\\n    }else if(params.loop === false){\\r\\n        this.loop = false;\\r\\n    }else if(params.loop === true){\\r\\n        this.loop = true;\\r\\n    }else{\\r\\n        this.loop = parseInt(params.loop);\\r\\n    }\\r\\n    this.autoplay = 'autoplay' in params ? params.autoplay : true;\\r\\n    this.name = params.name ? params.name :  '';\\r\\n    this.autoloadSegments = params.hasOwnProperty('autoloadSegments') ? params.autoloadSegments :  true;\\r\\n    this.assetsPath = params.assetsPath;\\r\\n    if(params.animationData){\\r\\n        this.configAnimation(params.animationData);\\r\\n    }else if(params.path){\\r\\n        if(params.path.substr(-4) != 'json'){\\r\\n            if (params.path.substr(-1, 1) != '/') {\\r\\n                params.path += '/';\\r\\n            }\\r\\n            params.path += 'data.json';\\r\\n        }\\r\\n\\r\\n        if(params.path.lastIndexOf('\\\\\\\\') != -1){\\r\\n            this.path = params.path.substr(0,params.path.lastIndexOf('\\\\\\\\')+1);\\r\\n        }else{\\r\\n            this.path = params.path.substr(0,params.path.lastIndexOf('/')+1);\\r\\n        }\\r\\n        this.fileName = params.path.substr(params.path.lastIndexOf('/')+1);\\r\\n        this.fileName = this.fileName.substr(0,this.fileName.lastIndexOf('.json'));\\r\\n\\r\\n        assetLoader.load(params.path, this.configAnimation.bind(this), function() {\\r\\n            this.trigger('data_failed');\\r\\n        }.bind(this));\\r\\n    }\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.setData = function (wrapper, animationData) {\\r\\n    var params = {\\r\\n        wrapper: wrapper,\\r\\n        animationData: animationData ? (typeof animationData  === \\\"object\\\") ? animationData : JSON.parse(animationData) : null\\r\\n    };\\r\\n    var wrapperAttributes = wrapper.attributes;\\r\\n\\r\\n    params.path = wrapperAttributes.getNamedItem('data-animation-path') ? wrapperAttributes.getNamedItem('data-animation-path').value : wrapperAttributes.getNamedItem('data-bm-path') ? wrapperAttributes.getNamedItem('data-bm-path').value :  wrapperAttributes.getNamedItem('bm-path') ? wrapperAttributes.getNamedItem('bm-path').value : '';\\r\\n    params.animType = wrapperAttributes.getNamedItem('data-anim-type') ? wrapperAttributes.getNamedItem('data-anim-type').value : wrapperAttributes.getNamedItem('data-bm-type') ? wrapperAttributes.getNamedItem('data-bm-type').value : wrapperAttributes.getNamedItem('bm-type') ? wrapperAttributes.getNamedItem('bm-type').value :  wrapperAttributes.getNamedItem('data-bm-renderer') ? wrapperAttributes.getNamedItem('data-bm-renderer').value : wrapperAttributes.getNamedItem('bm-renderer') ? wrapperAttributes.getNamedItem('bm-renderer').value : 'canvas';\\r\\n\\r\\n    var loop = wrapperAttributes.getNamedItem('data-anim-loop') ? wrapperAttributes.getNamedItem('data-anim-loop').value :  wrapperAttributes.getNamedItem('data-bm-loop') ? wrapperAttributes.getNamedItem('data-bm-loop').value :  wrapperAttributes.getNamedItem('bm-loop') ? wrapperAttributes.getNamedItem('bm-loop').value : '';\\r\\n    if(loop === ''){\\r\\n    }else if(loop === 'false'){\\r\\n        params.loop = false;\\r\\n    }else if(loop === 'true'){\\r\\n        params.loop = true;\\r\\n    }else{\\r\\n        params.loop = parseInt(loop);\\r\\n    }\\r\\n    var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') ? wrapperAttributes.getNamedItem('data-anim-autoplay').value :  wrapperAttributes.getNamedItem('data-bm-autoplay') ? wrapperAttributes.getNamedItem('data-bm-autoplay').value :  wrapperAttributes.getNamedItem('bm-autoplay') ? wrapperAttributes.getNamedItem('bm-autoplay').value : true;\\r\\n    params.autoplay = autoplay !== \\\"false\\\";\\r\\n\\r\\n    params.name = wrapperAttributes.getNamedItem('data-name') ? wrapperAttributes.getNamedItem('data-name').value :  wrapperAttributes.getNamedItem('data-bm-name') ? wrapperAttributes.getNamedItem('data-bm-name').value : wrapperAttributes.getNamedItem('bm-name') ? wrapperAttributes.getNamedItem('bm-name').value :  '';\\r\\n    var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') ? wrapperAttributes.getNamedItem('data-anim-prerender').value :  wrapperAttributes.getNamedItem('data-bm-prerender') ? wrapperAttributes.getNamedItem('data-bm-prerender').value :  wrapperAttributes.getNamedItem('bm-prerender') ? wrapperAttributes.getNamedItem('bm-prerender').value : '';\\r\\n\\r\\n    if(prerender === 'false'){\\r\\n        params.prerender = false;\\r\\n    }\\r\\n    this.setParams(params);\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.includeLayers = function(data) {\\r\\n    if(data.op > this.animationData.op){\\r\\n        this.animationData.op = data.op;\\r\\n        this.totalFrames = Math.floor(data.op - this.animationData.ip);\\r\\n    }\\r\\n    var layers = this.animationData.layers;\\r\\n    var i, len = layers.length;\\r\\n    var newLayers = data.layers;\\r\\n    var j, jLen = newLayers.length;\\r\\n    for(j=0;j<jLen;j+=1){\\r\\n        i = 0;\\r\\n        while(i<len){\\r\\n            if(layers[i].id == newLayers[j].id){\\r\\n                layers[i] = newLayers[j];\\r\\n                break;\\r\\n            }\\r\\n            i += 1;\\r\\n        }\\r\\n    }\\r\\n    if(data.chars || data.fonts){\\r\\n        this.renderer.globalData.fontManager.addChars(data.chars);\\r\\n        this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);\\r\\n    }\\r\\n    if(data.assets){\\r\\n        len = data.assets.length;\\r\\n        for(i = 0; i < len; i += 1){\\r\\n            this.animationData.assets.push(data.assets[i]);\\r\\n        }\\r\\n    }\\r\\n    this.animationData.__complete = false;\\r\\n    dataManager.completeData(this.animationData,this.renderer.globalData.fontManager);\\r\\n    this.renderer.includeLayers(data.layers);\\r\\n    if(expressionsPlugin){\\r\\n        expressionsPlugin.initExpressions(this);\\r\\n    }\\r\\n    this.loadNextSegment();\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.loadNextSegment = function() {\\r\\n    var segments = this.animationData.segments;\\r\\n    if(!segments || segments.length === 0 || !this.autoloadSegments){\\r\\n        this.trigger('data_ready');\\r\\n        this.timeCompleted = this.totalFrames;\\r\\n        return;\\r\\n    }\\r\\n    var segment = segments.shift();\\r\\n    this.timeCompleted = segment.time * this.frameRate;\\r\\n    var segmentPath = this.path+this.fileName+'_' + this.segmentPos + '.json';\\r\\n    this.segmentPos += 1;\\r\\n    assetLoader.load(segmentPath, this.includeLayers.bind(this), function() {\\r\\n        this.trigger('data_failed');\\r\\n    }.bind(this));\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.loadSegments = function() {\\r\\n    var segments = this.animationData.segments;\\r\\n    if(!segments) {\\r\\n        this.timeCompleted = this.totalFrames;\\r\\n    }\\r\\n    this.loadNextSegment();\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.imagesLoaded = function() {\\r\\n    this.trigger('loaded_images');\\r\\n    this.checkLoaded()\\r\\n}\\r\\n\\r\\nAnimationItem.prototype.preloadImages = function() {\\r\\n    this.imagePreloader.setAssetsPath(this.assetsPath);\\r\\n    this.imagePreloader.setPath(this.path);\\r\\n    this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));\\r\\n}\\r\\n\\r\\nAnimationItem.prototype.configAnimation = function (animData) {\\r\\n    if(!this.renderer){\\r\\n        return;\\r\\n    }\\r\\n    this.animationData = animData;\\r\\n    this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);\\r\\n    this.renderer.configAnimation(animData);\\r\\n    if(!animData.assets){\\r\\n        animData.assets = [];\\r\\n    }\\r\\n    this.renderer.searchExtraCompositions(animData.assets);\\r\\n\\r\\n    this.assets = this.animationData.assets;\\r\\n    this.frameRate = this.animationData.fr;\\r\\n    this.firstFrame = Math.round(this.animationData.ip);\\r\\n    this.frameMult = this.animationData.fr / 1000;\\r\\n    this.trigger('config_ready');\\r\\n    this.preloadImages();\\r\\n    this.loadSegments();\\r\\n    this.updaFrameModifier();\\r\\n    this.waitForFontsLoaded();\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.waitForFontsLoaded = function(){\\r\\n    if(!this.renderer) {\\r\\n        return;\\r\\n    }\\r\\n    if(this.renderer.globalData.fontManager.loaded()){\\r\\n        this.checkLoaded();\\r\\n    }else{\\r\\n        setTimeout(this.waitForFontsLoaded.bind(this),20);\\r\\n    }\\r\\n}\\r\\n\\r\\nAnimationItem.prototype.checkLoaded = function () {\\r\\n    if (!this.isLoaded && this.renderer.globalData.fontManager.loaded() && (this.imagePreloader.loaded() || this.renderer.rendererType !== 'canvas')) {\\r\\n        this.isLoaded = true;\\r\\n        dataManager.completeData(this.animationData, this.renderer.globalData.fontManager);\\r\\n        if(expressionsPlugin){\\r\\n            expressionsPlugin.initExpressions(this);\\r\\n        }\\r\\n        this.renderer.initItems();\\r\\n        setTimeout(function() {\\r\\n            this.trigger('DOMLoaded');\\r\\n        }.bind(this), 0);\\r\\n        this.gotoFrame();\\r\\n        if(this.autoplay){\\r\\n            this.play();\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.resize = function () {\\r\\n    this.renderer.updateContainerSize();\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.setSubframe = function(flag){\\r\\n    this.subframeEnabled = flag ? true : false;\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.gotoFrame = function () {\\r\\n    this.currentFrame = this.subframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame;\\r\\n\\r\\n    if(this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted){\\r\\n        this.currentFrame = this.timeCompleted;\\r\\n    }\\r\\n    this.trigger('enterFrame');\\r\\n    this.renderFrame();\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.renderFrame = function () {\\r\\n    if(this.isLoaded === false){\\r\\n        return;\\r\\n    }\\r\\n    this.renderer.renderFrame(this.currentFrame + this.firstFrame);\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.play = function (name) {\\r\\n    if(name && this.name != name){\\r\\n        return;\\r\\n    }\\r\\n    if(this.isPaused === true){\\r\\n        this.isPaused = false;\\r\\n        if(this._idle){\\r\\n            this._idle = false;\\r\\n            this.trigger('_active');\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.pause = function (name) {\\r\\n    if(name && this.name != name){\\r\\n        return;\\r\\n    }\\r\\n    if(this.isPaused === false){\\r\\n        this.isPaused = true;\\r\\n        this._idle = true;\\r\\n        this.trigger('_idle');\\r\\n    }\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.togglePause = function (name) {\\r\\n    if(name && this.name != name){\\r\\n        return;\\r\\n    }\\r\\n    if(this.isPaused === true){\\r\\n        this.play();\\r\\n    }else{\\r\\n        this.pause();\\r\\n    }\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.stop = function (name) {\\r\\n    if(name && this.name != name){\\r\\n        return;\\r\\n    }\\r\\n    this.pause();\\r\\n    this.playCount = 0;\\r\\n    this._completedLoop = false;\\r\\n    this.setCurrentRawFrameValue(0);\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.goToAndStop = function (value, isFrame, name) {\\r\\n    if(name && this.name != name){\\r\\n        return;\\r\\n    }\\r\\n    if(isFrame){\\r\\n        this.setCurrentRawFrameValue(value);\\r\\n    }else{\\r\\n        this.setCurrentRawFrameValue(value * this.frameModifier);\\r\\n    }\\r\\n    this.pause();\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {\\r\\n    this.goToAndStop(value, isFrame, name);\\r\\n    this.play();\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.advanceTime = function (value) {\\r\\n    if (this.isPaused === true || this.isLoaded === false) {\\r\\n        return;\\r\\n    }\\r\\n    var nextValue = this.currentRawFrame + value * this.frameModifier;\\r\\n    var _isComplete = false;\\r\\n    // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.\\r\\n    // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.\\r\\n    if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {\\r\\n        if (!this.loop || this.playCount === this.loop) {\\r\\n            if (!this.checkSegments(nextValue >  this.totalFrames ? nextValue % this.totalFrames : 0)) {\\r\\n                _isComplete = true;\\r\\n                nextValue = this.totalFrames - 1;\\r\\n            }\\r\\n        } else if (nextValue >= this.totalFrames) {\\r\\n            this.playCount += 1;\\r\\n            if (!this.checkSegments(nextValue % this.totalFrames)) {\\r\\n                this.setCurrentRawFrameValue(nextValue % this.totalFrames);\\r\\n                this._completedLoop = true;\\r\\n                this.trigger('loopComplete');\\r\\n            }\\r\\n        } else {\\r\\n            this.setCurrentRawFrameValue(nextValue);\\r\\n        }\\r\\n    } else if(nextValue < 0) {\\r\\n        if (!this.checkSegments(nextValue % this.totalFrames)) {\\r\\n            if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {\\r\\n                this.setCurrentRawFrameValue(this.totalFrames + (nextValue % this.totalFrames));\\r\\n                if(!this._completedLoop) {\\r\\n                    this._completedLoop = true;\\r\\n                } else {\\r\\n                    this.trigger('loopComplete');\\r\\n                }\\r\\n            } else {\\r\\n                _isComplete = true;\\r\\n                nextValue = 0;\\r\\n            }\\r\\n        }\\r\\n    } else {\\r\\n        this.setCurrentRawFrameValue(nextValue);\\r\\n    }\\r\\n    if (_isComplete) {\\r\\n        this.setCurrentRawFrameValue(nextValue);\\r\\n        this.pause();\\r\\n        this.trigger('complete');\\r\\n    }\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.adjustSegment = function(arr, offset){\\r\\n    this.playCount = 0;\\r\\n    if(arr[1] < arr[0]){\\r\\n        if(this.frameModifier > 0){\\r\\n            if(this.playSpeed < 0){\\r\\n                this.setSpeed(-this.playSpeed);\\r\\n            } else {\\r\\n                this.setDirection(-1);\\r\\n            }\\r\\n        }\\r\\n        this.timeCompleted = this.totalFrames = arr[0] - arr[1];\\r\\n        this.firstFrame = arr[1];\\r\\n        this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);\\r\\n    } else if(arr[1] > arr[0]){\\r\\n        if(this.frameModifier < 0){\\r\\n            if(this.playSpeed < 0){\\r\\n                this.setSpeed(-this.playSpeed);\\r\\n            } else {\\r\\n                this.setDirection(1);\\r\\n            }\\r\\n        }\\r\\n        this.timeCompleted = this.totalFrames = arr[1] - arr[0];\\r\\n        this.firstFrame = arr[0];\\r\\n        this.setCurrentRawFrameValue(0.001 + offset);\\r\\n    }\\r\\n    this.trigger('segmentStart');\\r\\n};\\r\\nAnimationItem.prototype.setSegment = function (init,end) {\\r\\n    var pendingFrame = -1;\\r\\n    if(this.isPaused) {\\r\\n        if (this.currentRawFrame + this.firstFrame < init) {\\r\\n            pendingFrame = init;\\r\\n        } else if (this.currentRawFrame + this.firstFrame > end) {\\r\\n            pendingFrame = end - init;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    this.firstFrame = init;\\r\\n    this.timeCompleted = this.totalFrames = end - init;\\r\\n    if(pendingFrame !== -1) {\\r\\n        this.goToAndStop(pendingFrame,true);\\r\\n    }\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.playSegments = function (arr, forceFlag) {\\r\\n    if (forceFlag) {\\r\\n        this.segments.length = 0;\\r\\n    }\\r\\n    if (typeof arr[0] === 'object') {\\r\\n        var i, len = arr.length;\\r\\n        for (i = 0; i < len; i += 1) {\\r\\n            this.segments.push(arr[i]);\\r\\n        }\\r\\n    } else {\\r\\n        this.segments.push(arr);\\r\\n    }\\r\\n    if (this.segments.length) {\\r\\n        this.adjustSegment(this.segments.shift(), 0);\\r\\n    }\\r\\n    if (this.isPaused) {\\r\\n        this.play();\\r\\n    }\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.resetSegments = function (forceFlag) {\\r\\n    this.segments.length = 0;\\r\\n    this.segments.push([this.animationData.ip,this.animationData.op]);\\r\\n    //this.segments.push([this.animationData.ip*this.frameRate,Math.floor(this.animationData.op - this.animationData.ip+this.animationData.ip*this.frameRate)]);\\r\\n    if (forceFlag) {\\r\\n        this.checkSegments(0);\\r\\n    }\\r\\n};\\r\\nAnimationItem.prototype.checkSegments = function(offset) {\\r\\n    if (this.segments.length) {\\r\\n        this.adjustSegment(this.segments.shift(), offset);\\r\\n        return true;\\r\\n    }\\r\\n    return false;\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.destroy = function (name) {\\r\\n    if ((name && this.name != name) || !this.renderer) {\\r\\n        return;\\r\\n    }\\r\\n    this.renderer.destroy();\\r\\n    this.imagePreloader.destroy();\\r\\n    this.trigger('destroy');\\r\\n    this._cbs = null;\\r\\n    this.onEnterFrame = this.onLoopComplete = this.onComplete = this.onSegmentStart = this.onDestroy = null;\\r\\n    this.renderer = null;\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.setCurrentRawFrameValue = function(value){\\r\\n    this.currentRawFrame = value;\\r\\n    this.gotoFrame();\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.setSpeed = function (val) {\\r\\n    this.playSpeed = val;\\r\\n    this.updaFrameModifier();\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.setDirection = function (val) {\\r\\n    this.playDirection = val < 0 ? -1 : 1;\\r\\n    this.updaFrameModifier();\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.updaFrameModifier = function () {\\r\\n    this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.getPath = function () {\\r\\n    return this.path;\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.getAssetsPath = function (assetData) {\\r\\n    var path = '';\\r\\n    if(assetData.e) {\\r\\n        path = assetData.p;\\r\\n    } else if(this.assetsPath){\\r\\n        var imagePath = assetData.p;\\r\\n        if(imagePath.indexOf('images/') !== -1){\\r\\n            imagePath = imagePath.split('/')[1];\\r\\n        }\\r\\n        path = this.assetsPath + imagePath;\\r\\n    } else {\\r\\n        path = this.path;\\r\\n        path += assetData.u ? assetData.u : '';\\r\\n        path += assetData.p;\\r\\n    }\\r\\n    return path;\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.getAssetData = function (id) {\\r\\n    var i = 0, len = this.assets.length;\\r\\n    while (i < len) {\\r\\n        if(id == this.assets[i].id){\\r\\n            return this.assets[i];\\r\\n        }\\r\\n        i += 1;\\r\\n    }\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.hide = function () {\\r\\n    this.renderer.hide();\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.show = function () {\\r\\n    this.renderer.show();\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.getDuration = function (isFrame) {\\r\\n    return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;\\r\\n};\\r\\n\\r\\nAnimationItem.prototype.trigger = function(name){\\r\\n    if(this._cbs && this._cbs[name]){\\r\\n        switch(name){\\r\\n            case 'enterFrame':\\r\\n                this.triggerEvent(name,new BMEnterFrameEvent(name,this.currentFrame,this.totalFrames,this.frameMult));\\r\\n                break;\\r\\n            case 'loopComplete':\\r\\n                this.triggerEvent(name,new BMCompleteLoopEvent(name,this.loop,this.playCount,this.frameMult));\\r\\n                break;\\r\\n            case 'complete':\\r\\n                this.triggerEvent(name,new BMCompleteEvent(name,this.frameMult));\\r\\n                break;\\r\\n            case 'segmentStart':\\r\\n                this.triggerEvent(name,new BMSegmentStartEvent(name,this.firstFrame,this.totalFrames));\\r\\n                break;\\r\\n            case 'destroy':\\r\\n                this.triggerEvent(name,new BMDestroyEvent(name,this));\\r\\n                break;\\r\\n            default:\\r\\n                this.triggerEvent(name);\\r\\n        }\\r\\n    }\\r\\n    if(name === 'enterFrame' && this.onEnterFrame){\\r\\n        this.onEnterFrame.call(this,new BMEnterFrameEvent(name,this.currentFrame,this.totalFrames,this.frameMult));\\r\\n    }\\r\\n    if(name === 'loopComplete' && this.onLoopComplete){\\r\\n        this.onLoopComplete.call(this,new BMCompleteLoopEvent(name,this.loop,this.playCount,this.frameMult));\\r\\n    }\\r\\n    if(name === 'complete' && this.onComplete){\\r\\n        this.onComplete.call(this,new BMCompleteEvent(name,this.frameMult));\\r\\n    }\\r\\n    if(name === 'segmentStart' && this.onSegmentStart){\\r\\n        this.onSegmentStart.call(this,new BMSegmentStartEvent(name,this.firstFrame,this.totalFrames));\\r\\n    }\\r\\n    if(name === 'destroy' && this.onDestroy){\\r\\n        this.onDestroy.call(this,new BMDestroyEvent(name,this));\\r\\n    }\\r\\n};\\r\\n\\nfunction EffectsManager(){}\\nfunction CanvasRenderer(animationItem, config){\\r\\n    this.animationItem = animationItem;\\r\\n    this.renderConfig = {\\r\\n        clearCanvas: (config && config.clearCanvas !== undefined) ? config.clearCanvas : true,\\r\\n        context: (config && config.context) || null,\\r\\n        progressiveLoad: (config && config.progressiveLoad) || false,\\r\\n        preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',\\r\\n        imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',\\r\\n        className: (config && config.className) || ''\\r\\n    };\\r\\n    this.renderConfig.dpr = (config && config.dpr) || 1;\\r\\n    if (this.animationItem.wrapper) {\\r\\n        this.renderConfig.dpr = (config && config.dpr) || window.devicePixelRatio || 1;\\r\\n    }\\r\\n    this.renderedFrame = -1;\\r\\n    this.globalData = {\\r\\n        frameNum: -1,\\r\\n        _mdf: false,\\r\\n        renderConfig: this.renderConfig,\\r\\n        currentGlobalAlpha: -1\\r\\n    };\\r\\n    this.contextData = new CVContextData();\\r\\n    this.elements = [];\\r\\n    this.pendingElements = [];\\r\\n    this.transformMat = new Matrix();\\r\\n    this.completeLayers = false;\\r\\n    this.rendererType = 'canvas';\\r\\n}\\r\\nextendPrototype([BaseRenderer],CanvasRenderer);\\r\\n\\r\\nCanvasRenderer.prototype.createShape = function (data) {\\r\\n    return new CVShapeElement(data, this.globalData, this);\\r\\n};\\r\\n\\r\\nCanvasRenderer.prototype.createText = function (data) {\\r\\n    return new CVTextElement(data, this.globalData, this);\\r\\n};\\r\\n\\r\\nCanvasRenderer.prototype.createImage = function (data) {\\r\\n    return new CVImageElement(data, this.globalData, this);\\r\\n};\\r\\n\\r\\nCanvasRenderer.prototype.createComp = function (data) {\\r\\n    return new CVCompElement(data, this.globalData, this);\\r\\n};\\r\\n\\r\\nCanvasRenderer.prototype.createSolid = function (data) {\\r\\n    return new CVSolidElement(data, this.globalData, this);\\r\\n};\\r\\n\\r\\nCanvasRenderer.prototype.createNull = SVGRenderer.prototype.createNull;\\r\\n\\r\\nCanvasRenderer.prototype.ctxTransform = function(props){\\r\\n    if(props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0){\\r\\n        return;\\r\\n    }\\r\\n    if(!this.renderConfig.clearCanvas){\\r\\n        this.canvasContext.transform(props[0],props[1],props[4],props[5],props[12],props[13]);\\r\\n        return;\\r\\n    }\\r\\n    this.transformMat.cloneFromProps(props);\\r\\n    var cProps = this.contextData.cTr.props;\\r\\n    this.transformMat.transform(cProps[0],cProps[1],cProps[2],cProps[3],cProps[4],cProps[5],cProps[6],cProps[7],cProps[8],cProps[9],cProps[10],cProps[11],cProps[12],cProps[13],cProps[14],cProps[15]);\\r\\n    //this.contextData.cTr.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);\\r\\n    this.contextData.cTr.cloneFromProps(this.transformMat.props);\\r\\n    var trProps = this.contextData.cTr.props;\\r\\n    this.canvasContext.setTransform(trProps[0],trProps[1],trProps[4],trProps[5],trProps[12],trProps[13]);\\r\\n};\\r\\n\\r\\nCanvasRenderer.prototype.ctxOpacity = function(op){\\r\\n    /*if(op === 1){\\r\\n        return;\\r\\n    }*/\\r\\n    if(!this.renderConfig.clearCanvas){\\r\\n        this.canvasContext.globalAlpha *= op < 0 ? 0 : op;\\r\\n        this.globalData.currentGlobalAlpha = this.contextData.cO;\\r\\n        return;\\r\\n    }\\r\\n    this.contextData.cO *= op < 0 ? 0 : op;\\r\\n    if(this.globalData.currentGlobalAlpha !== this.contextData.cO) {\\r\\n        this.canvasContext.globalAlpha = this.contextData.cO;\\r\\n        this.globalData.currentGlobalAlpha = this.contextData.cO;\\r\\n    }\\r\\n};\\r\\n\\r\\nCanvasRenderer.prototype.reset = function(){\\r\\n    if(!this.renderConfig.clearCanvas){\\r\\n        this.canvasContext.restore();\\r\\n        return;\\r\\n    }\\r\\n    this.contextData.reset();\\r\\n};\\r\\n\\r\\nCanvasRenderer.prototype.save = function(actionFlag){\\r\\n    if(!this.renderConfig.clearCanvas){\\r\\n        this.canvasContext.save();\\r\\n        return;\\r\\n    }\\r\\n    if(actionFlag){\\r\\n        this.canvasContext.save();\\r\\n    }\\r\\n    var props = this.contextData.cTr.props;\\r\\n    if(this.contextData._length <= this.contextData.cArrPos) {\\r\\n        this.contextData.duplicate();\\r\\n    }\\r\\n    var i, arr = this.contextData.saved[this.contextData.cArrPos];\\r\\n    for (i = 0; i < 16; i += 1) {\\r\\n        arr[i] = props[i];\\r\\n    }\\r\\n    this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO;\\r\\n    this.contextData.cArrPos += 1;\\r\\n};\\r\\n\\r\\nCanvasRenderer.prototype.restore = function(actionFlag){\\r\\n    if(!this.renderConfig.clearCanvas){\\r\\n        this.canvasContext.restore();\\r\\n        return;\\r\\n    }\\r\\n    if(actionFlag){\\r\\n        this.canvasContext.restore();\\r\\n        this.globalData.blendMode = 'source-over';\\r\\n    }\\r\\n    this.contextData.cArrPos -= 1;\\r\\n    var popped = this.contextData.saved[this.contextData.cArrPos];\\r\\n    var i,arr = this.contextData.cTr.props;\\r\\n    for(i=0;i<16;i+=1){\\r\\n        arr[i] = popped[i];\\r\\n    }\\r\\n    this.canvasContext.setTransform(popped[0],popped[1],popped[4],popped[5],popped[12],popped[13]);\\r\\n    popped = this.contextData.savedOp[this.contextData.cArrPos];\\r\\n    this.contextData.cO = popped;\\r\\n    if(this.globalData.currentGlobalAlpha !== popped) {\\r\\n        this.canvasContext.globalAlpha = popped;\\r\\n        this.globalData.currentGlobalAlpha = popped;\\r\\n    }\\r\\n};\\r\\n\\r\\nCanvasRenderer.prototype.configAnimation = function(animData){\\r\\n    if(this.animationItem.wrapper){\\r\\n        this.animationItem.container = createTag('canvas');\\r\\n        this.animationItem.container.style.width = '100%';\\r\\n        this.animationItem.container.style.height = '100%';\\r\\n        //this.animationItem.container.style.transform = 'translate3d(0,0,0)';\\r\\n        //this.animationItem.container.style.webkitTransform = 'translate3d(0,0,0)';\\r\\n        this.animationItem.container.style.transformOrigin = this.animationItem.container.style.mozTransformOrigin = this.animationItem.container.style.webkitTransformOrigin = this.animationItem.container.style['-webkit-transform'] = \\\"0px 0px 0px\\\";\\r\\n        this.animationItem.wrapper.appendChild(this.animationItem.container);\\r\\n        this.canvasContext = this.animationItem.container.getContext('2d');\\r\\n        if(this.renderConfig.className) {\\r\\n            this.animationItem.container.setAttribute('class', this.renderConfig.className);\\r\\n        }\\r\\n    }else{\\r\\n        this.canvasContext = this.renderConfig.context;\\r\\n    }\\r\\n    this.data = animData;\\r\\n    this.layers = animData.layers;\\r\\n    this.transformCanvas = {\\r\\n        w: animData.w,\\r\\n        h:animData.h,\\r\\n        sx:0,\\r\\n        sy:0,\\r\\n        tx:0,\\r\\n        ty:0\\r\\n    };\\r\\n    this.setupGlobalData(animData, document.body);\\r\\n    this.globalData.canvasContext = this.canvasContext;\\r\\n    this.globalData.renderer = this;\\r\\n    this.globalData.isDashed = false;\\r\\n    this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;\\r\\n    this.globalData.transformCanvas = this.transformCanvas;\\r\\n    this.elements = createSizedArray(animData.layers.length);\\r\\n\\r\\n    this.updateContainerSize();\\r\\n};\\r\\n\\r\\nCanvasRenderer.prototype.updateContainerSize = function () {\\r\\n    this.reset();\\r\\n    var elementWidth,elementHeight;\\r\\n    if(this.animationItem.wrapper && this.animationItem.container){\\r\\n        elementWidth = this.animationItem.wrapper.offsetWidth;\\r\\n        elementHeight = this.animationItem.wrapper.offsetHeight;\\r\\n        this.animationItem.container.setAttribute('width',elementWidth * this.renderConfig.dpr );\\r\\n        this.animationItem.container.setAttribute('height',elementHeight * this.renderConfig.dpr);\\r\\n    }else{\\r\\n        elementWidth = this.canvasContext.canvas.width * this.renderConfig.dpr;\\r\\n        elementHeight = this.canvasContext.canvas.height * this.renderConfig.dpr;\\r\\n    }\\r\\n    var elementRel,animationRel;\\r\\n    if(this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1){\\r\\n        var par = this.renderConfig.preserveAspectRatio.split(' ');\\r\\n        var fillType = par[1] || 'meet';\\r\\n        var pos = par[0] || 'xMidYMid';\\r\\n        var xPos = pos.substr(0,4);\\r\\n        var yPos = pos.substr(4);\\r\\n        elementRel = elementWidth/elementHeight;\\r\\n        animationRel = this.transformCanvas.w/this.transformCanvas.h;\\r\\n        if(animationRel>elementRel && fillType === 'meet' || animationRel<elementRel && fillType === 'slice'){\\r\\n            this.transformCanvas.sx = elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);\\r\\n            this.transformCanvas.sy = elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);\\r\\n        }else{\\r\\n            this.transformCanvas.sx = elementHeight/(this.transformCanvas.h / this.renderConfig.dpr);\\r\\n            this.transformCanvas.sy = elementHeight/(this.transformCanvas.h / this.renderConfig.dpr);\\r\\n        }\\r\\n\\r\\n        if(xPos === 'xMid' && ((animationRel<elementRel && fillType==='meet') || (animationRel>elementRel && fillType === 'slice'))){\\r\\n            this.transformCanvas.tx = (elementWidth-this.transformCanvas.w*(elementHeight/this.transformCanvas.h))/2*this.renderConfig.dpr;\\r\\n        } else if(xPos === 'xMax' && ((animationRel<elementRel && fillType==='meet') || (animationRel>elementRel && fillType === 'slice'))){\\r\\n            this.transformCanvas.tx = (elementWidth-this.transformCanvas.w*(elementHeight/this.transformCanvas.h))*this.renderConfig.dpr;\\r\\n        } else {\\r\\n            this.transformCanvas.tx = 0;\\r\\n        }\\r\\n        if(yPos === 'YMid' && ((animationRel>elementRel && fillType==='meet') || (animationRel<elementRel && fillType === 'slice'))){\\r\\n            this.transformCanvas.ty = ((elementHeight-this.transformCanvas.h*(elementWidth/this.transformCanvas.w))/2)*this.renderConfig.dpr;\\r\\n        } else if(yPos === 'YMax' && ((animationRel>elementRel && fillType==='meet') || (animationRel<elementRel && fillType === 'slice'))){\\r\\n            this.transformCanvas.ty = ((elementHeight-this.transformCanvas.h*(elementWidth/this.transformCanvas.w)))*this.renderConfig.dpr;\\r\\n        } else {\\r\\n            this.transformCanvas.ty = 0;\\r\\n        }\\r\\n\\r\\n    }else if(this.renderConfig.preserveAspectRatio == 'none'){\\r\\n        this.transformCanvas.sx = elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);\\r\\n        this.transformCanvas.sy = elementHeight/(this.transformCanvas.h/this.renderConfig.dpr);\\r\\n        this.transformCanvas.tx = 0;\\r\\n        this.transformCanvas.ty = 0;\\r\\n    }else{\\r\\n        this.transformCanvas.sx = this.renderConfig.dpr;\\r\\n        this.transformCanvas.sy = this.renderConfig.dpr;\\r\\n        this.transformCanvas.tx = 0;\\r\\n        this.transformCanvas.ty = 0;\\r\\n    }\\r\\n    this.transformCanvas.props = [this.transformCanvas.sx,0,0,0,0,this.transformCanvas.sy,0,0,0,0,1,0,this.transformCanvas.tx,this.transformCanvas.ty,0,1];\\r\\n    /*var i, len = this.elements.length;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        if(this.elements[i] && this.elements[i].data.ty === 0){\\r\\n            this.elements[i].resize(this.globalData.transformCanvas);\\r\\n        }\\r\\n    }*/\\r\\n    this.ctxTransform(this.transformCanvas.props);\\r\\n    this.canvasContext.beginPath();\\r\\n    this.canvasContext.rect(0,0,this.transformCanvas.w,this.transformCanvas.h);\\r\\n    this.canvasContext.closePath();\\r\\n    this.canvasContext.clip();\\r\\n};\\r\\n\\r\\nCanvasRenderer.prototype.destroy = function () {\\r\\n    if(this.renderConfig.clearCanvas) {\\r\\n        this.animationItem.wrapper.innerHTML = '';\\r\\n    }\\r\\n    var i, len = this.layers ? this.layers.length : 0;\\r\\n    for (i = len - 1; i >= 0; i-=1) {\\r\\n        if(this.elements[i]) {\\r\\n            this.elements[i].destroy();\\r\\n        }\\r\\n    }\\r\\n    this.elements.length = 0;\\r\\n    this.globalData.canvasContext = null;\\r\\n    this.animationItem.container = null;\\r\\n    this.destroyed = true;\\r\\n};\\r\\n\\r\\nCanvasRenderer.prototype.renderFrame = function(num){\\r\\n    if((this.renderedFrame == num && this.renderConfig.clearCanvas === true) || this.destroyed || num === -1){\\r\\n        return;\\r\\n    }\\r\\n    this.renderedFrame = num;\\r\\n    this.globalData.frameNum = num - this.animationItem._isFirstFrame;\\r\\n    this.globalData.frameId += 1;\\r\\n    this.globalData._mdf = !this.renderConfig.clearCanvas;\\r\\n    this.globalData.projectInterface.currentFrame = num;\\r\\n\\r\\n     // console.log('--------');\\r\\n     // console.log('NEW: ',num);\\r\\n    var i, len = this.layers.length;\\r\\n    if(!this.completeLayers){\\r\\n        this.checkLayers(num);\\r\\n    }\\r\\n\\r\\n    for (i = 0; i < len; i++) {\\r\\n        if(this.completeLayers || this.elements[i]){\\r\\n            this.elements[i].prepareFrame(num - this.layers[i].st);\\r\\n        }\\r\\n    }\\r\\n    if(this.globalData._mdf) {\\r\\n        if(this.renderConfig.clearCanvas === true){\\r\\n            this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);\\r\\n        }else{\\r\\n            this.save();\\r\\n        }\\r\\n        for (i = len - 1; i >= 0; i-=1) {\\r\\n            if(this.completeLayers || this.elements[i]){\\r\\n                this.elements[i].renderFrame();\\r\\n            }\\r\\n        }\\r\\n        if(this.renderConfig.clearCanvas !== true){\\r\\n            this.restore();\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nCanvasRenderer.prototype.buildItem = function(pos){\\r\\n    var elements = this.elements;\\r\\n    if(elements[pos] || this.layers[pos].ty == 99){\\r\\n        return;\\r\\n    }\\r\\n    var element = this.createItem(this.layers[pos], this,this.globalData);\\r\\n    elements[pos] = element;\\r\\n    element.initExpressions();\\r\\n    /*if(this.layers[pos].ty === 0){\\r\\n        element.resize(this.globalData.transformCanvas);\\r\\n    }*/\\r\\n};\\r\\n\\r\\nCanvasRenderer.prototype.checkPendingElements  = function(){\\r\\n    while(this.pendingElements.length){\\r\\n        var element = this.pendingElements.pop();\\r\\n        element.checkParenting();\\r\\n    }\\r\\n};\\r\\n\\r\\nCanvasRenderer.prototype.hide = function(){\\r\\n    this.animationItem.container.style.display = 'none';\\r\\n};\\r\\n\\r\\nCanvasRenderer.prototype.show = function(){\\r\\n    this.animationItem.container.style.display = 'block';\\r\\n};\\r\\n\\nfunction HybridRenderer(animationItem, config){\\r\\n    this.animationItem = animationItem;\\r\\n    this.layers = null;\\r\\n    this.renderedFrame = -1;\\r\\n    this.renderConfig = {\\r\\n        className: (config && config.className) || '',\\r\\n        imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',\\r\\n        hideOnTransparent: (config && config.hideOnTransparent === false) ? false : true\\r\\n    };\\r\\n    this.globalData = {\\r\\n        _mdf: false,\\r\\n        frameNum: -1,\\r\\n        renderConfig: this.renderConfig\\r\\n    };\\r\\n    this.pendingElements = [];\\r\\n    this.elements = [];\\r\\n    this.threeDElements = [];\\r\\n    this.destroyed = false;\\r\\n    this.camera = null;\\r\\n    this.supports3d = true;\\r\\n    this.rendererType = 'html';\\r\\n\\r\\n}\\r\\n\\r\\nextendPrototype([BaseRenderer],HybridRenderer);\\r\\n\\r\\nHybridRenderer.prototype.buildItem = SVGRenderer.prototype.buildItem;\\r\\n\\r\\nHybridRenderer.prototype.checkPendingElements  = function(){\\r\\n    while(this.pendingElements.length){\\r\\n        var element = this.pendingElements.pop();\\r\\n        element.checkParenting();\\r\\n    }\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.appendElementInPos = function(element, pos){\\r\\n    var newDOMElement = element.getBaseElement();\\r\\n    if(!newDOMElement){\\r\\n        return;\\r\\n    }\\r\\n    var layer = this.layers[pos];\\r\\n    if(!layer.ddd || !this.supports3d){\\r\\n        if(this.threeDElements) {\\r\\n            this.addTo3dContainer(newDOMElement,pos);\\r\\n        } else {\\r\\n            var i = 0;\\r\\n            var nextDOMElement, nextLayer, tmpDOMElement;\\r\\n            while(i<pos){\\r\\n                if(this.elements[i] && this.elements[i]!== true && this.elements[i].getBaseElement){\\r\\n                    nextLayer = this.elements[i];\\r\\n                    tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();\\r\\n                    nextDOMElement = tmpDOMElement || nextDOMElement;\\r\\n                }\\r\\n                i += 1;\\r\\n            }\\r\\n            if(nextDOMElement){\\r\\n                if(!layer.ddd || !this.supports3d){\\r\\n                    this.layerElement.insertBefore(newDOMElement, nextDOMElement);\\r\\n                }\\r\\n            } else {\\r\\n                if(!layer.ddd || !this.supports3d){\\r\\n                    this.layerElement.appendChild(newDOMElement);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        \\r\\n    } else {\\r\\n        this.addTo3dContainer(newDOMElement,pos);\\r\\n    }\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.createShape = function (data) {\\r\\n    if(!this.supports3d){\\r\\n        return new SVGShapeElement(data, this.globalData, this);\\r\\n    }\\r\\n    return new HShapeElement(data, this.globalData, this);\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.createText = function (data) {\\r\\n    if(!this.supports3d){\\r\\n        return new SVGTextElement(data, this.globalData, this);\\r\\n    }\\r\\n    return new HTextElement(data, this.globalData, this);\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.createCamera = function (data) {\\r\\n    this.camera = new HCameraElement(data, this.globalData, this);\\r\\n    return this.camera;\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.createImage = function (data) {\\r\\n    if(!this.supports3d){\\r\\n        return new IImageElement(data, this.globalData, this);\\r\\n    }\\r\\n    return new HImageElement(data, this.globalData, this);\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.createComp = function (data) {\\r\\n    if(!this.supports3d){\\r\\n        return new SVGCompElement(data, this.globalData, this);\\r\\n    }\\r\\n    return new HCompElement(data, this.globalData, this);\\r\\n\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.createSolid = function (data) {\\r\\n    if(!this.supports3d){\\r\\n        return new ISolidElement(data, this.globalData, this);\\r\\n    }\\r\\n    return new HSolidElement(data, this.globalData, this);\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.createNull = SVGRenderer.prototype.createNull;\\r\\n\\r\\nHybridRenderer.prototype.getThreeDContainerByPos = function(pos){\\r\\n    var i = 0, len = this.threeDElements.length;\\r\\n    while(i<len) {\\r\\n        if(this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {\\r\\n            return this.threeDElements[i].perspectiveElem;\\r\\n        }\\r\\n        i += 1;\\r\\n    }\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.createThreeDContainer = function(pos, type){\\r\\n    var perspectiveElem = createTag('div');\\r\\n    styleDiv(perspectiveElem);\\r\\n    var container = createTag('div');\\r\\n    styleDiv(container);\\r\\n    if(type === '3d') {\\r\\n        perspectiveElem.style.width = this.globalData.compSize.w+'px';\\r\\n        perspectiveElem.style.height = this.globalData.compSize.h+'px';\\r\\n        perspectiveElem.style.transformOrigin = perspectiveElem.style.mozTransformOrigin = perspectiveElem.style.webkitTransformOrigin = \\\"50% 50%\\\";\\r\\n        container.style.transform = container.style.webkitTransform = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';\\r\\n    }\\r\\n    \\r\\n    perspectiveElem.appendChild(container);\\r\\n    //this.resizerElem.appendChild(perspectiveElem);\\r\\n    var threeDContainerData = {\\r\\n        container:container,\\r\\n        perspectiveElem:perspectiveElem,\\r\\n        startPos: pos,\\r\\n        endPos: pos,\\r\\n        type: type\\r\\n    };\\r\\n    this.threeDElements.push(threeDContainerData);\\r\\n    return threeDContainerData;\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.build3dContainers = function(){\\r\\n    var i, len = this.layers.length;\\r\\n    var lastThreeDContainerData;\\r\\n    var currentContainer = '';\\r\\n    for(i=0;i<len;i+=1){\\r\\n        if(this.layers[i].ddd && this.layers[i].ty !== 3){\\r\\n            if(currentContainer !== '3d'){\\r\\n                currentContainer = '3d';\\r\\n                lastThreeDContainerData = this.createThreeDContainer(i,'3d');\\r\\n            }\\r\\n            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos,i);\\r\\n        } else {\\r\\n            if(currentContainer !== '2d'){\\r\\n                currentContainer = '2d';\\r\\n                lastThreeDContainerData = this.createThreeDContainer(i,'2d');\\r\\n            }\\r\\n            lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos,i);\\r\\n        }\\r\\n    }\\r\\n    len = this.threeDElements.length;\\r\\n    for(i = len - 1; i >= 0; i --) {\\r\\n        this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);\\r\\n    }\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.addTo3dContainer = function(elem,pos){\\r\\n    var i = 0, len = this.threeDElements.length;\\r\\n    while(i<len){\\r\\n        if(pos <= this.threeDElements[i].endPos){\\r\\n            var j = this.threeDElements[i].startPos;\\r\\n            var nextElement;\\r\\n            while(j<pos){\\r\\n                if(this.elements[j] && this.elements[j].getBaseElement){\\r\\n                    nextElement = this.elements[j].getBaseElement();\\r\\n                }\\r\\n                j += 1;\\r\\n            }\\r\\n            if(nextElement){\\r\\n                this.threeDElements[i].container.insertBefore(elem, nextElement);\\r\\n            } else {\\r\\n                this.threeDElements[i].container.appendChild(elem);\\r\\n            }\\r\\n            break;\\r\\n        }\\r\\n        i += 1;\\r\\n    }\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.configAnimation = function(animData){\\r\\n    var resizerElem = createTag('div');\\r\\n    var wrapper = this.animationItem.wrapper;\\r\\n    resizerElem.style.width = animData.w+'px';\\r\\n    resizerElem.style.height = animData.h+'px';\\r\\n    this.resizerElem = resizerElem;\\r\\n    styleDiv(resizerElem);\\r\\n    resizerElem.style.transformStyle = resizerElem.style.webkitTransformStyle = resizerElem.style.mozTransformStyle = \\\"flat\\\";\\r\\n    if(this.renderConfig.className) {\\r\\n      resizerElem.setAttribute('class', this.renderConfig.className);\\r\\n    }\\r\\n    wrapper.appendChild(resizerElem);\\r\\n\\r\\n    resizerElem.style.overflow = 'hidden';\\r\\n    var svg = createNS('svg');\\r\\n    svg.setAttribute('width','1');\\r\\n    svg.setAttribute('height','1');\\r\\n    styleDiv(svg);\\r\\n    this.resizerElem.appendChild(svg);\\r\\n    var defs = createNS('defs');\\r\\n    svg.appendChild(defs);\\r\\n    this.data = animData;\\r\\n    //Mask animation\\r\\n    this.setupGlobalData(animData, svg);\\r\\n    this.globalData.defs = defs;\\r\\n    this.layers = animData.layers;\\r\\n    this.layerElement = this.resizerElem;\\r\\n    this.build3dContainers();\\r\\n    this.updateContainerSize();\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.destroy = function () {\\r\\n    this.animationItem.wrapper.innerHTML = '';\\r\\n    this.animationItem.container = null;\\r\\n    this.globalData.defs = null;\\r\\n    var i, len = this.layers ? this.layers.length : 0;\\r\\n    for (i = 0; i < len; i++) {\\r\\n        this.elements[i].destroy();\\r\\n    }\\r\\n    this.elements.length = 0;\\r\\n    this.destroyed = true;\\r\\n    this.animationItem = null;\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.updateContainerSize = function () {\\r\\n    var elementWidth = this.animationItem.wrapper.offsetWidth;\\r\\n    var elementHeight = this.animationItem.wrapper.offsetHeight;\\r\\n    var elementRel = elementWidth/elementHeight;\\r\\n    var animationRel = this.globalData.compSize.w/this.globalData.compSize.h;\\r\\n    var sx,sy,tx,ty;\\r\\n    if(animationRel>elementRel){\\r\\n        sx = elementWidth/(this.globalData.compSize.w);\\r\\n        sy = elementWidth/(this.globalData.compSize.w);\\r\\n        tx = 0;\\r\\n        ty = ((elementHeight-this.globalData.compSize.h*(elementWidth/this.globalData.compSize.w))/2);\\r\\n    }else{\\r\\n        sx = elementHeight/(this.globalData.compSize.h);\\r\\n        sy = elementHeight/(this.globalData.compSize.h);\\r\\n        tx = (elementWidth-this.globalData.compSize.w*(elementHeight/this.globalData.compSize.h))/2;\\r\\n        ty = 0;\\r\\n    }\\r\\n    this.resizerElem.style.transform = this.resizerElem.style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,'+sy+',0,0,0,0,1,0,'+tx+','+ty+',0,1)';\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.renderFrame = SVGRenderer.prototype.renderFrame;\\r\\n\\r\\nHybridRenderer.prototype.hide = function(){\\r\\n    this.resizerElem.style.display = 'none';\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.show = function(){\\r\\n    this.resizerElem.style.display = 'block';\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.initItems = function(){\\r\\n    this.buildAllItems();\\r\\n    if(this.camera){\\r\\n        this.camera.setup();\\r\\n    } else {\\r\\n        var cWidth = this.globalData.compSize.w;\\r\\n        var cHeight = this.globalData.compSize.h;\\r\\n        var i, len = this.threeDElements.length;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            this.threeDElements[i].perspectiveElem.style.perspective = this.threeDElements[i].perspectiveElem.style.webkitPerspective = Math.sqrt(Math.pow(cWidth,2) + Math.pow(cHeight,2)) + 'px';\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nHybridRenderer.prototype.searchExtraCompositions = function(assets){\\r\\n    var i, len = assets.length;\\r\\n    var floatingContainer = createTag('div');\\r\\n    for(i=0;i<len;i+=1){\\r\\n        if(assets[i].xt){\\r\\n            var comp = this.createComp(assets[i],floatingContainer,this.globalData.comp,null);\\r\\n            comp.initExpressions();\\r\\n            this.globalData.projectInterface.registerComposition(comp);\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\nfunction CVShapeData(element, data, styles, transformsManager) {\\r\\n    this.styledShapes = [];\\r\\n    this.tr = [0,0,0,0,0,0];\\r\\n    var ty = 4;\\r\\n    if(data.ty == 'rc'){\\r\\n        ty = 5;\\r\\n    }else if(data.ty == 'el'){\\r\\n        ty = 6;\\r\\n    }else if(data.ty == 'sr'){\\r\\n        ty = 7;\\r\\n    }\\r\\n    this.sh = ShapePropertyFactory.getShapeProp(element,data,ty,element);\\r\\n    var i , len = styles.length,styledShape;\\r\\n    for (i = 0; i < len; i += 1) {\\r\\n        if (!styles[i].closed) {\\r\\n            styledShape = {\\r\\n                transforms: transformsManager.addTransformSequence(styles[i].transforms),\\r\\n                trNodes: []\\r\\n            }\\r\\n            this.styledShapes.push(styledShape);\\r\\n            styles[i].elements.push(styledShape);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nCVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;\\nfunction CVContextData() {\\r\\n\\tthis.saved = [];\\r\\n    this.cArrPos = 0;\\r\\n    this.cTr = new Matrix();\\r\\n    this.cO = 1;\\r\\n    var i, len = 15;\\r\\n    this.savedOp = createTypedArray('float32', len);\\r\\n    for(i=0;i<len;i+=1){\\r\\n        this.saved[i] = createTypedArray('float32', 16);\\r\\n    }\\r\\n    this._length = len;\\r\\n}\\r\\n\\r\\nCVContextData.prototype.duplicate = function() {\\r\\n\\tvar newLength = this._length * 2;\\r\\n\\tvar currentSavedOp = this.savedOp;\\r\\n    this.savedOp = createTypedArray('float32', newLength);\\r\\n    this.savedOp.set(currentSavedOp);\\r\\n    var i = 0;\\r\\n    for(i = this._length; i < newLength; i += 1) {\\r\\n        this.saved[i] = createTypedArray('float32', 16);\\r\\n    }\\r\\n    this._length = newLength;\\r\\n};\\r\\n\\r\\nCVContextData.prototype.reset = function() {\\r\\n\\tthis.cArrPos = 0;\\r\\n\\tthis.cTr.reset();\\r\\n    this.cO = 1;\\r\\n};\\nfunction CVBaseElement(){\\r\\n}\\r\\n\\r\\nCVBaseElement.prototype = {\\r\\n    createElements: function(){},\\r\\n    initRendererElement: function(){},\\r\\n    createContainerElements: function(){\\r\\n        this.canvasContext = this.globalData.canvasContext;\\r\\n        this.renderableEffectsManager = new CVEffects(this);\\r\\n    },\\r\\n    createContent: function(){},\\r\\n    setBlendMode: function(){\\r\\n        var globalData = this.globalData;\\r\\n        if(globalData.blendMode !== this.data.bm) {\\r\\n            globalData.blendMode = this.data.bm;\\r\\n            var blendModeValue = this.getBlendMode();\\r\\n            globalData.canvasContext.globalCompositeOperation = blendModeValue;\\r\\n        }\\r\\n    },\\r\\n    createRenderableComponents: function(){\\r\\n        this.maskManager = new CVMaskElement(this.data, this);\\r\\n    },\\r\\n    hideElement: function(){\\r\\n        if (!this.hidden && (!this.isInRange || this.isTransparent)) {\\r\\n            this.hidden = true;\\r\\n        }\\r\\n    },\\r\\n    showElement: function(){\\r\\n        if (this.isInRange && !this.isTransparent){\\r\\n            this.hidden = false;\\r\\n            this._isFirstFrame = true;\\r\\n            this.maskManager._isFirstFrame = true;\\r\\n        }\\r\\n    },\\r\\n    renderFrame: function() {\\r\\n        if (this.hidden || this.data.hd) {\\r\\n            return;\\r\\n        }\\r\\n        this.renderTransform();\\r\\n        this.renderRenderable();\\r\\n        this.setBlendMode();\\r\\n        this.globalData.renderer.save();\\r\\n        this.globalData.renderer.ctxTransform(this.finalTransform.mat.props);\\r\\n        this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v);\\r\\n        this.renderInnerContent();\\r\\n        this.globalData.renderer.restore();\\r\\n        if(this.maskManager.hasMasks) {\\r\\n            this.globalData.renderer.restore(true);\\r\\n        }\\r\\n        if (this._isFirstFrame) {\\r\\n            this._isFirstFrame = false;\\r\\n        }\\r\\n    },\\r\\n    destroy: function(){\\r\\n        this.canvasContext = null;\\r\\n        this.data = null;\\r\\n        this.globalData = null;\\r\\n        this.maskManager.destroy();\\r\\n    },\\r\\n    mHelper: new Matrix()\\r\\n};\\r\\nCVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;\\r\\nCVBaseElement.prototype.show = CVBaseElement.prototype.showElement;\\r\\n\\nfunction CVImageElement(data, globalData, comp){\\r\\n    this.failed = false;\\r\\n    this.assetData = globalData.getAssetData(data.refId);\\r\\n    this.img = globalData.imageLoader.getImage(this.assetData);\\r\\n    this.initElement(data,globalData,comp);\\r\\n}\\r\\nextendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);\\r\\n\\r\\nCVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;\\r\\nCVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;\\r\\n\\r\\nCVImageElement.prototype.createContent = function(){\\r\\n\\r\\n    if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {\\r\\n        var canvas = createTag('canvas');\\r\\n        canvas.width = this.assetData.w;\\r\\n        canvas.height = this.assetData.h;\\r\\n        var ctx = canvas.getContext('2d');\\r\\n\\r\\n        var imgW = this.img.width;\\r\\n        var imgH = this.img.height;\\r\\n        var imgRel = imgW / imgH;\\r\\n        var canvasRel = this.assetData.w/this.assetData.h;\\r\\n        var widthCrop, heightCrop;\\r\\n        var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;\\r\\n        if((imgRel > canvasRel && par === 'xMidYMid slice') || (imgRel < canvasRel && par !== 'xMidYMid slice')) {\\r\\n            heightCrop = imgH;\\r\\n            widthCrop = heightCrop*canvasRel;\\r\\n        } else {\\r\\n            widthCrop = imgW;\\r\\n            heightCrop = widthCrop/canvasRel;\\r\\n        }\\r\\n        ctx.drawImage(this.img,(imgW-widthCrop)/2,(imgH-heightCrop)/2,widthCrop,heightCrop,0,0,this.assetData.w,this.assetData.h);\\r\\n        this.img = canvas;\\r\\n    }\\r\\n\\r\\n};\\r\\n\\r\\nCVImageElement.prototype.renderInnerContent = function(parentMatrix){\\r\\n    if (this.failed) {\\r\\n        return;\\r\\n    }\\r\\n    this.canvasContext.drawImage(this.img, 0, 0);\\r\\n};\\r\\n\\r\\nCVImageElement.prototype.destroy = function(){\\r\\n    this.img = null;\\r\\n};\\nfunction CVCompElement(data, globalData, comp) {\\r\\n    this.completeLayers = false;\\r\\n    this.layers = data.layers;\\r\\n    this.pendingElements = [];\\r\\n    this.elements = createSizedArray(this.layers.length);\\r\\n    this.initElement(data, globalData, comp);\\r\\n    this.tm = data.tm ? PropertyFactory.getProp(this,data.tm,0,globalData.frameRate, this) : {_placeholder:true};\\r\\n}\\r\\n\\r\\nextendPrototype([CanvasRenderer, ICompElement, CVBaseElement], CVCompElement);\\r\\n\\r\\nCVCompElement.prototype.renderInnerContent = function() {\\r\\n    var i,len = this.layers.length;\\r\\n    for( i = len - 1; i >= 0; i -= 1 ){\\r\\n        if(this.completeLayers || this.elements[i]){\\r\\n            this.elements[i].renderFrame();\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nCVCompElement.prototype.destroy = function(){\\r\\n    var i,len = this.layers.length;\\r\\n    for( i = len - 1; i >= 0; i -= 1 ){\\r\\n        if(this.elements[i]) {\\r\\n            this.elements[i].destroy();\\r\\n        }\\r\\n    }\\r\\n    this.layers = null;\\r\\n    this.elements = null;\\r\\n};\\n\\r\\nfunction CVMaskElement(data,element){\\r\\n    this.data = data;\\r\\n    this.element = element;\\r\\n    this.masksProperties = this.data.masksProperties || [];\\r\\n    this.viewData = createSizedArray(this.masksProperties.length);\\r\\n    var i, len = this.masksProperties.length, hasMasks = false;\\r\\n    for (i = 0; i < len; i++) {\\r\\n        if(this.masksProperties[i].mode !== 'n'){\\r\\n            hasMasks = true;\\r\\n        }\\r\\n        this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element,this.masksProperties[i],3);\\r\\n    }\\r\\n    this.hasMasks = hasMasks;\\r\\n    if(hasMasks) {\\r\\n        this.element.addRenderableComponent(this);\\r\\n    }\\r\\n}\\r\\n\\r\\nCVMaskElement.prototype.renderFrame = function () {\\r\\n    if(!this.hasMasks){\\r\\n        return;\\r\\n    }\\r\\n    var transform = this.element.finalTransform.mat;\\r\\n    var ctx = this.element.canvasContext;\\r\\n    var i, len = this.masksProperties.length;\\r\\n    var pt,pts,data;\\r\\n    ctx.beginPath();\\r\\n    for (i = 0; i < len; i++) {\\r\\n        if(this.masksProperties[i].mode !== 'n'){\\r\\n            if (this.masksProperties[i].inv) {\\r\\n                ctx.moveTo(0, 0);\\r\\n                ctx.lineTo(this.element.globalData.compSize.w, 0);\\r\\n                ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);\\r\\n                ctx.lineTo(0, this.element.globalData.compSize.h);\\r\\n                ctx.lineTo(0, 0);\\r\\n            }\\r\\n            data = this.viewData[i].v;\\r\\n            pt = transform.applyToPointArray(data.v[0][0],data.v[0][1],0);\\r\\n            ctx.moveTo(pt[0], pt[1]);\\r\\n            var j, jLen = data._length;\\r\\n            for (j = 1; j < jLen; j++) {\\r\\n                pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);\\r\\n                ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);\\r\\n            }\\r\\n            pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);\\r\\n            ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);\\r\\n        }\\r\\n    }\\r\\n    this.element.globalData.renderer.save(true);\\r\\n    ctx.clip();\\r\\n};\\r\\n\\r\\nCVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;\\r\\n\\r\\nCVMaskElement.prototype.destroy = function(){\\r\\n    this.element = null;\\r\\n};\\nfunction CVShapeElement(data, globalData, comp) {\\r\\n    this.shapes = [];\\r\\n    this.shapesData = data.shapes;\\r\\n    this.stylesList = [];\\r\\n    this.itemsData = [];\\r\\n    this.prevViewData = [];\\r\\n    this.shapeModifiers = [];\\r\\n    this.processedElements = [];\\r\\n    this.transformsManager = new ShapeTransformManager();\\r\\n    this.initElement(data, globalData, comp);\\r\\n}\\r\\n\\r\\nextendPrototype([BaseElement,TransformElement,CVBaseElement,IShapeElement,HierarchyElement,FrameElement,RenderableElement], CVShapeElement);\\r\\n\\r\\nCVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;\\r\\n\\r\\nCVShapeElement.prototype.transformHelper = {opacity:1,_opMdf:false};\\r\\n\\r\\nCVShapeElement.prototype.dashResetter = [];\\r\\n\\r\\nCVShapeElement.prototype.createContent = function(){\\r\\n    this.searchShapes(this.shapesData,this.itemsData,this.prevViewData, true, []);\\r\\n};\\r\\n\\r\\nCVShapeElement.prototype.createStyleElement = function(data, transforms) {\\r\\n    var transformsSequence = this.transformsManager.addTransformSequence(transforms);\\r\\n    var styleElem = {\\r\\n        data: data,\\r\\n        type: data.ty,\\r\\n        preTransforms: transformsSequence,\\r\\n        transforms: [],\\r\\n        elements: [],\\r\\n        closed: data.hd === true\\r\\n    };\\r\\n    var elementData = {};\\r\\n    if(data.ty == 'fl' || data.ty == 'st'){\\r\\n        elementData.c = PropertyFactory.getProp(this,data.c,1,255,this);\\r\\n        if(!elementData.c.k){\\r\\n            styleElem.co = 'rgb('+bm_floor(elementData.c.v[0])+','+bm_floor(elementData.c.v[1])+','+bm_floor(elementData.c.v[2])+')';\\r\\n        }\\r\\n    } else if (data.ty === 'gf' || data.ty === 'gs') {\\r\\n        elementData.s = PropertyFactory.getProp(this,data.s,1,null,this);\\r\\n        elementData.e = PropertyFactory.getProp(this,data.e,1,null,this);\\r\\n        elementData.h = PropertyFactory.getProp(this,data.h||{k:0},0,0.01,this);\\r\\n        elementData.a = PropertyFactory.getProp(this,data.a||{k:0},0,degToRads,this);\\r\\n        elementData.g = new GradientProperty(this,data.g,this);\\r\\n    }\\r\\n    elementData.o = PropertyFactory.getProp(this,data.o,0,0.01,this);\\r\\n    if(data.ty == 'st' || data.ty == 'gs') {\\r\\n        styleElem.lc = this.lcEnum[data.lc] || 'round';\\r\\n        styleElem.lj = this.ljEnum[data.lj] || 'round';\\r\\n        if(data.lj == 1) {\\r\\n            styleElem.ml = data.ml;\\r\\n        }\\r\\n        elementData.w = PropertyFactory.getProp(this,data.w,0,null,this);\\r\\n        if(!elementData.w.k){\\r\\n            styleElem.wi = elementData.w.v;\\r\\n        }\\r\\n        if(data.d){\\r\\n            var d = new DashProperty(this,data.d,'canvas');\\r\\n            elementData.d = d;\\r\\n            if(!elementData.d.k){\\r\\n                styleElem.da = elementData.d.dashArray;\\r\\n                styleElem.do = elementData.d.dashoffset[0];\\r\\n            }\\r\\n        }\\r\\n    } else {\\r\\n        styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero';\\r\\n    }\\r\\n    this.stylesList.push(styleElem);\\r\\n    elementData.style = styleElem;\\r\\n    return elementData;\\r\\n};\\r\\n\\r\\nCVShapeElement.prototype.createGroupElement = function(data) {\\r\\n    var elementData = {\\r\\n        it: [],\\r\\n        prevViewData: []\\r\\n    };\\r\\n    return elementData;\\r\\n};\\r\\n\\r\\nCVShapeElement.prototype.createTransformElement = function(data) {\\r\\n    var elementData = {\\r\\n        transform : {\\r\\n            opacity: 1,\\r\\n            _opMdf:false,\\r\\n            key: this.transformsManager.getNewKey(),\\r\\n            op: PropertyFactory.getProp(this,data.o,0,0.01,this),\\r\\n            mProps: TransformPropertyFactory.getTransformProperty(this,data,this)\\r\\n        }\\r\\n    };\\r\\n    return elementData;\\r\\n};\\r\\n\\r\\nCVShapeElement.prototype.createShapeElement = function(data) {\\r\\n    var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);\\r\\n    \\r\\n    this.shapes.push(elementData);\\r\\n    this.addShapeToModifiers(elementData);\\r\\n    return elementData;\\r\\n};\\r\\n\\r\\nCVShapeElement.prototype.reloadShapes = function() {\\r\\n    this._isFirstFrame = true;\\r\\n    var i, len = this.itemsData.length;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        this.prevViewData[i] = this.itemsData[i];\\r\\n    }\\r\\n    this.searchShapes(this.shapesData,this.itemsData,this.prevViewData, true, []);\\r\\n    len = this.dynamicProperties.length;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        this.dynamicProperties[i].getValue();\\r\\n    }\\r\\n    this.renderModifiers();\\r\\n    this.transformsManager.processSequences(this._isFirstFrame);\\r\\n};\\r\\n\\r\\nCVShapeElement.prototype.addTransformToStyleList = function(transform) {\\r\\n    var i, len = this.stylesList.length;\\r\\n    for (i = 0; i < len; i += 1) {\\r\\n        if(!this.stylesList[i].closed) {\\r\\n            this.stylesList[i].transforms.push(transform);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nCVShapeElement.prototype.closeStyles = function(styles) {\\r\\n    var i, len = styles.length, j, jLen;\\r\\n    for (i = 0; i < len; i += 1) {\\r\\n        styles[i].closed = true;\\r\\n    }\\r\\n}\\r\\n\\r\\nCVShapeElement.prototype.searchShapes = function(arr,itemsData, prevViewData, shouldRender, transforms){\\r\\n    var i, len = arr.length - 1;\\r\\n    var j, jLen;\\r\\n    var ownStyles = [], ownModifiers = [], processedPos, modifier, currentTransform;\\r\\n    var ownTransforms = [].concat(transforms);\\r\\n    for(i=len;i>=0;i-=1){\\r\\n        processedPos = this.searchProcessedElement(arr[i]);\\r\\n        if(!processedPos){\\r\\n            arr[i]._shouldRender = shouldRender;\\r\\n        } else {\\r\\n            itemsData[i] = prevViewData[processedPos - 1];\\r\\n        }\\r\\n        if(arr[i].ty == 'fl' || arr[i].ty == 'st'|| arr[i].ty == 'gf'|| arr[i].ty == 'gs'){\\r\\n            if(!processedPos){\\r\\n                itemsData[i] = this.createStyleElement(arr[i], ownTransforms);\\r\\n            } else {\\r\\n                itemsData[i].style.closed = false;\\r\\n            }\\r\\n            \\r\\n            ownStyles.push(itemsData[i].style);\\r\\n        }else if(arr[i].ty == 'gr'){\\r\\n            if(!processedPos){\\r\\n                itemsData[i] = this.createGroupElement(arr[i]);\\r\\n            } else {\\r\\n                jLen = itemsData[i].it.length;\\r\\n                for(j=0;j<jLen;j+=1){\\r\\n                    itemsData[i].prevViewData[j] = itemsData[i].it[j];\\r\\n                }\\r\\n            }\\r\\n            this.searchShapes(arr[i].it,itemsData[i].it,itemsData[i].prevViewData, shouldRender, ownTransforms);\\r\\n        }else if(arr[i].ty == 'tr'){\\r\\n            if(!processedPos){\\r\\n                currentTransform = this.createTransformElement(arr[i]);\\r\\n                itemsData[i] = currentTransform;\\r\\n                ownTransforms.push(currentTransform);\\r\\n                this.addTransformToStyleList(currentTransform);\\r\\n            }\\r\\n        }else if(arr[i].ty == 'sh' || arr[i].ty == 'rc' || arr[i].ty == 'el' || arr[i].ty == 'sr'){\\r\\n            if(!processedPos){\\r\\n                itemsData[i] = this.createShapeElement(arr[i]);\\r\\n            }\\r\\n            \\r\\n        }else if(arr[i].ty == 'tm' || arr[i].ty == 'rd'){\\r\\n            if(!processedPos){\\r\\n                modifier = ShapeModifiers.getModifier(arr[i].ty);\\r\\n                modifier.init(this,arr[i]);\\r\\n                itemsData[i] = modifier;\\r\\n                this.shapeModifiers.push(modifier);\\r\\n            } else {\\r\\n                modifier = itemsData[i];\\r\\n                modifier.closed = false;\\r\\n            }\\r\\n            ownModifiers.push(modifier);\\r\\n        } else if(arr[i].ty == 'rp'){\\r\\n            if(!processedPos){\\r\\n                modifier = ShapeModifiers.getModifier(arr[i].ty);\\r\\n                itemsData[i] = modifier;\\r\\n                modifier.init(this,arr,i,itemsData);\\r\\n                this.shapeModifiers.push(modifier);\\r\\n                shouldRender = false;\\r\\n            }else{\\r\\n                modifier = itemsData[i];\\r\\n                modifier.closed = true;\\r\\n            }\\r\\n            ownModifiers.push(modifier);\\r\\n        }\\r\\n        this.addProcessedElement(arr[i], i + 1);\\r\\n    }\\r\\n    this.closeStyles(ownStyles);\\r\\n    len = ownModifiers.length;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        ownModifiers[i].closed = true;\\r\\n    }\\r\\n};\\r\\n\\r\\nCVShapeElement.prototype.renderInnerContent = function() {\\r\\n    this.transformHelper.opacity = 1;\\r\\n    this.transformHelper._opMdf = false;\\r\\n    this.renderModifiers();\\r\\n    this.transformsManager.processSequences(this._isFirstFrame);\\r\\n    this.renderShape(this.transformHelper,this.shapesData,this.itemsData,true);\\r\\n};\\r\\n\\r\\nCVShapeElement.prototype.renderShapeTransform = function(parentTransform, groupTransform) {\\r\\n    var props, groupMatrix;\\r\\n    if(parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {\\r\\n        groupTransform.opacity = parentTransform.opacity;\\r\\n        groupTransform.opacity *= groupTransform.op.v;\\r\\n        groupTransform._opMdf = true;\\r\\n    }\\r\\n};\\r\\n\\r\\nCVShapeElement.prototype.drawLayer = function() {\\r\\n    var i, len = this.stylesList.length;\\r\\n    var j, jLen, k, kLen,elems,nodes, renderer = this.globalData.renderer, ctx = this.globalData.canvasContext, type, currentStyle;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        currentStyle = this.stylesList[i];\\r\\n        type = currentStyle.type;\\r\\n\\r\\n        //Skipping style when\\r\\n        //Stroke width equals 0\\r\\n        //style should not be rendered (extra unused repeaters)\\r\\n        //current opacity equals 0\\r\\n        //global opacity equals 0\\r\\n        if(((type === 'st' || type === 'gs') && currentStyle.wi === 0) || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0){\\r\\n            continue;\\r\\n        }\\r\\n        renderer.save();\\r\\n        elems = currentStyle.elements;\\r\\n        if(type === 'st' || type === 'gs'){\\r\\n            ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;\\r\\n            ctx.lineWidth = currentStyle.wi;\\r\\n            ctx.lineCap = currentStyle.lc;\\r\\n            ctx.lineJoin = currentStyle.lj;\\r\\n            ctx.miterLimit = currentStyle.ml || 0;\\r\\n        } else {\\r\\n            ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;\\r\\n        }\\r\\n        renderer.ctxOpacity(currentStyle.coOp);\\r\\n        if(type !== 'st' && type !== 'gs'){\\r\\n            ctx.beginPath();\\r\\n        }\\r\\n        renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);\\r\\n        jLen = elems.length;\\r\\n        for(j=0;j<jLen;j+=1){\\r\\n            if(type === 'st' || type === 'gs'){\\r\\n                ctx.beginPath();\\r\\n                if(currentStyle.da){\\r\\n                    ctx.setLineDash(currentStyle.da);\\r\\n                    ctx.lineDashOffset = currentStyle.do;\\r\\n                }\\r\\n            }\\r\\n            nodes = elems[j].trNodes;\\r\\n            kLen = nodes.length;\\r\\n\\r\\n            for(k=0;k<kLen;k+=1){\\r\\n                if(nodes[k].t == 'm'){\\r\\n                    ctx.moveTo(nodes[k].p[0],nodes[k].p[1]);\\r\\n                }else if(nodes[k].t == 'c'){\\r\\n                    ctx.bezierCurveTo(nodes[k].pts[0],nodes[k].pts[1],nodes[k].pts[2],nodes[k].pts[3],nodes[k].pts[4],nodes[k].pts[5]);\\r\\n                }else{\\r\\n                    ctx.closePath();\\r\\n                }\\r\\n            }\\r\\n            if(type === 'st' || type === 'gs'){\\r\\n                ctx.stroke();\\r\\n                if(currentStyle.da){\\r\\n                    ctx.setLineDash(this.dashResetter);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if(type !== 'st' && type !== 'gs'){\\r\\n            ctx.fill(currentStyle.r);\\r\\n        }\\r\\n        renderer.restore();\\r\\n    }\\r\\n};\\r\\n\\r\\nCVShapeElement.prototype.renderShape = function(parentTransform,items,data,isMain){\\r\\n    var i, len = items.length - 1;\\r\\n    var groupTransform;\\r\\n    groupTransform = parentTransform;\\r\\n    for(i=len;i>=0;i-=1){\\r\\n        if(items[i].ty == 'tr'){\\r\\n            groupTransform = data[i].transform;\\r\\n            this.renderShapeTransform(parentTransform, groupTransform);\\r\\n        }else if(items[i].ty == 'sh' || items[i].ty == 'el' || items[i].ty == 'rc' || items[i].ty == 'sr'){\\r\\n            this.renderPath(items[i],data[i],groupTransform);\\r\\n        }else if(items[i].ty == 'fl'){\\r\\n            this.renderFill(items[i],data[i],groupTransform);\\r\\n        }else if(items[i].ty == 'st'){\\r\\n            this.renderStroke(items[i],data[i],groupTransform);\\r\\n        }else if(items[i].ty == 'gf' || items[i].ty == 'gs'){\\r\\n            this.renderGradientFill(items[i],data[i],groupTransform);\\r\\n        }else if(items[i].ty == 'gr'){\\r\\n            this.renderShape(groupTransform,items[i].it,data[i].it);\\r\\n        }else if(items[i].ty == 'tm'){\\r\\n            //\\r\\n        }\\r\\n    }\\r\\n    if(isMain){\\r\\n        this.drawLayer();\\r\\n    }\\r\\n    \\r\\n};\\r\\n\\r\\nCVShapeElement.prototype.renderStyledShape = function(styledShape, shape){\\r\\n    if(this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {\\r\\n        var shapeNodes = styledShape.trNodes;\\r\\n        var paths = shape.paths;\\r\\n        var i, len, j, jLen = paths._length;\\r\\n        shapeNodes.length = 0;\\r\\n        var groupTransformMat = styledShape.transforms.finalTransform;\\r\\n        for (j = 0; j < jLen; j += 1) {\\r\\n            var pathNodes = paths.shapes[j];\\r\\n            if(pathNodes && pathNodes.v){\\r\\n                len = pathNodes._length;\\r\\n                for (i = 1; i < len; i += 1) {\\r\\n                    if (i === 1) {\\r\\n                        shapeNodes.push({\\r\\n                            t: 'm',\\r\\n                            p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)\\r\\n                        });\\r\\n                    }\\r\\n                    shapeNodes.push({\\r\\n                        t: 'c',\\r\\n                        pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])\\r\\n                    });\\r\\n                }\\r\\n                if (len === 1) {\\r\\n                    shapeNodes.push({\\r\\n                        t: 'm',\\r\\n                        p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)\\r\\n                    });\\r\\n                }\\r\\n                if (pathNodes.c && len) {\\r\\n                    shapeNodes.push({\\r\\n                        t: 'c',\\r\\n                        pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])\\r\\n                    });\\r\\n                    shapeNodes.push({\\r\\n                        t: 'z'\\r\\n                    });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        styledShape.trNodes = shapeNodes;\\r\\n    }\\r\\n}\\r\\n\\r\\nCVShapeElement.prototype.renderPath = function(pathData,itemData,groupTransform){\\r\\n    if(pathData.hd !== true && pathData._shouldRender) {\\r\\n        var i, len = itemData.styledShapes.length;\\r\\n        for (i = 0; i < len; i += 1) {\\r\\n            this.renderStyledShape(itemData.styledShapes[i], itemData.sh);\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nCVShapeElement.prototype.renderFill = function(styleData,itemData, groupTransform){\\r\\n    var styleElem = itemData.style;\\r\\n\\r\\n    if (itemData.c._mdf || this._isFirstFrame) {\\r\\n        styleElem.co = 'rgb(' \\r\\n        + bm_floor(itemData.c.v[0]) + ',' \\r\\n        + bm_floor(itemData.c.v[1]) + ',' \\r\\n        + bm_floor(itemData.c.v[2]) + ')';\\r\\n    }\\r\\n    if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {\\r\\n        styleElem.coOp = itemData.o.v * groupTransform.opacity;\\r\\n    }\\r\\n};\\r\\n\\r\\nCVShapeElement.prototype.renderGradientFill = function(styleData,itemData, groupTransform){\\r\\n    var styleElem = itemData.style;\\r\\n    if(!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || (styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf))) {\\r\\n        var ctx = this.globalData.canvasContext;\\r\\n        var grd;\\r\\n        var pt1 = itemData.s.v, pt2 = itemData.e.v;\\r\\n        if (styleData.t === 1) {\\r\\n            grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);\\r\\n        } else {\\r\\n            var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\\r\\n            var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);\\r\\n\\r\\n            var percent = itemData.h.v >= 1 ? 0.99 : itemData.h.v <= -1 ? -0.99: itemData.h.v;\\r\\n            var dist = rad * percent;\\r\\n            var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];\\r\\n            var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];\\r\\n            var grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);\\r\\n        }\\r\\n\\r\\n        var i, len = styleData.g.p;\\r\\n        var cValues = itemData.g.c;\\r\\n        var opacity = 1;\\r\\n\\r\\n        for (i = 0; i < len; i += 1){\\r\\n            if(itemData.g._hasOpacity && itemData.g._collapsable) {\\r\\n                opacity = itemData.g.o[i*2 + 1];\\r\\n            }\\r\\n            grd.addColorStop(cValues[i * 4] / 100,'rgba('+ cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ','+cValues[i * 4 + 3] + ',' + opacity + ')');\\r\\n        }\\r\\n        styleElem.grd = grd;\\r\\n    }\\r\\n    styleElem.coOp = itemData.o.v*groupTransform.opacity;\\r\\n    \\r\\n};\\r\\n\\r\\nCVShapeElement.prototype.renderStroke = function(styleData,itemData, groupTransform){\\r\\n    var styleElem = itemData.style;\\r\\n    var d = itemData.d;\\r\\n    if(d && (d._mdf  || this._isFirstFrame)){\\r\\n        styleElem.da = d.dashArray;\\r\\n        styleElem.do = d.dashoffset[0];\\r\\n    }\\r\\n    if(itemData.c._mdf || this._isFirstFrame){\\r\\n        styleElem.co = 'rgb('+bm_floor(itemData.c.v[0])+','+bm_floor(itemData.c.v[1])+','+bm_floor(itemData.c.v[2])+')';\\r\\n    }\\r\\n    if(itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame){\\r\\n        styleElem.coOp = itemData.o.v*groupTransform.opacity;\\r\\n    }\\r\\n    if(itemData.w._mdf || this._isFirstFrame){\\r\\n        styleElem.wi = itemData.w.v;\\r\\n    }\\r\\n};\\r\\n\\r\\n\\r\\nCVShapeElement.prototype.destroy = function(){\\r\\n    this.shapesData = null;\\r\\n    this.globalData = null;\\r\\n    this.canvasContext = null;\\r\\n    this.stylesList.length = 0;\\r\\n    this.itemsData.length = 0;\\r\\n};\\r\\n\\r\\n\\nfunction CVSolidElement(data, globalData, comp) {\\r\\n    this.initElement(data,globalData,comp);\\r\\n}\\r\\nextendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);\\r\\n\\r\\nCVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;\\r\\nCVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;\\r\\n\\r\\nCVSolidElement.prototype.renderInnerContent = function() {\\r\\n    var ctx = this.canvasContext;\\r\\n    ctx.fillStyle = this.data.sc;\\r\\n    ctx.fillRect(0, 0, this.data.sw, this.data.sh);\\r\\n    //\\r\\n};\\nfunction CVTextElement(data, globalData, comp){\\r\\n    this.textSpans = [];\\r\\n    this.yOffset = 0;\\r\\n    this.fillColorAnim = false;\\r\\n    this.strokeColorAnim = false;\\r\\n    this.strokeWidthAnim = false;\\r\\n    this.stroke = false;\\r\\n    this.fill = false;\\r\\n    this.justifyOffset = 0;\\r\\n    this.currentRender = null;\\r\\n    this.renderType = 'canvas';\\r\\n    this.values = {\\r\\n        fill: 'rgba(0,0,0,0)',\\r\\n        stroke: 'rgba(0,0,0,0)',\\r\\n        sWidth: 0,\\r\\n        fValue: ''\\r\\n    };\\r\\n    this.initElement(data,globalData,comp);\\r\\n}\\r\\nextendPrototype([BaseElement,TransformElement,CVBaseElement,HierarchyElement,FrameElement,RenderableElement,ITextElement], CVTextElement);\\r\\n\\r\\nCVTextElement.prototype.tHelper = createTag('canvas').getContext('2d');\\r\\n\\r\\nCVTextElement.prototype.buildNewText = function(){\\r\\n    var documentData = this.textProperty.currentData;\\r\\n    this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);\\r\\n\\r\\n    var hasFill = false;\\r\\n    if(documentData.fc) {\\r\\n        hasFill = true;\\r\\n        this.values.fill = this.buildColor(documentData.fc);\\r\\n    }else{\\r\\n        this.values.fill = 'rgba(0,0,0,0)';\\r\\n    }\\r\\n    this.fill = hasFill;\\r\\n    var hasStroke = false;\\r\\n    if(documentData.sc){\\r\\n        hasStroke = true;\\r\\n        this.values.stroke = this.buildColor(documentData.sc);\\r\\n        this.values.sWidth = documentData.sw;\\r\\n    }\\r\\n    var fontData = this.globalData.fontManager.getFontByName(documentData.f);\\r\\n    var i, len;\\r\\n    var letters = documentData.l;\\r\\n    var matrixHelper = this.mHelper;\\r\\n    this.stroke = hasStroke;\\r\\n    this.values.fValue = documentData.finalSize + 'px '+ this.globalData.fontManager.getFontByName(documentData.f).fFamily;\\r\\n    len = documentData.finalText.length;\\r\\n    //this.tHelper.font = this.values.fValue;\\r\\n    var charData, shapeData, k, kLen, shapes, j, jLen, pathNodes, commands, pathArr, singleShape = this.data.singleShape;\\r\\n    var trackingOffset = documentData.tr/1000*documentData.finalSize;\\r\\n    var xPos = 0, yPos = 0, firstLine = true;\\r\\n    var cnt = 0;\\r\\n    for (i = 0; i < len; i += 1) {\\r\\n        charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\\r\\n        shapeData = charData && charData.data || {};\\r\\n        matrixHelper.reset();\\r\\n        if(singleShape && letters[i].n) {\\r\\n            xPos = -trackingOffset;\\r\\n            yPos += documentData.yOffset;\\r\\n            yPos += firstLine ? 1 : 0;\\r\\n            firstLine = false;\\r\\n        }\\r\\n\\r\\n        shapes = shapeData.shapes ? shapeData.shapes[0].it : [];\\r\\n        jLen = shapes.length;\\r\\n        matrixHelper.scale(documentData.finalSize/100,documentData.finalSize/100);\\r\\n        if(singleShape){\\r\\n            this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);\\r\\n        }\\r\\n        commands = createSizedArray(jLen);\\r\\n        for(j=0;j<jLen;j+=1){\\r\\n            kLen = shapes[j].ks.k.i.length;\\r\\n            pathNodes = shapes[j].ks.k;\\r\\n            pathArr = [];\\r\\n            for(k=1;k<kLen;k+=1){\\r\\n                if(k==1){\\r\\n                    pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0],pathNodes.v[0][1],0),matrixHelper.applyToY(pathNodes.v[0][0],pathNodes.v[0][1],0));\\r\\n                }\\r\\n                pathArr.push(matrixHelper.applyToX(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToY(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToX(pathNodes.i[k][0],pathNodes.i[k][1],0),matrixHelper.applyToY(pathNodes.i[k][0],pathNodes.i[k][1],0),matrixHelper.applyToX(pathNodes.v[k][0],pathNodes.v[k][1],0),matrixHelper.applyToY(pathNodes.v[k][0],pathNodes.v[k][1],0));\\r\\n            }\\r\\n            pathArr.push(matrixHelper.applyToX(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToY(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToX(pathNodes.i[0][0],pathNodes.i[0][1],0),matrixHelper.applyToY(pathNodes.i[0][0],pathNodes.i[0][1],0),matrixHelper.applyToX(pathNodes.v[0][0],pathNodes.v[0][1],0),matrixHelper.applyToY(pathNodes.v[0][0],pathNodes.v[0][1],0));\\r\\n            commands[j] = pathArr;\\r\\n        }\\r\\n        if(singleShape){\\r\\n            xPos += letters[i].l;\\r\\n            xPos += trackingOffset;\\r\\n        }\\r\\n        if(this.textSpans[cnt]){\\r\\n            this.textSpans[cnt].elem = commands;\\r\\n        } else {\\r\\n            this.textSpans[cnt] = {elem: commands};\\r\\n        }\\r\\n        cnt +=1;\\r\\n    }\\r\\n};\\r\\n\\r\\nCVTextElement.prototype.renderInnerContent = function(){\\r\\n    var ctx = this.canvasContext;\\r\\n    var finalMat = this.finalTransform.mat.props;\\r\\n    ctx.font = this.values.fValue;\\r\\n    ctx.lineCap = 'butt';\\r\\n    ctx.lineJoin = 'miter';\\r\\n    ctx.miterLimit = 4;\\r\\n\\r\\n    if(!this.data.singleShape){\\r\\n        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\\r\\n    }\\r\\n\\r\\n    var  i,len, j, jLen, k, kLen;\\r\\n    var renderedLetters = this.textAnimator.renderedLetters;\\r\\n\\r\\n    var letters = this.textProperty.currentData.l;\\r\\n\\r\\n    len = letters.length;\\r\\n    var renderedLetter;\\r\\n    var lastFill = null, lastStroke = null, lastStrokeW = null, commands, pathArr;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        if(letters[i].n){\\r\\n            continue;\\r\\n        }\\r\\n        renderedLetter = renderedLetters[i];\\r\\n        if(renderedLetter){\\r\\n            this.globalData.renderer.save();\\r\\n            this.globalData.renderer.ctxTransform(renderedLetter.p);\\r\\n            this.globalData.renderer.ctxOpacity(renderedLetter.o);\\r\\n        }\\r\\n        if(this.fill){\\r\\n            if(renderedLetter && renderedLetter.fc){\\r\\n                if(lastFill !== renderedLetter.fc){\\r\\n                    lastFill = renderedLetter.fc;\\r\\n                    ctx.fillStyle = renderedLetter.fc;\\r\\n                }\\r\\n            }else if(lastFill !== this.values.fill){\\r\\n                lastFill = this.values.fill;\\r\\n                ctx.fillStyle = this.values.fill;\\r\\n            }\\r\\n            commands = this.textSpans[i].elem;\\r\\n            jLen = commands.length;\\r\\n            this.globalData.canvasContext.beginPath();\\r\\n            for(j=0;j<jLen;j+=1) {\\r\\n                pathArr = commands[j];\\r\\n                kLen = pathArr.length;\\r\\n                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);\\r\\n                for (k = 2; k < kLen; k += 6) {\\r\\n                    this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);\\r\\n                }\\r\\n            }\\r\\n            this.globalData.canvasContext.closePath();\\r\\n            this.globalData.canvasContext.fill();\\r\\n            ///ctx.fillText(this.textSpans[i].val,0,0);\\r\\n        }\\r\\n        if(this.stroke){\\r\\n            if(renderedLetter && renderedLetter.sw){\\r\\n                if(lastStrokeW !== renderedLetter.sw){\\r\\n                    lastStrokeW = renderedLetter.sw;\\r\\n                    ctx.lineWidth = renderedLetter.sw;\\r\\n                }\\r\\n            }else if(lastStrokeW !== this.values.sWidth){\\r\\n                lastStrokeW = this.values.sWidth;\\r\\n                ctx.lineWidth = this.values.sWidth;\\r\\n            }\\r\\n            if(renderedLetter && renderedLetter.sc){\\r\\n                if(lastStroke !== renderedLetter.sc){\\r\\n                    lastStroke = renderedLetter.sc;\\r\\n                    ctx.strokeStyle = renderedLetter.sc;\\r\\n                }\\r\\n            }else if(lastStroke !== this.values.stroke){\\r\\n                lastStroke = this.values.stroke;\\r\\n                ctx.strokeStyle = this.values.stroke;\\r\\n            }\\r\\n            commands = this.textSpans[i].elem;\\r\\n            jLen = commands.length;\\r\\n            this.globalData.canvasContext.beginPath();\\r\\n            for(j=0;j<jLen;j+=1) {\\r\\n                pathArr = commands[j];\\r\\n                kLen = pathArr.length;\\r\\n                this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);\\r\\n                for (k = 2; k < kLen; k += 6) {\\r\\n                    this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);\\r\\n                }\\r\\n            }\\r\\n            this.globalData.canvasContext.closePath();\\r\\n            this.globalData.canvasContext.stroke();\\r\\n            ///ctx.strokeText(letters[i].val,0,0);\\r\\n        }\\r\\n        if(renderedLetter) {\\r\\n            this.globalData.renderer.restore();\\r\\n        }\\r\\n    }\\r\\n};\\nfunction CVEffects() {\\r\\n\\r\\n}\\r\\nCVEffects.prototype.renderFrame = function(){};\\nfunction HBaseElement(data,globalData,comp){}\\r\\nHBaseElement.prototype = {\\r\\n    checkBlendMode: function(){},\\r\\n    initRendererElement: function(){\\r\\n        this.baseElement = createTag(this.data.tg || 'div');\\r\\n        if(this.data.hasMask) {\\r\\n            this.svgElement = createNS('svg');\\r\\n            this.layerElement = createNS('g');\\r\\n            this.maskedElement = this.layerElement;\\r\\n            this.svgElement.appendChild(this.layerElement);\\r\\n            this.baseElement.appendChild(this.svgElement);\\r\\n        } else {\\r\\n            this.layerElement = this.baseElement;\\r\\n        }\\r\\n        styleDiv(this.baseElement);\\r\\n    },\\r\\n    createContainerElements: function(){\\r\\n        this.renderableEffectsManager = new CVEffects(this);\\r\\n        this.transformedElement = this.baseElement;\\r\\n        this.maskedElement = this.layerElement;\\r\\n        if (this.data.ln) {\\r\\n            this.layerElement.setAttribute('id',this.data.ln);\\r\\n        }\\r\\n        if (this.data.cl) {\\r\\n            this.layerElement.setAttribute('class', this.data.cl);\\r\\n        }\\r\\n        if (this.data.bm !== 0) {\\r\\n            this.setBlendMode();\\r\\n        }\\r\\n    },\\r\\n    renderElement: function() {\\r\\n        if(this.finalTransform._matMdf){\\r\\n            this.transformedElement.style.transform = this.transformedElement.style.webkitTransform = this.finalTransform.mat.toCSS();\\r\\n        }\\r\\n        if(this.finalTransform._opMdf){\\r\\n            this.transformedElement.style.opacity = this.finalTransform.mProp.o.v;\\r\\n        }\\r\\n    },\\r\\n    renderFrame: function() {\\r\\n        //If it is exported as hidden (data.hd === true) no need to render\\r\\n        //If it is not visible no need to render\\r\\n        if (this.data.hd || this.hidden) {\\r\\n            return;\\r\\n        }\\r\\n        this.renderTransform();\\r\\n        this.renderRenderable();\\r\\n        this.renderElement();\\r\\n        this.renderInnerContent();\\r\\n        if (this._isFirstFrame) {\\r\\n            this._isFirstFrame = false;\\r\\n        }\\r\\n    },\\r\\n    destroy: function(){\\r\\n        this.layerElement = null;\\r\\n        this.transformedElement = null;\\r\\n        if(this.matteElement) {\\r\\n            this.matteElement = null;\\r\\n        }\\r\\n        if(this.maskManager) {\\r\\n            this.maskManager.destroy();\\r\\n            this.maskManager = null;\\r\\n        }\\r\\n    },\\r\\n    createRenderableComponents: function(){\\r\\n        this.maskManager = new MaskElement(this.data, this, this.globalData);\\r\\n    },\\r\\n    addEffects: function(){\\r\\n    },\\r\\n    setMatte: function(){}\\r\\n};\\r\\nHBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;\\r\\nHBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;\\r\\nHBaseElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting;\\nfunction HSolidElement(data,globalData,comp){\\r\\n    this.initElement(data,globalData,comp);\\r\\n}\\r\\nextendPrototype([BaseElement,TransformElement,HBaseElement,HierarchyElement,FrameElement,RenderableDOMElement], HSolidElement);\\r\\n\\r\\nHSolidElement.prototype.createContent = function(){\\r\\n    var rect;\\r\\n    if(this.data.hasMask){\\r\\n        rect = createNS('rect');\\r\\n        rect.setAttribute('width',this.data.sw);\\r\\n        rect.setAttribute('height',this.data.sh);\\r\\n        rect.setAttribute('fill',this.data.sc);\\r\\n        this.svgElement.setAttribute('width',this.data.sw);\\r\\n        this.svgElement.setAttribute('height',this.data.sh);\\r\\n    } else {\\r\\n        rect = createTag('div');\\r\\n        rect.style.width = this.data.sw + 'px';\\r\\n        rect.style.height = this.data.sh + 'px';\\r\\n        rect.style.backgroundColor = this.data.sc;\\r\\n    }\\r\\n    this.layerElement.appendChild(rect);\\r\\n};\\r\\n\\nfunction HCompElement(data,globalData,comp){\\r\\n    this.layers = data.layers;\\r\\n    this.supports3d = !data.hasMask;\\r\\n    this.completeLayers = false;\\r\\n    this.pendingElements = [];\\r\\n    this.elements = this.layers ? createSizedArray(this.layers.length) : [];\\r\\n    this.initElement(data,globalData,comp);\\r\\n    this.tm = data.tm ? PropertyFactory.getProp(this,data.tm,0,globalData.frameRate,this) : {_placeholder:true};\\r\\n}\\r\\n\\r\\nextendPrototype([HybridRenderer, ICompElement, HBaseElement], HCompElement);\\r\\nHCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;\\r\\n\\r\\nHCompElement.prototype.createContainerElements = function(){\\r\\n    this._createBaseContainerElements();\\r\\n    //divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';\\r\\n    if(this.data.hasMask){\\r\\n        this.svgElement.setAttribute('width',this.data.w);\\r\\n        this.svgElement.setAttribute('height',this.data.h);\\r\\n        this.transformedElement = this.baseElement;\\r\\n    } else {\\r\\n        this.transformedElement = this.layerElement;\\r\\n    }\\r\\n};\\r\\n\\r\\nHCompElement.prototype.addTo3dContainer = function(elem,pos) {\\r\\n    var j = 0;\\r\\n    var nextElement;\\r\\n    while(j<pos){\\r\\n        if(this.elements[j] && this.elements[j].getBaseElement){\\r\\n            nextElement = this.elements[j].getBaseElement();\\r\\n        }\\r\\n        j += 1;\\r\\n    }\\r\\n    if(nextElement){\\r\\n        this.layerElement.insertBefore(elem, nextElement);\\r\\n    } else {\\r\\n        this.layerElement.appendChild(elem);\\r\\n    }\\r\\n}\\r\\n\\nfunction HShapeElement(data,globalData,comp){\\r\\n    //List of drawable elements\\r\\n    this.shapes = [];\\r\\n    // Full shape data\\r\\n    this.shapesData = data.shapes;\\r\\n    //List of styles that will be applied to shapes\\r\\n    this.stylesList = [];\\r\\n    //List of modifiers that will be applied to shapes\\r\\n    this.shapeModifiers = [];\\r\\n    //List of items in shape tree\\r\\n    this.itemsData = [];\\r\\n    //List of items in previous shape tree\\r\\n    this.processedElements = [];\\r\\n    // List of animated components\\r\\n    this.animatedContents = [];\\r\\n    this.shapesContainer = createNS('g');\\r\\n    this.initElement(data,globalData,comp);\\r\\n    //Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\\r\\n    // List of elements that have been created\\r\\n    this.prevViewData = [];\\r\\n    this.currentBBox = {\\r\\n        x:999999,\\r\\n        y: -999999,\\r\\n        h: 0,\\r\\n        w: 0\\r\\n    };\\r\\n}\\r\\nextendPrototype([BaseElement,TransformElement,HSolidElement,SVGShapeElement,HBaseElement,HierarchyElement,FrameElement,RenderableElement], HShapeElement);\\r\\nHShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;\\r\\n\\r\\nHShapeElement.prototype.createContent = function(){\\r\\n    var cont;\\r\\n    this.baseElement.style.fontSize = 0;\\r\\n    if (this.data.hasMask) {\\r\\n        this.layerElement.appendChild(this.shapesContainer);\\r\\n        cont = this.svgElement;\\r\\n    } else {\\r\\n        cont = createNS('svg');\\r\\n        var size = this.comp.data ? this.comp.data : this.globalData.compSize;\\r\\n        cont.setAttribute('width',size.w);\\r\\n        cont.setAttribute('height',size.h);\\r\\n        cont.appendChild(this.shapesContainer);\\r\\n        this.layerElement.appendChild(cont);\\r\\n    }\\r\\n\\r\\n    this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,this.shapesContainer,0, [], true);\\r\\n    this.filterUniqueShapes();\\r\\n    this.shapeCont = cont;\\r\\n};\\r\\n\\r\\nHShapeElement.prototype.getTransformedPoint = function(transformers, point) {\\r\\n    var i, len = transformers.length;\\r\\n    for(i = 0; i < len; i += 1) {\\r\\n        point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);\\r\\n    }\\r\\n    return point;\\r\\n}\\r\\n\\r\\nHShapeElement.prototype.calculateShapeBoundingBox = function(item, boundingBox) {\\r\\n    var shape = item.sh.v;\\r\\n    var transformers = item.transformers;\\r\\n    var i, len = shape._length, vPoint, oPoint, nextIPoint, nextVPoint, bounds;\\r\\n    if (len <= 1) {\\r\\n        return;\\r\\n    }\\r\\n    for (i = 0; i < len - 1; i += 1) {\\r\\n        vPoint = this.getTransformedPoint(transformers, shape.v[i]);\\r\\n        oPoint = this.getTransformedPoint(transformers, shape.o[i]);\\r\\n        nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);\\r\\n        nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);\\r\\n        this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);\\r\\n    }\\r\\n    if(shape.c) {\\r\\n        vPoint = this.getTransformedPoint(transformers, shape.v[i]);\\r\\n        oPoint = this.getTransformedPoint(transformers, shape.o[i]);\\r\\n        nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);\\r\\n        nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);\\r\\n        this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);\\r\\n    }\\r\\n}\\r\\n\\r\\nHShapeElement.prototype.checkBounds = function(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {\\r\\n    this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);\\r\\n    var bounds = this.shapeBoundingBox;\\r\\n    boundingBox.x = bm_min(bounds.left, boundingBox.x);\\r\\n    boundingBox.xMax = bm_max(bounds.right, boundingBox.xMax);\\r\\n    boundingBox.y = bm_min(bounds.top, boundingBox.y);\\r\\n    boundingBox.yMax = bm_max(bounds.bottom, boundingBox.yMax);\\r\\n}\\r\\n\\r\\nHShapeElement.prototype.shapeBoundingBox = {\\r\\n    left:0,\\r\\n    right:0,\\r\\n    top:0,\\r\\n    bottom:0,\\r\\n}\\r\\n\\r\\nHShapeElement.prototype.tempBoundingBox = {\\r\\n    x:0,\\r\\n    xMax:0,\\r\\n    y:0,\\r\\n    yMax:0,\\r\\n    width:0,\\r\\n    height:0\\r\\n}\\r\\n\\r\\nHShapeElement.prototype.getBoundsOfCurve = function(p0, p1, p2, p3) {\\r\\n\\r\\n    var bounds = [[p0[0],p3[0]], [p0[1],p3[1]]];\\r\\n\\r\\n    for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) {\\r\\n\\r\\n      b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\\r\\n      a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\\r\\n      c = 3 * p1[i] - 3 * p0[i];\\r\\n\\r\\n      b = b | 0;\\r\\n      a = a | 0;\\r\\n      c = c | 0;\\r\\n\\r\\n      if (a === 0) {\\r\\n\\r\\n        if (b === 0) {\\r\\n          continue;\\r\\n        }\\r\\n\\r\\n        t = -c / b;\\r\\n\\r\\n        if (0 < t && t < 1) {\\r\\n          bounds[i].push(this.calculateF(t,p0,p1,p2,p3,i));\\r\\n        }\\r\\n        continue;\\r\\n      }\\r\\n\\r\\n      b2ac = b * b - 4 * c * a;\\r\\n\\r\\n      if (b2ac < 0) {\\r\\n        continue;\\r\\n      }\\r\\n\\r\\n      t1 = (-b + bm_sqrt(b2ac))/(2 * a);\\r\\n      if (0 < t1 && t1 < 1) bounds[i].push(this.calculateF(t1,p0,p1,p2,p3,i));\\r\\n\\r\\n      t2 = (-b - bm_sqrt(b2ac))/(2 * a);\\r\\n      if (0 < t2 && t2 < 1) bounds[i].push(this.calculateF(t2,p0,p1,p2,p3,i));\\r\\n\\r\\n    }\\r\\n\\r\\n    this.shapeBoundingBox.left = bm_min.apply(null, bounds[0]);\\r\\n    this.shapeBoundingBox.top = bm_min.apply(null, bounds[1]);\\r\\n    this.shapeBoundingBox.right = bm_max.apply(null, bounds[0]);\\r\\n    this.shapeBoundingBox.bottom = bm_max.apply(null, bounds[1]);\\r\\n  };\\r\\n\\r\\n  HShapeElement.prototype.calculateF = function(t, p0, p1, p2, p3, i) {\\r\\n    return bm_pow(1-t, 3) * p0[i]\\r\\n        + 3 * bm_pow(1-t, 2) * t * p1[i]\\r\\n        + 3 * (1-t) * bm_pow(t, 2) * p2[i]\\r\\n        + bm_pow(t, 3) * p3[i];\\r\\n  }\\r\\n\\r\\nHShapeElement.prototype.calculateBoundingBox = function(itemsData, boundingBox) {\\r\\n    var i, len = itemsData.length, path;\\r\\n    for(i = 0; i < len; i += 1) {\\r\\n        if(itemsData[i] && itemsData[i].sh) {\\r\\n            this.calculateShapeBoundingBox(itemsData[i], boundingBox)\\r\\n        } else if(itemsData[i] && itemsData[i].it) {\\r\\n            this.calculateBoundingBox(itemsData[i].it, boundingBox)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nHShapeElement.prototype.currentBoxContains = function(box) {\\r\\n    return this.currentBBox.x <= box.x \\r\\n    && this.currentBBox.y <= box.y \\r\\n    && this.currentBBox.width + this.currentBBox.x >= box.x + box.width\\r\\n    && this.currentBBox.height + this.currentBBox.y >= box.y + box.height\\r\\n}\\r\\n\\r\\nHShapeElement.prototype.renderInnerContent = function() {\\r\\n    this._renderShapeFrame();\\r\\n\\r\\n    if(!this.hidden && (this._isFirstFrame || this._mdf)) {\\r\\n        var tempBoundingBox = this.tempBoundingBox;\\r\\n        var max = 999999;\\r\\n        tempBoundingBox.x = max;\\r\\n        tempBoundingBox.xMax = -max;\\r\\n        tempBoundingBox.y = max;\\r\\n        tempBoundingBox.yMax = -max;\\r\\n        this.calculateBoundingBox(this.itemsData, tempBoundingBox);\\r\\n        tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;\\r\\n        tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;\\r\\n        //var tempBoundingBox = this.shapeCont.getBBox();\\r\\n        if(this.currentBoxContains(tempBoundingBox)) {\\r\\n            return;\\r\\n        }\\r\\n        var changed = false;\\r\\n        if(this.currentBBox.w !== tempBoundingBox.width){\\r\\n            this.currentBBox.w = tempBoundingBox.width;\\r\\n            this.shapeCont.setAttribute('width',tempBoundingBox.width);\\r\\n            changed = true;\\r\\n        }\\r\\n        if(this.currentBBox.h !== tempBoundingBox.height){\\r\\n            this.currentBBox.h = tempBoundingBox.height;\\r\\n            this.shapeCont.setAttribute('height',tempBoundingBox.height);\\r\\n            changed = true;\\r\\n        }\\r\\n        if(changed  || this.currentBBox.x !== tempBoundingBox.x  || this.currentBBox.y !== tempBoundingBox.y){\\r\\n            this.currentBBox.w = tempBoundingBox.width;\\r\\n            this.currentBBox.h = tempBoundingBox.height;\\r\\n            this.currentBBox.x = tempBoundingBox.x;\\r\\n            this.currentBBox.y = tempBoundingBox.y;\\r\\n\\r\\n            this.shapeCont.setAttribute('viewBox',this.currentBBox.x+' '+this.currentBBox.y+' '+this.currentBBox.w+' '+this.currentBBox.h);\\r\\n            this.shapeCont.style.transform = this.shapeCont.style.webkitTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';\\r\\n        }\\r\\n    }\\r\\n\\r\\n};\\nfunction HTextElement(data,globalData,comp){\\r\\n    this.textSpans = [];\\r\\n    this.textPaths = [];\\r\\n    this.currentBBox = {\\r\\n        x:999999,\\r\\n        y: -999999,\\r\\n        h: 0,\\r\\n        w: 0\\r\\n    };\\r\\n    this.renderType = 'svg';\\r\\n    this.isMasked = false;\\r\\n    this.initElement(data,globalData,comp);\\r\\n\\r\\n}\\r\\nextendPrototype([BaseElement,TransformElement,HBaseElement,HierarchyElement,FrameElement,RenderableDOMElement,ITextElement], HTextElement);\\r\\n\\r\\nHTextElement.prototype.createContent = function(){\\r\\n    this.isMasked = this.checkMasks();\\r\\n    if(this.isMasked){\\r\\n        this.renderType = 'svg';\\r\\n        this.compW = this.comp.data.w;\\r\\n        this.compH = this.comp.data.h;\\r\\n        this.svgElement.setAttribute('width',this.compW);\\r\\n        this.svgElement.setAttribute('height',this.compH);\\r\\n        var g = createNS('g');\\r\\n        this.maskedElement.appendChild(g);\\r\\n        this.innerElem = g;\\r\\n    } else {\\r\\n        this.renderType = 'html';\\r\\n        this.innerElem = this.layerElement;\\r\\n    }\\r\\n\\r\\n    this.checkParenting();\\r\\n\\r\\n};\\r\\n\\r\\nHTextElement.prototype.buildNewText = function(){\\r\\n    var documentData = this.textProperty.currentData;\\r\\n    this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);\\r\\n    var innerElemStyle = this.innerElem.style;\\r\\n    innerElemStyle.color = innerElemStyle.fill = documentData.fc ? this.buildColor(documentData.fc) : 'rgba(0,0,0,0)';\\r\\n    if(documentData.sc){\\r\\n        innerElemStyle.stroke = this.buildColor(documentData.sc);\\r\\n        innerElemStyle.strokeWidth = documentData.sw+'px';\\r\\n    }\\r\\n    var fontData = this.globalData.fontManager.getFontByName(documentData.f);\\r\\n    if(!this.globalData.fontManager.chars){\\r\\n        innerElemStyle.fontSize = documentData.finalSize+'px';\\r\\n        innerElemStyle.lineHeight = documentData.finalSize+'px';\\r\\n        if(fontData.fClass){\\r\\n            this.innerElem.className = fontData.fClass;\\r\\n        } else {\\r\\n            innerElemStyle.fontFamily = fontData.fFamily;\\r\\n            var fWeight = documentData.fWeight, fStyle = documentData.fStyle;\\r\\n            innerElemStyle.fontStyle = fStyle;\\r\\n            innerElemStyle.fontWeight = fWeight;\\r\\n        }\\r\\n    }\\r\\n    var i, len;\\r\\n\\r\\n    var letters = documentData.l;\\r\\n    len = letters.length;\\r\\n    var tSpan,tParent,tCont;\\r\\n    var matrixHelper = this.mHelper;\\r\\n    var shapes, shapeStr = '';\\r\\n    var cnt = 0;\\r\\n    for (i = 0;i < len ;i += 1) {\\r\\n        if(this.globalData.fontManager.chars){\\r\\n            if(!this.textPaths[cnt]){\\r\\n                tSpan = createNS('path');\\r\\n                tSpan.setAttribute('stroke-linecap', 'butt');\\r\\n                tSpan.setAttribute('stroke-linejoin','round');\\r\\n                tSpan.setAttribute('stroke-miterlimit','4');\\r\\n            } else {\\r\\n                tSpan = this.textPaths[cnt];\\r\\n            }\\r\\n            if(!this.isMasked){\\r\\n                if(this.textSpans[cnt]){\\r\\n                    tParent = this.textSpans[cnt];\\r\\n                    tCont = tParent.children[0];\\r\\n                } else {\\r\\n\\r\\n                    tParent = createTag('div');\\r\\n                    tCont = createNS('svg');\\r\\n                    tCont.appendChild(tSpan);\\r\\n                    styleDiv(tParent);\\r\\n                }\\r\\n            }\\r\\n        }else{\\r\\n            if(!this.isMasked){\\r\\n                if(this.textSpans[cnt]){\\r\\n                    tParent = this.textSpans[cnt];\\r\\n                    tSpan = this.textPaths[cnt];\\r\\n                } else {\\r\\n                    tParent = createTag('span');\\r\\n                    styleDiv(tParent);\\r\\n                    tSpan = createTag('span');\\r\\n                    styleDiv(tSpan);\\r\\n                    tParent.appendChild(tSpan);\\r\\n                }\\r\\n            } else {\\r\\n                tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS('text');\\r\\n            }\\r\\n        }\\r\\n        //tSpan.setAttribute('visibility', 'hidden');\\r\\n        if(this.globalData.fontManager.chars){\\r\\n            var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\\r\\n            var shapeData;\\r\\n            if(charData){\\r\\n                shapeData = charData.data;\\r\\n            } else {\\r\\n                shapeData = null;\\r\\n            }\\r\\n            matrixHelper.reset();\\r\\n            if(shapeData && shapeData.shapes){\\r\\n                shapes = shapeData.shapes[0].it;\\r\\n                matrixHelper.scale(documentData.finalSize/100,documentData.finalSize/100);\\r\\n                shapeStr = this.createPathShape(matrixHelper,shapes);\\r\\n                tSpan.setAttribute('d',shapeStr);\\r\\n            }\\r\\n            if(!this.isMasked){\\r\\n                this.innerElem.appendChild(tParent);\\r\\n                if(shapeData && shapeData.shapes){\\r\\n\\r\\n                    //document.body.appendChild is needed to get exact measure of shape\\r\\n                    document.body.appendChild(tCont);\\r\\n                    var boundingBox = tCont.getBBox();\\r\\n                    tCont.setAttribute('width',boundingBox.width + 2);\\r\\n                    tCont.setAttribute('height',boundingBox.height + 2);\\r\\n                    tCont.setAttribute('viewBox',(boundingBox.x-1)+' '+ (boundingBox.y-1)+' '+ (boundingBox.width+2)+' '+ (boundingBox.height+2));\\r\\n                    tCont.style.transform = tCont.style.webkitTransform = 'translate(' + (boundingBox.x-1) + 'px,' + (boundingBox.y-1) + 'px)';\\r\\n\\r\\n                    letters[i].yOffset = boundingBox.y-1;\\r\\n\\r\\n                } else{\\r\\n                    tCont.setAttribute('width',1);\\r\\n                    tCont.setAttribute('height',1);\\r\\n                }\\r\\n                    tParent.appendChild(tCont);\\r\\n            }else{\\r\\n                this.innerElem.appendChild(tSpan);\\r\\n            }\\r\\n        }else{\\r\\n            tSpan.textContent = letters[i].val;\\r\\n            tSpan.setAttributeNS(\\\"http://www.w3.org/XML/1998/namespace\\\", \\\"xml:space\\\",\\\"preserve\\\");\\r\\n            if(!this.isMasked){\\r\\n                this.innerElem.appendChild(tParent);\\r\\n                //\\r\\n                tSpan.style.transform = tSpan.style.webkitTransform = 'translate3d(0,'+ -documentData.finalSize/1.2+'px,0)';\\r\\n            } else {\\r\\n                this.innerElem.appendChild(tSpan);\\r\\n            }\\r\\n        }\\r\\n        //\\r\\n        if(!this.isMasked){\\r\\n            this.textSpans[cnt] = tParent;\\r\\n        }else{\\r\\n            this.textSpans[cnt] = tSpan;\\r\\n        }\\r\\n        this.textSpans[cnt].style.display = 'block';\\r\\n        this.textPaths[cnt] = tSpan;\\r\\n        cnt += 1;\\r\\n    }\\r\\n    while(cnt < this.textSpans.length){\\r\\n        this.textSpans[cnt].style.display = 'none';\\r\\n        cnt += 1;\\r\\n    }\\r\\n};\\r\\n\\r\\nHTextElement.prototype.renderInnerContent = function() {\\r\\n\\r\\n    if(this.data.singleShape){\\r\\n        if(!this._isFirstFrame && !this.lettersChangedFlag){\\r\\n            return;\\r\\n        } else {\\r\\n            // Todo Benchmark if using this is better than getBBox\\r\\n             if(this.isMasked && this.finalTransform._matMdf){\\r\\n                 this.svgElement.setAttribute('viewBox',-this.finalTransform.mProp.p.v[0]+' '+ -this.finalTransform.mProp.p.v[1]+' '+this.compW+' '+this.compH);\\r\\n                this.svgElement.style.transform = this.svgElement.style.webkitTransform = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';\\r\\n             }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\\r\\n    if(!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag){\\r\\n        return;\\r\\n    }\\r\\n    var  i,len, count = 0;\\r\\n    var renderedLetters = this.textAnimator.renderedLetters;\\r\\n\\r\\n    var letters = this.textProperty.currentData.l;\\r\\n\\r\\n    len = letters.length;\\r\\n    var renderedLetter, textSpan, textPath;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        if(letters[i].n){\\r\\n            count += 1;\\r\\n            continue;\\r\\n        }\\r\\n        textSpan = this.textSpans[i];\\r\\n        textPath = this.textPaths[i];\\r\\n        renderedLetter = renderedLetters[count];\\r\\n        count += 1;\\r\\n        if(renderedLetter._mdf.m) {\\r\\n            if(!this.isMasked){\\r\\n                textSpan.style.transform = textSpan.style.webkitTransform = renderedLetter.m;\\r\\n            }else{\\r\\n                textSpan.setAttribute('transform',renderedLetter.m);\\r\\n            }\\r\\n        }\\r\\n        ////textSpan.setAttribute('opacity',renderedLetter.o);\\r\\n        textSpan.style.opacity = renderedLetter.o;\\r\\n        if(renderedLetter.sw && renderedLetter._mdf.sw){\\r\\n            textPath.setAttribute('stroke-width',renderedLetter.sw);\\r\\n        }\\r\\n        if(renderedLetter.sc && renderedLetter._mdf.sc){\\r\\n            textPath.setAttribute('stroke',renderedLetter.sc);\\r\\n        }\\r\\n        if(renderedLetter.fc && renderedLetter._mdf.fc){\\r\\n            textPath.setAttribute('fill',renderedLetter.fc);\\r\\n            textPath.style.color = renderedLetter.fc;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    if(this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)){\\r\\n        var boundingBox = this.innerElem.getBBox();\\r\\n\\r\\n        if(this.currentBBox.w !== boundingBox.width){\\r\\n            this.currentBBox.w = boundingBox.width;\\r\\n            this.svgElement.setAttribute('width',boundingBox.width);\\r\\n        }\\r\\n        if(this.currentBBox.h !== boundingBox.height){\\r\\n            this.currentBBox.h = boundingBox.height;\\r\\n            this.svgElement.setAttribute('height',boundingBox.height);\\r\\n        }\\r\\n\\r\\n        var margin = 1;\\r\\n        if(this.currentBBox.w !== (boundingBox.width + margin*2) || this.currentBBox.h !== (boundingBox.height + margin*2)  || this.currentBBox.x !== (boundingBox.x - margin)  || this.currentBBox.y !== (boundingBox.y - margin)){\\r\\n            this.currentBBox.w = boundingBox.width + margin*2;\\r\\n            this.currentBBox.h = boundingBox.height + margin*2;\\r\\n            this.currentBBox.x = boundingBox.x - margin;\\r\\n            this.currentBBox.y = boundingBox.y - margin;\\r\\n\\r\\n            this.svgElement.setAttribute('viewBox',this.currentBBox.x+' '+this.currentBBox.y+' '+this.currentBBox.w+' '+this.currentBBox.h);\\r\\n            this.svgElement.style.transform = this.svgElement.style.webkitTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';\\r\\n        }\\r\\n    }\\r\\n};\\nfunction HImageElement(data,globalData,comp){\\r\\n    this.assetData = globalData.getAssetData(data.refId);\\r\\n    this.initElement(data,globalData,comp);\\r\\n}\\r\\n\\r\\nextendPrototype([BaseElement,TransformElement,HBaseElement,HSolidElement,HierarchyElement,FrameElement,RenderableElement], HImageElement);\\r\\n\\r\\n\\r\\nHImageElement.prototype.createContent = function(){\\r\\n    var assetPath = this.globalData.getAssetsPath(this.assetData);\\r\\n    var img = new Image();\\r\\n\\r\\n    if(this.data.hasMask){\\r\\n        this.imageElem = createNS('image');\\r\\n        this.imageElem.setAttribute('width',this.assetData.w+\\\"px\\\");\\r\\n        this.imageElem.setAttribute('height',this.assetData.h+\\\"px\\\");\\r\\n        this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink','href',assetPath);\\r\\n        this.layerElement.appendChild(this.imageElem);\\r\\n        this.baseElement.setAttribute('width',this.assetData.w);\\r\\n        this.baseElement.setAttribute('height',this.assetData.h);\\r\\n    } else {\\r\\n        this.layerElement.appendChild(img);\\r\\n    }\\r\\n    img.src = assetPath;\\r\\n    if(this.data.ln){\\r\\n        this.baseElement.setAttribute('id',this.data.ln);\\r\\n    }\\r\\n};\\nfunction HCameraElement(data,globalData,comp){\\r\\n    this.initFrame();\\r\\n    this.initBaseData(data,globalData,comp);\\r\\n    this.initHierarchy();\\r\\n    var getProp = PropertyFactory.getProp;\\r\\n    this.pe = getProp(this,data.pe,0,0,this);\\r\\n    if(data.ks.p.s){\\r\\n        this.px = getProp(this,data.ks.p.x,1,0,this);\\r\\n        this.py = getProp(this,data.ks.p.y,1,0,this);\\r\\n        this.pz = getProp(this,data.ks.p.z,1,0,this);\\r\\n    }else{\\r\\n        this.p = getProp(this,data.ks.p,1,0,this);\\r\\n    }\\r\\n    if(data.ks.a){\\r\\n        this.a = getProp(this,data.ks.a,1,0,this);\\r\\n    }\\r\\n    if(data.ks.or.k.length && data.ks.or.k[0].to){\\r\\n        var i,len = data.ks.or.k.length;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            data.ks.or.k[i].to = null;\\r\\n            data.ks.or.k[i].ti = null;\\r\\n        }\\r\\n    }\\r\\n    this.or = getProp(this,data.ks.or,1,degToRads,this);\\r\\n    this.or.sh = true;\\r\\n    this.rx = getProp(this,data.ks.rx,0,degToRads,this);\\r\\n    this.ry = getProp(this,data.ks.ry,0,degToRads,this);\\r\\n    this.rz = getProp(this,data.ks.rz,0,degToRads,this);\\r\\n    this.mat = new Matrix();\\r\\n    this._prevMat = new Matrix();\\r\\n    this._isFirstFrame = true;\\r\\n}\\r\\nextendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);\\r\\n\\r\\nHCameraElement.prototype.setup = function() {\\r\\n    var i, len = this.comp.threeDElements.length, comp;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        //[perspectiveElem,container]\\r\\n        comp = this.comp.threeDElements[i];\\r\\n        if(comp.type === '3d') {\\r\\n            comp.perspectiveElem.style.perspective = comp.perspectiveElem.style.webkitPerspective = this.pe.v+'px';\\r\\n            comp.container.style.transformOrigin = comp.container.style.mozTransformOrigin = comp.container.style.webkitTransformOrigin = \\\"0px 0px 0px\\\";\\r\\n            comp.perspectiveElem.style.transform = comp.perspectiveElem.style.webkitTransform = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';\\r\\n        }\\r\\n    }\\r\\n};\\r\\n\\r\\nHCameraElement.prototype.createElements = function(){\\r\\n};\\r\\n\\r\\nHCameraElement.prototype.hide = function(){\\r\\n};\\r\\n\\r\\nHCameraElement.prototype.renderFrame = function(){\\r\\n    var _mdf = this._isFirstFrame;\\r\\n    var i, len;\\r\\n    if(this.hierarchy){\\r\\n        len = this.hierarchy.length;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;\\r\\n        }\\r\\n    }\\r\\n    if(_mdf || this.pe._mdf || (this.p && this.p._mdf) || (this.px && (this.px._mdf || this.py._mdf || this.pz._mdf)) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || (this.a && this.a._mdf)) {\\r\\n        this.mat.reset();\\r\\n\\r\\n        if(this.hierarchy){\\r\\n            var mat;\\r\\n            len = this.hierarchy.length - 1;\\r\\n            for (i = len; i >= 0; i -= 1) {\\r\\n                /*mat = this.hierarchy[i].finalTransform.mProp.v.props;\\r\\n                console.log(mat)\\r\\n                this.mat.transform(-mat[0],-mat[1],-mat[2],-mat[3],-mat[4],-mat[5],-mat[6],-mat[7],-mat[8],-mat[9],-mat[10],-mat[11],-mat[12],-mat[13],-mat[14],mat[15]);\\r\\n                console.log(this.mat.props)*/\\r\\n                var mTransf = this.hierarchy[i].finalTransform.mProp;\\r\\n                this.mat.translate(-mTransf.p.v[0],-mTransf.p.v[1],mTransf.p.v[2]);\\r\\n                this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);\\r\\n                this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);\\r\\n                this.mat.scale(1/mTransf.s.v[0],1/mTransf.s.v[1],1/mTransf.s.v[2]);\\r\\n                this.mat.translate(mTransf.a.v[0],mTransf.a.v[1],mTransf.a.v[2]);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(this.p){\\r\\n            this.mat.translate(-this.p.v[0],-this.p.v[1],this.p.v[2]);\\r\\n        }else{\\r\\n            this.mat.translate(-this.px.v,-this.py.v,this.pz.v);\\r\\n        }\\r\\n        if(this.a){\\r\\n            var diffVector = [this.p.v[0]-this.a.v[0],this.p.v[1]-this.a.v[1],this.p.v[2]-this.a.v[2]];\\r\\n            var mag = Math.sqrt(Math.pow(diffVector[0],2)+Math.pow(diffVector[1],2)+Math.pow(diffVector[2],2));\\r\\n            //var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));\\r\\n            var lookDir = [diffVector[0]/mag,diffVector[1]/mag,diffVector[2]/mag];\\r\\n            var lookLengthOnXZ = Math.sqrt( lookDir[2]*lookDir[2] + lookDir[0]*lookDir[0] );\\r\\n            var m_rotationX = (Math.atan2( lookDir[1], lookLengthOnXZ ));\\r\\n            var m_rotationY = (Math.atan2( lookDir[0], -lookDir[2]));\\r\\n            this.mat.rotateY(m_rotationY).rotateX(-m_rotationX);\\r\\n\\r\\n        }\\r\\n        this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);\\r\\n        this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);\\r\\n        this.mat.translate(this.globalData.compSize.w/2,this.globalData.compSize.h/2,0);\\r\\n        this.mat.translate(0,0,this.pe.v);\\r\\n\\r\\n\\r\\n        \\r\\n\\r\\n        var hasMatrixChanged = !this._prevMat.equals(this.mat);\\r\\n        if((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {\\r\\n            len = this.comp.threeDElements.length;\\r\\n            var comp;\\r\\n            for(i=0;i<len;i+=1){\\r\\n                comp = this.comp.threeDElements[i];\\r\\n                if(comp.type === '3d') {\\r\\n                    if(hasMatrixChanged) {\\r\\n                        comp.container.style.transform = comp.container.style.webkitTransform = this.mat.toCSS();\\r\\n                    }\\r\\n                    if(this.pe._mdf) {\\r\\n                        comp.perspectiveElem.style.perspective = comp.perspectiveElem.style.webkitPerspective = this.pe.v+'px';\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            this.mat.clone(this._prevMat);\\r\\n        }\\r\\n    }\\r\\n    this._isFirstFrame = false;\\r\\n};\\r\\n\\r\\nHCameraElement.prototype.prepareFrame = function(num) {\\r\\n    this.prepareProperties(num, true);\\r\\n};\\r\\n\\r\\nHCameraElement.prototype.destroy = function(){\\r\\n};\\r\\nHCameraElement.prototype.initExpressions = function(){};\\r\\nHCameraElement.prototype.getBaseElement = function(){return null;};\\nfunction HEffects() {\\r\\n}\\r\\nHEffects.prototype.renderFrame = function(){};\\nvar Expressions = (function(){\\r\\n    var ob = {};\\r\\n    ob.initExpressions = initExpressions;\\r\\n\\r\\n\\r\\n    function initExpressions(animation){\\r\\n        animation.renderer.compInterface = CompExpressionInterface(animation.renderer);\\r\\n        animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);\\r\\n    }\\r\\n   return ob;\\r\\n}());\\r\\n\\r\\nexpressionsPlugin = Expressions;\\r\\n\\nvar ExpressionManager = (function(){\\r\\n    'use strict';\\r\\n    var ob = {};\\r\\n    var Math = BMMath;\\r\\n    var window = null;\\r\\n    var document = null;\\r\\n\\r\\n    function $bm_isInstanceOfArray(arr) {\\r\\n        return arr.constructor === Array || arr.constructor === Float32Array;\\r\\n    }\\r\\n\\r\\n    function isNumerable(tOfV, v) {\\r\\n        return tOfV === 'number' || tOfV === 'boolean' || tOfV === 'string' || v instanceof Number;\\r\\n    }\\r\\n\\r\\n    function $bm_neg(a){\\r\\n        var tOfA = typeof a;\\r\\n        if(tOfA === 'number' || tOfA === 'boolean'  || a instanceof Number ){\\r\\n            return -a;\\r\\n        }\\r\\n        if($bm_isInstanceOfArray(a)){\\r\\n            var i, lenA = a.length;\\r\\n            var retArr = [];\\r\\n            for(i=0;i<lenA;i+=1){\\r\\n                retArr[i] = -a[i];\\r\\n            }\\r\\n            return retArr;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function sum(a,b) {\\r\\n        var tOfA = typeof a;\\r\\n        var tOfB = typeof b;\\r\\n        if(tOfA === 'string' || tOfB === 'string'){\\r\\n            return a + b;\\r\\n        }\\r\\n        if(isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\\r\\n            return a + b;\\r\\n        }\\r\\n        if($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)){\\r\\n            a = a.slice(0);\\r\\n            a[0] = a[0] + b;\\r\\n            return a;\\r\\n        }\\r\\n        if(isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)){\\r\\n            b = b.slice(0);\\r\\n            b[0] = a + b[0];\\r\\n            return b;\\r\\n        }\\r\\n        if($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)){\\r\\n            \\r\\n            var i = 0, lenA = a.length, lenB = b.length;\\r\\n            var retArr = [];\\r\\n            while(i<lenA || i < lenB){\\r\\n                if((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)){\\r\\n                    retArr[i] = a[i] + b[i];\\r\\n                }else{\\r\\n                    retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];\\r\\n                }\\r\\n                i += 1;\\r\\n            }\\r\\n            return retArr;\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n    var add = sum;\\r\\n\\r\\n    function sub(a,b) {\\r\\n        var tOfA = typeof a;\\r\\n        var tOfB = typeof b;\\r\\n        if(isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\\r\\n            if(tOfA === 'string') {\\r\\n                a = parseInt(a);\\r\\n            }\\r\\n            if(tOfB === 'string') {\\r\\n                b = parseInt(b);\\r\\n            }\\r\\n            return a - b;\\r\\n        }\\r\\n        if( $bm_isInstanceOfArray(a) && isNumerable(tOfB, b)){\\r\\n            a = a.slice(0);\\r\\n            a[0] = a[0] - b;\\r\\n            return a;\\r\\n        }\\r\\n        if(isNumerable(tOfA, a) &&  $bm_isInstanceOfArray(b)){\\r\\n            b = b.slice(0);\\r\\n            b[0] = a - b[0];\\r\\n            return b;\\r\\n        }\\r\\n        if($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)){\\r\\n            var i = 0, lenA = a.length, lenB = b.length;\\r\\n            var retArr = [];\\r\\n            while(i<lenA || i < lenB){\\r\\n                if((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)){\\r\\n                    retArr[i] = a[i] - b[i];\\r\\n                }else{\\r\\n                    retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];\\r\\n                }\\r\\n                i += 1;\\r\\n            }\\r\\n            return retArr;\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function mul(a,b) {\\r\\n        var tOfA = typeof a;\\r\\n        var tOfB = typeof b;\\r\\n        var arr;\\r\\n        if(isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\\r\\n            return a * b;\\r\\n        }\\r\\n\\r\\n        var i, len;\\r\\n        if($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)){\\r\\n            len = a.length;\\r\\n            arr = createTypedArray('float32', len);\\r\\n            for(i=0;i<len;i+=1){\\r\\n                arr[i] = a[i] * b;\\r\\n            }\\r\\n            return arr;\\r\\n        }\\r\\n        if(isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)){\\r\\n            len = b.length;\\r\\n            arr = createTypedArray('float32', len);\\r\\n            for(i=0;i<len;i+=1){\\r\\n                arr[i] = a * b[i];\\r\\n            }\\r\\n            return arr;\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n\\r\\n    function div(a,b) {\\r\\n        var tOfA = typeof a;\\r\\n        var tOfB = typeof b;\\r\\n        var arr;\\r\\n        if(isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\\r\\n            return a / b;\\r\\n        }\\r\\n        var i, len;\\r\\n        if($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)){\\r\\n            len = a.length;\\r\\n            arr = createTypedArray('float32', len);\\r\\n            for(i=0;i<len;i+=1){\\r\\n                arr[i] = a[i] / b;\\r\\n            }\\r\\n            return arr;\\r\\n        }\\r\\n        if(isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)){\\r\\n            len = b.length;\\r\\n            arr = createTypedArray('float32', len);\\r\\n            for(i=0;i<len;i+=1){\\r\\n                arr[i] = a / b[i];\\r\\n            }\\r\\n            return arr;\\r\\n        }\\r\\n        return 0;\\r\\n    }\\r\\n    function mod(a,b) {\\r\\n        if(typeof a === 'string') {\\r\\n            a = parseInt(a);\\r\\n        }\\r\\n        if(typeof b === 'string') {\\r\\n            b = parseInt(b);\\r\\n        }\\r\\n        return a % b;\\r\\n    }\\r\\n\\r\\n    function clamp(num, min, max) {\\r\\n        if(min > max){\\r\\n            var mm = max;\\r\\n            max = min;\\r\\n            min = mm;\\r\\n        }\\r\\n        return Math.min(Math.max(num, min), max);\\r\\n    }\\r\\n\\r\\n    function radiansToDegrees(val) {\\r\\n        return val/degToRads;\\r\\n    }\\r\\n    var radians_to_degrees = radiansToDegrees;\\r\\n\\r\\n    function degreesToRadians(val) {\\r\\n        return val*degToRads;\\r\\n    }\\r\\n    var degrees_to_radians = radiansToDegrees;\\r\\n\\r\\n    var helperLengthArray = [0,0,0,0,0,0];\\r\\n\\r\\n    function length(arr1, arr2) {\\r\\n        if (typeof arr1 === 'number' || arr1 instanceof Number) {\\r\\n            arr2 = arr2 || 0;\\r\\n            return Math.abs(arr1 - arr2);\\r\\n        }\\r\\n        if(!arr2) {\\r\\n            arr2 = helperLengthArray;\\r\\n        }\\r\\n        var i, len = Math.min(arr1.length, arr2.length);\\r\\n        var addedLength = 0;\\r\\n        for (i = 0; i < len; i += 1) {\\r\\n            addedLength += Math.pow(arr2[i] - arr1[i], 2);\\r\\n        }\\r\\n        return Math.sqrt(addedLength);\\r\\n    }\\r\\n\\r\\n    function normalize(vec) {\\r\\n        return div(vec, length(vec));\\r\\n    }\\r\\n\\r\\n    function rgbToHsl(val) {\\r\\n        var r = val[0]; var g = val[1]; var b = val[2];\\r\\n        var max = Math.max(r, g, b), min = Math.min(r, g, b);\\r\\n        var h, s, l = (max + min) / 2;\\r\\n\\r\\n        if(max == min){\\r\\n            h = s = 0; // achromatic\\r\\n        }else{\\r\\n            var d = max - min;\\r\\n            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\\r\\n            switch(max){\\r\\n                case r: h = (g - b) / d + (g < b ? 6 : 0); break;\\r\\n                case g: h = (b - r) / d + 2; break;\\r\\n                case b: h = (r - g) / d + 4; break;\\r\\n            }\\r\\n            h /= 6;\\r\\n        }\\r\\n\\r\\n        return [h, s, l,val[3]];\\r\\n    }\\r\\n\\r\\n    function hue2rgb(p, q, t){\\r\\n        if(t < 0) t += 1;\\r\\n        if(t > 1) t -= 1;\\r\\n        if(t < 1/6) return p + (q - p) * 6 * t;\\r\\n        if(t < 1/2) return q;\\r\\n        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;\\r\\n        return p;\\r\\n    }\\r\\n\\r\\n    function hslToRgb(val){\\r\\n        var h = val[0];\\r\\n        var s = val[1];\\r\\n        var l = val[2];\\r\\n\\r\\n        var r, g, b;\\r\\n\\r\\n        if(s === 0){\\r\\n            r = g = b = l; // achromatic\\r\\n        }else{\\r\\n\\r\\n            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\\r\\n            var p = 2 * l - q;\\r\\n            r = hue2rgb(p, q, h + 1/3);\\r\\n            g = hue2rgb(p, q, h);\\r\\n            b = hue2rgb(p, q, h - 1/3);\\r\\n        }\\r\\n\\r\\n        return [r, g , b, val[3]];\\r\\n    }\\r\\n\\r\\n    function linear(t, tMin, tMax, value1, value2){\\r\\n        if(value1 === undefined || value2 === undefined){\\r\\n            value1 = tMin;\\r\\n            value2 = tMax;\\r\\n            tMin = 0;\\r\\n            tMax = 1;\\r\\n        }\\r\\n        if(tMax < tMin) {\\r\\n            var _tMin = tMax;\\r\\n            tMax = tMin;\\r\\n            tMin = _tMin;\\r\\n        }\\r\\n        if(t <= tMin) {\\r\\n            return value1;\\r\\n        }else if(t >= tMax){\\r\\n            return value2;\\r\\n        }\\r\\n        var perc = tMax === tMin ? 0 : (t-tMin)/(tMax-tMin);\\r\\n        if(!value1.length){\\r\\n            return value1 + (value2-value1)*perc;\\r\\n        }\\r\\n        var i, len = value1.length;\\r\\n        var arr = createTypedArray('float32', len);\\r\\n        for(i=0;i<len;i+=1){\\r\\n            arr[i] = value1[i] + (value2[i]-value1[i])*perc;\\r\\n        }\\r\\n        return arr;\\r\\n    }\\r\\n    function random(min,max){\\r\\n        if(max === undefined){\\r\\n            if(min === undefined){\\r\\n                min = 0;\\r\\n                max = 1;\\r\\n            } else {\\r\\n                max = min;\\r\\n                min = undefined;\\r\\n            }\\r\\n        }\\r\\n        if(max.length){\\r\\n            var i, len = max.length;\\r\\n            if(!min){\\r\\n                min = createTypedArray('float32', len);\\r\\n            }\\r\\n            var arr = createTypedArray('float32', len);\\r\\n            var rnd = BMMath.random();\\r\\n            for(i=0;i<len;i+=1){\\r\\n                arr[i] = min[i] + rnd*(max[i]-min[i]);\\r\\n            }\\r\\n            return arr;\\r\\n        }\\r\\n        if(min === undefined){\\r\\n            min = 0;\\r\\n        }\\r\\n        var rndm = BMMath.random();\\r\\n        return min + rndm*(max-min);\\r\\n    }\\r\\n\\r\\n    function createPath(points, inTangents, outTangents, closed) {\\r\\n        var i, len = points.length;\\r\\n        var path = shape_pool.newElement();\\r\\n        path.setPathData(!!closed, len);\\r\\n        var arrPlaceholder = [0,0], inVertexPoint, outVertexPoint;\\r\\n        for(i = 0; i < len; i += 1) {\\r\\n            inVertexPoint = (inTangents && inTangents[i]) ? inTangents[i] : arrPlaceholder;\\r\\n            outVertexPoint = (outTangents && outTangents[i]) ? outTangents[i] : arrPlaceholder;\\r\\n            path.setTripleAt(points[i][0],points[i][1],outVertexPoint[0] + points[i][0],outVertexPoint[1] + points[i][1],inVertexPoint[0] + points[i][0],inVertexPoint[1] + points[i][1],i,true);\\r\\n        }\\r\\n        return path;\\r\\n    }\\r\\n\\r\\n    function initiateExpression(elem,data,property){\\r\\n        var val = data.x;\\r\\n        var needsVelocity = /velocity(?![\\\\w\\\\d])/.test(val);\\r\\n        var _needsRandom = val.indexOf('random') !== -1;\\r\\n        var elemType = elem.data.ty;\\r\\n        var transform,$bm_transform,content,effect;\\r\\n        var thisProperty = property;\\r\\n        elem.comp.frameDuration = 1/elem.comp.globalData.frameRate;\\r\\n        var inPoint = elem.data.ip/elem.comp.globalData.frameRate;\\r\\n        var outPoint = elem.data.op/elem.comp.globalData.frameRate;\\r\\n        var width = elem.data.sw ? elem.data.sw : 0;\\r\\n        var height = elem.data.sh ? elem.data.sh : 0;\\r\\n        var name = elem.data.nm;\\r\\n        var loopIn, loop_in, loopOut, loop_out;\\r\\n        var toWorld,fromWorld,fromComp,toComp,fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer,thisComp,mask,valueAtTime,velocityAtTime;\\r\\n        var __expression_functions = [];\\r\\n        if(data.xf) {\\r\\n            var i, len = data.xf.length;\\r\\n            for(i = 0; i < len; i += 1) {\\r\\n                __expression_functions[i] = eval('(function(){ return ' + data.xf[i] + '}())');\\r\\n            }\\r\\n        }\\r\\n\\r\\n        var scoped_bm_rt;\\r\\n        var expression_function = eval('[function _expression_function(){' + val+';scoped_bm_rt=$bm_rt}' + ']')[0];\\r\\n        var numKeys = property.kf ? data.k.length : 0;\\r\\n\\r\\n        var active = !this.data || this.data.hd !== true;\\r\\n\\r\\n        var wiggle = function wiggle(freq,amp){\\r\\n            var i,j, len = this.pv.length ? this.pv.length : 1;\\r\\n            var addedAmps = createTypedArray('float32', len);\\r\\n            freq = 5;\\r\\n            var iterations = Math.floor(time*freq);\\r\\n            i = 0;\\r\\n            j = 0;\\r\\n            while(i<iterations){\\r\\n                //var rnd = BMMath.random();\\r\\n                for(j=0;j<len;j+=1){\\r\\n                    addedAmps[j] += -amp + amp*2*BMMath.random();\\r\\n                    //addedAmps[j] += -amp + amp*2*rnd;\\r\\n                }\\r\\n                i += 1;\\r\\n            }\\r\\n            //var rnd2 = BMMath.random();\\r\\n            var periods = time*freq;\\r\\n            var perc = periods - Math.floor(periods);\\r\\n            var arr = createTypedArray('float32', len);\\r\\n            if(len>1){\\r\\n                for(j=0;j<len;j+=1){\\r\\n                    arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*BMMath.random())*perc;\\r\\n                    //arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;\\r\\n                    //arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);\\r\\n                }\\r\\n                return arr;\\r\\n            } else {\\r\\n                return this.pv + addedAmps[0] + (-amp + amp*2*BMMath.random())*perc;\\r\\n            }\\r\\n        }.bind(this);\\r\\n\\r\\n        if(thisProperty.loopIn) {\\r\\n            loopIn = thisProperty.loopIn.bind(thisProperty);\\r\\n            loop_in = loopIn;\\r\\n        }\\r\\n\\r\\n        if(thisProperty.loopOut) {\\r\\n            loopOut = thisProperty.loopOut.bind(thisProperty);\\r\\n            loop_out = loopOut;\\r\\n        }\\r\\n\\r\\n        function loopInDuration(type,duration){\\r\\n            return loopIn(type,duration,true);\\r\\n        }\\r\\n\\r\\n        function loopOutDuration(type,duration){\\r\\n            return loopOut(type,duration,true);\\r\\n        }\\r\\n\\r\\n        if(this.getValueAtTime) {\\r\\n            valueAtTime = this.getValueAtTime.bind(this);\\r\\n        }\\r\\n\\r\\n        if(this.getVelocityAtTime) {\\r\\n            velocityAtTime = this.getVelocityAtTime.bind(this);\\r\\n        }\\r\\n\\r\\n        var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);\\r\\n\\r\\n        function lookAt(elem1,elem2){\\r\\n            var fVec = [elem2[0]-elem1[0],elem2[1]-elem1[1],elem2[2]-elem1[2]];\\r\\n            var pitch = Math.atan2(fVec[0],Math.sqrt(fVec[1]*fVec[1]+fVec[2]*fVec[2]))/degToRads;\\r\\n            var yaw = -Math.atan2(fVec[1],fVec[2])/degToRads;\\r\\n            return [yaw,pitch,0];\\r\\n        }\\r\\n\\r\\n        function easeOut(t, tMin, tMax, val1, val2){\\r\\n            if(val1 === undefined){\\r\\n                val1 = tMin;\\r\\n                val2 = tMax;\\r\\n            } else {\\r\\n                t = (t - tMin) / (tMax - tMin);\\r\\n            }\\r\\n            return -(val2-val1) * t*(t-2) + val1;\\r\\n        }\\r\\n\\r\\n        function easeIn(t, tMin, tMax, val1, val2){\\r\\n            if(val1 === undefined){\\r\\n                val1 = tMin;\\r\\n                val2 = tMax;\\r\\n            } else {\\r\\n                t = (t - tMin) / (tMax - tMin);\\r\\n            }\\r\\n            return (val2-val1)*t*t + val1;\\r\\n        }\\r\\n\\r\\n        function nearestKey(time){\\r\\n            var i, len = data.k.length,index,keyTime;\\r\\n            if(!data.k.length || typeof(data.k[0]) === 'number'){\\r\\n                index = 0;\\r\\n                keyTime = 0;\\r\\n            } else {\\r\\n                index = -1;\\r\\n                time *= elem.comp.globalData.frameRate;\\r\\n                if (time < data.k[0].t) {\\r\\n                    index = 1;\\r\\n                    keyTime = data.k[0].t;\\r\\n                } else {\\r\\n                    for(i=0;i<len-1;i+=1){\\r\\n                        if(time === data.k[i].t){\\r\\n                            index = i + 1;\\r\\n                            keyTime = data.k[i].t;\\r\\n                            break;\\r\\n                        }else if(time>data.k[i].t && time<data.k[i+1].t){\\r\\n                            if(time-data.k[i].t > data.k[i+1].t - time){\\r\\n                                index = i + 2;\\r\\n                                keyTime = data.k[i+1].t;\\r\\n                            } else {\\r\\n                                index = i + 1;\\r\\n                                keyTime = data.k[i].t;\\r\\n                            }\\r\\n                            break;\\r\\n                        }\\r\\n                    }\\r\\n                    if(index === -1){\\r\\n                        index = i + 1;\\r\\n                        keyTime = data.k[i].t;\\r\\n                    }\\r\\n                }\\r\\n                \\r\\n            }\\r\\n            var ob = {};\\r\\n            ob.index = index;\\r\\n            ob.time = keyTime/elem.comp.globalData.frameRate;\\r\\n            return ob;\\r\\n        }\\r\\n\\r\\n        function key(ind){\\r\\n            var ob, i, len;\\r\\n            if(!data.k.length || typeof(data.k[0]) === 'number'){\\r\\n                throw new Error('The property has no keyframe at index ' + ind);\\r\\n            }\\r\\n            ind -= 1;\\r\\n            ob = {\\r\\n                time: data.k[ind].t/elem.comp.globalData.frameRate\\r\\n            };\\r\\n            var arr;\\r\\n            if(ind === data.k.length - 1 && !data.k[ind].h){\\r\\n                arr = data.k[ind-1].e;\\r\\n            }else{\\r\\n                arr = data.k[ind].s;\\r\\n            }\\r\\n            len = arr.length;\\r\\n            for(i=0;i<len;i+=1){\\r\\n                ob[i] = arr[i];\\r\\n            }\\r\\n            return ob;\\r\\n        }\\r\\n\\r\\n        function framesToTime(frames, fps) { \\r\\n            if (!fps) {\\r\\n                fps = elem.comp.globalData.frameRate;\\r\\n            }\\r\\n            return frames / fps;\\r\\n        }\\r\\n\\r\\n        function timeToFrames(t, fps) {\\r\\n            if (!t && t !== 0) {\\r\\n                t = time;\\r\\n            }\\r\\n            if (!fps) {\\r\\n                fps = elem.comp.globalData.frameRate;\\r\\n            }\\r\\n            return t * fps;\\r\\n        }\\r\\n\\r\\n        function seedRandom(seed){\\r\\n            BMMath.seedrandom(randSeed + seed);\\r\\n        }\\r\\n\\r\\n        function sourceRectAtTime() {\\r\\n            return elem.sourceRectAtTime();\\r\\n        }\\r\\n\\r\\n        function substring(init, end) {\\r\\n            if(typeof value === 'string') {\\r\\n                if(end === undefined) {\\r\\n                return value.substring(init)\\r\\n                }\\r\\n                return value.substring(init, end)\\r\\n            }\\r\\n            return '';\\r\\n        }\\r\\n\\r\\n        function substr(init, end) {\\r\\n            if(typeof value === 'string') {\\r\\n                if(end === undefined) {\\r\\n                return value.substr(init)\\r\\n                }\\r\\n                return value.substr(init, end)\\r\\n            }\\r\\n            return '';\\r\\n        }\\r\\n\\r\\n        var time, velocity, value, text, textIndex, textTotal, selectorValue;\\r\\n        var index = elem.data.ind;\\r\\n        var hasParent = !!(elem.hierarchy && elem.hierarchy.length);\\r\\n        var parent;\\r\\n        var randSeed = Math.floor(Math.random()*1000000);\\r\\n        function executeExpression(_value) {\\r\\n            value = _value;\\r\\n            if (_needsRandom) {\\r\\n                seedRandom(randSeed);\\r\\n            }\\r\\n            if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {\\r\\n                return value;\\r\\n            }\\r\\n            if(this.propType === 'textSelector'){\\r\\n                textIndex = this.textIndex;\\r\\n                textTotal = this.textTotal;\\r\\n                selectorValue = this.selectorValue;\\r\\n            }\\r\\n            if (!thisLayer) {\\r\\n                text = elem.layerInterface.text;\\r\\n                thisLayer = elem.layerInterface;\\r\\n                thisComp = elem.comp.compInterface;\\r\\n                toWorld = thisLayer.toWorld.bind(thisLayer);\\r\\n                fromWorld = thisLayer.fromWorld.bind(thisLayer);\\r\\n                fromComp = thisLayer.fromComp.bind(thisLayer);\\r\\n                toComp = thisLayer.toComp.bind(thisLayer);\\r\\n                mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;\\r\\n                fromCompToSurface = fromComp;\\r\\n            }\\r\\n            if (!transform) {\\r\\n                transform = elem.layerInterface(\\\"ADBE Transform Group\\\");\\r\\n                $bm_transform = transform;\\r\\n                if(transform) {\\r\\n                    anchorPoint = transform.anchorPoint;\\r\\n                    /*position = transform.position;\\r\\n                    rotation = transform.rotation;\\r\\n                    scale = transform.scale;*/\\r\\n                }\\r\\n            }\\r\\n            \\r\\n            if (elemType === 4 && !content) {\\r\\n                content = thisLayer(\\\"ADBE Root Vectors Group\\\");\\r\\n            }\\r\\n            if (!effect) {\\r\\n                effect = thisLayer(4);\\r\\n            }\\r\\n            hasParent = !!(elem.hierarchy && elem.hierarchy.length);\\r\\n            if (hasParent && !parent) {\\r\\n                parent = elem.hierarchy[0].layerInterface;\\r\\n            }\\r\\n            time = this.comp.renderedFrame/this.comp.globalData.frameRate;\\r\\n            if (needsVelocity) {\\r\\n                velocity = velocityAtTime(time);\\r\\n            }\\r\\n            expression_function();\\r\\n            this.frameExpressionId = elem.globalData.frameId;\\r\\n\\r\\n\\r\\n            //TODO: Check if it's possible to return on ShapeInterface the .v value\\r\\n            if (scoped_bm_rt.propType === \\\"shape\\\") {\\r\\n                scoped_bm_rt = shape_pool.clone(scoped_bm_rt.v);\\r\\n            }\\r\\n            return scoped_bm_rt;\\r\\n        }\\r\\n        return executeExpression;\\r\\n    }\\r\\n\\r\\n    ob.initiateExpression = initiateExpression;\\r\\n    return ob;\\r\\n}());\\n(function addPropertyDecorator() {\\r\\n\\r\\n    function getStaticValueAtTime() {\\r\\n        return this.pv;\\r\\n    }\\r\\n\\r\\n    function loopOut(type,duration,durationFlag){\\r\\n        if(!this.k || !this.keyframes){\\r\\n            return this.pv;\\r\\n        }\\r\\n        type = type ? type.toLowerCase() : '';\\r\\n        var currentFrame = this.comp.renderedFrame;\\r\\n        var keyframes = this.keyframes;\\r\\n        var lastKeyFrame = keyframes[keyframes.length - 1].t;\\r\\n        if(currentFrame<=lastKeyFrame){\\r\\n            return this.pv;\\r\\n        }else{\\r\\n            var cycleDuration, firstKeyFrame;\\r\\n            if(!durationFlag){\\r\\n                if(!duration || duration > keyframes.length - 1){\\r\\n                    duration = keyframes.length - 1;\\r\\n                }\\r\\n                firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;\\r\\n                cycleDuration = lastKeyFrame - firstKeyFrame;\\r\\n            } else {\\r\\n                if(!duration){\\r\\n                    cycleDuration = Math.max(0,lastKeyFrame - this.elem.data.ip);\\r\\n                } else {\\r\\n                    cycleDuration = Math.abs(lastKeyFrame - elem.comp.globalData.frameRate*duration);\\r\\n                }\\r\\n                firstKeyFrame = lastKeyFrame - cycleDuration;\\r\\n            }\\r\\n            var i, len, ret;\\r\\n            if(type === 'pingpong') {\\r\\n                var iterations = Math.floor((currentFrame - firstKeyFrame)/cycleDuration);\\r\\n                if(iterations % 2 !== 0){\\r\\n                    return this.getValueAtTime(((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration +  firstKeyFrame)) / this.comp.globalData.frameRate, 0);\\r\\n                }\\r\\n            } else if(type === 'offset'){\\r\\n                var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\\r\\n                var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\\r\\n                var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration +  firstKeyFrame) / this.comp.globalData.frameRate, 0);\\r\\n                var repeats = Math.floor((currentFrame - firstKeyFrame)/cycleDuration);\\r\\n                if(this.pv.length){\\r\\n                    ret = new Array(initV.length);\\r\\n                    len = ret.length;\\r\\n                    for(i=0;i<len;i+=1){\\r\\n                        ret[i] = (endV[i]-initV[i])*repeats + current[i];\\r\\n                    }\\r\\n                    return ret;\\r\\n                }\\r\\n                return (endV-initV)*repeats + current;\\r\\n            } else if(type === 'continue'){\\r\\n                var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\\r\\n                var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);\\r\\n                if(this.pv.length){\\r\\n                    ret = new Array(lastValue.length);\\r\\n                    len = ret.length;\\r\\n                    for(i=0;i<len;i+=1){\\r\\n                        ret[i] = lastValue[i] + (lastValue[i]-nextLastValue[i])*((currentFrame - lastKeyFrame)/ this.comp.globalData.frameRate)/0.0005;\\r\\n                    }\\r\\n                    return ret;\\r\\n                }\\r\\n                return lastValue + (lastValue-nextLastValue)*(((currentFrame - lastKeyFrame))/0.001);\\r\\n            }\\r\\n            return this.getValueAtTime((((currentFrame - firstKeyFrame) % cycleDuration +  firstKeyFrame)) / this.comp.globalData.frameRate, 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function loopIn(type,duration, durationFlag) {\\r\\n        if(!this.k){\\r\\n            return this.pv;\\r\\n        }\\r\\n        type = type ? type.toLowerCase() : '';\\r\\n        var currentFrame = this.comp.renderedFrame;\\r\\n        var keyframes = this.keyframes;\\r\\n        var firstKeyFrame = keyframes[0].t;\\r\\n        if(currentFrame>=firstKeyFrame){\\r\\n            return this.pv;\\r\\n        }else{\\r\\n            var cycleDuration, lastKeyFrame;\\r\\n            if(!durationFlag){\\r\\n                if(!duration || duration > keyframes.length - 1){\\r\\n                    duration = keyframes.length - 1;\\r\\n                }\\r\\n                lastKeyFrame = keyframes[duration].t;\\r\\n                cycleDuration = lastKeyFrame - firstKeyFrame;\\r\\n            } else {\\r\\n                if(!duration){\\r\\n                    cycleDuration = Math.max(0,this.elem.data.op - firstKeyFrame);\\r\\n                } else {\\r\\n                    cycleDuration = Math.abs(elem.comp.globalData.frameRate*duration);\\r\\n                }\\r\\n                lastKeyFrame = firstKeyFrame + cycleDuration;\\r\\n            }\\r\\n            var i, len, ret;\\r\\n            if(type === 'pingpong') {\\r\\n                var iterations = Math.floor((firstKeyFrame - currentFrame)/cycleDuration);\\r\\n                if(iterations % 2 === 0){\\r\\n                    return this.getValueAtTime((((firstKeyFrame - currentFrame)%cycleDuration +  firstKeyFrame)) / this.comp.globalData.frameRate, 0);\\r\\n                }\\r\\n            } else if(type === 'offset'){\\r\\n                var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\\r\\n                var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\\r\\n                var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame)%cycleDuration +  firstKeyFrame) / this.comp.globalData.frameRate, 0);\\r\\n                var repeats = Math.floor((firstKeyFrame - currentFrame)/cycleDuration)+1;\\r\\n                if(this.pv.length){\\r\\n                    ret = new Array(initV.length);\\r\\n                    len = ret.length;\\r\\n                    for(i=0;i<len;i+=1){\\r\\n                        ret[i] = current[i]-(endV[i]-initV[i])*repeats;\\r\\n                    }\\r\\n                    return ret;\\r\\n                }\\r\\n                return current-(endV-initV)*repeats;\\r\\n            } else if(type === 'continue'){\\r\\n                var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\\r\\n                var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);\\r\\n                if(this.pv.length){\\r\\n                    ret = new Array(firstValue.length);\\r\\n                    len = ret.length;\\r\\n                    for(i=0;i<len;i+=1){\\r\\n                        ret[i] = firstValue[i] + (firstValue[i]-nextFirstValue[i])*(firstKeyFrame - currentFrame)/0.001;\\r\\n                    }\\r\\n                    return ret;\\r\\n                }\\r\\n                return firstValue + (firstValue-nextFirstValue)*(firstKeyFrame - currentFrame)/0.001;\\r\\n            }\\r\\n            return this.getValueAtTime(((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration +  firstKeyFrame)) / this.comp.globalData.frameRate, 0);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getValueAtTime(frameNum) {\\r\\n        if(frameNum !== this._cachingAtTime.lastFrame) {\\r\\n            frameNum *= this.elem.globalData.frameRate;\\r\\n            frameNum -= this.offsetTime;\\r\\n            this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;\\r\\n            this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);\\r\\n            this._cachingAtTime.lastFrame = frameNum;\\r\\n        }\\r\\n        return this._cachingAtTime.value;\\r\\n\\r\\n    }\\r\\n\\r\\n    function getSpeedAtTime(frameNum) {\\r\\n        var delta = -0.01;\\r\\n        var v1 = this.getValueAtTime(frameNum);\\r\\n        var v2 = this.getValueAtTime(frameNum + delta);\\r\\n        var speed = 0;\\r\\n        if(v1.length){\\r\\n            var i;\\r\\n            for(i=0;i<v1.length;i+=1){\\r\\n                speed += Math.pow(v2[i] - v1[i], 2);\\r\\n            }\\r\\n            speed = Math.sqrt(speed) * 100;\\r\\n        } else {\\r\\n            speed = 0;\\r\\n        }\\r\\n        return speed;\\r\\n    }\\r\\n\\r\\n    function getVelocityAtTime(frameNum) {\\r\\n        if(this.vel !== undefined){\\r\\n            return this.vel;\\r\\n        }\\r\\n        var delta = -0.001;\\r\\n        //frameNum += this.elem.data.st;\\r\\n        var v1 = this.getValueAtTime(frameNum);\\r\\n        var v2 = this.getValueAtTime(frameNum + delta);\\r\\n        var velocity;\\r\\n        if(v1.length){\\r\\n            velocity = createTypedArray('float32', v1.length);\\r\\n            var i;\\r\\n            for(i=0;i<v1.length;i+=1){\\r\\n                //removing frameRate\\r\\n                //if needed, don't add it here\\r\\n                //velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);\\r\\n                velocity[i] = (v2[i] - v1[i])/delta;\\r\\n            }\\r\\n        } else {\\r\\n            velocity = (v2 - v1)/delta;\\r\\n        }\\r\\n        return velocity;\\r\\n    }\\r\\n\\r\\n    function setGroupProperty(propertyGroup){\\r\\n        this.propertyGroup = propertyGroup;\\r\\n    }\\r\\n\\r\\n    function searchExpressions(elem,data,prop){\\r\\n        if(data.x){\\r\\n            prop.k = true;\\r\\n            prop.x = true;\\r\\n            prop.initiateExpression = ExpressionManager.initiateExpression;\\r\\n            prop.effectsSequence.push(prop.initiateExpression(elem,data,prop).bind(prop));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getTransformValueAtTime(time) {\\r\\n        console.warn('Transform at time not supported');\\r\\n    }\\r\\n\\r\\n    function getTransformStaticValueAtTime(time) {\\r\\n\\r\\n    }\\r\\n\\r\\n    var TextExpressionSelectorProp = (function(){\\r\\n\\r\\n        function getValueProxy(index,total){\\r\\n            this.textIndex = index+1;\\r\\n            this.textTotal = total;\\r\\n            this.getValue();\\r\\n            return this.v;\\r\\n        }\\r\\n\\r\\n        return function TextExpressionSelectorProp(elem,data){\\r\\n            this.pv = 1;\\r\\n            this.comp = elem.comp;\\r\\n            this.elem = elem;\\r\\n            this.mult = 0.01;\\r\\n            this.propType = 'textSelector';\\r\\n            this.textTotal = data.totalChars;\\r\\n            this.selectorValue = 100;\\r\\n            this.lastValue = [1,1,1];\\r\\n            searchExpressions.bind(this)(elem,data,this);\\r\\n            this.getMult = getValueProxy;\\r\\n            this.getVelocityAtTime = getVelocityAtTime;\\r\\n            if(this.kf){\\r\\n                this.getValueAtTime = getValueAtTime.bind(this);\\r\\n            } else {\\r\\n                this.getValueAtTime = getStaticValueAtTime.bind(this);\\r\\n            }\\r\\n            this.setGroupProperty = setGroupProperty;\\r\\n        };\\r\\n    }());\\r\\n\\r\\n    var getTransformProperty = TransformPropertyFactory.getTransformProperty;\\r\\n    TransformPropertyFactory.getTransformProperty = function(elem, data, container) {\\r\\n        var prop = getTransformProperty(elem, data, container);\\r\\n        if(prop.dynamicProperties.length) {\\r\\n            prop.getValueAtTime = getTransformValueAtTime.bind(prop);\\r\\n        } else {\\r\\n            prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);\\r\\n        }\\r\\n        prop.setGroupProperty = setGroupProperty;\\r\\n        return prop;\\r\\n    };\\r\\n\\r\\n    var propertyGetProp = PropertyFactory.getProp;\\r\\n    PropertyFactory.getProp = function(elem,data,type, mult, container){\\r\\n        var prop = propertyGetProp(elem,data,type, mult, container);\\r\\n        //prop.getVelocityAtTime = getVelocityAtTime;\\r\\n        //prop.loopOut = loopOut;\\r\\n        //prop.loopIn = loopIn;\\r\\n        if(prop.kf){\\r\\n            prop.getValueAtTime = getValueAtTime.bind(prop);\\r\\n        } else {\\r\\n            prop.getValueAtTime = getStaticValueAtTime.bind(prop);\\r\\n        }\\r\\n        prop.setGroupProperty = setGroupProperty;\\r\\n        prop.loopOut = loopOut;\\r\\n        prop.loopIn = loopIn;\\r\\n        prop.getVelocityAtTime = getVelocityAtTime.bind(prop);\\r\\n        prop.getSpeedAtTime = getSpeedAtTime.bind(prop);\\r\\n        prop.numKeys = data.a === 1 ? data.k.length : 0;\\r\\n        prop.propertyIndex = data.ix;\\r\\n        var value = 0;\\r\\n        if(type !== 0) {\\r\\n            value = createTypedArray('float32', data.a === 1 ?  data.k[0].s.length : data.k.length);\\r\\n        }\\r\\n        prop._cachingAtTime = {\\r\\n            lastFrame: initialDefaultFrame,\\r\\n            lastIndex: 0,\\r\\n            value: value\\r\\n        };\\r\\n        searchExpressions(elem,data,prop);\\r\\n        if(prop.k){\\r\\n            container.addDynamicProperty(prop);\\r\\n        }\\r\\n\\r\\n        return prop;\\r\\n    };\\r\\n\\r\\n    function getShapeValueAtTime(frameNum) {\\r\\n        //For now this caching object is created only when needed instead of creating it when the shape is initialized.\\r\\n        if (!this._cachingAtTime) {\\r\\n            this._cachingAtTime = {\\r\\n                shapeValue: shape_pool.clone(this.pv),\\r\\n                lastIndex: 0,\\r\\n                lastTime: initialDefaultFrame\\r\\n            };\\r\\n        }\\r\\n        if(frameNum !== this._cachingAtTime.lastTime) {\\r\\n            this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;\\r\\n            this._cachingAtTime.lastTime = frameNum;\\r\\n            frameNum *= this.elem.globalData.frameRate;\\r\\n            this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);\\r\\n        }\\r\\n        return this._cachingAtTime.shapeValue;\\r\\n    }\\r\\n\\r\\n    var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();\\r\\n    var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();\\r\\n\\r\\n    function ShapeExpressions(){}\\r\\n    ShapeExpressions.prototype = {\\r\\n        vertices: function(prop, time){\\r\\n            var shapePath = this.v;\\r\\n            if(time !== undefined) {\\r\\n                shapePath = this.getValueAtTime(time, 0);\\r\\n            }\\r\\n            var i, len = shapePath._length;\\r\\n            var vertices = shapePath[prop];\\r\\n            var points = shapePath.v;\\r\\n            var arr = createSizedArray(len);\\r\\n            for(i = 0; i < len; i += 1) {\\r\\n                if(prop === 'i' || prop === 'o') {\\r\\n                    arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]];\\r\\n                } else {\\r\\n                    arr[i] = [vertices[i][0], vertices[i][1]];\\r\\n                }\\r\\n                \\r\\n            }\\r\\n            return arr;\\r\\n        },\\r\\n        points: function(time){\\r\\n            return this.vertices('v', time);\\r\\n        },\\r\\n        inTangents: function(time){\\r\\n            return this.vertices('i', time);\\r\\n        },\\r\\n        outTangents: function(time){\\r\\n            return this.vertices('o', time);\\r\\n        },\\r\\n        isClosed: function(){\\r\\n            return this.v.c;\\r\\n        },\\r\\n        pointOnPath: function(perc, time){\\r\\n            var shapePath = this.v;\\r\\n            if(time !== undefined) {\\r\\n                shapePath = this.getValueAtTime(time, 0);\\r\\n            }\\r\\n            if(!this._segmentsLength) {\\r\\n                this._segmentsLength = bez.getSegmentsLength(shapePath);\\r\\n            }\\r\\n\\r\\n            var segmentsLength = this._segmentsLength;\\r\\n            var lengths = segmentsLength.lengths;\\r\\n            var lengthPos = segmentsLength.totalLength * perc;\\r\\n            var i = 0, len = lengths.length;\\r\\n            var j = 0, jLen;\\r\\n            var accumulatedLength = 0, pt;\\r\\n            while(i < len) {\\r\\n                if(accumulatedLength + lengths[i].addedLength > lengthPos) {\\r\\n                    var initIndex = i;\\r\\n                    var endIndex = (shapePath.c && i === len - 1) ? 0 : i + 1;\\r\\n                    var segmentPerc = (lengthPos - accumulatedLength)/lengths[i].addedLength;\\r\\n                    pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);\\r\\n                    break;\\r\\n                } else {\\r\\n                    accumulatedLength += lengths[i].addedLength;\\r\\n                }\\r\\n                i += 1;\\r\\n            }\\r\\n            if(!pt){\\r\\n                pt = shapePath.c ? [shapePath.v[0][0],shapePath.v[0][1]]:[shapePath.v[shapePath._length-1][0],shapePath.v[shapePath._length-1][1]];\\r\\n            }\\r\\n            return pt;\\r\\n        },\\r\\n        vectorOnPath: function(perc, time, vectorType){\\r\\n            //perc doesn't use triple equality because it can be a Number object as well as a primitive.\\r\\n            perc = perc == 1 ? this.v.c ? 0 : 0.999 : perc;\\r\\n            var pt1 = this.pointOnPath(perc, time);\\r\\n            var pt2 = this.pointOnPath(perc + 0.001, time);\\r\\n            var xLength = pt2[0] - pt1[0];\\r\\n            var yLength = pt2[1] - pt1[1];\\r\\n            var magnitude = Math.sqrt(Math.pow(xLength,2) + Math.pow(yLength,2));\\r\\n            var unitVector = vectorType === 'tangent' ? [xLength/magnitude, yLength/magnitude] : [-yLength/magnitude, xLength/magnitude];\\r\\n            return unitVector;\\r\\n        },\\r\\n        tangentOnPath: function(perc, time){\\r\\n            return this.vectorOnPath(perc, time, 'tangent');\\r\\n        },\\r\\n        normalOnPath: function(perc, time){\\r\\n            return this.vectorOnPath(perc, time, 'normal');\\r\\n        },\\r\\n        setGroupProperty: setGroupProperty,\\r\\n        getValueAtTime: getStaticValueAtTime\\r\\n    };\\r\\n    extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);\\r\\n    extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);\\r\\n    KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;\\r\\n    KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;\\r\\n\\r\\n    var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;\\r\\n    ShapePropertyFactory.getShapeProp = function(elem,data,type, arr, trims){\\r\\n        var prop = propertyGetShapeProp(elem,data,type, arr, trims);\\r\\n        prop.propertyIndex = data.ix;\\r\\n        prop.lock = false;\\r\\n        if(type === 3){\\r\\n            searchExpressions(elem,data.pt,prop);\\r\\n        } else if(type === 4){\\r\\n            searchExpressions(elem,data.ks,prop);\\r\\n        }\\r\\n        if(prop.k){\\r\\n            elem.addDynamicProperty(prop);\\r\\n        }\\r\\n        return prop;\\r\\n    };\\r\\n\\r\\n    var propertyGetTextProp = TextSelectorProp.getTextSelectorProp;\\r\\n    TextSelectorProp.getTextSelectorProp = function(elem, data,arr){\\r\\n        if(data.t === 1){\\r\\n            return new TextExpressionSelectorProp(elem, data,arr);\\r\\n        } else {\\r\\n            return propertyGetTextProp(elem,data,arr);\\r\\n        }\\r\\n    };\\r\\n}());\\n(function addDecorator() {\\r\\n\\r\\n    function searchExpressions(){\\r\\n        if(this.data.d.x){\\r\\n            this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem,this.data.d,this);\\r\\n            this.addEffect(this.getExpressionValue.bind(this));\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    TextProperty.prototype.getExpressionValue = function(currentValue, text) {\\r\\n        var newValue = this.calculateExpression(text);\\r\\n        if(currentValue.t !== newValue) {\\r\\n            var newData = {};\\r\\n            this.copyData(newData, currentValue);\\r\\n            newData.t = newValue.toString();\\r\\n            newData.__complete = false;\\r\\n            return newData;\\r\\n        }\\r\\n        return currentValue;\\r\\n    }\\r\\n\\r\\n    TextProperty.prototype.searchProperty = function(){\\r\\n\\r\\n        var isKeyframed = this.searchKeyframes();\\r\\n        var hasExpressions = this.searchExpressions();\\r\\n        this.kf = isKeyframed || hasExpressions;\\r\\n        return this.kf;\\r\\n    };\\r\\n\\r\\n    TextProperty.prototype.searchExpressions = searchExpressions;\\r\\n    \\r\\n}());\\nvar ShapeExpressionInterface = (function(){\\r\\n\\r\\n    function iterateElements(shapes,view, propertyGroup){\\r\\n        var arr = [];\\r\\n        var i, len = shapes ? shapes.length : 0;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            if(shapes[i].ty == 'gr'){\\r\\n                arr.push(groupInterfaceFactory(shapes[i],view[i],propertyGroup));\\r\\n            }else if(shapes[i].ty == 'fl'){\\r\\n                arr.push(fillInterfaceFactory(shapes[i],view[i],propertyGroup));\\r\\n            }else if(shapes[i].ty == 'st'){\\r\\n                arr.push(strokeInterfaceFactory(shapes[i],view[i],propertyGroup));\\r\\n            }else if(shapes[i].ty == 'tm'){\\r\\n                arr.push(trimInterfaceFactory(shapes[i],view[i],propertyGroup));\\r\\n            }else if(shapes[i].ty == 'tr'){\\r\\n                //arr.push(transformInterfaceFactory(shapes[i],view[i],propertyGroup));\\r\\n            }else if(shapes[i].ty == 'el'){\\r\\n                arr.push(ellipseInterfaceFactory(shapes[i],view[i],propertyGroup));\\r\\n            }else if(shapes[i].ty == 'sr'){\\r\\n                arr.push(starInterfaceFactory(shapes[i],view[i],propertyGroup));\\r\\n            } else if(shapes[i].ty == 'sh'){\\r\\n                arr.push(pathInterfaceFactory(shapes[i],view[i],propertyGroup));\\r\\n            } else if(shapes[i].ty == 'rc'){\\r\\n                arr.push(rectInterfaceFactory(shapes[i],view[i],propertyGroup));\\r\\n            } else if(shapes[i].ty == 'rd'){\\r\\n                arr.push(roundedInterfaceFactory(shapes[i],view[i],propertyGroup));\\r\\n            } else if(shapes[i].ty == 'rp'){\\r\\n                arr.push(repeaterInterfaceFactory(shapes[i],view[i],propertyGroup));\\r\\n            }\\r\\n        }\\r\\n        return arr;\\r\\n    }\\r\\n\\r\\n    function contentsInterfaceFactory(shape,view, propertyGroup){\\r\\n       var interfaces;\\r\\n       var interfaceFunction = function _interfaceFunction(value){\\r\\n           var i = 0, len = interfaces.length;\\r\\n            while(i<len){\\r\\n                if(interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value){\\r\\n                   return interfaces[i];\\r\\n                }\\r\\n                i+=1;\\r\\n            }\\r\\n            if(typeof value === 'number'){\\r\\n               return interfaces[value-1];\\r\\n            }\\r\\n       };\\r\\n       interfaceFunction.propertyGroup = function(val){\\r\\n           if(val === 1){\\r\\n               return interfaceFunction;\\r\\n           } else{\\r\\n               return propertyGroup(val-1);\\r\\n           }\\r\\n       };\\r\\n       interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);\\r\\n       interfaceFunction.numProperties = interfaces.length;\\r\\n       interfaceFunction.propertyIndex = shape.cix;\\r\\n       interfaceFunction._name = shape.nm;\\r\\n\\r\\n       return interfaceFunction;\\r\\n   }\\r\\n\\r\\n    function groupInterfaceFactory(shape,view, propertyGroup){\\r\\n        var interfaceFunction = function _interfaceFunction(value){\\r\\n            switch(value){\\r\\n                case 'ADBE Vectors Group':\\r\\n                case 'Contents':\\r\\n                case 2:\\r\\n                    return interfaceFunction.content;\\r\\n                //Not necessary for now. Keeping them here in case a new case appears\\r\\n                //case 'ADBE Vector Transform Group':\\r\\n                //case 3:\\r\\n                default:\\r\\n                    return interfaceFunction.transform;\\r\\n            }\\r\\n        };\\r\\n        interfaceFunction.propertyGroup = function(val){\\r\\n            if(val === 1){\\r\\n                return interfaceFunction;\\r\\n            } else{\\r\\n                return propertyGroup(val-1);\\r\\n            }\\r\\n        };\\r\\n        var content = contentsInterfaceFactory(shape,view,interfaceFunction.propertyGroup);\\r\\n        var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1],view.it[view.it.length - 1],interfaceFunction.propertyGroup);\\r\\n        interfaceFunction.content = content;\\r\\n        interfaceFunction.transform = transformInterface;\\r\\n        Object.defineProperty(interfaceFunction, '_name', {\\r\\n            get: function(){\\r\\n                return shape.nm;\\r\\n            }\\r\\n        });\\r\\n        //interfaceFunction.content = interfaceFunction;\\r\\n        interfaceFunction.numProperties = shape.np;\\r\\n        interfaceFunction.propertyIndex = shape.ix;\\r\\n        interfaceFunction.nm = shape.nm;\\r\\n        interfaceFunction.mn = shape.mn;\\r\\n        return interfaceFunction;\\r\\n    }\\r\\n\\r\\n    function fillInterfaceFactory(shape,view,propertyGroup){\\r\\n        function interfaceFunction(val){\\r\\n            if(val === 'Color' || val === 'color'){\\r\\n                return interfaceFunction.color;\\r\\n            } else if(val === 'Opacity' || val === 'opacity'){\\r\\n                return interfaceFunction.opacity;\\r\\n            }\\r\\n        }\\r\\n        Object.defineProperties(interfaceFunction, {\\r\\n            'color': {\\r\\n                get: function() {\\r\\n                    return ExpressionValue(view.c, 1 / view.c.mult, 'color');\\r\\n                }\\r\\n            },\\r\\n            'opacity': {\\r\\n                get: function() {\\r\\n                    return ExpressionValue(view.o, 100);\\r\\n                }\\r\\n            },\\r\\n            '_name': { value: shape.nm },\\r\\n            'mn': { value: shape.mn }\\r\\n        });\\r\\n\\r\\n        view.c.setGroupProperty(propertyGroup);\\r\\n        view.o.setGroupProperty(propertyGroup);\\r\\n        return interfaceFunction;\\r\\n    }\\r\\n\\r\\n    function strokeInterfaceFactory(shape,view,propertyGroup){\\r\\n        function _propertyGroup(val){\\r\\n            if(val === 1){\\r\\n                return ob;\\r\\n            } else{\\r\\n                return propertyGroup(val-1);\\r\\n            }\\r\\n        }\\r\\n        function _dashPropertyGroup(val){\\r\\n            if(val === 1){\\r\\n                return dashOb;\\r\\n            } else{\\r\\n                return _propertyGroup(val-1);\\r\\n            }\\r\\n        }\\r\\n        function addPropertyToDashOb(i) {\\r\\n            Object.defineProperty(dashOb, shape.d[i].nm, {\\r\\n                get: function(){\\r\\n                    return ExpressionValue(view.d.dataProps[i].p);\\r\\n                }\\r\\n            });\\r\\n        }\\r\\n        var i, len = shape.d ? shape.d.length : 0;\\r\\n        var dashOb = {};\\r\\n        for (i = 0; i < len; i += 1) {\\r\\n            addPropertyToDashOb(i);\\r\\n            view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);\\r\\n        }\\r\\n\\r\\n        function interfaceFunction(val){\\r\\n            if(val === 'Color' || val === 'color'){\\r\\n                return interfaceFunction.color;\\r\\n            } else if(val === 'Opacity' || val === 'opacity'){\\r\\n                return interfaceFunction.opacity;\\r\\n            } else if(val === 'Stroke Width' || val === 'stroke width'){\\r\\n                return interfaceFunction.strokeWidth;\\r\\n            }\\r\\n        }\\r\\n        Object.defineProperties(interfaceFunction, {\\r\\n            'color': {\\r\\n                get: function() {\\r\\n                    return ExpressionValue(view.c, 1 / view.c.mult, 'color');\\r\\n                }\\r\\n            },\\r\\n            'opacity': {\\r\\n                get: function() {\\r\\n                    return ExpressionValue(view.o, 100);\\r\\n                }\\r\\n            },\\r\\n            'strokeWidth': {\\r\\n                get: function() {\\r\\n                    return ExpressionValue(view.w);\\r\\n                }\\r\\n            },\\r\\n            'dash': {\\r\\n                get: function() {\\r\\n                    return dashOb;\\r\\n                }\\r\\n            },\\r\\n            '_name': { value: shape.nm },\\r\\n            'mn': { value: shape.mn }\\r\\n        });\\r\\n\\r\\n        view.c.setGroupProperty(_propertyGroup);\\r\\n        view.o.setGroupProperty(_propertyGroup);\\r\\n        view.w.setGroupProperty(_propertyGroup);\\r\\n        return interfaceFunction;\\r\\n    }\\r\\n\\r\\n    function trimInterfaceFactory(shape,view,propertyGroup){\\r\\n        function _propertyGroup(val){\\r\\n            if(val == 1){\\r\\n                return interfaceFunction;\\r\\n            } else {\\r\\n                return propertyGroup(--val);\\r\\n            }\\r\\n        }\\r\\n        interfaceFunction.propertyIndex = shape.ix;\\r\\n\\r\\n        view.s.setGroupProperty(_propertyGroup);\\r\\n        view.e.setGroupProperty(_propertyGroup);\\r\\n        view.o.setGroupProperty(_propertyGroup);\\r\\n\\r\\n        function interfaceFunction(val){\\r\\n            if(val === shape.e.ix || val === 'End' || val === 'end'){\\r\\n                return interfaceFunction.end;\\r\\n            }\\r\\n            if(val === shape.s.ix){\\r\\n                return interfaceFunction.start;\\r\\n            }\\r\\n            if(val === shape.o.ix){\\r\\n                return interfaceFunction.offset;\\r\\n            }\\r\\n        }\\r\\n        interfaceFunction.propertyIndex = shape.ix;\\r\\n\\r\\n        Object.defineProperties(interfaceFunction, {\\r\\n            'start': {\\r\\n                get: function() {\\r\\n                    return ExpressionValue(view.s, 1 / view.s.mult);\\r\\n                }\\r\\n            },\\r\\n            'end': {\\r\\n                get: function() {\\r\\n                    return ExpressionValue(view.e, 1 / view.e.mult);\\r\\n                }\\r\\n            },\\r\\n            'offset': {\\r\\n                get: function() {\\r\\n                    return ExpressionValue(view.o);\\r\\n                }\\r\\n            },\\r\\n            '_name': { value: shape.nm }\\r\\n        });\\r\\n        interfaceFunction.mn = shape.mn;\\r\\n        return interfaceFunction;\\r\\n    }\\r\\n\\r\\n    function transformInterfaceFactory(shape,view,propertyGroup){\\r\\n        function _propertyGroup(val){\\r\\n            if(val == 1){\\r\\n                return interfaceFunction;\\r\\n            } else {\\r\\n                return propertyGroup(--val);\\r\\n            }\\r\\n        }\\r\\n        view.transform.mProps.o.setGroupProperty(_propertyGroup);\\r\\n        view.transform.mProps.p.setGroupProperty(_propertyGroup);\\r\\n        view.transform.mProps.a.setGroupProperty(_propertyGroup);\\r\\n        view.transform.mProps.s.setGroupProperty(_propertyGroup);\\r\\n        view.transform.mProps.r.setGroupProperty(_propertyGroup);\\r\\n        if(view.transform.mProps.sk){\\r\\n            view.transform.mProps.sk.setGroupProperty(_propertyGroup);\\r\\n            view.transform.mProps.sa.setGroupProperty(_propertyGroup);\\r\\n        }\\r\\n        view.transform.op.setGroupProperty(_propertyGroup);\\r\\n\\r\\n        function interfaceFunction(value){\\r\\n            if(shape.a.ix === value || value === 'Anchor Point'){\\r\\n                return interfaceFunction.anchorPoint;\\r\\n            }\\r\\n            if(shape.o.ix === value || value === 'Opacity'){\\r\\n                return interfaceFunction.opacity;\\r\\n            }\\r\\n            if(shape.p.ix === value || value === 'Position'){\\r\\n                return interfaceFunction.position;\\r\\n            }\\r\\n            if(shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation'){\\r\\n                return interfaceFunction.rotation;\\r\\n            }\\r\\n            if(shape.s.ix === value || value === 'Scale'){\\r\\n                return interfaceFunction.scale;\\r\\n            }\\r\\n            if(shape.sk && shape.sk.ix === value || value === 'Skew'){\\r\\n                return interfaceFunction.skew;\\r\\n            }\\r\\n            if(shape.sa && shape.sa.ix === value || value === 'Skew Axis'){\\r\\n                return interfaceFunction.skewAxis;\\r\\n            }\\r\\n\\r\\n        }\\r\\n        Object.defineProperties(interfaceFunction, {\\r\\n            'opacity': {\\r\\n                get: function(){\\r\\n                    return ExpressionValue(view.transform.mProps.o, 1/view.transform.mProps.o.mult);\\r\\n                }\\r\\n            },\\r\\n            'position': {\\r\\n                get: function(){\\r\\n                    return ExpressionValue(view.transform.mProps.p);\\r\\n                }\\r\\n            },\\r\\n            'anchorPoint': {\\r\\n                get: function(){\\r\\n                    return ExpressionValue(view.transform.mProps.a);\\r\\n                }\\r\\n            },\\r\\n            'scale': {\\r\\n                get: function(){\\r\\n                    return ExpressionValue(view.transform.mProps.s, 1 / view.transform.mProps.s.mult);\\r\\n                }\\r\\n            },\\r\\n            'rotation': {\\r\\n                get: function(){\\r\\n                    return ExpressionValue(view.transform.mProps.r, 1 / view.transform.mProps.r.mult);\\r\\n                }\\r\\n            },\\r\\n            'skew': {\\r\\n                get: function(){\\r\\n                    return ExpressionValue(view.transform.mProps.sk);\\r\\n                }\\r\\n            },\\r\\n            'skewAxis': {\\r\\n                get: function(){\\r\\n                    return ExpressionValue(view.transform.mProps.sa);\\r\\n                }\\r\\n            },\\r\\n            '_name': { value: shape.nm }\\r\\n        });\\r\\n        interfaceFunction.ty = 'tr';\\r\\n        interfaceFunction.mn = shape.mn;\\r\\n        return interfaceFunction;\\r\\n    }\\r\\n\\r\\n    function ellipseInterfaceFactory(shape,view,propertyGroup){\\r\\n        function _propertyGroup(val){\\r\\n            if(val == 1){\\r\\n                return interfaceFunction;\\r\\n            } else {\\r\\n                return propertyGroup(--val);\\r\\n            }\\r\\n        }\\r\\n        interfaceFunction.propertyIndex = shape.ix;\\r\\n        var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;\\r\\n        prop.s.setGroupProperty(_propertyGroup);\\r\\n        prop.p.setGroupProperty(_propertyGroup);\\r\\n        function interfaceFunction(value){\\r\\n            if(shape.p.ix === value){\\r\\n                return interfaceFunction.position;\\r\\n            }\\r\\n            if(shape.s.ix === value){\\r\\n                return interfaceFunction.size;\\r\\n            }\\r\\n        }\\r\\n        Object.defineProperties(interfaceFunction, {\\r\\n            'size': {\\r\\n                get: function(){\\r\\n                    return ExpressionValue(prop.s);\\r\\n                }\\r\\n            },\\r\\n            'position': {\\r\\n                get: function(){\\r\\n                    return ExpressionValue(prop.p);\\r\\n                }\\r\\n            },\\r\\n            '_name': { value: shape.nm }\\r\\n        });\\r\\n        interfaceFunction.mn = shape.mn;\\r\\n        return interfaceFunction;\\r\\n    }\\r\\n\\r\\n    function starInterfaceFactory(shape,view,propertyGroup){\\r\\n        function _propertyGroup(val){\\r\\n            if(val == 1){\\r\\n                return interfaceFunction;\\r\\n            } else {\\r\\n                return propertyGroup(--val);\\r\\n            }\\r\\n        }\\r\\n        var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;\\r\\n        interfaceFunction.propertyIndex = shape.ix;\\r\\n        prop.or.setGroupProperty(_propertyGroup);\\r\\n        prop.os.setGroupProperty(_propertyGroup);\\r\\n        prop.pt.setGroupProperty(_propertyGroup);\\r\\n        prop.p.setGroupProperty(_propertyGroup);\\r\\n        prop.r.setGroupProperty(_propertyGroup);\\r\\n        if(shape.ir){\\r\\n            prop.ir.setGroupProperty(_propertyGroup);\\r\\n            prop.is.setGroupProperty(_propertyGroup);\\r\\n        }\\r\\n\\r\\n        function interfaceFunction(value){\\r\\n            if(shape.p.ix === value){\\r\\n                return interfaceFunction.position;\\r\\n            }\\r\\n            if(shape.r.ix === value){\\r\\n                return interfaceFunction.rotation;\\r\\n            }\\r\\n            if(shape.pt.ix === value){\\r\\n                return interfaceFunction.points;\\r\\n            }\\r\\n            if(shape.or.ix === value || 'ADBE Vector Star Outer Radius' === value){\\r\\n                return interfaceFunction.outerRadius;\\r\\n            }\\r\\n            if(shape.os.ix === value){\\r\\n                return interfaceFunction.outerRoundness;\\r\\n            }\\r\\n            if(shape.ir && (shape.ir.ix === value || 'ADBE Vector Star Inner Radius' === value)){\\r\\n                return interfaceFunction.innerRadius;\\r\\n            }\\r\\n            if(shape.is && shape.is.ix === value){\\r\\n                return interfaceFunction.innerRoundness;\\r\\n            }\\r\\n\\r\\n        }\\r\\n        Object.defineProperties(interfaceFunction, {\\r\\n            'position': {\\r\\n                get: function() {\\r\\n                    return ExpressionValue(prop.p);\\r\\n                }\\r\\n            },\\r\\n            'rotation': {\\r\\n                get: function() {\\r\\n                    return ExpressionValue(prop.r, 1 / prop.r.mult);\\r\\n                }\\r\\n            },\\r\\n            'points': {\\r\\n                get: function() {\\r\\n                    return ExpressionValue(prop.pt);\\r\\n                }\\r\\n            },\\r\\n            'outerRadius': {\\r\\n                get: function() {\\r\\n                    return ExpressionValue(prop.or);\\r\\n                }\\r\\n            },\\r\\n            'outerRoundness': {\\r\\n                get: function(){\\r\\n                    return ExpressionValue(prop.os);\\r\\n                }\\r\\n            },\\r\\n            'innerRadius': {\\r\\n                get: function(){\\r\\n                    if(!prop.ir){\\r\\n                        return 0;\\r\\n                    }\\r\\n                    return ExpressionValue(prop.ir);\\r\\n                }\\r\\n            },\\r\\n            'innerRoundness': {\\r\\n                get: function(){\\r\\n                    if(!prop.is){\\r\\n                        return 0;\\r\\n                    }\\r\\n                    return ExpressionValue(prop.is, 1 / prop.is.mult);\\r\\n                }\\r\\n            },\\r\\n            '_name': { value: shape.nm }\\r\\n        });\\r\\n        interfaceFunction.mn = shape.mn;\\r\\n        return interfaceFunction;\\r\\n    }\\r\\n\\r\\n    function rectInterfaceFactory(shape,view,propertyGroup){\\r\\n        function _propertyGroup(val){\\r\\n            if(val == 1){\\r\\n                return interfaceFunction;\\r\\n            } else {\\r\\n                return propertyGroup(--val);\\r\\n            }\\r\\n        }\\r\\n        var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;\\r\\n        interfaceFunction.propertyIndex = shape.ix;\\r\\n        prop.p.setGroupProperty(_propertyGroup);\\r\\n        prop.s.setGroupProperty(_propertyGroup);\\r\\n        prop.r.setGroupProperty(_propertyGroup);\\r\\n\\r\\n        function interfaceFunction(value){\\r\\n            if(shape.p.ix === value){\\r\\n                return interfaceFunction.position;\\r\\n            }\\r\\n            if(shape.r.ix === value){\\r\\n                return interfaceFunction.roundness;\\r\\n            }\\r\\n            if(shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size'){\\r\\n                return interfaceFunction.size;\\r\\n            }\\r\\n\\r\\n        }\\r\\n        Object.defineProperties(interfaceFunction, {\\r\\n            'position': {\\r\\n                get: function(){\\r\\n                    return ExpressionValue(prop.p);\\r\\n                }\\r\\n            },\\r\\n            'roundness': {\\r\\n                get: function(){\\r\\n                    return ExpressionValue(prop.r);\\r\\n                }\\r\\n            },\\r\\n            'size': {\\r\\n                get: function(){\\r\\n                    return ExpressionValue(prop.s);\\r\\n                }\\r\\n            },\\r\\n            '_name': { value: shape.nm }\\r\\n        });\\r\\n        interfaceFunction.mn = shape.mn;\\r\\n        return interfaceFunction;\\r\\n    }\\r\\n\\r\\n    function roundedInterfaceFactory(shape,view,propertyGroup){\\r\\n        function _propertyGroup(val){\\r\\n            if(val == 1){\\r\\n                return interfaceFunction;\\r\\n            } else {\\r\\n                return propertyGroup(--val);\\r\\n            }\\r\\n        }\\r\\n        var prop = view;\\r\\n        interfaceFunction.propertyIndex = shape.ix;\\r\\n        prop.rd.setGroupProperty(_propertyGroup);\\r\\n\\r\\n        function interfaceFunction(value){\\r\\n            if(shape.r.ix === value || 'Round Corners 1' === value){\\r\\n                return interfaceFunction.radius;\\r\\n            }\\r\\n\\r\\n        }\\r\\n        Object.defineProperties(interfaceFunction, {\\r\\n            'radius': {\\r\\n                get: function() {\\r\\n                    return ExpressionValue(prop.rd);\\r\\n                }\\r\\n            },\\r\\n            '_name': { value: shape.nm }\\r\\n        });\\r\\n        interfaceFunction.mn = shape.mn;\\r\\n        return interfaceFunction;\\r\\n    }\\r\\n\\r\\n    function repeaterInterfaceFactory(shape,view,propertyGroup){\\r\\n        function _propertyGroup(val){\\r\\n            if(val == 1){\\r\\n                return interfaceFunction;\\r\\n            } else {\\r\\n                return propertyGroup(--val);\\r\\n            }\\r\\n        }\\r\\n        var prop = view;\\r\\n        interfaceFunction.propertyIndex = shape.ix;\\r\\n        prop.c.setGroupProperty(_propertyGroup);\\r\\n        prop.o.setGroupProperty(_propertyGroup);\\r\\n\\r\\n        function interfaceFunction(value){\\r\\n            if(shape.c.ix === value || 'Copies' === value){\\r\\n                return interfaceFunction.copies;\\r\\n            } else if(shape.o.ix === value || 'Offset' === value){\\r\\n                return interfaceFunction.offset;\\r\\n            }\\r\\n\\r\\n        }\\r\\n        Object.defineProperties(interfaceFunction, {\\r\\n            'copies': {\\r\\n                get: function(){\\r\\n                    return ExpressionValue(prop.c);\\r\\n                }\\r\\n            },\\r\\n            'offset': {\\r\\n                get: function(){\\r\\n                    return ExpressionValue(prop.o);\\r\\n                }\\r\\n            },\\r\\n            '_name': { value: shape.nm }\\r\\n        });\\r\\n        interfaceFunction.mn = shape.mn;\\r\\n        return interfaceFunction;\\r\\n    }\\r\\n\\r\\n    function pathInterfaceFactory(shape,view,propertyGroup){\\r\\n        var prop = view.sh;\\r\\n        function _propertyGroup(val){\\r\\n            if(val == 1){\\r\\n                return interfaceFunction;\\r\\n            } else {\\r\\n                return propertyGroup(--val);\\r\\n            }\\r\\n        }\\r\\n        prop.setGroupProperty(_propertyGroup);\\r\\n\\r\\n        function interfaceFunction(val){\\r\\n            if(val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2){\\r\\n                return interfaceFunction.path;\\r\\n            }\\r\\n        }\\r\\n        Object.defineProperties(interfaceFunction, {\\r\\n            'path': {\\r\\n                get: function(){\\r\\n                    if(prop.k){\\r\\n                        prop.getValue();\\r\\n                    }\\r\\n                    return prop;\\r\\n                }\\r\\n            },\\r\\n            'shape': {\\r\\n                get: function(){\\r\\n                    if(prop.k){\\r\\n                        prop.getValue();\\r\\n                    }\\r\\n                    return prop;\\r\\n                }\\r\\n            },\\r\\n            '_name': { value: shape.nm },\\r\\n            'ix': { value: shape.ix },\\r\\n            'mn': { value: shape.mn }\\r\\n        });\\r\\n        return interfaceFunction;\\r\\n    }\\r\\n\\r\\n    return function(shapes,view,propertyGroup) {\\r\\n        var interfaces;\\r\\n        function _interfaceFunction(value){\\r\\n            if(typeof value === 'number'){\\r\\n                return interfaces[value-1];\\r\\n            } else {\\r\\n                var i = 0, len = interfaces.length;\\r\\n                while(i<len){\\r\\n                    if(interfaces[i]._name === value){\\r\\n                        return interfaces[i];\\r\\n                    }\\r\\n                    i+=1;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        _interfaceFunction.propertyGroup = propertyGroup;\\r\\n        interfaces = iterateElements(shapes, view, _interfaceFunction);\\r\\n        return _interfaceFunction;\\r\\n    };\\r\\n}());\\r\\n\\nvar TextExpressionInterface = (function(){\\r\\n\\treturn function(elem){\\r\\n        var _prevValue, _sourceText;\\r\\n        function _thisLayerFunction(){\\r\\n        }\\r\\n        Object.defineProperty(_thisLayerFunction, \\\"sourceText\\\", {\\r\\n            get: function(){\\r\\n                var stringValue = elem.textProperty.currentData.t;\\r\\n                if(stringValue !== _prevValue) {\\r\\n                    elem.textProperty.currentData.t = _prevValue;\\r\\n                    _sourceText = new String(stringValue);\\r\\n                    //If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive\\r\\n                    _sourceText.value = stringValue ? stringValue : new String(stringValue);\\r\\n                }\\r\\n                return _sourceText;\\r\\n            }\\r\\n        });\\r\\n        return _thisLayerFunction;\\r\\n    };\\r\\n}());\\nvar LayerExpressionInterface = (function (){\\r\\n    function toWorld(arr, time){\\r\\n        var toWorldMat = new Matrix();\\r\\n        toWorldMat.reset();\\r\\n        var transformMat;\\r\\n        if(time) {\\r\\n            //Todo implement value at time on transform properties\\r\\n            //transformMat = this._elem.finalTransform.mProp.getValueAtTime(time);\\r\\n            transformMat = this._elem.finalTransform.mProp;\\r\\n        } else {\\r\\n            transformMat = this._elem.finalTransform.mProp;\\r\\n        }\\r\\n        transformMat.applyToMatrix(toWorldMat);\\r\\n        if(this._elem.hierarchy && this._elem.hierarchy.length){\\r\\n            var i, len = this._elem.hierarchy.length;\\r\\n            for(i=0;i<len;i+=1){\\r\\n                this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);\\r\\n            }\\r\\n            return toWorldMat.applyToPointArray(arr[0],arr[1],arr[2]||0);\\r\\n        }\\r\\n        return toWorldMat.applyToPointArray(arr[0],arr[1],arr[2]||0);\\r\\n    }\\r\\n    function fromWorld(arr, time){\\r\\n        var toWorldMat = new Matrix();\\r\\n        toWorldMat.reset();\\r\\n        var transformMat;\\r\\n        if(time) {\\r\\n            //Todo implement value at time on transform properties\\r\\n            //transformMat = this._elem.finalTransform.mProp.getValueAtTime(time);\\r\\n            transformMat = this._elem.finalTransform.mProp;\\r\\n        } else {\\r\\n            transformMat = this._elem.finalTransform.mProp;\\r\\n        }\\r\\n        transformMat.applyToMatrix(toWorldMat);\\r\\n        if(this._elem.hierarchy && this._elem.hierarchy.length){\\r\\n            var i, len = this._elem.hierarchy.length;\\r\\n            for(i=0;i<len;i+=1){\\r\\n                this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);\\r\\n            }\\r\\n            return toWorldMat.inversePoint(arr);\\r\\n        }\\r\\n        return toWorldMat.inversePoint(arr);\\r\\n    }\\r\\n    function fromComp(arr){\\r\\n        var toWorldMat = new Matrix();\\r\\n        toWorldMat.reset();\\r\\n        this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);\\r\\n        if(this._elem.hierarchy && this._elem.hierarchy.length){\\r\\n            var i, len = this._elem.hierarchy.length;\\r\\n            for(i=0;i<len;i+=1){\\r\\n                this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);\\r\\n            }\\r\\n            return toWorldMat.inversePoint(arr);\\r\\n        }\\r\\n        return toWorldMat.inversePoint(arr);\\r\\n    }\\r\\n\\r\\n    function sampleImage() {\\r\\n        return [1,1,1,1];\\r\\n    }\\r\\n\\r\\n\\r\\n    return function(elem){\\r\\n\\r\\n        var transformInterface;\\r\\n\\r\\n        function _registerMaskInterface(maskManager){\\r\\n            _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);\\r\\n        }\\r\\n        function _registerEffectsInterface(effects){\\r\\n            _thisLayerFunction.effect = effects;\\r\\n        }\\r\\n\\r\\n        function _thisLayerFunction(name){\\r\\n            switch(name){\\r\\n                case \\\"ADBE Root Vectors Group\\\":\\r\\n                case \\\"Contents\\\":\\r\\n                case 2:\\r\\n                    return _thisLayerFunction.shapeInterface;\\r\\n                case 1:\\r\\n                case 6:\\r\\n                case \\\"Transform\\\":\\r\\n                case \\\"transform\\\":\\r\\n                case \\\"ADBE Transform Group\\\":\\r\\n                    return transformInterface;\\r\\n                case 4:\\r\\n                case \\\"ADBE Effect Parade\\\":\\r\\n                    return _thisLayerFunction.effect;\\r\\n            }\\r\\n        }\\r\\n        _thisLayerFunction.toWorld = toWorld;\\r\\n        _thisLayerFunction.fromWorld = fromWorld;\\r\\n        _thisLayerFunction.toComp = toWorld;\\r\\n        _thisLayerFunction.fromComp = fromComp;\\r\\n        _thisLayerFunction.sampleImage = sampleImage;\\r\\n        _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);\\r\\n        _thisLayerFunction._elem = elem;\\r\\n        transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);\\r\\n        var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint');\\r\\n        Object.defineProperties(_thisLayerFunction,{\\r\\n            hasParent: {\\r\\n                get: function(){\\r\\n                    return elem.hierarchy.length;\\r\\n                }\\r\\n            },\\r\\n            parent: {\\r\\n                get: function(){\\r\\n                    return elem.hierarchy[0].layerInterface;\\r\\n                }\\r\\n            },\\r\\n            rotation: getDescriptor(transformInterface, 'rotation'),\\r\\n            scale: getDescriptor(transformInterface, 'scale'),\\r\\n            position: getDescriptor(transformInterface, 'position'),\\r\\n            opacity: getDescriptor(transformInterface, 'opacity'),\\r\\n            anchorPoint: anchorPointDescriptor,\\r\\n            anchor_point: anchorPointDescriptor,\\r\\n            transform: {\\r\\n                get: function () {\\r\\n                    return transformInterface;\\r\\n                }\\r\\n            },\\r\\n            active: {\\r\\n                get: function(){\\r\\n                    return elem.isInRange;\\r\\n                }\\r\\n            }\\r\\n        });\\r\\n\\r\\n        _thisLayerFunction.startTime = elem.data.st;\\r\\n        _thisLayerFunction.index = elem.data.ind;\\r\\n        _thisLayerFunction.source = elem.data.refId;\\r\\n        _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;\\r\\n        _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;\\r\\n        _thisLayerFunction.inPoint = elem.data.ip/elem.comp.globalData.frameRate;\\r\\n        _thisLayerFunction.outPoint = elem.data.op/elem.comp.globalData.frameRate;\\r\\n        _thisLayerFunction._name = elem.data.nm;\\r\\n\\r\\n        _thisLayerFunction.registerMaskInterface = _registerMaskInterface;\\r\\n        _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;\\r\\n        return _thisLayerFunction;\\r\\n    };\\r\\n}());\\r\\n\\nvar CompExpressionInterface = (function (){\\r\\n    return function(comp){\\r\\n        function _thisLayerFunction(name){\\r\\n            var i=0, len = comp.layers.length;\\r\\n            while(i<len){\\r\\n                if(comp.layers[i].nm === name || comp.layers[i].ind === name){\\r\\n                    return comp.elements[i].layerInterface;\\r\\n                }\\r\\n                i += 1;\\r\\n            }\\r\\n            return null;\\r\\n            //return {active:false};\\r\\n        }\\r\\n        Object.defineProperty(_thisLayerFunction, \\\"_name\\\", { value:comp.data.nm });\\r\\n        _thisLayerFunction.layer = _thisLayerFunction;\\r\\n        _thisLayerFunction.pixelAspect = 1;\\r\\n        _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;\\r\\n        _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;\\r\\n        _thisLayerFunction.pixelAspect = 1;\\r\\n        _thisLayerFunction.frameDuration = 1/comp.globalData.frameRate;\\r\\n        _thisLayerFunction.numLayers = comp.layers.length;\\r\\n        return _thisLayerFunction;\\r\\n    };\\r\\n}());\\nvar TransformExpressionInterface = (function (){\\r\\n    return function(transform){\\r\\n        function _thisFunction(name){\\r\\n            switch(name){\\r\\n                case \\\"scale\\\":\\r\\n                case \\\"Scale\\\":\\r\\n                case \\\"ADBE Scale\\\":\\r\\n                case 6:\\r\\n                    return _thisFunction.scale;\\r\\n                case \\\"rotation\\\":\\r\\n                case \\\"Rotation\\\":\\r\\n                case \\\"ADBE Rotation\\\":\\r\\n                case \\\"ADBE Rotate Z\\\":\\r\\n                case 10:\\r\\n                    return _thisFunction.rotation;\\r\\n                case \\\"ADBE Rotate X\\\":\\r\\n                    return _thisFunction.xRotation;\\r\\n                case \\\"ADBE Rotate Y\\\":\\r\\n                    return _thisFunction.yRotation;\\r\\n                case \\\"position\\\":\\r\\n                case \\\"Position\\\":\\r\\n                case \\\"ADBE Position\\\":\\r\\n                case 2:\\r\\n                    return _thisFunction.position;\\r\\n                case 'ADBE Position_0':\\r\\n                    return _thisFunction.xPosition;\\r\\n                case 'ADBE Position_1':\\r\\n                    return _thisFunction.yPosition;\\r\\n                case 'ADBE Position_2':\\r\\n                    return _thisFunction.zPosition;\\r\\n                case \\\"anchorPoint\\\":\\r\\n                case \\\"AnchorPoint\\\":\\r\\n                case \\\"Anchor Point\\\":\\r\\n                case \\\"ADBE AnchorPoint\\\":\\r\\n                case 1:\\r\\n                    return _thisFunction.anchorPoint;\\r\\n                case \\\"opacity\\\":\\r\\n                case \\\"Opacity\\\":\\r\\n                case 11:\\r\\n                    return _thisFunction.opacity;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        Object.defineProperty(_thisFunction, \\\"rotation\\\", {\\r\\n            get: function(){\\r\\n                if(transform.r) {\\r\\n                    return ExpressionValue(transform.r, 1/degToRads);\\r\\n                } else {\\r\\n                    return ExpressionValue(transform.rz, 1/degToRads);\\r\\n                }\\r\\n            }\\r\\n        });\\r\\n\\r\\n        Object.defineProperty(_thisFunction, \\\"xRotation\\\", {\\r\\n            get: function(){\\r\\n                    return ExpressionValue(transform.rx, 1/degToRads);\\r\\n            }\\r\\n        });\\r\\n\\r\\n        Object.defineProperty(_thisFunction, \\\"yRotation\\\", {\\r\\n            get: function(){\\r\\n                    return ExpressionValue(transform.ry, 1/degToRads);\\r\\n            }\\r\\n        });\\r\\n        Object.defineProperty(_thisFunction, \\\"scale\\\", {\\r\\n            get: function () {\\r\\n                return ExpressionValue(transform.s, 100);\\r\\n            }\\r\\n        });\\r\\n\\r\\n        Object.defineProperty(_thisFunction, \\\"position\\\", {\\r\\n            get: function () {\\r\\n                if(transform.p) {\\r\\n                    return ExpressionValue(transform.p);\\r\\n                } else {\\r\\n                    return [transform.px.v, transform.py.v, transform.pz ? transform.pz.v : 0];\\r\\n                }\\r\\n            }\\r\\n        });\\r\\n\\r\\n        Object.defineProperty(_thisFunction, \\\"xPosition\\\", {\\r\\n            get: function () {\\r\\n                return ExpressionValue(transform.px);\\r\\n            }\\r\\n        });\\r\\n\\r\\n        Object.defineProperty(_thisFunction, \\\"yPosition\\\", {\\r\\n            get: function () {\\r\\n                return ExpressionValue(transform.py);\\r\\n            }\\r\\n        });\\r\\n\\r\\n        Object.defineProperty(_thisFunction, \\\"zPosition\\\", {\\r\\n            get: function () {\\r\\n                return ExpressionValue(transform.pz);\\r\\n            }\\r\\n        });\\r\\n\\r\\n        Object.defineProperty(_thisFunction, \\\"anchorPoint\\\", {\\r\\n            get: function () {\\r\\n                return ExpressionValue(transform.a);\\r\\n            }\\r\\n        });\\r\\n\\r\\n        Object.defineProperty(_thisFunction, \\\"opacity\\\", {\\r\\n            get: function () {\\r\\n                return ExpressionValue(transform.o, 100);\\r\\n            }\\r\\n        });\\r\\n\\r\\n        Object.defineProperty(_thisFunction, \\\"skew\\\", {\\r\\n            get: function () {\\r\\n                return ExpressionValue(transform.sk);\\r\\n            }\\r\\n        });\\r\\n\\r\\n        Object.defineProperty(_thisFunction, \\\"skewAxis\\\", {\\r\\n            get: function () {\\r\\n                return ExpressionValue(transform.sa);\\r\\n            }\\r\\n        });\\r\\n\\r\\n        Object.defineProperty(_thisFunction, \\\"orientation\\\", {\\r\\n            get: function () {\\r\\n                return ExpressionValue(transform.or);\\r\\n            }\\r\\n        });\\r\\n\\r\\n        return _thisFunction;\\r\\n    };\\r\\n}());\\nvar ProjectInterface = (function (){\\r\\n\\r\\n    function registerComposition(comp){\\r\\n        this.compositions.push(comp);\\r\\n    }\\r\\n\\r\\n    return function(){\\r\\n        function _thisProjectFunction(name){\\r\\n            var i = 0, len = this.compositions.length;\\r\\n            while(i<len){\\r\\n                if(this.compositions[i].data && this.compositions[i].data.nm === name){\\r\\n                    if(this.compositions[i].prepareFrame && this.compositions[i].data.xt) {\\r\\n                        this.compositions[i].prepareFrame(this.currentFrame);\\r\\n                    }\\r\\n                    return this.compositions[i].compInterface;\\r\\n                }\\r\\n                i+=1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        _thisProjectFunction.compositions = [];\\r\\n        _thisProjectFunction.currentFrame = 0;\\r\\n\\r\\n        _thisProjectFunction.registerComposition = registerComposition;\\r\\n\\r\\n\\r\\n\\r\\n        return _thisProjectFunction;\\r\\n    };\\r\\n}());\\nvar EffectsExpressionInterface = (function (){\\r\\n    var ob = {\\r\\n        createEffectsInterface: createEffectsInterface\\r\\n    };\\r\\n\\r\\n    function createEffectsInterface(elem, propertyGroup){\\r\\n        if(elem.effectsManager){\\r\\n\\r\\n            var effectElements = [];\\r\\n            var effectsData = elem.data.ef;\\r\\n            var i, len = elem.effectsManager.effectElements.length;\\r\\n            for(i=0;i<len;i+=1){\\r\\n                effectElements.push(createGroupInterface(effectsData[i],elem.effectsManager.effectElements[i],propertyGroup,elem));\\r\\n            }\\r\\n\\r\\n            return function(name){\\r\\n                var effects = elem.data.ef || [], i = 0, len = effects.length;\\r\\n                while(i<len) {\\r\\n                    if(name === effects[i].nm || name === effects[i].mn || name === effects[i].ix){\\r\\n                        return effectElements[i];\\r\\n                    }\\r\\n                    i += 1;\\r\\n                }\\r\\n            };\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function createGroupInterface(data,elements, propertyGroup, elem){\\r\\n        var effectElements = [];\\r\\n        var i, len = data.ef.length;\\r\\n        for(i=0;i<len;i+=1){\\r\\n            if(data.ef[i].ty === 5){\\r\\n                effectElements.push(createGroupInterface(data.ef[i],elements.effectElements[i],elements.effectElements[i].propertyGroup, elem));\\r\\n            } else {\\r\\n                effectElements.push(createValueInterface(elements.effectElements[i],data.ef[i].ty, elem, _propertyGroup));\\r\\n            }\\r\\n        }\\r\\n\\r\\n        function _propertyGroup(val) {\\r\\n            if(val === 1){\\r\\n               return groupInterface;\\r\\n            } else{\\r\\n               return propertyGroup(val-1);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        var groupInterface = function(name){\\r\\n            var effects = data.ef, i = 0, len = effects.length;\\r\\n            while(i<len) {\\r\\n                if(name === effects[i].nm || name === effects[i].mn || name === effects[i].ix){\\r\\n                    if(effects[i].ty === 5){\\r\\n                        return effectElements[i];\\r\\n                    } else {\\r\\n                        return effectElements[i]();\\r\\n                    }\\r\\n                }\\r\\n                i += 1;\\r\\n            }\\r\\n            return effectElements[0]();\\r\\n        };\\r\\n\\r\\n        groupInterface.propertyGroup = _propertyGroup;\\r\\n\\r\\n        if(data.mn === 'ADBE Color Control'){\\r\\n            Object.defineProperty(groupInterface, 'color', {\\r\\n                get: function(){\\r\\n                    return effectElements[0]();\\r\\n                }\\r\\n            });\\r\\n        }\\r\\n        Object.defineProperty(groupInterface, 'numProperties', {\\r\\n            get: function(){\\r\\n                return data.np;\\r\\n            }\\r\\n        });\\r\\n        groupInterface.active = data.en !== 0;\\r\\n        return groupInterface;\\r\\n    }\\r\\n\\r\\n    function createValueInterface(element, type, elem, propertyGroup){\\r\\n        function interfaceFunction(){\\r\\n            if(type === 10){\\r\\n                return elem.comp.compInterface(element.p.v);\\r\\n            }\\r\\n            return ExpressionValue(element.p);\\r\\n        }\\r\\n\\r\\n        if(element.p.setGroupProperty) {\\r\\n            element.p.setGroupProperty(propertyGroup);\\r\\n        }\\r\\n\\r\\n        return interfaceFunction;\\r\\n    }\\r\\n\\r\\n    return ob;\\r\\n\\r\\n}());\\nvar MaskManagerInterface = (function(){\\r\\n\\r\\n\\tfunction MaskInterface(mask, data){\\r\\n\\t\\tthis._mask = mask;\\r\\n\\t\\tthis._data = data;\\r\\n\\t}\\r\\n\\tObject.defineProperty(MaskInterface.prototype, 'maskPath', {\\r\\n        get: function(){\\r\\n                if(this._mask.prop.k){\\r\\n                    this._mask.prop.getValue();\\r\\n                }\\r\\n                return this._mask.prop;\\r\\n            }\\r\\n        });\\r\\n\\r\\n\\tvar MaskManager = function(maskManager, elem){\\r\\n\\t\\tvar _maskManager = maskManager;\\r\\n\\t\\tvar _elem = elem;\\r\\n\\t\\tvar _masksInterfaces = createSizedArray(maskManager.viewData.length);\\r\\n\\t\\tvar i, len = maskManager.viewData.length;\\r\\n\\t\\tfor(i = 0; i < len; i += 1) {\\r\\n\\t\\t\\t_masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tvar maskFunction = function(name){\\r\\n\\t\\t\\ti = 0;\\r\\n\\t\\t    while(i<len){\\r\\n\\t\\t        if(maskManager.masksProperties[i].nm === name){\\r\\n\\t\\t            return _masksInterfaces[i];\\r\\n\\t\\t        }\\r\\n\\t\\t        i += 1;\\r\\n\\t\\t    }\\r\\n\\t\\t};\\r\\n\\t\\treturn maskFunction;\\r\\n\\t};\\r\\n\\treturn MaskManager;\\r\\n}());\\r\\n\\nvar ExpressionValue = (function() {\\r\\n\\treturn function(elementProp, mult, type) {\\r\\n        mult = mult || 1;\\r\\n        var expressionValue, arrayValue;\\r\\n\\r\\n\\t\\tif (elementProp.k) {\\r\\n            elementProp.getValue();\\r\\n        }\\r\\n        var i, len, arrValue, val;\\r\\n        if (type) {\\r\\n        \\tif(type === 'color') {\\r\\n        \\t\\tlen = 4;\\r\\n                expressionValue = createTypedArray('float32', len);\\r\\n                arrValue = createTypedArray('float32', len);\\r\\n\\t\\t        for (i = 0; i < len; i += 1) {\\r\\n\\t\\t            expressionValue[i] = arrValue[i] = (i < 3) ? elementProp.v[i] * mult : 1;\\r\\n\\t\\t        }\\r\\n\\t        \\texpressionValue.value = arrValue;\\r\\n        \\t}\\r\\n        } else if (elementProp.propType === 'unidimensional'){\\r\\n            val = elementProp.v * mult;\\r\\n            expressionValue = new Number(val);\\r\\n            expressionValue.value = val;\\r\\n        } else {\\r\\n        \\tlen = elementProp.pv.length;\\r\\n            expressionValue = createTypedArray('float32', len);\\r\\n            arrValue = createTypedArray('float32', len);\\r\\n\\t        for (i = 0; i < len; i += 1) {\\r\\n\\t            expressionValue[i] = arrValue[i] = elementProp.v[i] * mult;\\r\\n\\t        }\\r\\n\\t        expressionValue.value = arrValue;\\r\\n        }\\r\\n        \\r\\n        expressionValue.numKeys = elementProp.keyframes ? elementProp.keyframes.length : 0;\\r\\n        expressionValue.key = function(pos) {\\r\\n            if (!expressionValue.numKeys) {\\r\\n                return 0;\\r\\n            } else {\\r\\n                return elementProp.keyframes[pos-1].t;\\r\\n            }\\r\\n        };\\r\\n        expressionValue.valueAtTime = elementProp.getValueAtTime;\\r\\n        expressionValue.speedAtTime = elementProp.getSpeedAtTime;\\r\\n        expressionValue.velocityAtTime = elementProp.getVelocityAtTime;\\r\\n        expressionValue.propertyGroup = elementProp.propertyGroup;\\r\\n        return expressionValue;\\r\\n\\t};\\r\\n}());\\nfunction SliderEffect(data,elem, container){\\r\\n    this.p = PropertyFactory.getProp(elem,data.v,0,0,container);\\r\\n}\\r\\nfunction AngleEffect(data,elem, container){\\r\\n    this.p = PropertyFactory.getProp(elem,data.v,0,0,container);\\r\\n}\\r\\nfunction ColorEffect(data,elem, container){\\r\\n    this.p = PropertyFactory.getProp(elem,data.v,1,0,container);\\r\\n}\\r\\nfunction PointEffect(data,elem, container){\\r\\n    this.p = PropertyFactory.getProp(elem,data.v,1,0,container);\\r\\n}\\r\\nfunction LayerIndexEffect(data,elem, container){\\r\\n    this.p = PropertyFactory.getProp(elem,data.v,0,0,container);\\r\\n}\\r\\nfunction MaskIndexEffect(data,elem, container){\\r\\n    this.p = PropertyFactory.getProp(elem,data.v,0,0,container);\\r\\n}\\r\\nfunction CheckboxEffect(data,elem, container){\\r\\n    this.p = PropertyFactory.getProp(elem,data.v,0,0,container);\\r\\n}\\r\\nfunction NoValueEffect(){\\r\\n    this.p = {};\\r\\n}\\nfunction EffectsManager(data,element){\\r\\n    var effects = data.ef || [];\\r\\n    this.effectElements = [];\\r\\n    var i,len = effects.length;\\r\\n    var effectItem;\\r\\n    for(i=0;i<len;i++) {\\r\\n        effectItem = new GroupEffect(effects[i],element);\\r\\n        this.effectElements.push(effectItem);\\r\\n    }\\r\\n}\\r\\n\\r\\nfunction GroupEffect(data,element){\\r\\n    this.init(data,element);\\r\\n}\\r\\n\\r\\nextendPrototype([DynamicPropertyContainer], GroupEffect);\\r\\n\\r\\nGroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;\\r\\n\\r\\nGroupEffect.prototype.init = function(data,element){\\r\\n    this.data = data;\\r\\n    this.effectElements = [];\\r\\n    this.initDynamicPropertyContainer(element);\\r\\n    var i, len = this.data.ef.length;\\r\\n    var eff, effects = this.data.ef;\\r\\n    for(i=0;i<len;i+=1){\\r\\n        eff = null;\\r\\n        switch(effects[i].ty){\\r\\n            case 0:\\r\\n                eff = new SliderEffect(effects[i],element,this);\\r\\n                break;\\r\\n            case 1:\\r\\n                eff = new AngleEffect(effects[i],element,this);\\r\\n                break;\\r\\n            case 2:\\r\\n                eff = new ColorEffect(effects[i],element,this);\\r\\n                break;\\r\\n            case 3:\\r\\n                eff = new PointEffect(effects[i],element,this);\\r\\n                break;\\r\\n            case 4:\\r\\n            case 7:\\r\\n                eff = new CheckboxEffect(effects[i],element,this);\\r\\n                break;\\r\\n            case 10:\\r\\n                eff = new LayerIndexEffect(effects[i],element,this);\\r\\n                break;\\r\\n            case 11:\\r\\n                eff = new MaskIndexEffect(effects[i],element,this);\\r\\n                break;\\r\\n            case 5:\\r\\n                eff = new EffectsManager(effects[i],element,this);\\r\\n                break;\\r\\n            //case 6:\\r\\n            default:\\r\\n                eff = new NoValueEffect(effects[i],element,this);\\r\\n                break;\\r\\n        }\\r\\n        if(eff) {\\r\\n            this.effectElements.push(eff);\\r\\n        }\\r\\n    }\\r\\n};\\r\\n    var lottiejs = {};\\r\\n\\r\\n    var _isFrozen = false;\\r\\n\\r\\n    function setLocationHref (href) {\\r\\n        locationHref = href;\\r\\n    }\\r\\n\\r\\n    function searchAnimations() {\\r\\n        if (standalone === true) {\\r\\n            animationManager.searchAnimations(animationData, standalone, renderer);\\r\\n        } else {\\r\\n            animationManager.searchAnimations();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setSubframeRendering(flag) {\\r\\n        subframeEnabled = flag;\\r\\n    }\\r\\n\\r\\n    function loadAnimation(params) {\\r\\n        if (standalone === true) {\\r\\n            params.animationData = JSON.parse(animationData);\\r\\n        }\\r\\n        return animationManager.loadAnimation(params);\\r\\n    }\\r\\n\\r\\n    function setQuality(value) {\\r\\n        if (typeof value === 'string') {\\r\\n            switch (value) {\\r\\n                case 'high':\\r\\n                    defaultCurveSegments = 200;\\r\\n                    break;\\r\\n                case 'medium':\\r\\n                    defaultCurveSegments = 50;\\r\\n                    break;\\r\\n                case 'low':\\r\\n                    defaultCurveSegments = 10;\\r\\n                    break;\\r\\n            }\\r\\n        } else if (!isNaN(value) && value > 1) {\\r\\n            defaultCurveSegments = value;\\r\\n        }\\r\\n        if (defaultCurveSegments >= 50) {\\r\\n            roundValues(false);\\r\\n        } else {\\r\\n            roundValues(true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function inBrowser() {\\r\\n        return typeof navigator !== 'undefined';\\r\\n    }\\r\\n\\r\\n    function installPlugin(type, plugin) {\\r\\n        if (type === 'expressions') {\\r\\n            expressionsPlugin = plugin;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getFactory(name) {\\r\\n        switch (name) {\\r\\n            case \\\"propertyFactory\\\":\\r\\n                return PropertyFactory;\\r\\n            case \\\"shapePropertyFactory\\\":\\r\\n                return ShapePropertyFactory;\\r\\n            case \\\"matrix\\\":\\r\\n                return Matrix;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    lottiejs.play = animationManager.play;\\r\\n    lottiejs.pause = animationManager.pause;\\r\\n    lottiejs.setLocationHref = setLocationHref;\\r\\n    lottiejs.togglePause = animationManager.togglePause;\\r\\n    lottiejs.setSpeed = animationManager.setSpeed;\\r\\n    lottiejs.setDirection = animationManager.setDirection;\\r\\n    lottiejs.stop = animationManager.stop;\\r\\n    lottiejs.searchAnimations = searchAnimations;\\r\\n    lottiejs.registerAnimation = animationManager.registerAnimation;\\r\\n    lottiejs.loadAnimation = loadAnimation;\\r\\n    lottiejs.setSubframeRendering = setSubframeRendering;\\r\\n    lottiejs.resize = animationManager.resize;\\r\\n    //lottiejs.start = start;\\r\\n    lottiejs.goToAndStop = animationManager.goToAndStop;\\r\\n    lottiejs.destroy = animationManager.destroy;\\r\\n    lottiejs.setQuality = setQuality;\\r\\n    lottiejs.inBrowser = inBrowser;\\r\\n    lottiejs.installPlugin = installPlugin;\\r\\n    lottiejs.freeze = animationManager.freeze;\\r\\n    lottiejs.unfreeze = animationManager.unfreeze;\\r\\n    lottiejs.getRegisteredAnimations = animationManager.getRegisteredAnimations;\\r\\n    lottiejs.__getFactory = getFactory;\\r\\n    lottiejs.version = '5.3.4';\\r\\n\\r\\n    function checkReady() {\\r\\n        if (document.readyState === \\\"complete\\\") {\\r\\n            clearInterval(readyStateCheckInterval);\\r\\n            searchAnimations();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getQueryVariable(variable) {\\r\\n        var vars = queryString.split('&');\\r\\n        for (var i = 0; i < vars.length; i++) {\\r\\n            var pair = vars[i].split('=');\\r\\n            if (decodeURIComponent(pair[0]) == variable) {\\r\\n                return decodeURIComponent(pair[1]);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    var standalone = '__[STANDALONE]__';\\r\\n    var animationData = '__[ANIMATIONDATA]__';\\r\\n    var renderer = '';\\r\\n    if (standalone) {\\r\\n        var scripts = document.getElementsByTagName('script');\\r\\n        var index = scripts.length - 1;\\r\\n        var myScript = scripts[index] || {\\r\\n            src: ''\\r\\n        };\\r\\n        var queryString = myScript.src.replace(/^[^\\\\?]+\\\\??/, '');\\r\\n        renderer = getQueryVariable('renderer');\\r\\n    }\\r\\n    var readyStateCheckInterval = setInterval(checkReady, 100);\\r\\n    return lottiejs;\\r\\n}));\\r//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG90dGllLXdlYi9idWlsZC9wbGF5ZXIvbG90dGllLmpzPzk0ZjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQUE7QUFDVCxLQUFLLFFBS0w7QUFDQSxDQUFDLGNBQWM7QUFDZjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQSxDQUFDOztBQUVELDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU8sT0FBTztBQUNwQyxzQkFBc0IsT0FBTyxPQUFPO0FBQ3BDLHNCQUFzQixPQUFPLE9BQU87QUFDcEMsc0JBQXNCLE9BQU8sT0FBTztBQUNwQyxzQkFBc0IsT0FBTyxPQUFPO0FBQ3BDLHNCQUFzQixPQUFPLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEIsaURBQWlELFlBQVk7QUFDN0Qsb0NBQW9DLFlBQVk7QUFDaEQsb0NBQW9DLFlBQVk7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QiwwQkFBMEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0IsMEJBQTBCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQyxVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQixVQUFVLDhCQUE4QjtBQUN4QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQixpQkFBaUI7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDLDJCQUEyQjtBQUMzQiw4QkFBOEI7QUFDOUI7QUFDQSxtQ0FBbUM7QUFDbkMsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekI7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUEsaUNBQWlDLHNCQUFzQjtBQUN2RCxpQ0FBaUMsZ0NBQWdDO0FBQ2pFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQSx5Q0FBeUMscUJBQXFCLEVBQUU7QUFDaEU7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixzQkFBc0IsYUFBYTs7QUFFbEU7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixrQkFBa0I7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0Q0FBNEMsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnREFBZ0Q7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQixvQ0FBb0M7QUFDL0QsMkJBQTJCLDhCQUE4QjtBQUN6RCwyQkFBMkIsa0JBQWtCOztBQUU3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0VBQW9FO0FBQ3RGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscURBQXFEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBLHdCQUF3QixNQUFNO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxVQUFVO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQixHQUFHO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQ0FBa0Msc0JBQXNCOztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwyQ0FBMkMseUNBQXlDLG9CQUFvQixtQ0FBbUM7QUFDM0k7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQztBQUNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLE9BQU87QUFDdkIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSx5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUssdUJBQXVCLHVCQUF1QixxQkFBcUIsTUFBTSx1QkFBdUIsTUFBTSxtQkFBbUIsWUFBWSxFQUFFLFlBQVksRUFBRSxNQUFNLDJCQUEyQixPQUFPLG1CQUFtQixPQUFPLG1CQUFtQixXQUFXOztBQUV6UjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwyQkFBMkIsVUFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxTQUFTOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0hBQXdIO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELElBQUk7QUFDN0Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQkFBc0I7QUFDdEI7QUFDQSx5REFBeUQsSUFBSTtBQUM3RCwyREFBMkQsSUFBSTtBQUMvRCwyREFBMkQsSUFBSTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkcsSUFBSTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixTQUFTO0FBQ1Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxJQUFJO0FBQ3ZELG1EQUFtRCxJQUFJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBLGdEO0FBQ0EsNkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlDQUFpQztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEMscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5Rjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw4REFBOEQsSUFBSTtBQUNsRSw4REFBOEQsSUFBSTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNkNBQTZDLE9BQU87O0FBRXBEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFELDRDQUE0QztBQUM1Qyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQiw4REFBOEQsMkJBQTJCO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQSx5RUFBeUUsVUFBVSxvQkFBb0I7QUFDdkc7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQixrQkFBa0I7QUFDeEMsbUJBQW1CO0FBQ25CLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQixrQkFBa0I7QUFDeEMsbUJBQW1CO0FBQ25CLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixzQkFBc0I7QUFDdEIsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixzQkFBc0I7QUFDdEIsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixzQkFBc0I7QUFDdEIsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QixTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixzQkFBc0I7QUFDdEIsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQixrQkFBa0I7QUFDeEMsbUJBQW1CLGtCQUFrQjtBQUNyQyxtQkFBbUI7QUFDbkIsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsNERBQTRELHFCQUFxQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIpICYmIChmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KHJvb3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJvb3QpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByb290LmxvdHRpZSA9IGZhY3Rvcnkocm9vdCk7XHJcbiAgICAgICAgcm9vdC5ib2R5bW92aW4gPSByb290LmxvdHRpZTtcclxuICAgIH1cclxufSgod2luZG93IHx8IHt9KSwgZnVuY3Rpb24od2luZG93KSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuICAgIHZhciBzdmdOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcclxuXHJcbnZhciBsb2NhdGlvbkhyZWYgPSAnJztcclxuXHJcbnZhciBpbml0aWFsRGVmYXVsdEZyYW1lID0gLTk5OTk5OTtcclxuXG52YXIgc3ViZnJhbWVFbmFibGVkID0gdHJ1ZTtcclxudmFyIGV4cHJlc3Npb25zUGx1Z2luO1xyXG52YXIgaXNTYWZhcmkgPSAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xyXG52YXIgY2FjaGVkQ29sb3JzID0ge307XHJcbnZhciBibV9yb3VuZGVyID0gTWF0aC5yb3VuZDtcclxudmFyIGJtX3JuZDtcclxudmFyIGJtX3BvdyA9IE1hdGgucG93O1xyXG52YXIgYm1fc3FydCA9IE1hdGguc3FydDtcclxudmFyIGJtX2FicyA9IE1hdGguYWJzO1xyXG52YXIgYm1fZmxvb3IgPSBNYXRoLmZsb29yO1xyXG52YXIgYm1fbWF4ID0gTWF0aC5tYXg7XHJcbnZhciBibV9taW4gPSBNYXRoLm1pbjtcclxudmFyIGJsaXR0ZXIgPSAxMDtcclxuXHJcbnZhciBCTU1hdGggPSB7fTtcclxuKGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgcHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE1hdGgpO1xyXG4gICAgdmFyIGksIGxlbiA9IHByb3BlcnR5TmFtZXMubGVuZ3RoO1xyXG4gICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICBCTU1hdGhbcHJvcGVydHlOYW1lc1tpXV0gPSBNYXRoW3Byb3BlcnR5TmFtZXNbaV1dO1xyXG4gICAgfVxyXG59KCkpO1xyXG5cclxuZnVuY3Rpb24gUHJvamVjdEludGVyZmFjZSgpe3JldHVybiB7fTt9XHJcblxyXG5CTU1hdGgucmFuZG9tID0gTWF0aC5yYW5kb207XHJcbkJNTWF0aC5hYnMgPSBmdW5jdGlvbih2YWwpe1xyXG4gICAgdmFyIHRPZlZhbCA9IHR5cGVvZiB2YWw7XHJcbiAgICBpZih0T2ZWYWwgPT09ICdvYmplY3QnICYmIHZhbC5sZW5ndGgpe1xyXG4gICAgICAgIHZhciBhYnNBcnIgPSBjcmVhdGVTaXplZEFycmF5KHZhbC5sZW5ndGgpO1xyXG4gICAgICAgIHZhciBpLCBsZW4gPSB2YWwubGVuZ3RoO1xyXG4gICAgICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgICAgIGFic0FycltpXSA9IE1hdGguYWJzKHZhbFtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhYnNBcnI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWF0aC5hYnModmFsKTtcclxuXHJcbn07XHJcbnZhciBkZWZhdWx0Q3VydmVTZWdtZW50cyA9IDE1MDtcclxudmFyIGRlZ1RvUmFkcyA9IE1hdGguUEkvMTgwO1xyXG52YXIgcm91bmRDb3JuZXIgPSAwLjU1MTk7XHJcblxyXG5mdW5jdGlvbiByb3VuZFZhbHVlcyhmbGFnKXtcclxuICAgIGlmKGZsYWcpe1xyXG4gICAgICAgIGJtX3JuZCA9IE1hdGgucm91bmQ7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgICBibV9ybmQgPSBmdW5jdGlvbih2YWwpe1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxucm91bmRWYWx1ZXMoZmFsc2UpO1xyXG5cclxuZnVuY3Rpb24gc3R5bGVEaXYoZWxlbWVudCl7XHJcbiAgICBlbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgIGVsZW1lbnQuc3R5bGUudG9wID0gMDtcclxuICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IDA7XHJcbiAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBlbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9ICcwIDAnO1xyXG4gICAgZWxlbWVudC5zdHlsZS5iYWNrZmFjZVZpc2liaWxpdHkgID0gZWxlbWVudC5zdHlsZS53ZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSAndmlzaWJsZSc7XHJcbiAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybVN0eWxlID0gZWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm1TdHlsZSA9IGVsZW1lbnQuc3R5bGUubW96VHJhbnNmb3JtU3R5bGUgPSBcInByZXNlcnZlLTNkXCI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEJNRW50ZXJGcmFtZUV2ZW50KG4sYyx0LGQpe1xyXG4gICAgdGhpcy50eXBlID0gbjtcclxuICAgIHRoaXMuY3VycmVudFRpbWUgPSBjO1xyXG4gICAgdGhpcy50b3RhbFRpbWUgPSB0O1xyXG4gICAgdGhpcy5kaXJlY3Rpb24gPSBkIDwgMCA/IC0xOjE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEJNQ29tcGxldGVFdmVudChuLGQpe1xyXG4gICAgdGhpcy50eXBlID0gbjtcclxuICAgIHRoaXMuZGlyZWN0aW9uID0gZCA8IDAgPyAtMToxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBCTUNvbXBsZXRlTG9vcEV2ZW50KG4sYyx0LGQpe1xyXG4gICAgdGhpcy50eXBlID0gbjtcclxuICAgIHRoaXMuY3VycmVudExvb3AgPSB0O1xyXG4gICAgdGhpcy50b3RhbExvb3BzID0gYztcclxuICAgIHRoaXMuZGlyZWN0aW9uID0gZCA8IDAgPyAtMToxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBCTVNlZ21lbnRTdGFydEV2ZW50KG4sZix0KXtcclxuICAgIHRoaXMudHlwZSA9IG47XHJcbiAgICB0aGlzLmZpcnN0RnJhbWUgPSBmO1xyXG4gICAgdGhpcy50b3RhbEZyYW1lcyA9IHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIEJNRGVzdHJveUV2ZW50KG4sdCl7XHJcbiAgICB0aGlzLnR5cGUgPSBuO1xyXG4gICAgdGhpcy50YXJnZXQgPSB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiByYW5kb21TdHJpbmcobGVuZ3RoLCBjaGFycyl7XHJcbiAgICBpZihjaGFycyA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICBjaGFycyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMTIzNDU2Nzg5MCc7XHJcbiAgICB9XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciByZXN1bHQgPSAnJztcclxuICAgIGZvciAoaSA9IGxlbmd0aDsgaSA+IDA7IC0taSkgcmVzdWx0ICs9IGNoYXJzW01hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIChjaGFycy5sZW5ndGggLSAxKSldO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZnVuY3Rpb24gSFNWdG9SR0IoaCwgcywgdikge1xyXG4gICAgdmFyIHIsIGcsIGIsIGksIGYsIHAsIHEsIHQ7XHJcbiAgICBpID0gTWF0aC5mbG9vcihoICogNik7XHJcbiAgICBmID0gaCAqIDYgLSBpO1xyXG4gICAgcCA9IHYgKiAoMSAtIHMpO1xyXG4gICAgcSA9IHYgKiAoMSAtIGYgKiBzKTtcclxuICAgIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XHJcbiAgICBzd2l0Y2ggKGkgJSA2KSB7XHJcbiAgICAgICAgY2FzZSAwOiByID0gdjsgZyA9IHQ7IGIgPSBwOyBicmVhaztcclxuICAgICAgICBjYXNlIDE6IHIgPSBxOyBnID0gdjsgYiA9IHA7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjogciA9IHA7IGcgPSB2OyBiID0gdDsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzOiByID0gcDsgZyA9IHE7IGIgPSB2OyBicmVhaztcclxuICAgICAgICBjYXNlIDQ6IHIgPSB0OyBnID0gcDsgYiA9IHY7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgNTogciA9IHY7IGcgPSBwOyBiID0gcTsgYnJlYWs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gWyByLFxyXG4gICAgICAgIGcsXHJcbiAgICAgICAgIGIgXTtcclxufVxyXG5cclxuZnVuY3Rpb24gUkdCdG9IU1YociwgZywgYikge1xyXG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcclxuICAgICAgICBkID0gbWF4IC0gbWluLFxyXG4gICAgICAgIGgsXHJcbiAgICAgICAgcyA9IChtYXggPT09IDAgPyAwIDogZCAvIG1heCksXHJcbiAgICAgICAgdiA9IG1heCAvIDI1NTtcclxuXHJcbiAgICBzd2l0Y2ggKG1heCkge1xyXG4gICAgICAgIGNhc2UgbWluOiBoID0gMDsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSByOiBoID0gKGcgLSBiKSArIGQgKiAoZyA8IGIgPyA2OiAwKTsgaCAvPSA2ICogZDsgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBnOiBoID0gKGIgLSByKSArIGQgKiAyOyBoIC89IDYgKiBkOyBicmVhaztcclxuICAgICAgICBjYXNlIGI6IGggPSAociAtIGcpICsgZCAqIDQ7IGggLz0gNiAqIGQ7IGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgIGgsXHJcbiAgICAgICAgIHMsXHJcbiAgICAgICAgIHZcclxuICAgIF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFkZFNhdHVyYXRpb25Ub1JHQihjb2xvcixvZmZzZXQpe1xyXG4gICAgdmFyIGhzdiA9IFJHQnRvSFNWKGNvbG9yWzBdKjI1NSxjb2xvclsxXSoyNTUsY29sb3JbMl0qMjU1KTtcclxuICAgIGhzdlsxXSArPSBvZmZzZXQ7XHJcbiAgICBpZiAoaHN2WzFdID4gMSkge1xyXG4gICAgICAgIGhzdlsxXSA9IDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChoc3ZbMV0gPD0gMCkge1xyXG4gICAgICAgIGhzdlsxXSA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSFNWdG9SR0IoaHN2WzBdLGhzdlsxXSxoc3ZbMl0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRCcmlnaHRuZXNzVG9SR0IoY29sb3Isb2Zmc2V0KXtcclxuICAgIHZhciBoc3YgPSBSR0J0b0hTVihjb2xvclswXSoyNTUsY29sb3JbMV0qMjU1LGNvbG9yWzJdKjI1NSk7XHJcbiAgICBoc3ZbMl0gKz0gb2Zmc2V0O1xyXG4gICAgaWYgKGhzdlsyXSA+IDEpIHtcclxuICAgICAgICBoc3ZbMl0gPSAxO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaHN2WzJdIDwgMCkge1xyXG4gICAgICAgIGhzdlsyXSA9IDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSFNWdG9SR0IoaHN2WzBdLGhzdlsxXSxoc3ZbMl0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhZGRIdWVUb1JHQihjb2xvcixvZmZzZXQpIHtcclxuICAgIHZhciBoc3YgPSBSR0J0b0hTVihjb2xvclswXSoyNTUsY29sb3JbMV0qMjU1LGNvbG9yWzJdKjI1NSk7XHJcbiAgICBoc3ZbMF0gKz0gb2Zmc2V0LzM2MDtcclxuICAgIGlmIChoc3ZbMF0gPiAxKSB7XHJcbiAgICAgICAgaHN2WzBdIC09IDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChoc3ZbMF0gPCAwKSB7XHJcbiAgICAgICAgaHN2WzBdICs9IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gSFNWdG9SR0IoaHN2WzBdLGhzdlsxXSxoc3ZbMl0pO1xyXG59XHJcblxyXG52YXIgcmdiVG9IZXggPSAoZnVuY3Rpb24oKXtcclxuICAgIHZhciBjb2xvck1hcCA9IFtdO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgaGV4O1xyXG4gICAgZm9yKGk9MDtpPDI1NjtpKz0xKXtcclxuICAgICAgICBoZXggPSBpLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICBjb2xvck1hcFtpXSA9IGhleC5sZW5ndGggPT0gMSA/ICcwJyArIGhleCA6IGhleDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24ociwgZywgYikge1xyXG4gICAgICAgIGlmKHI8MCl7XHJcbiAgICAgICAgICAgIHIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihnPDApe1xyXG4gICAgICAgICAgICBnID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoYjwwKXtcclxuICAgICAgICAgICAgYiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnIycgKyBjb2xvck1hcFtyXSArIGNvbG9yTWFwW2ddICsgY29sb3JNYXBbYl07XHJcbiAgICB9O1xyXG59KCkpO1xuZnVuY3Rpb24gQmFzZUV2ZW50KCl7fVxyXG5CYXNlRXZlbnQucHJvdG90eXBlID0ge1xyXG5cdHRyaWdnZXJFdmVudDogZnVuY3Rpb24gKGV2ZW50TmFtZSwgYXJncykge1xyXG5cdCAgICBpZiAodGhpcy5fY2JzW2V2ZW50TmFtZV0pIHtcclxuXHQgICAgICAgIHZhciBsZW4gPSB0aGlzLl9jYnNbZXZlbnROYW1lXS5sZW5ndGg7XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKXtcclxuXHQgICAgICAgICAgICB0aGlzLl9jYnNbZXZlbnROYW1lXVtpXShhcmdzKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdH0sXHJcblx0YWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcclxuXHQgICAgaWYgKCF0aGlzLl9jYnNbZXZlbnROYW1lXSl7XHJcblx0ICAgICAgICB0aGlzLl9jYnNbZXZlbnROYW1lXSA9IFtdO1xyXG5cdCAgICB9XHJcblx0ICAgIHRoaXMuX2Nic1tldmVudE5hbWVdLnB1c2goY2FsbGJhY2spO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xyXG5cdFx0fS5iaW5kKHRoaXMpO1xyXG5cdH0sXHJcblx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKGV2ZW50TmFtZSxjYWxsYmFjayl7XHJcblx0ICAgIGlmICghY2FsbGJhY2spe1xyXG5cdCAgICAgICAgdGhpcy5fY2JzW2V2ZW50TmFtZV0gPSBudWxsO1xyXG5cdCAgICB9ZWxzZSBpZih0aGlzLl9jYnNbZXZlbnROYW1lXSl7XHJcblx0ICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX2Nic1tldmVudE5hbWVdLmxlbmd0aDtcclxuXHQgICAgICAgIHdoaWxlKGk8bGVuKXtcclxuXHQgICAgICAgICAgICBpZih0aGlzLl9jYnNbZXZlbnROYW1lXVtpXSA9PT0gY2FsbGJhY2spe1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jYnNbZXZlbnROYW1lXS5zcGxpY2UoaSwxKTtcclxuXHQgICAgICAgICAgICAgICAgaSAtPTE7XHJcblx0ICAgICAgICAgICAgICAgIGxlbiAtPSAxO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBpICs9IDE7XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpZighdGhpcy5fY2JzW2V2ZW50TmFtZV0ubGVuZ3RoKXtcclxuXHQgICAgICAgICAgICB0aGlzLl9jYnNbZXZlbnROYW1lXSA9IG51bGw7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHR9XHJcbn07XG52YXIgY3JlYXRlVHlwZWRBcnJheSA9IChmdW5jdGlvbigpe1xyXG5cdGZ1bmN0aW9uIGNyZWF0ZVJlZ3VsYXJBcnJheSh0eXBlLCBsZW4pe1xyXG5cdFx0dmFyIGkgPSAwLCBhcnIgPSBbXSwgdmFsdWU7XHJcblx0XHRzd2l0Y2godHlwZSkge1xyXG5cdFx0XHRjYXNlICdpbnQxNic6XHJcblx0XHRcdGNhc2UgJ3VpbnQ4Yyc6XHJcblx0XHRcdFx0dmFsdWUgPSAxO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdHZhbHVlID0gMS4xO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuXHRcdFx0YXJyLnB1c2godmFsdWUpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGFycjtcclxuXHR9XHJcblx0ZnVuY3Rpb24gY3JlYXRlVHlwZWRBcnJheSh0eXBlLCBsZW4pe1xyXG5cdFx0aWYodHlwZSA9PT0gJ2Zsb2F0MzInKSB7XHJcblx0XHRcdHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGxlbik7XHJcblx0XHR9IGVsc2UgaWYodHlwZSA9PT0gJ2ludDE2Jykge1xyXG5cdFx0XHRyZXR1cm4gbmV3IEludDE2QXJyYXkobGVuKTtcclxuXHRcdH0gZWxzZSBpZih0eXBlID09PSAndWludDhjJykge1xyXG5cdFx0XHRyZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGxlbik7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmKHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRyZXR1cm4gY3JlYXRlVHlwZWRBcnJheTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmV0dXJuIGNyZWF0ZVJlZ3VsYXJBcnJheTtcclxuXHR9XHJcbn0oKSk7XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVTaXplZEFycmF5KGxlbikge1xyXG5cdHJldHVybiBBcnJheS5hcHBseShudWxsLHtsZW5ndGg6bGVufSk7XHJcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5TKHR5cGUpIHtcclxuXHQvL3JldHVybiB7YXBwZW5kQ2hpbGQ6ZnVuY3Rpb24oKXt9LHNldEF0dHJpYnV0ZTpmdW5jdGlvbigpe30sc3R5bGU6e319XHJcblx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgdHlwZSk7XHJcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRhZyh0eXBlKSB7XHJcblx0Ly9yZXR1cm4ge2FwcGVuZENoaWxkOmZ1bmN0aW9uKCl7fSxzZXRBdHRyaWJ1dGU6ZnVuY3Rpb24oKXt9LHN0eWxlOnt9fVxyXG5cdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xyXG59XG5mdW5jdGlvbiBEeW5hbWljUHJvcGVydHlDb250YWluZXIoKXt9O1xyXG5EeW5hbWljUHJvcGVydHlDb250YWluZXIucHJvdG90eXBlID0ge1xyXG5cdGFkZER5bmFtaWNQcm9wZXJ0eTogZnVuY3Rpb24ocHJvcCkge1xyXG5cdFx0aWYodGhpcy5keW5hbWljUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xyXG5cdCAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcy5wdXNoKHByb3ApO1xyXG5cdCAgICAgICAgdGhpcy5jb250YWluZXIuYWRkRHluYW1pY1Byb3BlcnR5KHRoaXMpO1xyXG5cdCAgICBcdHRoaXMuX2lzQW5pbWF0ZWQgPSB0cnVlO1xyXG5cdCAgICB9XHJcblx0fSxcclxuXHRpdGVyYXRlRHluYW1pY1Byb3BlcnRpZXM6IGZ1bmN0aW9uKCl7XHJcblx0ICAgIHRoaXMuX21kZiA9IGZhbHNlO1xyXG5cdCAgICB2YXIgaSwgbGVuID0gdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7XHJcblx0ICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcblx0ICAgICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLmdldFZhbHVlKCk7XHJcblx0ICAgICAgICBpZih0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLl9tZGYpIHtcclxuXHQgICAgICAgICAgICB0aGlzLl9tZGYgPSB0cnVlO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9XHJcblx0fSxcclxuXHRpbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyOiBmdW5jdGlvbihjb250YWluZXIpe1xyXG5cdCAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuXHQgICAgdGhpcy5keW5hbWljUHJvcGVydGllcyA9IFtdO1xyXG5cdCAgICB0aGlzLl9tZGYgPSBmYWxzZTtcclxuXHQgICAgdGhpcy5faXNBbmltYXRlZCA9IGZhbHNlO1xyXG5cdH1cclxufVxuLyohXHJcbiBUcmFuc2Zvcm1hdGlvbiBNYXRyaXggdjIuMFxyXG4gKGMpIEVwaXN0ZW1leCAyMDE0LTIwMTVcclxuIHd3dy5lcGlzdGVtZXguY29tXHJcbiBCeSBLZW4gRnlyc3RlbmJlcmdcclxuIENvbnRyaWJ1dGlvbnMgYnkgbGVlb25peWEuXHJcbiBMaWNlbnNlOiBNSVQsIGhlYWRlciByZXF1aXJlZC5cclxuICovXHJcblxyXG4vKipcclxuICogMkQgdHJhbnNmb3JtYXRpb24gbWF0cml4IG9iamVjdCBpbml0aWFsaXplZCB3aXRoIGlkZW50aXR5IG1hdHJpeC5cclxuICpcclxuICogVGhlIG1hdHJpeCBjYW4gc3luY2hyb25pemUgYSBjYW52YXMgY29udGV4dCBieSBzdXBwbHlpbmcgdGhlIGNvbnRleHRcclxuICogYXMgYW4gYXJndW1lbnQsIG9yIGxhdGVyIGFwcGx5IGN1cnJlbnQgYWJzb2x1dGUgdHJhbnNmb3JtIHRvIGFuXHJcbiAqIGV4aXN0aW5nIGNvbnRleHQuXHJcbiAqXHJcbiAqIEFsbCB2YWx1ZXMgYXJlIGhhbmRsZWQgYXMgZmxvYXRpbmcgcG9pbnQgdmFsdWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gW2NvbnRleHRdIC0gT3B0aW9uYWwgY29udGV4dCB0byBzeW5jIHdpdGggTWF0cml4XHJcbiAqIEBwcm9wIHtudW1iZXJ9IGEgLSBzY2FsZSB4XHJcbiAqIEBwcm9wIHtudW1iZXJ9IGIgLSBzaGVhciB5XHJcbiAqIEBwcm9wIHtudW1iZXJ9IGMgLSBzaGVhciB4XHJcbiAqIEBwcm9wIHtudW1iZXJ9IGQgLSBzY2FsZSB5XHJcbiAqIEBwcm9wIHtudW1iZXJ9IGUgLSB0cmFuc2xhdGUgeFxyXG4gKiBAcHJvcCB7bnVtYmVyfSBmIC0gdHJhbnNsYXRlIHlcclxuICogQHByb3Age0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRHxudWxsfSBbY29udGV4dD1udWxsXSAtIHNldCBvciBnZXQgY3VycmVudCBjYW52YXMgY29udGV4dFxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcblxyXG52YXIgTWF0cml4ID0gKGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgdmFyIF9jb3MgPSBNYXRoLmNvcztcclxuICAgIHZhciBfc2luID0gTWF0aC5zaW47XHJcbiAgICB2YXIgX3RhbiA9IE1hdGgudGFuO1xyXG4gICAgdmFyIF9ybmQgPSBNYXRoLnJvdW5kO1xyXG5cclxuICAgIGZ1bmN0aW9uIHJlc2V0KCl7XHJcbiAgICAgICAgdGhpcy5wcm9wc1swXSA9IDE7XHJcbiAgICAgICAgdGhpcy5wcm9wc1sxXSA9IDA7XHJcbiAgICAgICAgdGhpcy5wcm9wc1syXSA9IDA7XHJcbiAgICAgICAgdGhpcy5wcm9wc1szXSA9IDA7XHJcbiAgICAgICAgdGhpcy5wcm9wc1s0XSA9IDA7XHJcbiAgICAgICAgdGhpcy5wcm9wc1s1XSA9IDE7XHJcbiAgICAgICAgdGhpcy5wcm9wc1s2XSA9IDA7XHJcbiAgICAgICAgdGhpcy5wcm9wc1s3XSA9IDA7XHJcbiAgICAgICAgdGhpcy5wcm9wc1s4XSA9IDA7XHJcbiAgICAgICAgdGhpcy5wcm9wc1s5XSA9IDA7XHJcbiAgICAgICAgdGhpcy5wcm9wc1sxMF0gPSAxO1xyXG4gICAgICAgIHRoaXMucHJvcHNbMTFdID0gMDtcclxuICAgICAgICB0aGlzLnByb3BzWzEyXSA9IDA7XHJcbiAgICAgICAgdGhpcy5wcm9wc1sxM10gPSAwO1xyXG4gICAgICAgIHRoaXMucHJvcHNbMTRdID0gMDtcclxuICAgICAgICB0aGlzLnByb3BzWzE1XSA9IDE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcm90YXRlKGFuZ2xlKSB7XHJcbiAgICAgICAgaWYoYW5nbGUgPT09IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1Db3MgPSBfY29zKGFuZ2xlKTtcclxuICAgICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90KG1Db3MsIC1tU2luLCAgMCwgMCwgbVNpbiwgIG1Db3MsIDAsIDAsIDAsICAwLCAgMSwgMCwgMCwgMCwgMCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcm90YXRlWChhbmdsZSl7XHJcbiAgICAgICAgaWYoYW5nbGUgPT09IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1Db3MgPSBfY29zKGFuZ2xlKTtcclxuICAgICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90KDEsIDAsIDAsIDAsIDAsIG1Db3MsIC1tU2luLCAwLCAwLCBtU2luLCAgbUNvcywgMCwgMCwgMCwgMCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcm90YXRlWShhbmdsZSl7XHJcbiAgICAgICAgaWYoYW5nbGUgPT09IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1Db3MgPSBfY29zKGFuZ2xlKTtcclxuICAgICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90KG1Db3MsICAwLCAgbVNpbiwgMCwgMCwgMSwgMCwgMCwgLW1TaW4sICAwLCAgbUNvcywgMCwgMCwgMCwgMCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcm90YXRlWihhbmdsZSl7XHJcbiAgICAgICAgaWYoYW5nbGUgPT09IDApe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1Db3MgPSBfY29zKGFuZ2xlKTtcclxuICAgICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90KG1Db3MsIC1tU2luLCAgMCwgMCwgbVNpbiwgIG1Db3MsIDAsIDAsIDAsICAwLCAgMSwgMCwgMCwgMCwgMCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2hlYXIoc3gsc3kpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90KDEsIHN5LCBzeCwgMSwgMCwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2tldyhheCwgYXkpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNoZWFyKF90YW4oYXgpLCBfdGFuKGF5KSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2tld0Zyb21BeGlzKGF4LCBhbmdsZSl7XHJcbiAgICAgICAgdmFyIG1Db3MgPSBfY29zKGFuZ2xlKTtcclxuICAgICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90KG1Db3MsIG1TaW4sICAwLCAwLCAtbVNpbiwgIG1Db3MsIDAsIDAsIDAsICAwLCAgMSwgMCwgMCwgMCwgMCwgMSlcclxuICAgICAgICAgICAgLl90KDEsIDAsICAwLCAwLCBfdGFuKGF4KSwgIDEsIDAsIDAsIDAsICAwLCAgMSwgMCwgMCwgMCwgMCwgMSlcclxuICAgICAgICAgICAgLl90KG1Db3MsIC1tU2luLCAgMCwgMCwgbVNpbiwgIG1Db3MsIDAsIDAsIDAsICAwLCAgMSwgMCwgMCwgMCwgMCwgMSk7XHJcbiAgICAgICAgLy9yZXR1cm4gdGhpcy5fdChtQ29zLCBtU2luLCAtbVNpbiwgbUNvcywgMCwgMCkuX3QoMSwgMCwgX3RhbihheCksIDEsIDAsIDApLl90KG1Db3MsIC1tU2luLCBtU2luLCBtQ29zLCAwLCAwKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzY2FsZShzeCwgc3ksIHN6KSB7XHJcbiAgICAgICAgaWYoIXN6ICYmIHN6ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHN6ID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoc3ggPT09IDEgJiYgc3kgPT09IDEgJiYgc3ogPT09IDEpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Qoc3gsIDAsIDAsIDAsIDAsIHN5LCAwLCAwLCAwLCAwLCBzeiwgMCwgMCwgMCwgMCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0sIG4sIG8sIHApIHtcclxuICAgICAgICB0aGlzLnByb3BzWzBdID0gYTtcclxuICAgICAgICB0aGlzLnByb3BzWzFdID0gYjtcclxuICAgICAgICB0aGlzLnByb3BzWzJdID0gYztcclxuICAgICAgICB0aGlzLnByb3BzWzNdID0gZDtcclxuICAgICAgICB0aGlzLnByb3BzWzRdID0gZTtcclxuICAgICAgICB0aGlzLnByb3BzWzVdID0gZjtcclxuICAgICAgICB0aGlzLnByb3BzWzZdID0gZztcclxuICAgICAgICB0aGlzLnByb3BzWzddID0gaDtcclxuICAgICAgICB0aGlzLnByb3BzWzhdID0gaTtcclxuICAgICAgICB0aGlzLnByb3BzWzldID0gajtcclxuICAgICAgICB0aGlzLnByb3BzWzEwXSA9IGs7XHJcbiAgICAgICAgdGhpcy5wcm9wc1sxMV0gPSBsO1xyXG4gICAgICAgIHRoaXMucHJvcHNbMTJdID0gbTtcclxuICAgICAgICB0aGlzLnByb3BzWzEzXSA9IG47XHJcbiAgICAgICAgdGhpcy5wcm9wc1sxNF0gPSBvO1xyXG4gICAgICAgIHRoaXMucHJvcHNbMTVdID0gcDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0cmFuc2xhdGUodHgsIHR5LCB0eikge1xyXG4gICAgICAgIHR6ID0gdHogfHwgMDtcclxuICAgICAgICBpZih0eCAhPT0gMCB8fCB0eSAhPT0gMCB8fCB0eiAhPT0gMCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90KDEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLHR4LHR5LHR6LDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0oYTIsIGIyLCBjMiwgZDIsIGUyLCBmMiwgZzIsIGgyLCBpMiwgajIsIGsyLCBsMiwgbTIsIG4yLCBvMiwgcDIpIHtcclxuXHJcbiAgICAgICAgdmFyIF9wID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICAgICAgaWYoYTIgPT09IDEgJiYgYjIgPT09IDAgJiYgYzIgPT09IDAgJiYgZDIgPT09IDAgJiYgZTIgPT09IDAgJiYgZjIgPT09IDEgJiYgZzIgPT09IDAgJiYgaDIgPT09IDAgJiYgaTIgPT09IDAgJiYgajIgPT09IDAgJiYgazIgPT09IDEgJiYgbDIgPT09IDApe1xyXG4gICAgICAgICAgICAvL05PVEU6IGNvbW1lbnRpbmcgdGhpcyBjb25kaXRpb24gYmVjYXVzZSBUdXJib0ZhbiBkZW9wdGltaXplcyBjb2RlIHdoZW4gcHJlc2VudFxyXG4gICAgICAgICAgICAvL2lmKG0yICE9PSAwIHx8IG4yICE9PSAwIHx8IG8yICE9PSAwKXtcclxuICAgICAgICAgICAgICAgIF9wWzEyXSA9IF9wWzEyXSAqIGEyICsgX3BbMTVdICogbTI7XHJcbiAgICAgICAgICAgICAgICBfcFsxM10gPSBfcFsxM10gKiBmMiArIF9wWzE1XSAqIG4yO1xyXG4gICAgICAgICAgICAgICAgX3BbMTRdID0gX3BbMTRdICogazIgKyBfcFsxNV0gKiBvMjtcclxuICAgICAgICAgICAgICAgIF9wWzE1XSA9IF9wWzE1XSAqIHAyO1xyXG4gICAgICAgICAgICAvL31cclxuICAgICAgICAgICAgdGhpcy5faWRlbnRpdHlDYWxjdWxhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGExID0gX3BbMF07XHJcbiAgICAgICAgdmFyIGIxID0gX3BbMV07XHJcbiAgICAgICAgdmFyIGMxID0gX3BbMl07XHJcbiAgICAgICAgdmFyIGQxID0gX3BbM107XHJcbiAgICAgICAgdmFyIGUxID0gX3BbNF07XHJcbiAgICAgICAgdmFyIGYxID0gX3BbNV07XHJcbiAgICAgICAgdmFyIGcxID0gX3BbNl07XHJcbiAgICAgICAgdmFyIGgxID0gX3BbN107XHJcbiAgICAgICAgdmFyIGkxID0gX3BbOF07XHJcbiAgICAgICAgdmFyIGoxID0gX3BbOV07XHJcbiAgICAgICAgdmFyIGsxID0gX3BbMTBdO1xyXG4gICAgICAgIHZhciBsMSA9IF9wWzExXTtcclxuICAgICAgICB2YXIgbTEgPSBfcFsxMl07XHJcbiAgICAgICAgdmFyIG4xID0gX3BbMTNdO1xyXG4gICAgICAgIHZhciBvMSA9IF9wWzE0XTtcclxuICAgICAgICB2YXIgcDEgPSBfcFsxNV07XHJcblxyXG4gICAgICAgIC8qIG1hdHJpeCBvcmRlciAoY2FudmFzIGNvbXBhdGlibGUpOlxyXG4gICAgICAgICAqIGFjZVxyXG4gICAgICAgICAqIGJkZlxyXG4gICAgICAgICAqIDAwMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9wWzBdID0gYTEgKiBhMiArIGIxICogZTIgKyBjMSAqIGkyICsgZDEgKiBtMjtcclxuICAgICAgICBfcFsxXSA9IGExICogYjIgKyBiMSAqIGYyICsgYzEgKiBqMiArIGQxICogbjIgO1xyXG4gICAgICAgIF9wWzJdID0gYTEgKiBjMiArIGIxICogZzIgKyBjMSAqIGsyICsgZDEgKiBvMiA7XHJcbiAgICAgICAgX3BbM10gPSBhMSAqIGQyICsgYjEgKiBoMiArIGMxICogbDIgKyBkMSAqIHAyIDtcclxuXHJcbiAgICAgICAgX3BbNF0gPSBlMSAqIGEyICsgZjEgKiBlMiArIGcxICogaTIgKyBoMSAqIG0yIDtcclxuICAgICAgICBfcFs1XSA9IGUxICogYjIgKyBmMSAqIGYyICsgZzEgKiBqMiArIGgxICogbjIgO1xyXG4gICAgICAgIF9wWzZdID0gZTEgKiBjMiArIGYxICogZzIgKyBnMSAqIGsyICsgaDEgKiBvMiA7XHJcbiAgICAgICAgX3BbN10gPSBlMSAqIGQyICsgZjEgKiBoMiArIGcxICogbDIgKyBoMSAqIHAyIDtcclxuXHJcbiAgICAgICAgX3BbOF0gPSBpMSAqIGEyICsgajEgKiBlMiArIGsxICogaTIgKyBsMSAqIG0yIDtcclxuICAgICAgICBfcFs5XSA9IGkxICogYjIgKyBqMSAqIGYyICsgazEgKiBqMiArIGwxICogbjIgO1xyXG4gICAgICAgIF9wWzEwXSA9IGkxICogYzIgKyBqMSAqIGcyICsgazEgKiBrMiArIGwxICogbzIgO1xyXG4gICAgICAgIF9wWzExXSA9IGkxICogZDIgKyBqMSAqIGgyICsgazEgKiBsMiArIGwxICogcDIgO1xyXG5cclxuICAgICAgICBfcFsxMl0gPSBtMSAqIGEyICsgbjEgKiBlMiArIG8xICogaTIgKyBwMSAqIG0yIDtcclxuICAgICAgICBfcFsxM10gPSBtMSAqIGIyICsgbjEgKiBmMiArIG8xICogajIgKyBwMSAqIG4yIDtcclxuICAgICAgICBfcFsxNF0gPSBtMSAqIGMyICsgbjEgKiBnMiArIG8xICogazIgKyBwMSAqIG8yIDtcclxuICAgICAgICBfcFsxNV0gPSBtMSAqIGQyICsgbjEgKiBoMiArIG8xICogbDIgKyBwMSAqIHAyIDtcclxuXHJcbiAgICAgICAgdGhpcy5faWRlbnRpdHlDYWxjdWxhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNJZGVudGl0eSgpIHtcclxuICAgICAgICBpZighdGhpcy5faWRlbnRpdHlDYWxjdWxhdGVkKXtcclxuICAgICAgICAgICAgdGhpcy5faWRlbnRpdHkgPSAhKHRoaXMucHJvcHNbMF0gIT09IDEgfHwgdGhpcy5wcm9wc1sxXSAhPT0gMCB8fCB0aGlzLnByb3BzWzJdICE9PSAwIHx8IHRoaXMucHJvcHNbM10gIT09IDAgfHwgdGhpcy5wcm9wc1s0XSAhPT0gMCB8fCB0aGlzLnByb3BzWzVdICE9PSAxIHx8IHRoaXMucHJvcHNbNl0gIT09IDAgfHwgdGhpcy5wcm9wc1s3XSAhPT0gMCB8fCB0aGlzLnByb3BzWzhdICE9PSAwIHx8IHRoaXMucHJvcHNbOV0gIT09IDAgfHwgdGhpcy5wcm9wc1sxMF0gIT09IDEgfHwgdGhpcy5wcm9wc1sxMV0gIT09IDAgfHwgdGhpcy5wcm9wc1sxMl0gIT09IDAgfHwgdGhpcy5wcm9wc1sxM10gIT09IDAgfHwgdGhpcy5wcm9wc1sxNF0gIT09IDAgfHwgdGhpcy5wcm9wc1sxNV0gIT09IDEpO1xyXG4gICAgICAgICAgICB0aGlzLl9pZGVudGl0eUNhbGN1bGF0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5faWRlbnRpdHk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXF1YWxzKG1hdHIpe1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA8IDE2KSB7XHJcbiAgICAgICAgICAgIGlmKG1hdHIucHJvcHNbaV0gIT09IHRoaXMucHJvcHNbaV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKz0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjbG9uZShtYXRyKXtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IoaT0wO2k8MTY7aSs9MSl7XHJcbiAgICAgICAgICAgIG1hdHIucHJvcHNbaV0gPSB0aGlzLnByb3BzW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjbG9uZUZyb21Qcm9wcyhwcm9wcyl7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yKGk9MDtpPDE2O2krPTEpe1xyXG4gICAgICAgICAgICB0aGlzLnByb3BzW2ldID0gcHJvcHNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5VG9Qb2ludCh4LCB5LCB6KSB7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHg6IHggKiB0aGlzLnByb3BzWzBdICsgeSAqIHRoaXMucHJvcHNbNF0gKyB6ICogdGhpcy5wcm9wc1s4XSArIHRoaXMucHJvcHNbMTJdLFxyXG4gICAgICAgICAgICB5OiB4ICogdGhpcy5wcm9wc1sxXSArIHkgKiB0aGlzLnByb3BzWzVdICsgeiAqIHRoaXMucHJvcHNbOV0gKyB0aGlzLnByb3BzWzEzXSxcclxuICAgICAgICAgICAgejogeCAqIHRoaXMucHJvcHNbMl0gKyB5ICogdGhpcy5wcm9wc1s2XSArIHogKiB0aGlzLnByb3BzWzEwXSArIHRoaXMucHJvcHNbMTRdXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKnJldHVybiB7XHJcbiAgICAgICAgIHg6IHggKiBtZS5hICsgeSAqIG1lLmMgKyBtZS5lLFxyXG4gICAgICAgICB5OiB4ICogbWUuYiArIHkgKiBtZS5kICsgbWUuZlxyXG4gICAgICAgICB9OyovXHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBhcHBseVRvWCh4LCB5LCB6KSB7XHJcbiAgICAgICAgcmV0dXJuIHggKiB0aGlzLnByb3BzWzBdICsgeSAqIHRoaXMucHJvcHNbNF0gKyB6ICogdGhpcy5wcm9wc1s4XSArIHRoaXMucHJvcHNbMTJdO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gYXBwbHlUb1koeCwgeSwgeikge1xyXG4gICAgICAgIHJldHVybiB4ICogdGhpcy5wcm9wc1sxXSArIHkgKiB0aGlzLnByb3BzWzVdICsgeiAqIHRoaXMucHJvcHNbOV0gKyB0aGlzLnByb3BzWzEzXTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGFwcGx5VG9aKHgsIHksIHopIHtcclxuICAgICAgICByZXR1cm4geCAqIHRoaXMucHJvcHNbMl0gKyB5ICogdGhpcy5wcm9wc1s2XSArIHogKiB0aGlzLnByb3BzWzEwXSArIHRoaXMucHJvcHNbMTRdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGludmVyc2VQb2ludChwdCkge1xyXG4gICAgICAgIHZhciBkZXRlcm1pbmFudCA9IHRoaXMucHJvcHNbMF0gKiB0aGlzLnByb3BzWzVdIC0gdGhpcy5wcm9wc1sxXSAqIHRoaXMucHJvcHNbNF07XHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLnByb3BzWzVdL2RldGVybWluYW50O1xyXG4gICAgICAgIHZhciBiID0gLSB0aGlzLnByb3BzWzFdL2RldGVybWluYW50O1xyXG4gICAgICAgIHZhciBjID0gLSB0aGlzLnByb3BzWzRdL2RldGVybWluYW50O1xyXG4gICAgICAgIHZhciBkID0gdGhpcy5wcm9wc1swXS9kZXRlcm1pbmFudDtcclxuICAgICAgICB2YXIgZSA9ICh0aGlzLnByb3BzWzRdICogdGhpcy5wcm9wc1sxM10gLSB0aGlzLnByb3BzWzVdICogdGhpcy5wcm9wc1sxMl0pL2RldGVybWluYW50O1xyXG4gICAgICAgIHZhciBmID0gLSAodGhpcy5wcm9wc1swXSAqIHRoaXMucHJvcHNbMTNdIC0gdGhpcy5wcm9wc1sxXSAqIHRoaXMucHJvcHNbMTJdKS9kZXRlcm1pbmFudDtcclxuICAgICAgICByZXR1cm4gW3B0WzBdICogYSArIHB0WzFdICogYyArIGUsIHB0WzBdICogYiArIHB0WzFdICogZCArIGYsIDBdO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGludmVyc2VQb2ludHMocHRzKXtcclxuICAgICAgICB2YXIgaSwgbGVuID0gcHRzLmxlbmd0aCwgcmV0UHRzID0gW107XHJcbiAgICAgICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAgICAgcmV0UHRzW2ldID0gaW52ZXJzZVBvaW50KHB0c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXRQdHM7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYXBwbHlUb1RyaXBsZVBvaW50cyhwdDEsIHB0MiwgcHQzKSB7XHJcbiAgICAgICAgdmFyIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCA2KTtcclxuICAgICAgICBpZih0aGlzLmlzSWRlbnRpdHkoKSkge1xyXG4gICAgICAgICAgICBhcnJbMF0gPSBwdDFbMF07XHJcbiAgICAgICAgICAgIGFyclsxXSA9IHB0MVsxXTtcclxuICAgICAgICAgICAgYXJyWzJdID0gcHQyWzBdO1xyXG4gICAgICAgICAgICBhcnJbM10gPSBwdDJbMV07XHJcbiAgICAgICAgICAgIGFycls0XSA9IHB0M1swXTtcclxuICAgICAgICAgICAgYXJyWzVdID0gcHQzWzFdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBwMCA9IHRoaXMucHJvcHNbMF0sIHAxID0gdGhpcy5wcm9wc1sxXSwgcDQgPSB0aGlzLnByb3BzWzRdLCBwNSA9IHRoaXMucHJvcHNbNV0sIHAxMiA9IHRoaXMucHJvcHNbMTJdLCBwMTMgPSB0aGlzLnByb3BzWzEzXTtcclxuICAgICAgICAgICAgYXJyWzBdID0gcHQxWzBdICogcDAgKyBwdDFbMV0gKiBwNCArIHAxMjtcclxuICAgICAgICAgICAgYXJyWzFdID0gcHQxWzBdICogcDEgKyBwdDFbMV0gKiBwNSArIHAxMztcclxuICAgICAgICAgICAgYXJyWzJdID0gcHQyWzBdICogcDAgKyBwdDJbMV0gKiBwNCArIHAxMjtcclxuICAgICAgICAgICAgYXJyWzNdID0gcHQyWzBdICogcDEgKyBwdDJbMV0gKiBwNSArIHAxMztcclxuICAgICAgICAgICAgYXJyWzRdID0gcHQzWzBdICogcDAgKyBwdDNbMV0gKiBwNCArIHAxMjtcclxuICAgICAgICAgICAgYXJyWzVdID0gcHQzWzBdICogcDEgKyBwdDNbMV0gKiBwNSArIHAxMztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhcHBseVRvUG9pbnRBcnJheSh4LHkseil7XHJcbiAgICAgICAgdmFyIGFycjtcclxuICAgICAgICBpZih0aGlzLmlzSWRlbnRpdHkoKSkge1xyXG4gICAgICAgICAgICBhcnIgPSBbeCx5LHpdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGFyciA9IFt4ICogdGhpcy5wcm9wc1swXSArIHkgKiB0aGlzLnByb3BzWzRdICsgeiAqIHRoaXMucHJvcHNbOF0gKyB0aGlzLnByb3BzWzEyXSx4ICogdGhpcy5wcm9wc1sxXSArIHkgKiB0aGlzLnByb3BzWzVdICsgeiAqIHRoaXMucHJvcHNbOV0gKyB0aGlzLnByb3BzWzEzXSx4ICogdGhpcy5wcm9wc1syXSArIHkgKiB0aGlzLnByb3BzWzZdICsgeiAqIHRoaXMucHJvcHNbMTBdICsgdGhpcy5wcm9wc1sxNF1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKHgsIHkpIHtcclxuICAgICAgICBpZih0aGlzLmlzSWRlbnRpdHkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4geCArICcsJyArIHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfcCA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoKHggKiBfcFswXSArIHkgKiBfcFs0XSArIF9wWzEyXSkgKiAxMDApIC8gMTAwKycsJysgTWF0aC5yb3VuZCgoeCAqIF9wWzFdICsgeSAqIF9wWzVdICsgX3BbMTNdKSAqIDEwMCkgLyAxMDA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9DU1MoKSB7XHJcbiAgICAgICAgLy9Eb2Vzbid0IG1ha2UgbXVjaCBzZW5zZSB0byBhZGQgdGhpcyBvcHRpbWl6YXRpb24uIElmIGl0IGlzIGFuIGlkZW50aXR5IG1hdHJpeCwgaXQncyB2ZXJ5IGxpa2VseSB0aGlzIHdpbGwgZ2V0IGNhbGxlZCBvbmx5IG9uY2Ugc2luY2UgaXQgd29uJ3QgYmUga2V5ZnJhbWVkLlxyXG4gICAgICAgIC8qaWYodGhpcy5pc0lkZW50aXR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH0qL1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHZhciBjc3NWYWx1ZSA9ICdtYXRyaXgzZCgnO1xyXG4gICAgICAgIHZhciB2ID0gMTAwMDA7XHJcbiAgICAgICAgd2hpbGUoaTwxNil7XHJcbiAgICAgICAgICAgIGNzc1ZhbHVlICs9IF9ybmQocHJvcHNbaV0qdikvdjtcclxuICAgICAgICAgICAgY3NzVmFsdWUgKz0gaSA9PT0gMTUgPyAnKSc6JywnO1xyXG4gICAgICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjc3NWYWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByb3VuZE1hdHJpeFByb3BlcnR5KHZhbCkge1xyXG4gICAgICAgIHZhciB2ID0gMTAwMDA7XHJcbiAgICAgICAgaWYoKHZhbCA8IDAuMDAwMDAxICYmIHZhbCA+IDApIHx8ICh2YWwgPiAtMC4wMDAwMDEgJiYgdmFsIDwgMCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9ybmQodmFsICogdikgLyB2O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRvMmRDU1MoKSB7XHJcbiAgICAgICAgLy9Eb2Vzbid0IG1ha2UgbXVjaCBzZW5zZSB0byBhZGQgdGhpcyBvcHRpbWl6YXRpb24uIElmIGl0IGlzIGFuIGlkZW50aXR5IG1hdHJpeCwgaXQncyB2ZXJ5IGxpa2VseSB0aGlzIHdpbGwgZ2V0IGNhbGxlZCBvbmx5IG9uY2Ugc2luY2UgaXQgd29uJ3QgYmUga2V5ZnJhbWVkLlxyXG4gICAgICAgIC8qaWYodGhpcy5pc0lkZW50aXR5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH0qL1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgdmFyIF9hID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1swXSk7XHJcbiAgICAgICAgdmFyIF9iID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1sxXSk7XHJcbiAgICAgICAgdmFyIF9jID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1s0XSk7XHJcbiAgICAgICAgdmFyIF9kID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1s1XSk7XHJcbiAgICAgICAgdmFyIF9lID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1sxMl0pO1xyXG4gICAgICAgIHZhciBfZiA9IHJvdW5kTWF0cml4UHJvcGVydHkocHJvcHNbMTNdKTtcclxuICAgICAgICByZXR1cm4gXCJtYXRyaXgoXCIgKyBfYSArICcsJyArIF9iICsgJywnICsgX2MgKyAnLCcgKyBfZCArICcsJyArIF9lICsgJywnICsgX2YgKyBcIilcIjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLnJlc2V0ID0gcmVzZXQ7XHJcbiAgICAgICAgdGhpcy5yb3RhdGUgPSByb3RhdGU7XHJcbiAgICAgICAgdGhpcy5yb3RhdGVYID0gcm90YXRlWDtcclxuICAgICAgICB0aGlzLnJvdGF0ZVkgPSByb3RhdGVZO1xyXG4gICAgICAgIHRoaXMucm90YXRlWiA9IHJvdGF0ZVo7XHJcbiAgICAgICAgdGhpcy5za2V3ID0gc2tldztcclxuICAgICAgICB0aGlzLnNrZXdGcm9tQXhpcyA9IHNrZXdGcm9tQXhpcztcclxuICAgICAgICB0aGlzLnNoZWFyID0gc2hlYXI7XHJcbiAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtID0gc2V0VHJhbnNmb3JtO1xyXG4gICAgICAgIHRoaXMudHJhbnNsYXRlID0gdHJhbnNsYXRlO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgICAgIHRoaXMuYXBwbHlUb1BvaW50ID0gYXBwbHlUb1BvaW50O1xyXG4gICAgICAgIHRoaXMuYXBwbHlUb1ggPSBhcHBseVRvWDtcclxuICAgICAgICB0aGlzLmFwcGx5VG9ZID0gYXBwbHlUb1k7XHJcbiAgICAgICAgdGhpcy5hcHBseVRvWiA9IGFwcGx5VG9aO1xyXG4gICAgICAgIHRoaXMuYXBwbHlUb1BvaW50QXJyYXkgPSBhcHBseVRvUG9pbnRBcnJheTtcclxuICAgICAgICB0aGlzLmFwcGx5VG9UcmlwbGVQb2ludHMgPSBhcHBseVRvVHJpcGxlUG9pbnRzO1xyXG4gICAgICAgIHRoaXMuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQgPSBhcHBseVRvUG9pbnRTdHJpbmdpZmllZDtcclxuICAgICAgICB0aGlzLnRvQ1NTID0gdG9DU1M7XHJcbiAgICAgICAgdGhpcy50bzJkQ1NTID0gdG8yZENTUztcclxuICAgICAgICB0aGlzLmNsb25lID0gY2xvbmU7XHJcbiAgICAgICAgdGhpcy5jbG9uZUZyb21Qcm9wcyA9IGNsb25lRnJvbVByb3BzO1xyXG4gICAgICAgIHRoaXMuZXF1YWxzID0gZXF1YWxzO1xyXG4gICAgICAgIHRoaXMuaW52ZXJzZVBvaW50cyA9IGludmVyc2VQb2ludHM7XHJcbiAgICAgICAgdGhpcy5pbnZlcnNlUG9pbnQgPSBpbnZlcnNlUG9pbnQ7XHJcbiAgICAgICAgdGhpcy5fdCA9IHRoaXMudHJhbnNmb3JtO1xyXG4gICAgICAgIHRoaXMuaXNJZGVudGl0eSA9IGlzSWRlbnRpdHk7XHJcbiAgICAgICAgdGhpcy5faWRlbnRpdHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2lkZW50aXR5Q2FsY3VsYXRlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICB0aGlzLnByb3BzID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDE2KTtcclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICB9O1xyXG59KCkpO1xyXG5cbi8qXHJcbiBDb3B5cmlnaHQgMjAxNCBEYXZpZCBCYXUuXHJcblxyXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXHJcbiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcclxuIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xyXG4gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxyXG4gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXHJcbiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cclxuIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcclxuXHJcbiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxyXG4gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXHJcblxyXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcclxuIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxyXG4gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxyXG4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcclxuIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXHJcbiBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxyXG4gU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXHJcblxyXG4gKi9cclxuXHJcbihmdW5jdGlvbiAocG9vbCwgbWF0aCkge1xyXG4vL1xyXG4vLyBUaGUgZm9sbG93aW5nIGNvbnN0YW50cyBhcmUgcmVsYXRlZCB0byBJRUVFIDc1NCBsaW1pdHMuXHJcbi8vXHJcbiAgICB2YXIgZ2xvYmFsID0gdGhpcyxcclxuICAgICAgICB3aWR0aCA9IDI1NiwgICAgICAgIC8vIGVhY2ggUkM0IG91dHB1dCBpcyAwIDw9IHggPCAyNTZcclxuICAgICAgICBjaHVua3MgPSA2LCAgICAgICAgIC8vIGF0IGxlYXN0IHNpeCBSQzQgb3V0cHV0cyBmb3IgZWFjaCBkb3VibGVcclxuICAgICAgICBkaWdpdHMgPSA1MiwgICAgICAgIC8vIHRoZXJlIGFyZSA1MiBzaWduaWZpY2FudCBkaWdpdHMgaW4gYSBkb3VibGVcclxuICAgICAgICBybmduYW1lID0gJ3JhbmRvbScsIC8vIHJuZ25hbWU6IG5hbWUgZm9yIE1hdGgucmFuZG9tIGFuZCBNYXRoLnNlZWRyYW5kb21cclxuICAgICAgICBzdGFydGRlbm9tID0gbWF0aC5wb3cod2lkdGgsIGNodW5rcyksXHJcbiAgICAgICAgc2lnbmlmaWNhbmNlID0gbWF0aC5wb3coMiwgZGlnaXRzKSxcclxuICAgICAgICBvdmVyZmxvdyA9IHNpZ25pZmljYW5jZSAqIDIsXHJcbiAgICAgICAgbWFzayA9IHdpZHRoIC0gMSxcclxuICAgICAgICBub2RlY3J5cHRvOyAgICAgICAgIC8vIG5vZGUuanMgY3J5cHRvIG1vZHVsZSwgaW5pdGlhbGl6ZWQgYXQgdGhlIGJvdHRvbS5cclxuXHJcbi8vXHJcbi8vIHNlZWRyYW5kb20oKVxyXG4vLyBUaGlzIGlzIHRoZSBzZWVkcmFuZG9tIGZ1bmN0aW9uIGRlc2NyaWJlZCBhYm92ZS5cclxuLy9cclxuICAgIGZ1bmN0aW9uIHNlZWRyYW5kb20oc2VlZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIga2V5ID0gW107XHJcbiAgICAgICAgb3B0aW9ucyA9IChvcHRpb25zID09PSB0cnVlKSA/IHsgZW50cm9weTogdHJ1ZSB9IDogKG9wdGlvbnMgfHwge30pO1xyXG5cclxuICAgICAgICAvLyBGbGF0dGVuIHRoZSBzZWVkIHN0cmluZyBvciBidWlsZCBvbmUgZnJvbSBsb2NhbCBlbnRyb3B5IGlmIG5lZWRlZC5cclxuICAgICAgICB2YXIgc2hvcnRzZWVkID0gbWl4a2V5KGZsYXR0ZW4oXHJcbiAgICAgICAgICAgIG9wdGlvbnMuZW50cm9weSA/IFtzZWVkLCB0b3N0cmluZyhwb29sKV0gOlxyXG4gICAgICAgICAgICAgICAgKHNlZWQgPT09IG51bGwpID8gYXV0b3NlZWQoKSA6IHNlZWQsIDMpLCBrZXkpO1xyXG5cclxuICAgICAgICAvLyBVc2UgdGhlIHNlZWQgdG8gaW5pdGlhbGl6ZSBhbiBBUkM0IGdlbmVyYXRvci5cclxuICAgICAgICB2YXIgYXJjNCA9IG5ldyBBUkM0KGtleSk7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHJhbmRvbSBkb3VibGUgaW4gWzAsIDEpIHRoYXQgY29udGFpbnNcclxuICAgICAgICAvLyByYW5kb21uZXNzIGluIGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2Egb2YgdGhlIElFRUUgNzU0IHZhbHVlLlxyXG4gICAgICAgIHZhciBwcm5nID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gYXJjNC5nKGNodW5rcyksICAgICAgICAgICAgIC8vIFN0YXJ0IHdpdGggYSBudW1lcmF0b3IgbiA8IDIgXiA0OFxyXG4gICAgICAgICAgICAgICAgZCA9IHN0YXJ0ZGVub20sICAgICAgICAgICAgICAgICAvLyAgIGFuZCBkZW5vbWluYXRvciBkID0gMiBeIDQ4LlxyXG4gICAgICAgICAgICAgICAgeCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGFuZCBubyAnZXh0cmEgbGFzdCBieXRlJy5cclxuICAgICAgICAgICAgd2hpbGUgKG4gPCBzaWduaWZpY2FuY2UpIHsgICAgICAgICAgLy8gRmlsbCB1cCBhbGwgc2lnbmlmaWNhbnQgZGlnaXRzIGJ5XHJcbiAgICAgICAgICAgICAgICBuID0gKG4gKyB4KSAqIHdpZHRoOyAgICAgICAgICAgICAgLy8gICBzaGlmdGluZyBudW1lcmF0b3IgYW5kXHJcbiAgICAgICAgICAgICAgICBkICo9IHdpZHRoOyAgICAgICAgICAgICAgICAgICAgICAgLy8gICBkZW5vbWluYXRvciBhbmQgZ2VuZXJhdGluZyBhXHJcbiAgICAgICAgICAgICAgICB4ID0gYXJjNC5nKDEpOyAgICAgICAgICAgICAgICAgICAgLy8gICBuZXcgbGVhc3Qtc2lnbmlmaWNhbnQtYnl0ZS5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB3aGlsZSAobiA+PSBvdmVyZmxvdykgeyAgICAgICAgICAgICAvLyBUbyBhdm9pZCByb3VuZGluZyB1cCwgYmVmb3JlIGFkZGluZ1xyXG4gICAgICAgICAgICAgICAgbiAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgbGFzdCBieXRlLCBzaGlmdCBldmVyeXRoaW5nXHJcbiAgICAgICAgICAgICAgICBkIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICByaWdodCB1c2luZyBpbnRlZ2VyIG1hdGggdW50aWxcclxuICAgICAgICAgICAgICAgIHggPj4+PSAxOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHdlIGhhdmUgZXhhY3RseSB0aGUgZGVzaXJlZCBiaXRzLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAobiArIHgpIC8gZDsgICAgICAgICAgICAgICAgIC8vIEZvcm0gdGhlIG51bWJlciB3aXRoaW4gWzAsIDEpLlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHBybmcuaW50MzIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGFyYzQuZyg0KSB8IDA7IH07XHJcbiAgICAgICAgcHJuZy5xdWljayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJjNC5nKDQpIC8gMHgxMDAwMDAwMDA7IH07XHJcbiAgICAgICAgcHJuZy5kb3VibGUgPSBwcm5nO1xyXG5cclxuICAgICAgICAvLyBNaXggdGhlIHJhbmRvbW5lc3MgaW50byBhY2N1bXVsYXRlZCBlbnRyb3B5LlxyXG4gICAgICAgIG1peGtleSh0b3N0cmluZyhhcmM0LlMpLCBwb29sKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbGluZyBjb252ZW50aW9uOiB3aGF0IHRvIHJldHVybiBhcyBhIGZ1bmN0aW9uIG9mIHBybmcsIHNlZWQsIGlzX21hdGguXHJcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLnBhc3MgfHwgY2FsbGJhY2sgfHxcclxuICAgICAgICBmdW5jdGlvbihwcm5nLCBzZWVkLCBpc19tYXRoX2NhbGwsIHN0YXRlKSB7XHJcbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTG9hZCB0aGUgYXJjNCBzdGF0ZSBmcm9tIHRoZSBnaXZlbiBzdGF0ZSBpZiBpdCBoYXMgYW4gUyBhcnJheS5cclxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5TKSB7IGNvcHkoc3RhdGUsIGFyYzQpOyB9XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHByb3ZpZGUgdGhlIC5zdGF0ZSBtZXRob2QgaWYgcmVxdWVzdGVkIHZpYSBvcHRpb25zLnN0YXRlLlxyXG4gICAgICAgICAgICAgICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weShhcmM0LCB7fSk7IH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIElmIGNhbGxlZCBhcyBhIG1ldGhvZCBvZiBNYXRoIChNYXRoLnNlZWRyYW5kb20oKSksIG11dGF0ZVxyXG4gICAgICAgICAgICAvLyBNYXRoLnJhbmRvbSBiZWNhdXNlIHRoYXQgaXMgaG93IHNlZWRyYW5kb20uanMgaGFzIHdvcmtlZCBzaW5jZSB2MS4wLlxyXG4gICAgICAgICAgICBpZiAoaXNfbWF0aF9jYWxsKSB7IG1hdGhbcm5nbmFtZV0gPSBwcm5nOyByZXR1cm4gc2VlZDsgfVxyXG5cclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCBpcyBhIG5ld2VyIGNhbGxpbmcgY29udmVudGlvbiwgc28gcmV0dXJuIHRoZVxyXG4gICAgICAgICAgICAvLyBwcm5nIGRpcmVjdGx5LlxyXG4gICAgICAgICAgICBlbHNlIHJldHVybiBwcm5nO1xyXG4gICAgICAgIH0pKFxyXG4gICAgICAgICAgICBwcm5nLFxyXG4gICAgICAgICAgICBzaG9ydHNlZWQsXHJcbiAgICAgICAgICAgICdnbG9iYWwnIGluIG9wdGlvbnMgPyBvcHRpb25zLmdsb2JhbCA6ICh0aGlzID09IG1hdGgpLFxyXG4gICAgICAgICAgICBvcHRpb25zLnN0YXRlKTtcclxuICAgIH1cclxuICAgIG1hdGhbJ3NlZWQnICsgcm5nbmFtZV0gPSBzZWVkcmFuZG9tO1xyXG5cclxuLy9cclxuLy8gQVJDNFxyXG4vL1xyXG4vLyBBbiBBUkM0IGltcGxlbWVudGF0aW9uLiAgVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEga2V5IGluIHRoZSBmb3JtIG9mXHJcbi8vIGFuIGFycmF5IG9mIGF0IG1vc3QgKHdpZHRoKSBpbnRlZ2VycyB0aGF0IHNob3VsZCBiZSAwIDw9IHggPCAod2lkdGgpLlxyXG4vL1xyXG4vLyBUaGUgZyhjb3VudCkgbWV0aG9kIHJldHVybnMgYSBwc2V1ZG9yYW5kb20gaW50ZWdlciB0aGF0IGNvbmNhdGVuYXRlc1xyXG4vLyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgZnJvbSBBUkM0LiAgSXRzIHJldHVybiB2YWx1ZSBpcyBhIG51bWJlciB4XHJcbi8vIHRoYXQgaXMgaW4gdGhlIHJhbmdlIDAgPD0geCA8ICh3aWR0aCBeIGNvdW50KS5cclxuLy9cclxuICAgIGZ1bmN0aW9uIEFSQzQoa2V5KSB7XHJcbiAgICAgICAgdmFyIHQsIGtleWxlbiA9IGtleS5sZW5ndGgsXHJcbiAgICAgICAgICAgIG1lID0gdGhpcywgaSA9IDAsIGogPSBtZS5pID0gbWUuaiA9IDAsIHMgPSBtZS5TID0gW107XHJcblxyXG4gICAgICAgIC8vIFRoZSBlbXB0eSBrZXkgW10gaXMgdHJlYXRlZCBhcyBbMF0uXHJcbiAgICAgICAgaWYgKCFrZXlsZW4pIHsga2V5ID0gW2tleWxlbisrXTsgfVxyXG5cclxuICAgICAgICAvLyBTZXQgdXAgUyB1c2luZyB0aGUgc3RhbmRhcmQga2V5IHNjaGVkdWxpbmcgYWxnb3JpdGhtLlxyXG4gICAgICAgIHdoaWxlIChpIDwgd2lkdGgpIHtcclxuICAgICAgICAgICAgc1tpXSA9IGkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcclxuICAgICAgICAgICAgc1tpXSA9IHNbaiA9IG1hc2sgJiAoaiArIGtleVtpICUga2V5bGVuXSArICh0ID0gc1tpXSkpXTtcclxuICAgICAgICAgICAgc1tqXSA9IHQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgXCJnXCIgbWV0aG9kIHJldHVybnMgdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGFzIG9uZSBudW1iZXIuXHJcbiAgICAgICAgbWUuZyA9IGZ1bmN0aW9uKGNvdW50KSB7XHJcbiAgICAgICAgICAgIC8vIFVzaW5nIGluc3RhbmNlIG1lbWJlcnMgaW5zdGVhZCBvZiBjbG9zdXJlIHN0YXRlIG5lYXJseSBkb3VibGVzIHNwZWVkLlxyXG4gICAgICAgICAgICB2YXIgdCwgciA9IDAsXHJcbiAgICAgICAgICAgICAgICBpID0gbWUuaSwgaiA9IG1lLmosIHMgPSBtZS5TO1xyXG4gICAgICAgICAgICB3aGlsZSAoY291bnQtLSkge1xyXG4gICAgICAgICAgICAgICAgdCA9IHNbaSA9IG1hc2sgJiAoaSArIDEpXTtcclxuICAgICAgICAgICAgICAgIHIgPSByICogd2lkdGggKyBzW21hc2sgJiAoKHNbaV0gPSBzW2ogPSBtYXNrICYgKGogKyB0KV0pICsgKHNbal0gPSB0KSldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1lLmkgPSBpOyBtZS5qID0gajtcclxuICAgICAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgICAgICAgIC8vIEZvciByb2J1c3QgdW5wcmVkaWN0YWJpbGl0eSwgdGhlIGZ1bmN0aW9uIGNhbGwgYmVsb3cgYXV0b21hdGljYWxseVxyXG4gICAgICAgICAgICAvLyBkaXNjYXJkcyBhbiBpbml0aWFsIGJhdGNoIG9mIHZhbHVlcy4gIFRoaXMgaXMgY2FsbGVkIFJDNC1kcm9wWzI1Nl0uXHJcbiAgICAgICAgICAgIC8vIFNlZSBodHRwOi8vZ29vZ2xlLmNvbS9zZWFyY2g/cT1yc2ErZmx1aHJlcityZXNwb25zZSZidG5JXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbi8vXHJcbi8vIGNvcHkoKVxyXG4vLyBDb3BpZXMgaW50ZXJuYWwgc3RhdGUgb2YgQVJDNCB0byBvciBmcm9tIGEgcGxhaW4gb2JqZWN0LlxyXG4vL1xyXG4gICAgZnVuY3Rpb24gY29weShmLCB0KSB7XHJcbiAgICAgICAgdC5pID0gZi5pO1xyXG4gICAgICAgIHQuaiA9IGYuajtcclxuICAgICAgICB0LlMgPSBmLlMuc2xpY2UoKTtcclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuXHJcbi8vXHJcbi8vIGZsYXR0ZW4oKVxyXG4vLyBDb252ZXJ0cyBhbiBvYmplY3QgdHJlZSB0byBuZXN0ZWQgYXJyYXlzIG9mIHN0cmluZ3MuXHJcbi8vXHJcbiAgICBmdW5jdGlvbiBmbGF0dGVuKG9iaiwgZGVwdGgpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW10sIHR5cCA9ICh0eXBlb2Ygb2JqKSwgcHJvcDtcclxuICAgICAgICBpZiAoZGVwdGggJiYgdHlwID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGZvciAocHJvcCBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7IHJlc3VsdC5wdXNoKGZsYXR0ZW4ob2JqW3Byb3BdLCBkZXB0aCAtIDEpKTsgfSBjYXRjaCAoZSkge31cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHJlc3VsdC5sZW5ndGggPyByZXN1bHQgOiB0eXAgPT0gJ3N0cmluZycgPyBvYmogOiBvYmogKyAnXFwwJyk7XHJcbiAgICB9XHJcblxyXG4vL1xyXG4vLyBtaXhrZXkoKVxyXG4vLyBNaXhlcyBhIHN0cmluZyBzZWVkIGludG8gYSBrZXkgdGhhdCBpcyBhbiBhcnJheSBvZiBpbnRlZ2VycywgYW5kXHJcbi8vIHJldHVybnMgYSBzaG9ydGVuZWQgc3RyaW5nIHNlZWQgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZSByZXN1bHQga2V5LlxyXG4vL1xyXG4gICAgZnVuY3Rpb24gbWl4a2V5KHNlZWQsIGtleSkge1xyXG4gICAgICAgIHZhciBzdHJpbmdzZWVkID0gc2VlZCArICcnLCBzbWVhciwgaiA9IDA7XHJcbiAgICAgICAgd2hpbGUgKGogPCBzdHJpbmdzZWVkLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBrZXlbbWFzayAmIGpdID1cclxuICAgICAgICAgICAgICAgIG1hc2sgJiAoKHNtZWFyIF49IGtleVttYXNrICYgal0gKiAxOSkgKyBzdHJpbmdzZWVkLmNoYXJDb2RlQXQoaisrKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b3N0cmluZyhrZXkpO1xyXG4gICAgfVxyXG5cclxuLy9cclxuLy8gYXV0b3NlZWQoKVxyXG4vLyBSZXR1cm5zIGFuIG9iamVjdCBmb3IgYXV0b3NlZWRpbmcsIHVzaW5nIHdpbmRvdy5jcnlwdG8gYW5kIE5vZGUgY3J5cHRvXHJcbi8vIG1vZHVsZSBpZiBhdmFpbGFibGUuXHJcbi8vXHJcbiAgICBmdW5jdGlvbiBhdXRvc2VlZCgpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAobm9kZWNyeXB0bykgeyByZXR1cm4gdG9zdHJpbmcobm9kZWNyeXB0by5yYW5kb21CeXRlcyh3aWR0aCkpOyB9XHJcbiAgICAgICAgICAgIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSh3aWR0aCk7XHJcbiAgICAgICAgICAgIChnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0bykuZ2V0UmFuZG9tVmFsdWVzKG91dCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0b3N0cmluZyhvdXQpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgdmFyIGJyb3dzZXIgPSBnbG9iYWwubmF2aWdhdG9yLFxyXG4gICAgICAgICAgICAgICAgcGx1Z2lucyA9IGJyb3dzZXIgJiYgYnJvd3Nlci5wbHVnaW5zO1xyXG4gICAgICAgICAgICByZXR1cm4gWytuZXcgRGF0ZSgpLCBnbG9iYWwsIHBsdWdpbnMsIGdsb2JhbC5zY3JlZW4sIHRvc3RyaW5nKHBvb2wpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4vL1xyXG4vLyB0b3N0cmluZygpXHJcbi8vIENvbnZlcnRzIGFuIGFycmF5IG9mIGNoYXJjb2RlcyB0byBhIHN0cmluZ1xyXG4vL1xyXG4gICAgZnVuY3Rpb24gdG9zdHJpbmcoYSkge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KDAsIGEpO1xyXG4gICAgfVxyXG5cclxuLy9cclxuLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcclxuLy8gZnJvbSB0aGUgYnVpbHQtaW4gUk5HIGludG8gdGhlIGVudHJvcHkgcG9vbC4gIEJlY2F1c2Ugd2UgZG9cclxuLy8gbm90IHdhbnQgdG8gaW50ZXJmZXJlIHdpdGggZGV0ZXJtaW5pc3RpYyBQUk5HIHN0YXRlIGxhdGVyLFxyXG4vLyBzZWVkcmFuZG9tIHdpbGwgbm90IGNhbGwgbWF0aC5yYW5kb20gb24gaXRzIG93biBhZ2FpbiBhZnRlclxyXG4vLyBpbml0aWFsaXphdGlvbi5cclxuLy9cclxuICAgIG1peGtleShtYXRoLnJhbmRvbSgpLCBwb29sKTtcclxuXHJcbi8vXHJcbi8vIE5vZGVqcyBhbmQgQU1EIHN1cHBvcnQ6IGV4cG9ydCB0aGUgaW1wbGVtZW50YXRpb24gYXMgYSBtb2R1bGUgdXNpbmdcclxuLy8gZWl0aGVyIGNvbnZlbnRpb24uXHJcbi8vXHJcblxyXG4vLyBFbmQgYW5vbnltb3VzIHNjb3BlLCBhbmQgcGFzcyBpbml0aWFsIHZhbHVlcy5cclxufSkoXHJcbiAgICBbXSwgICAgIC8vIHBvb2w6IGVudHJvcHkgcG9vbCBzdGFydHMgZW1wdHlcclxuICAgIEJNTWF0aCAgICAvLyBtYXRoOiBwYWNrYWdlIGNvbnRhaW5pbmcgcmFuZG9tLCBwb3csIGFuZCBzZWVkcmFuZG9tXHJcbik7XG52YXIgQmV6aWVyRmFjdG9yeSA9IChmdW5jdGlvbigpe1xyXG4gICAgLyoqXHJcbiAgICAgKiBCZXppZXJFYXNpbmcgLSB1c2UgYmV6aWVyIGN1cnZlIGZvciB0cmFuc2l0aW9uIGVhc2luZyBmdW5jdGlvblxyXG4gICAgICogYnkgR2HDq3RhbiBSZW5hdWRlYXUgMjAxNCAtIDIwMTUg4oCTIE1JVCBMaWNlbnNlXHJcbiAgICAgKlxyXG4gICAgICogQ3JlZGl0czogaXMgYmFzZWQgb24gRmlyZWZveCdzIG5zU01JTEtleVNwbGluZS5jcHBcclxuICAgICAqIFVzYWdlOlxyXG4gICAgICogdmFyIHNwbGluZSA9IEJlemllckVhc2luZyhbIDAuMjUsIDAuMSwgMC4yNSwgMS4wIF0pXHJcbiAgICAgKiBzcGxpbmUuZ2V0KHgpID0+IHJldHVybnMgdGhlIGVhc2luZyB2YWx1ZSB8IHggbXVzdCBiZSBpbiBbMCwgMV0gcmFuZ2VcclxuICAgICAqXHJcbiAgICAgKi9cclxuXHJcbiAgICAgICAgdmFyIG9iID0ge307XHJcbiAgICBvYi5nZXRCZXppZXJFYXNpbmcgPSBnZXRCZXppZXJFYXNpbmc7XHJcbiAgICB2YXIgYmV6aWVycyA9IHt9O1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldEJlemllckVhc2luZyhhLGIsYyxkLG5tKXtcclxuICAgICAgICB2YXIgc3RyID0gbm0gfHwgKCdiZXpfJyArIGErJ18nK2IrJ18nK2MrJ18nK2QpLnJlcGxhY2UoL1xcLi9nLCAncCcpO1xyXG4gICAgICAgIGlmKGJlemllcnNbc3RyXSl7XHJcbiAgICAgICAgICAgIHJldHVybiBiZXppZXJzW3N0cl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiZXpFYXNpbmcgPSBuZXcgQmV6aWVyRWFzaW5nKFthLGIsYyxkXSk7XHJcbiAgICAgICAgYmV6aWVyc1tzdHJdID0gYmV6RWFzaW5nO1xyXG4gICAgICAgIHJldHVybiBiZXpFYXNpbmc7XHJcbiAgICB9XHJcblxyXG4vLyBUaGVzZSB2YWx1ZXMgYXJlIGVzdGFibGlzaGVkIGJ5IGVtcGlyaWNpc20gd2l0aCB0ZXN0cyAodHJhZGVvZmY6IHBlcmZvcm1hbmNlIFZTIHByZWNpc2lvbilcclxuICAgIHZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQ7XHJcbiAgICB2YXIgTkVXVE9OX01JTl9TTE9QRSA9IDAuMDAxO1xyXG4gICAgdmFyIFNVQkRJVklTSU9OX1BSRUNJU0lPTiA9IDAuMDAwMDAwMTtcclxuICAgIHZhciBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwO1xyXG5cclxuICAgIHZhciBrU3BsaW5lVGFibGVTaXplID0gMTE7XHJcbiAgICB2YXIga1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApO1xyXG5cclxuICAgIHZhciBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSBcImZ1bmN0aW9uXCI7XHJcblxyXG4gICAgZnVuY3Rpb24gQSAoYUExLCBhQTIpIHsgcmV0dXJuIDEuMCAtIDMuMCAqIGFBMiArIDMuMCAqIGFBMTsgfVxyXG4gICAgZnVuY3Rpb24gQiAoYUExLCBhQTIpIHsgcmV0dXJuIDMuMCAqIGFBMiAtIDYuMCAqIGFBMTsgfVxyXG4gICAgZnVuY3Rpb24gQyAoYUExKSAgICAgIHsgcmV0dXJuIDMuMCAqIGFBMTsgfVxyXG5cclxuLy8gUmV0dXJucyB4KHQpIGdpdmVuIHQsIHgxLCBhbmQgeDIsIG9yIHkodCkgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cclxuICAgIGZ1bmN0aW9uIGNhbGNCZXppZXIgKGFULCBhQTEsIGFBMikge1xyXG4gICAgICAgIHJldHVybiAoKEEoYUExLCBhQTIpKmFUICsgQihhQTEsIGFBMikpKmFUICsgQyhhQTEpKSphVDtcclxuICAgIH1cclxuXHJcbi8vIFJldHVybnMgZHgvZHQgZ2l2ZW4gdCwgeDEsIGFuZCB4Miwgb3IgZHkvZHQgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cclxuICAgIGZ1bmN0aW9uIGdldFNsb3BlIChhVCwgYUExLCBhQTIpIHtcclxuICAgICAgICByZXR1cm4gMy4wICogQShhQTEsIGFBMikqYVQqYVQgKyAyLjAgKiBCKGFBMSwgYUEyKSAqIGFUICsgQyhhQTEpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZSAoYVgsIGFBLCBhQiwgbVgxLCBtWDIpIHtcclxuICAgICAgICB2YXIgY3VycmVudFgsIGN1cnJlbnRULCBpID0gMDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XHJcbiAgICAgICAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50WCA+IDAuMCkge1xyXG4gICAgICAgICAgICAgICAgYUIgPSBjdXJyZW50VDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGFBID0gY3VycmVudFQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBTVUJESVZJU0lPTl9QUkVDSVNJT04gJiYgKytpIDwgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMpO1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50VDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZSAoYVgsIGFHdWVzc1QsIG1YMSwgbVgyKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBORVdUT05fSVRFUkFUSU9OUzsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDAuMCkgcmV0dXJuIGFHdWVzc1Q7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XHJcbiAgICAgICAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhR3Vlc3NUO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogcG9pbnRzIGlzIGFuIGFycmF5IG9mIFsgbVgxLCBtWTEsIG1YMiwgbVkyIF1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQmV6aWVyRWFzaW5nIChwb2ludHMpIHtcclxuICAgICAgICB0aGlzLl9wID0gcG9pbnRzO1xyXG4gICAgICAgIHRoaXMuX21TYW1wbGVWYWx1ZXMgPSBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPyBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpIDogbmV3IEFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xyXG4gICAgICAgIHRoaXMuX3ByZWNvbXB1dGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuZ2V0ID0gdGhpcy5nZXQuYmluZCh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBCZXppZXJFYXNpbmcucHJvdG90eXBlID0ge1xyXG5cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgIHZhciBtWDEgPSB0aGlzLl9wWzBdLFxyXG4gICAgICAgICAgICAgICAgbVkxID0gdGhpcy5fcFsxXSxcclxuICAgICAgICAgICAgICAgIG1YMiA9IHRoaXMuX3BbMl0sXHJcbiAgICAgICAgICAgICAgICBtWTIgPSB0aGlzLl9wWzNdO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ByZWNvbXB1dGVkKSB0aGlzLl9wcmVjb21wdXRlKCk7XHJcbiAgICAgICAgICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMikgcmV0dXJuIHg7IC8vIGxpbmVhclxyXG4gICAgICAgICAgICAvLyBCZWNhdXNlIEphdmFTY3JpcHQgbnVtYmVyIGFyZSBpbXByZWNpc2UsIHdlIHNob3VsZCBndWFyYW50ZWUgdGhlIGV4dHJlbWVzIGFyZSByaWdodC5cclxuICAgICAgICAgICAgaWYgKHggPT09IDApIHJldHVybiAwO1xyXG4gICAgICAgICAgICBpZiAoeCA9PT0gMSkgcmV0dXJuIDE7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxjQmV6aWVyKHRoaXMuX2dldFRGb3JYKHgpLCBtWTEsIG1ZMik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLy8gUHJpdmF0ZSBwYXJ0XHJcblxyXG4gICAgICAgIF9wcmVjb21wdXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBtWDEgPSB0aGlzLl9wWzBdLFxyXG4gICAgICAgICAgICAgICAgbVkxID0gdGhpcy5fcFsxXSxcclxuICAgICAgICAgICAgICAgIG1YMiA9IHRoaXMuX3BbMl0sXHJcbiAgICAgICAgICAgICAgICBtWTIgPSB0aGlzLl9wWzNdO1xyXG4gICAgICAgICAgICB0aGlzLl9wcmVjb21wdXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMilcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGNTYW1wbGVWYWx1ZXMoKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfY2FsY1NhbXBsZVZhbHVlczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbVgxID0gdGhpcy5fcFswXSxcclxuICAgICAgICAgICAgICAgIG1YMiA9IHRoaXMuX3BbMl07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga1NwbGluZVRhYmxlU2l6ZTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tU2FtcGxlVmFsdWVzW2ldID0gY2FsY0JlemllcihpICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBnZXRURm9yWCBjaG9zZSB0aGUgZmFzdGVzdCBoZXVyaXN0aWMgdG8gZGV0ZXJtaW5lIHRoZSBwZXJjZW50YWdlIHZhbHVlIHByZWNpc2VseSBmcm9tIGEgZ2l2ZW4gWCBwcm9qZWN0aW9uLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF9nZXRURm9yWDogZnVuY3Rpb24gKGFYKSB7XHJcbiAgICAgICAgICAgIHZhciBtWDEgPSB0aGlzLl9wWzBdLFxyXG4gICAgICAgICAgICAgICAgbVgyID0gdGhpcy5fcFsyXSxcclxuICAgICAgICAgICAgICAgIG1TYW1wbGVWYWx1ZXMgPSB0aGlzLl9tU2FtcGxlVmFsdWVzO1xyXG5cclxuICAgICAgICAgICAgdmFyIGludGVydmFsU3RhcnQgPSAwLjA7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50U2FtcGxlID0gMTtcclxuICAgICAgICAgICAgdmFyIGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLS1jdXJyZW50U2FtcGxlO1xyXG5cclxuICAgICAgICAgICAgLy8gSW50ZXJwb2xhdGUgdG8gcHJvdmlkZSBhbiBpbml0aWFsIGd1ZXNzIGZvciB0XHJcbiAgICAgICAgICAgIHZhciBkaXN0ID0gKGFYIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgLyAobVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlKzFdIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XHJcbiAgICAgICAgICAgIHZhciBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZTtcclxuXHJcbiAgICAgICAgICAgIHZhciBpbml0aWFsU2xvcGUgPSBnZXRTbG9wZShndWVzc0ZvclQsIG1YMSwgbVgyKTtcclxuICAgICAgICAgICAgaWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gb2I7XHJcblxyXG59KCkpO1xuKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBsYXN0VGltZSA9IDA7XHJcbiAgICB2YXIgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XHJcbiAgICBmb3IodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCkge1xyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcclxuICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddIHx8IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddO1xyXG4gICAgfVxyXG4gICAgaWYoIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpXHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZWxlbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgICAgICAgdmFyIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XHJcbiAgICAgICAgICAgIHZhciBpZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgdGltZVRvQ2FsbCk7XHJcbiAgICAgICAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICAgICAgfTtcclxuICAgIGlmKCF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpXHJcbiAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XHJcbiAgICAgICAgfTtcclxufSgpKTtcclxuXG5mdW5jdGlvbiBleHRlbmRQcm90b3R5cGUoc291cmNlcyxkZXN0aW5hdGlvbil7XHJcbiAgICB2YXIgaSwgbGVuID0gc291cmNlcy5sZW5ndGgsIHNvdXJjZVByb3RvdHlwZTtcclxuICAgIGZvciAoaSA9IDA7aSA8IGxlbjtpICs9IDEpIHtcclxuICAgICAgICBzb3VyY2VQcm90b3R5cGUgPSBzb3VyY2VzW2ldLnByb3RvdHlwZTtcclxuICAgICAgICBmb3IgKHZhciBhdHRyIGluIHNvdXJjZVByb3RvdHlwZSkge1xyXG4gICAgICAgICAgICBpZiAoc291cmNlUHJvdG90eXBlLmhhc093blByb3BlcnR5KGF0dHIpKSBkZXN0aW5hdGlvbi5wcm90b3R5cGVbYXR0cl0gPSBzb3VyY2VQcm90b3R5cGVbYXR0cl07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXREZXNjcmlwdG9yKG9iamVjdCwgcHJvcCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlUHJveHlGdW5jdGlvbihwcm90b3R5cGUpIHtcclxuXHRmdW5jdGlvbiBQcm94eUZ1bmN0aW9uKCl7fVxyXG5cdFByb3h5RnVuY3Rpb24ucHJvdG90eXBlID0gcHJvdG90eXBlO1xyXG5cdHJldHVybiBQcm94eUZ1bmN0aW9uO1xyXG59XG5mdW5jdGlvbiBiZXpGdW5jdGlvbigpe1xyXG5cclxuICAgIHZhciBlYXNpbmdGdW5jdGlvbnMgPSBbXTtcclxuICAgIHZhciBtYXRoID0gTWF0aDtcclxuXHJcbiAgICBmdW5jdGlvbiBwb2ludE9uTGluZTJEKHgxLHkxLCB4Mix5MiwgeDMseTMpe1xyXG4gICAgICAgIHZhciBkZXQxID0gKHgxKnkyKSArICh5MSp4MykgKyAoeDIqeTMpIC0gKHgzKnkyKSAtICh5Myp4MSkgLSAoeDIqeTEpO1xyXG4gICAgICAgIHJldHVybiBkZXQxID4gLTAuMDAxICYmIGRldDEgPCAwLjAwMTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwb2ludE9uTGluZTNEKHgxLHkxLHoxLCB4Mix5Mix6MiwgeDMseTMsejMpe1xyXG4gICAgICAgIGlmKHoxID09PSAwICYmIHoyID09PSAwICYmIHozID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwb2ludE9uTGluZTJEKHgxLHkxLCB4Mix5MiwgeDMseTMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGlzdDEgPSBNYXRoLnNxcnQoTWF0aC5wb3coeDIgLSB4MSwgMikgKyBNYXRoLnBvdyh5MiAtIHkxLCAyKSArIE1hdGgucG93KHoyIC0gejEsIDIpKTtcclxuICAgICAgICB2YXIgZGlzdDIgPSBNYXRoLnNxcnQoTWF0aC5wb3coeDMgLSB4MSwgMikgKyBNYXRoLnBvdyh5MyAtIHkxLCAyKSArIE1hdGgucG93KHozIC0gejEsIDIpKTtcclxuICAgICAgICB2YXIgZGlzdDMgPSBNYXRoLnNxcnQoTWF0aC5wb3coeDMgLSB4MiwgMikgKyBNYXRoLnBvdyh5MyAtIHkyLCAyKSArIE1hdGgucG93KHozIC0gejIsIDIpKTtcclxuICAgICAgICB2YXIgZGlmZkRpc3Q7XHJcbiAgICAgICAgaWYoZGlzdDEgPiBkaXN0Mil7XHJcbiAgICAgICAgICAgIGlmKGRpc3QxID4gZGlzdDMpe1xyXG4gICAgICAgICAgICAgICAgZGlmZkRpc3QgPSBkaXN0MSAtIGRpc3QyIC0gZGlzdDM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmRGlzdCA9IGRpc3QzIC0gZGlzdDIgLSBkaXN0MTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZihkaXN0MyA+IGRpc3QyKXtcclxuICAgICAgICAgICAgZGlmZkRpc3QgPSBkaXN0MyAtIGRpc3QyIC0gZGlzdDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGlmZkRpc3QgPSBkaXN0MiAtIGRpc3QxIC0gZGlzdDM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaWZmRGlzdCA+IC0wLjAwMDEgJiYgZGlmZkRpc3QgPCAwLjAwMDE7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGdldEJlemllckxlbmd0aCA9IChmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocHQxLHB0MixwdDMscHQ0KXtcclxuICAgICAgICAgICAgdmFyIGN1cnZlU2VnbWVudHMgPSBkZWZhdWx0Q3VydmVTZWdtZW50cztcclxuICAgICAgICAgICAgdmFyIGs7XHJcbiAgICAgICAgICAgIHZhciBpLCBsZW47XHJcbiAgICAgICAgICAgIHZhciBwdENvb3JkLHBlcmMsYWRkZWRMZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB2YXIgcHREaXN0YW5jZTtcclxuICAgICAgICAgICAgdmFyIHBvaW50ID0gW10sbGFzdFBvaW50ID0gW107XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGhEYXRhID0gYmV6aWVyX2xlbmd0aF9wb29sLm5ld0VsZW1lbnQoKTtcclxuICAgICAgICAgICAgbGVuID0gcHQzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yKGs9MDtrPGN1cnZlU2VnbWVudHM7ays9MSl7XHJcbiAgICAgICAgICAgICAgICBwZXJjID0gay8oY3VydmVTZWdtZW50cy0xKTtcclxuICAgICAgICAgICAgICAgIHB0RGlzdGFuY2UgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAgICAgICAgICAgICBwdENvb3JkID0gYm1fcG93KDEtcGVyYywzKSpwdDFbaV0rMypibV9wb3coMS1wZXJjLDIpKnBlcmMqcHQzW2ldKzMqKDEtcGVyYykqYm1fcG93KHBlcmMsMikqcHQ0W2ldK2JtX3BvdyhwZXJjLDMpKnB0MltpXTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludFtpXSA9IHB0Q29vcmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobGFzdFBvaW50W2ldICE9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHREaXN0YW5jZSArPSBibV9wb3cocG9pbnRbaV0gLSBsYXN0UG9pbnRbaV0sMik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RQb2ludFtpXSA9IHBvaW50W2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYocHREaXN0YW5jZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgcHREaXN0YW5jZSA9IGJtX3NxcnQocHREaXN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRMZW5ndGggKz0gcHREaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxlbmd0aERhdGEucGVyY2VudHNba10gPSBwZXJjO1xyXG4gICAgICAgICAgICAgICAgbGVuZ3RoRGF0YS5sZW5ndGhzW2tdID0gYWRkZWRMZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGVuZ3RoRGF0YS5hZGRlZExlbmd0aCA9IGFkZGVkTGVuZ3RoO1xyXG4gICAgICAgICAgICByZXR1cm4gbGVuZ3RoRGF0YTtcclxuICAgICAgICB9O1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTZWdtZW50c0xlbmd0aChzaGFwZURhdGEpIHtcclxuICAgICAgICB2YXIgc2VnbWVudHNMZW5ndGggPSBzZWdtZW50c19sZW5ndGhfcG9vbC5uZXdFbGVtZW50KCk7XHJcbiAgICAgICAgdmFyIGNsb3NlZCA9IHNoYXBlRGF0YS5jO1xyXG4gICAgICAgIHZhciBwYXRoViA9IHNoYXBlRGF0YS52O1xyXG4gICAgICAgIHZhciBwYXRoTyA9IHNoYXBlRGF0YS5vO1xyXG4gICAgICAgIHZhciBwYXRoSSA9IHNoYXBlRGF0YS5pO1xyXG4gICAgICAgIHZhciBpLCBsZW4gPSBzaGFwZURhdGEuX2xlbmd0aDtcclxuICAgICAgICB2YXIgbGVuZ3RocyA9IHNlZ21lbnRzTGVuZ3RoLmxlbmd0aHM7XHJcbiAgICAgICAgdmFyIHRvdGFsTGVuZ3RoID0gMDtcclxuICAgICAgICBmb3IoaT0wO2k8bGVuLTE7aSs9MSl7XHJcbiAgICAgICAgICAgIGxlbmd0aHNbaV0gPSBnZXRCZXppZXJMZW5ndGgocGF0aFZbaV0scGF0aFZbaSsxXSxwYXRoT1tpXSxwYXRoSVtpKzFdKTtcclxuICAgICAgICAgICAgdG90YWxMZW5ndGggKz0gbGVuZ3Roc1tpXS5hZGRlZExlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoY2xvc2VkICYmIGxlbil7XHJcbiAgICAgICAgICAgIGxlbmd0aHNbaV0gPSBnZXRCZXppZXJMZW5ndGgocGF0aFZbaV0scGF0aFZbMF0scGF0aE9baV0scGF0aElbMF0pO1xyXG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSBsZW5ndGhzW2ldLmFkZGVkTGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWdtZW50c0xlbmd0aC50b3RhbExlbmd0aCA9IHRvdGFsTGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiBzZWdtZW50c0xlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBCZXppZXJEYXRhKGxlbmd0aCl7XHJcbiAgICAgICAgdGhpcy5zZWdtZW50TGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLnBvaW50cyA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFBvaW50RGF0YShwYXJ0aWFsLHBvaW50KXtcclxuICAgICAgICB0aGlzLnBhcnRpYWxMZW5ndGggPSBwYXJ0aWFsO1xyXG4gICAgICAgIHRoaXMucG9pbnQgPSBwb2ludDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYnVpbGRCZXppZXJEYXRhID0gKGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgICAgIHZhciBzdG9yZWREYXRhID0ge307XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoa2V5RGF0YSl7XHJcbiAgICAgICAgICAgIHZhciBwdDEgPSBrZXlEYXRhLnM7XHJcbiAgICAgICAgICAgIHZhciBwdDIgPSBrZXlEYXRhLmU7XHJcbiAgICAgICAgICAgIHZhciBwdDMgPSBrZXlEYXRhLnRvO1xyXG4gICAgICAgICAgICB2YXIgcHQ0ID0ga2V5RGF0YS50aTtcclxuICAgICAgICAgICAgdmFyIGJlemllck5hbWUgPSAocHQxWzBdKydfJytwdDFbMV0rJ18nK3B0MlswXSsnXycrcHQyWzFdKydfJytwdDNbMF0rJ18nK3B0M1sxXSsnXycrcHQ0WzBdKydfJytwdDRbMV0pLnJlcGxhY2UoL1xcLi9nLCAncCcpO1xyXG4gICAgICAgICAgICBpZihzdG9yZWREYXRhW2Jlemllck5hbWVdKXtcclxuICAgICAgICAgICAgICAgIGtleURhdGEuYmV6aWVyRGF0YSA9IHN0b3JlZERhdGFbYmV6aWVyTmFtZV07XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGN1cnZlU2VnbWVudHMgPSBkZWZhdWx0Q3VydmVTZWdtZW50cztcclxuICAgICAgICAgICAgdmFyIGssIGksIGxlbjtcclxuICAgICAgICAgICAgdmFyIHB0Q29vcmQscGVyYyxhZGRlZExlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBwdERpc3RhbmNlO1xyXG4gICAgICAgICAgICB2YXIgcG9pbnQsbGFzdFBvaW50ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHB0MS5sZW5ndGggPT09IDIgJiYgKHB0MVswXSAhPSBwdDJbMF0gfHwgcHQxWzFdICE9IHB0MlsxXSkgJiYgcG9pbnRPbkxpbmUyRChwdDFbMF0scHQxWzFdLHB0MlswXSxwdDJbMV0scHQxWzBdK3B0M1swXSxwdDFbMV0rcHQzWzFdKSAmJiBwb2ludE9uTGluZTJEKHB0MVswXSxwdDFbMV0scHQyWzBdLHB0MlsxXSxwdDJbMF0rcHQ0WzBdLHB0MlsxXStwdDRbMV0pKXtcclxuICAgICAgICAgICAgICAgIGN1cnZlU2VnbWVudHMgPSAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBiZXppZXJEYXRhID0gbmV3IEJlemllckRhdGEoY3VydmVTZWdtZW50cyk7XHJcbiAgICAgICAgICAgIGxlbiA9IHB0My5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBjdXJ2ZVNlZ21lbnRzOyBrICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50ID0gY3JlYXRlU2l6ZWRBcnJheShsZW4pO1xyXG4gICAgICAgICAgICAgICAgcGVyYyA9IGsgLyAoY3VydmVTZWdtZW50cyAtIDEpO1xyXG4gICAgICAgICAgICAgICAgcHREaXN0YW5jZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpe1xyXG4gICAgICAgICAgICAgICAgICAgIHB0Q29vcmQgPSBibV9wb3coMS1wZXJjLDMpKnB0MVtpXSszKmJtX3BvdygxLXBlcmMsMikqcGVyYyoocHQxW2ldICsgcHQzW2ldKSszKigxLXBlcmMpKmJtX3BvdyhwZXJjLDIpKihwdDJbaV0gKyBwdDRbaV0pK2JtX3BvdyhwZXJjLDMpKnB0MltpXTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludFtpXSA9IHB0Q29vcmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobGFzdFBvaW50ICE9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHREaXN0YW5jZSArPSBibV9wb3cocG9pbnRbaV0gLSBsYXN0UG9pbnRbaV0sMik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcHREaXN0YW5jZSA9IGJtX3NxcnQocHREaXN0YW5jZSk7XHJcbiAgICAgICAgICAgICAgICBhZGRlZExlbmd0aCArPSBwdERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgYmV6aWVyRGF0YS5wb2ludHNba10gPSBuZXcgUG9pbnREYXRhKHB0RGlzdGFuY2UsIHBvaW50KTtcclxuICAgICAgICAgICAgICAgIGxhc3RQb2ludCA9IHBvaW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJlemllckRhdGEuc2VnbWVudExlbmd0aCA9IGFkZGVkTGVuZ3RoO1xyXG4gICAgICAgICAgICBrZXlEYXRhLmJlemllckRhdGEgPSBiZXppZXJEYXRhO1xyXG4gICAgICAgICAgICBzdG9yZWREYXRhW2Jlemllck5hbWVdID0gYmV6aWVyRGF0YTtcclxuICAgICAgICB9O1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXREaXN0YW5jZVBlcmMocGVyYyxiZXppZXJEYXRhKXtcclxuICAgICAgICB2YXIgcGVyY2VudHMgPSBiZXppZXJEYXRhLnBlcmNlbnRzO1xyXG4gICAgICAgIHZhciBsZW5ndGhzID0gYmV6aWVyRGF0YS5sZW5ndGhzO1xyXG4gICAgICAgIHZhciBsZW4gPSBwZXJjZW50cy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGluaXRQb3MgPSBibV9mbG9vcigobGVuLTEpKnBlcmMpO1xyXG4gICAgICAgIHZhciBsZW5ndGhQb3MgPSBwZXJjKmJlemllckRhdGEuYWRkZWRMZW5ndGg7XHJcbiAgICAgICAgdmFyIGxQZXJjID0gMDtcclxuICAgICAgICBpZihpbml0UG9zID09PSBsZW4gLSAxIHx8IGluaXRQb3MgPT09IDAgfHwgbGVuZ3RoUG9zID09PSBsZW5ndGhzW2luaXRQb3NdKXtcclxuICAgICAgICAgICAgcmV0dXJuIHBlcmNlbnRzW2luaXRQb3NdO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB2YXIgZGlyID0gbGVuZ3Roc1tpbml0UG9zXSA+IGxlbmd0aFBvcyA/IC0xIDogMTtcclxuICAgICAgICAgICAgdmFyIGZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICB3aGlsZShmbGFnKXtcclxuICAgICAgICAgICAgICAgIGlmKGxlbmd0aHNbaW5pdFBvc10gPD0gbGVuZ3RoUG9zICYmIGxlbmd0aHNbaW5pdFBvcysxXSA+IGxlbmd0aFBvcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgbFBlcmMgPSAobGVuZ3RoUG9zIC0gbGVuZ3Roc1tpbml0UG9zXSkgLyAobGVuZ3Roc1tpbml0UG9zKzFdIC0gbGVuZ3Roc1tpbml0UG9zXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdFBvcyArPSBkaXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZihpbml0UG9zIDwgMCB8fCBpbml0UG9zID49IGxlbiAtIDEpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vRklYIGZvciBUeXBlZEFycmF5cyB0aGF0IGRvbid0IHN0b3JlIGZsb2F0aW5nIHBvaW50IHZhbHVlcyB3aXRoIGVub3VnaCBhY2N1cmFjeVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGluaXRQb3MgPT09IGxlbiAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBlcmNlbnRzW2luaXRQb3NdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBlcmNlbnRzW2luaXRQb3NdICsgKHBlcmNlbnRzW2luaXRQb3MrMV0gLSBwZXJjZW50c1tpbml0UG9zXSkqbFBlcmM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFBvaW50SW5TZWdtZW50KHB0MSwgcHQyLCBwdDMsIHB0NCwgcGVyY2VudCwgYmV6aWVyRGF0YSkge1xyXG4gICAgICAgIHZhciB0MSA9IGdldERpc3RhbmNlUGVyYyhwZXJjZW50LGJlemllckRhdGEpO1xyXG4gICAgICAgIHZhciB1MCA9IDE7XHJcbiAgICAgICAgdmFyIHUxID0gMSAtIHQxO1xyXG4gICAgICAgIHZhciBwdFggPSBNYXRoLnJvdW5kKCh1MSp1MSp1MSogcHQxWzBdICsgKHQxKnUxKnUxICsgdTEqdDEqdTEgKyB1MSp1MSp0MSkqIHB0M1swXSArICh0MSp0MSp1MSArIHUxKnQxKnQxICsgdDEqdTEqdDEpKnB0NFswXSArIHQxKnQxKnQxKiBwdDJbMF0pKiAxMDAwKSAvIDEwMDA7XHJcbiAgICAgICAgdmFyIHB0WSA9IE1hdGgucm91bmQoKHUxKnUxKnUxKiBwdDFbMV0gKyAodDEqdTEqdTEgKyB1MSp0MSp1MSArIHUxKnUxKnQxKSogcHQzWzFdICsgKHQxKnQxKnUxICsgdTEqdDEqdDEgKyB0MSp1MSp0MSkqcHQ0WzFdICsgdDEqdDEqdDEqIHB0MlsxXSkqIDEwMDApIC8gMTAwMDtcclxuICAgICAgICByZXR1cm4gW3B0WCwgcHRZXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTZWdtZW50QXJyYXkoKSB7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHZhciBiZXppZXJfc2VnbWVudF9wb2ludHMgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgOCk7XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0TmV3U2VnbWVudChwdDEscHQyLHB0MyxwdDQsc3RhcnRQZXJjLGVuZFBlcmMsIGJlemllckRhdGEpe1xyXG5cclxuICAgICAgICBzdGFydFBlcmMgPSBzdGFydFBlcmMgPCAwID8gMCA6IHN0YXJ0UGVyYyA+IDEgPyAxIDogc3RhcnRQZXJjO1xyXG4gICAgICAgIHZhciB0MCA9IGdldERpc3RhbmNlUGVyYyhzdGFydFBlcmMsYmV6aWVyRGF0YSk7XHJcbiAgICAgICAgZW5kUGVyYyA9IGVuZFBlcmMgPiAxID8gMSA6IGVuZFBlcmM7XHJcbiAgICAgICAgdmFyIHQxID0gZ2V0RGlzdGFuY2VQZXJjKGVuZFBlcmMsYmV6aWVyRGF0YSk7XHJcbiAgICAgICAgdmFyIGksIGxlbiA9IHB0MS5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHUwID0gMSAtIHQwO1xyXG4gICAgICAgIHZhciB1MSA9IDEgLSB0MTtcclxuICAgICAgICB2YXIgdTB1MHUwID0gdTAqdTAqdTA7XHJcbiAgICAgICAgdmFyIHQwdTB1MF8zID0gdDAqdTAqdTAqMztcclxuICAgICAgICB2YXIgdDB0MHUwXzMgPSB0MCp0MCp1MCozO1xyXG4gICAgICAgIHZhciB0MHQwdDAgPSB0MCp0MCp0MDtcclxuICAgICAgICAvL1xyXG4gICAgICAgIHZhciB1MHUwdTEgPSB1MCp1MCp1MTtcclxuICAgICAgICB2YXIgdDB1MHUxXzMgPSB0MCp1MCp1MSArIHUwKnQwKnUxICsgdTAqdTAqdDE7XHJcbiAgICAgICAgdmFyIHQwdDB1MV8zID0gdDAqdDAqdTEgKyB1MCp0MCp0MSArIHQwKnUwKnQxO1xyXG4gICAgICAgIHZhciB0MHQwdDEgPSB0MCp0MCp0MTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIHZhciB1MHUxdTEgPSB1MCp1MSp1MTtcclxuICAgICAgICB2YXIgdDB1MXUxXzMgPSB0MCp1MSp1MSArIHUwKnQxKnUxICsgdTAqdTEqdDE7XHJcbiAgICAgICAgdmFyIHQwdDF1MV8zID0gdDAqdDEqdTEgKyB1MCp0MSp0MSArIHQwKnUxKnQxO1xyXG4gICAgICAgIHZhciB0MHQxdDEgPSB0MCp0MSp0MTtcclxuICAgICAgICAvL1xyXG4gICAgICAgIHZhciB1MXUxdTEgPSB1MSp1MSp1MTtcclxuICAgICAgICB2YXIgdDF1MXUxXzMgPSB0MSp1MSp1MSArIHUxKnQxKnUxICsgdTEqdTEqdDE7XHJcbiAgICAgICAgdmFyIHQxdDF1MV8zID0gdDEqdDEqdTEgKyB1MSp0MSp0MSArIHQxKnUxKnQxO1xyXG4gICAgICAgIHZhciB0MXQxdDEgPSB0MSp0MSp0MTtcclxuICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICBiZXppZXJfc2VnbWVudF9wb2ludHNbaSAqIDRdID0gTWF0aC5yb3VuZCgodTB1MHUwICogcHQxW2ldICsgdDB1MHUwXzMgKiBwdDNbaV0gKyB0MHQwdTBfMyAqIHB0NFtpXSArIHQwdDB0MCAqIHB0MltpXSkgKiAxMDAwKSAvIDEwMDA7XHJcbiAgICAgICAgICAgIGJlemllcl9zZWdtZW50X3BvaW50c1tpICogNCArIDFdID0gTWF0aC5yb3VuZCgodTB1MHUxICogcHQxW2ldICsgdDB1MHUxXzMgKiBwdDNbaV0gKyB0MHQwdTFfMyAqIHB0NFtpXSArIHQwdDB0MSAqIHB0MltpXSkgKiAxMDAwKSAvIDEwMDA7XHJcbiAgICAgICAgICAgIGJlemllcl9zZWdtZW50X3BvaW50c1tpICogNCArIDJdID0gTWF0aC5yb3VuZCgodTB1MXUxICogcHQxW2ldICsgdDB1MXUxXzMgKiBwdDNbaV0gKyB0MHQxdTFfMyAqIHB0NFtpXSArIHQwdDF0MSAqIHB0MltpXSkgKiAxMDAwKSAvIDEwMDA7XHJcbiAgICAgICAgICAgIGJlemllcl9zZWdtZW50X3BvaW50c1tpICogNCArIDNdID0gTWF0aC5yb3VuZCgodTF1MXUxICogcHQxW2ldICsgdDF1MXUxXzMgKiBwdDNbaV0gKyB0MXQxdTFfMyAqIHB0NFtpXSArIHQxdDF0MSAqIHB0MltpXSkgKiAxMDAwKSAvIDEwMDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYmV6aWVyX3NlZ21lbnRfcG9pbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0U2VnbWVudHNMZW5ndGggOiBnZXRTZWdtZW50c0xlbmd0aCxcclxuICAgICAgICBnZXROZXdTZWdtZW50IDogZ2V0TmV3U2VnbWVudCxcclxuICAgICAgICBnZXRQb2ludEluU2VnbWVudCA6IGdldFBvaW50SW5TZWdtZW50LFxyXG4gICAgICAgIGJ1aWxkQmV6aWVyRGF0YSA6IGJ1aWxkQmV6aWVyRGF0YSxcclxuICAgICAgICBwb2ludE9uTGluZTJEIDogcG9pbnRPbkxpbmUyRCxcclxuICAgICAgICBwb2ludE9uTGluZTNEIDogcG9pbnRPbkxpbmUzRFxyXG4gICAgfTtcclxufVxyXG5cclxudmFyIGJleiA9IGJlekZ1bmN0aW9uKCk7XG5mdW5jdGlvbiBkYXRhRnVuY3Rpb25NYW5hZ2VyKCl7XHJcblxyXG4gICAgLy92YXIgdENhbnZhc0hlbHBlciA9IGNyZWF0ZVRhZygnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICBmdW5jdGlvbiBjb21wbGV0ZUxheWVycyhsYXllcnMsIGNvbXBzLCBmb250TWFuYWdlcil7XHJcbiAgICAgICAgdmFyIGxheWVyRGF0YTtcclxuICAgICAgICB2YXIgYW5pbUFycmF5LCBsYXN0RnJhbWU7XHJcbiAgICAgICAgdmFyIGksIGxlbiA9IGxheWVycy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGosIGpMZW4sIGssIGtMZW47XHJcbiAgICAgICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAgICAgbGF5ZXJEYXRhID0gbGF5ZXJzW2ldO1xyXG4gICAgICAgICAgICBpZighKCdrcycgaW4gbGF5ZXJEYXRhKSB8fCBsYXllckRhdGEuY29tcGxldGVkKXtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxheWVyRGF0YS5jb21wbGV0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZihsYXllckRhdGEudHQpe1xyXG4gICAgICAgICAgICAgICAgbGF5ZXJzW2ktMV0udGQgPSBsYXllckRhdGEudHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYW5pbUFycmF5ID0gW107XHJcbiAgICAgICAgICAgIGxhc3RGcmFtZSA9IC0xO1xyXG4gICAgICAgICAgICBpZihsYXllckRhdGEuaGFzTWFzayl7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWFza1Byb3BzID0gbGF5ZXJEYXRhLm1hc2tzUHJvcGVydGllcztcclxuICAgICAgICAgICAgICAgIGpMZW4gPSBtYXNrUHJvcHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yKGo9MDtqPGpMZW47ais9MSl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobWFza1Byb3BzW2pdLnB0LmsuaSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMobWFza1Byb3BzW2pdLnB0LmspO1xyXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrTGVuID0gbWFza1Byb3BzW2pdLnB0LmsubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3Ioaz0wO2s8a0xlbjtrKz0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1hc2tQcm9wc1tqXS5wdC5rW2tdLnMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMobWFza1Byb3BzW2pdLnB0Lmtba10uc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihtYXNrUHJvcHNbal0ucHQua1trXS5lKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0UGF0aHNUb0Fic29sdXRlVmFsdWVzKG1hc2tQcm9wc1tqXS5wdC5rW2tdLmVbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGxheWVyRGF0YS50eT09PTApe1xyXG4gICAgICAgICAgICAgICAgbGF5ZXJEYXRhLmxheWVycyA9IGZpbmRDb21wTGF5ZXJzKGxheWVyRGF0YS5yZWZJZCwgY29tcHMpO1xyXG4gICAgICAgICAgICAgICAgY29tcGxldGVMYXllcnMobGF5ZXJEYXRhLmxheWVycyxjb21wcywgZm9udE1hbmFnZXIpO1xyXG4gICAgICAgICAgICB9ZWxzZSBpZihsYXllckRhdGEudHkgPT09IDQpe1xyXG4gICAgICAgICAgICAgICAgY29tcGxldGVTaGFwZXMobGF5ZXJEYXRhLnNoYXBlcyk7XHJcbiAgICAgICAgICAgIH1lbHNlIGlmKGxheWVyRGF0YS50eSA9PSA1KXtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlVGV4dChsYXllckRhdGEsIGZvbnRNYW5hZ2VyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmaW5kQ29tcExheWVycyhpZCxjb21wcyl7XHJcbiAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSBjb21wcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUoaTxsZW4pe1xyXG4gICAgICAgICAgICBpZihjb21wc1tpXS5pZCA9PT0gaWQpe1xyXG4gICAgICAgICAgICAgICAgaWYoIWNvbXBzW2ldLmxheWVycy5fX3VzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wc1tpXS5sYXllcnMuX191c2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcHNbaV0ubGF5ZXJzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29tcHNbaV0ubGF5ZXJzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjb21wbGV0ZVNoYXBlcyhhcnIpe1xyXG4gICAgICAgIHZhciBpLCBsZW4gPSBhcnIubGVuZ3RoO1xyXG4gICAgICAgIHZhciBqLCBqTGVuO1xyXG4gICAgICAgIHZhciBoYXNQYXRocyA9IGZhbHNlO1xyXG4gICAgICAgIGZvcihpPWxlbi0xO2k+PTA7aS09MSl7XHJcbiAgICAgICAgICAgIGlmKGFycltpXS50eSA9PSAnc2gnKXtcclxuICAgICAgICAgICAgICAgIGlmKGFycltpXS5rcy5rLmkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMoYXJyW2ldLmtzLmspO1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgakxlbiA9IGFycltpXS5rcy5rLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3Ioaj0wO2o8akxlbjtqKz0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXJyW2ldLmtzLmtbal0ucyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0UGF0aHNUb0Fic29sdXRlVmFsdWVzKGFycltpXS5rcy5rW2pdLnNbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGFycltpXS5rcy5rW2pdLmUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhhcnJbaV0ua3Mua1tqXS5lWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGhhc1BhdGhzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfWVsc2UgaWYoYXJyW2ldLnR5ID09ICdncicpe1xyXG4gICAgICAgICAgICAgICAgY29tcGxldGVTaGFwZXMoYXJyW2ldLml0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvKmlmKGhhc1BhdGhzKXtcclxuICAgICAgICAgICAgLy9teDogZGlzdGFuY2VcclxuICAgICAgICAgICAgLy9zczogc2Vuc2l0aXZpdHlcclxuICAgICAgICAgICAgLy9kYzogZGVjYXlcclxuICAgICAgICAgICAgYXJyLnNwbGljZShhcnIubGVuZ3RoLTEsMCx7XHJcbiAgICAgICAgICAgICAgICBcInR5XCI6IFwibXNcIixcclxuICAgICAgICAgICAgICAgIFwibXhcIjoyMCxcclxuICAgICAgICAgICAgICAgIFwic3NcIjoxMCxcclxuICAgICAgICAgICAgICAgICBcImRjXCI6MC4wMDEsXHJcbiAgICAgICAgICAgICAgICBcIm1heERpc3RcIjoyMDBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSovXHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhwYXRoKXtcclxuICAgICAgICB2YXIgaSwgbGVuID0gcGF0aC5pLmxlbmd0aDtcclxuICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICBwYXRoLmlbaV1bMF0gKz0gcGF0aC52W2ldWzBdO1xyXG4gICAgICAgICAgICBwYXRoLmlbaV1bMV0gKz0gcGF0aC52W2ldWzFdO1xyXG4gICAgICAgICAgICBwYXRoLm9baV1bMF0gKz0gcGF0aC52W2ldWzBdO1xyXG4gICAgICAgICAgICBwYXRoLm9baV1bMV0gKz0gcGF0aC52W2ldWzFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja1ZlcnNpb24obWluaW11bSxhbmltVmVyc2lvblN0cmluZyl7XHJcbiAgICAgICAgdmFyIGFuaW1WZXJzaW9uID0gYW5pbVZlcnNpb25TdHJpbmcgPyBhbmltVmVyc2lvblN0cmluZy5zcGxpdCgnLicpIDogWzEwMCwxMDAsMTAwXTtcclxuICAgICAgICBpZihtaW5pbXVtWzBdPmFuaW1WZXJzaW9uWzBdKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfSBlbHNlIGlmKGFuaW1WZXJzaW9uWzBdID4gbWluaW11bVswXSl7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYobWluaW11bVsxXT5hbmltVmVyc2lvblsxXSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSBpZihhbmltVmVyc2lvblsxXSA+IG1pbmltdW1bMV0pe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKG1pbmltdW1bMl0+YW5pbVZlcnNpb25bMl0pe1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9IGVsc2UgaWYoYW5pbVZlcnNpb25bMl0gPiBtaW5pbXVtWzJdKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgY2hlY2tUZXh0ID0gKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIG1pbmltdW1WZXJzaW9uID0gWzQsNCwxNF07XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRleHRMYXllcih0ZXh0TGF5ZXIpe1xyXG4gICAgICAgICAgICB2YXIgZG9jdW1lbnREYXRhID0gdGV4dExheWVyLnQuZDtcclxuICAgICAgICAgICAgdGV4dExheWVyLnQuZCA9IHtcclxuICAgICAgICAgICAgICAgIGs6IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHM6ZG9jdW1lbnREYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0OjBcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlTGF5ZXJzKGxheWVycyl7XHJcbiAgICAgICAgICAgIHZhciBpLCBsZW4gPSBsYXllcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICAgICAgaWYobGF5ZXJzW2ldLnR5ID09PSA1KXtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVUZXh0TGF5ZXIobGF5ZXJzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbmltYXRpb25EYXRhKXtcclxuICAgICAgICAgICAgaWYoY2hlY2tWZXJzaW9uKG1pbmltdW1WZXJzaW9uLGFuaW1hdGlvbkRhdGEudikpe1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmxheWVycyk7XHJcbiAgICAgICAgICAgICAgICBpZihhbmltYXRpb25EYXRhLmFzc2V0cyl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIGxlbiA9IGFuaW1hdGlvbkRhdGEuYXNzZXRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIHZhciBjaGVja0NoYXJzID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBtaW5pbXVtVmVyc2lvbiA9IFs0LDcsOTldO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSl7XHJcbiAgICAgICAgICAgIGlmKGFuaW1hdGlvbkRhdGEuY2hhcnMgJiYgIWNoZWNrVmVyc2lvbihtaW5pbXVtVmVyc2lvbixhbmltYXRpb25EYXRhLnYpKXtcclxuICAgICAgICAgICAgICAgIHZhciBpLCBsZW4gPSBhbmltYXRpb25EYXRhLmNoYXJzLmxlbmd0aCwgaiwgakxlbiwgaywga0xlbjtcclxuICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSwgcGF0aHM7XHJcbiAgICAgICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGFuaW1hdGlvbkRhdGEuY2hhcnNbaV0uZGF0YSAmJiBhbmltYXRpb25EYXRhLmNoYXJzW2ldLmRhdGEuc2hhcGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhzID0gYW5pbWF0aW9uRGF0YS5jaGFyc1tpXS5kYXRhLnNoYXBlc1swXS5pdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgakxlbiA9IHBhdGhzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aERhdGEgPSBwYXRoc1tqXS5rcy5rO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXBhdGhEYXRhLl9fY29udmVydGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhwYXRoc1tqXS5rcy5rKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoRGF0YS5fX2NvbnZlcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICB2YXIgY2hlY2tDb2xvcnMgPSAoZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgbWluaW11bVZlcnNpb24gPSBbNCwxLDldO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlU2hhcGVzKHNoYXBlcyl7XHJcbiAgICAgICAgICAgIHZhciBpLCBsZW4gPSBzaGFwZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgaiwgakxlbjtcclxuICAgICAgICAgICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAgICAgICAgIGlmKHNoYXBlc1tpXS50eSA9PT0gJ2dyJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZVNoYXBlcyhzaGFwZXNbaV0uaXQpO1xyXG4gICAgICAgICAgICAgICAgfWVsc2UgaWYoc2hhcGVzW2ldLnR5ID09PSAnZmwnIHx8IHNoYXBlc1tpXS50eSA9PT0gJ3N0Jyl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc2hhcGVzW2ldLmMuayAmJiBzaGFwZXNbaV0uYy5rWzBdLmkpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqTGVuID0gc2hhcGVzW2ldLmMuay5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihqPTA7ajxqTGVuO2orPTEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2hhcGVzW2ldLmMua1tqXS5zKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbMF0gLz0gMjU1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uc1sxXSAvPSAyNTU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1tqXS5zWzJdIC89IDI1NTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbM10gLz0gMjU1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2hhcGVzW2ldLmMua1tqXS5lKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLmVbMF0gLz0gMjU1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbal0uZVsxXSAvPSAyNTU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1tqXS5lWzJdIC89IDI1NTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLmVbM10gLz0gMjU1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1swXSAvPSAyNTU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlc1tpXS5jLmtbMV0gLz0gMjU1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rWzJdIC89IDI1NTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGVzW2ldLmMua1szXSAvPSAyNTU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlTGF5ZXJzKGxheWVycyl7XHJcbiAgICAgICAgICAgIHZhciBpLCBsZW4gPSBsYXllcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICAgICAgaWYobGF5ZXJzW2ldLnR5ID09PSA0KXtcclxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlU2hhcGVzKGxheWVyc1tpXS5zaGFwZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFuaW1hdGlvbkRhdGEpe1xyXG4gICAgICAgICAgICBpZihjaGVja1ZlcnNpb24obWluaW11bVZlcnNpb24sYW5pbWF0aW9uRGF0YS52KSl7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRlTGF5ZXJzKGFuaW1hdGlvbkRhdGEubGF5ZXJzKTtcclxuICAgICAgICAgICAgICAgIGlmKGFuaW1hdGlvbkRhdGEuYXNzZXRzKXtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSwgbGVuID0gYW5pbWF0aW9uRGF0YS5hc3NldHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRlTGF5ZXJzKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH0oKSk7XHJcblxyXG4gICAgdmFyIGNoZWNrU2hhcGVzID0gKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIG1pbmltdW1WZXJzaW9uID0gWzQsNCwxOF07XHJcblxyXG5cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gY29tcGxldGVTaGFwZXMoYXJyKXtcclxuICAgICAgICAgICAgdmFyIGksIGxlbiA9IGFyci5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBqLCBqTGVuO1xyXG4gICAgICAgICAgICB2YXIgaGFzUGF0aHMgPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9yKGk9bGVuLTE7aT49MDtpLT0xKXtcclxuICAgICAgICAgICAgICAgIGlmKGFycltpXS50eSA9PSAnc2gnKXtcclxuICAgICAgICAgICAgICAgICAgICBpZihhcnJbaV0ua3Muay5pKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJyW2ldLmtzLmsuYyA9IGFycltpXS5jbG9zZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpMZW4gPSBhcnJbaV0ua3Muay5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcihqPTA7ajxqTGVuO2orPTEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXJyW2ldLmtzLmtbal0ucyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyW2ldLmtzLmtbal0uc1swXS5jID0gYXJyW2ldLmNsb3NlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGFycltpXS5rcy5rW2pdLmUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycltpXS5rcy5rW2pdLmVbMF0uYyA9IGFycltpXS5jbG9zZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaGFzUGF0aHMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfWVsc2UgaWYoYXJyW2ldLnR5ID09ICdncicpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlU2hhcGVzKGFycltpXS5pdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVMYXllcnMobGF5ZXJzKXtcclxuICAgICAgICAgICAgdmFyIGxheWVyRGF0YTtcclxuICAgICAgICAgICAgdmFyIGksIGxlbiA9IGxheWVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBqLCBqTGVuLCBrLCBrTGVuO1xyXG4gICAgICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICAgICAgbGF5ZXJEYXRhID0gbGF5ZXJzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYobGF5ZXJEYXRhLmhhc01hc2spe1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXNrUHJvcHMgPSBsYXllckRhdGEubWFza3NQcm9wZXJ0aWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIGpMZW4gPSBtYXNrUHJvcHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihqPTA7ajxqTGVuO2orPTEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtYXNrUHJvcHNbal0ucHQuay5pKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tQcm9wc1tqXS5wdC5rLmMgPSBtYXNrUHJvcHNbal0uY2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga0xlbiA9IG1hc2tQcm9wc1tqXS5wdC5rLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihrPTA7azxrTGVuO2srPTEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1hc2tQcm9wc1tqXS5wdC5rW2tdLnMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrUHJvcHNbal0ucHQua1trXS5zWzBdLmMgPSBtYXNrUHJvcHNbal0uY2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG1hc2tQcm9wc1tqXS5wdC5rW2tdLmUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrUHJvcHNbal0ucHQua1trXS5lWzBdLmMgPSBtYXNrUHJvcHNbal0uY2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYobGF5ZXJEYXRhLnR5ID09PSA0KXtcclxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVNoYXBlcyhsYXllckRhdGEuc2hhcGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbmltYXRpb25EYXRhKXtcclxuICAgICAgICAgICAgaWYoY2hlY2tWZXJzaW9uKG1pbmltdW1WZXJzaW9uLGFuaW1hdGlvbkRhdGEudikpe1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmxheWVycyk7XHJcbiAgICAgICAgICAgICAgICBpZihhbmltYXRpb25EYXRhLmFzc2V0cyl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGksIGxlbiA9IGFuaW1hdGlvbkRhdGEuYXNzZXRzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlRGF0YShhbmltYXRpb25EYXRhLCBmb250TWFuYWdlcil7XHJcbiAgICAgICAgaWYoYW5pbWF0aW9uRGF0YS5fX2NvbXBsZXRlKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGVja0NvbG9ycyhhbmltYXRpb25EYXRhKTtcclxuICAgICAgICBjaGVja1RleHQoYW5pbWF0aW9uRGF0YSk7XHJcbiAgICAgICAgY2hlY2tDaGFycyhhbmltYXRpb25EYXRhKTtcclxuICAgICAgICBjaGVja1NoYXBlcyhhbmltYXRpb25EYXRhKTtcclxuICAgICAgICBjb21wbGV0ZUxheWVycyhhbmltYXRpb25EYXRhLmxheWVycywgYW5pbWF0aW9uRGF0YS5hc3NldHMsIGZvbnRNYW5hZ2VyKTtcclxuICAgICAgICBhbmltYXRpb25EYXRhLl9fY29tcGxldGUgPSB0cnVlO1xyXG4gICAgICAgIC8vYmxpdEFuaW1hdGlvbihhbmltYXRpb25EYXRhLCBhbmltYXRpb25EYXRhLmFzc2V0cywgZm9udE1hbmFnZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlVGV4dChkYXRhLCBmb250TWFuYWdlcil7XHJcbiAgICAgICAgaWYoZGF0YS50LmEubGVuZ3RoID09PSAwICYmICEoJ20nIGluIGRhdGEudC5wKSl7XHJcbiAgICAgICAgICAgIGRhdGEuc2luZ2xlU2hhcGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgbW9kdWxlT2IgPSB7fTtcclxuICAgIG1vZHVsZU9iLmNvbXBsZXRlRGF0YSA9IGNvbXBsZXRlRGF0YTtcclxuXHJcbiAgICByZXR1cm4gbW9kdWxlT2I7XHJcbn1cclxuXHJcbnZhciBkYXRhTWFuYWdlciA9IGRhdGFGdW5jdGlvbk1hbmFnZXIoKTtcbnZhciBGb250TWFuYWdlciA9IChmdW5jdGlvbigpe1xyXG5cclxuICAgIHZhciBtYXhXYWl0aW5nVGltZSA9IDUwMDA7XHJcbiAgICB2YXIgZW1wdHlDaGFyID0ge1xyXG4gICAgICAgIHc6IDAsXHJcbiAgICAgICAgc2l6ZTowLFxyXG4gICAgICAgIHNoYXBlczpbXVxyXG4gICAgfTtcclxuICAgIHZhciBjb21iaW5lZENoYXJhY3RlcnMgPSBbXTtcclxuICAgIC8vSGluZGkgY2hhcmFjdGVyc1xyXG4gICAgY29tYmluZWRDaGFyYWN0ZXJzID0gY29tYmluZWRDaGFyYWN0ZXJzLmNvbmNhdChbMjMwNCwgMjMwNSwgMjMwNiwgMjMwNywgMjM2MiwgMjM2MywgMjM2NCwgMjM2NCwgMjM2NlxyXG4gICAgLCAyMzY3LCAyMzY4LCAyMzY5LCAyMzcwLCAyMzcxLCAyMzcyLCAyMzczLCAyMzc0LCAyMzc1LCAyMzc2LCAyMzc3LCAyMzc4LCAyMzc5XHJcbiAgICAsIDIzODAsIDIzODEsIDIzODIsIDIzODMsIDIzODcsIDIzODgsIDIzODksIDIzOTAsIDIzOTEsIDI0MDIsIDI0MDNdKTtcclxuXHJcbiAgICBmdW5jdGlvbiBzZXRVcE5vZGUoZm9udCwgZmFtaWx5KXtcclxuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGNyZWF0ZVRhZygnc3BhbicpO1xyXG4gICAgICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udEZhbWlseSAgICA9IGZhbWlseTtcclxuICAgICAgICB2YXIgbm9kZSA9IGNyZWF0ZVRhZygnc3BhbicpO1xyXG4gICAgICAgIC8vIENoYXJhY3RlcnMgdGhhdCB2YXJ5IHNpZ25pZmljYW50bHkgYW1vbmcgZGlmZmVyZW50IGZvbnRzXHJcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSAnZ2lJdFQxV1F5QCEtLyMnO1xyXG4gICAgICAgIC8vIFZpc2libGUgLSBzbyB3ZSBjYW4gbWVhc3VyZSBpdCAtIGJ1dCBub3Qgb24gdGhlIHNjcmVlblxyXG4gICAgICAgIHBhcmVudE5vZGUuc3R5bGUucG9zaXRpb24gICAgICA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgcGFyZW50Tm9kZS5zdHlsZS5sZWZ0ICAgICAgICAgID0gJy0xMDAwMHB4JztcclxuICAgICAgICBwYXJlbnROb2RlLnN0eWxlLnRvcCAgICAgICAgICAgPSAnLTEwMDAwcHgnO1xyXG4gICAgICAgIC8vIExhcmdlIGZvbnQgc2l6ZSBtYWtlcyBldmVuIHN1YnRsZSBjaGFuZ2VzIG9idmlvdXNcclxuICAgICAgICBwYXJlbnROb2RlLnN0eWxlLmZvbnRTaXplICAgICAgPSAnMzAwcHgnO1xyXG4gICAgICAgIC8vIFJlc2V0IGFueSBmb250IHByb3BlcnRpZXNcclxuICAgICAgICBwYXJlbnROb2RlLnN0eWxlLmZvbnRWYXJpYW50ICAgPSAnbm9ybWFsJztcclxuICAgICAgICBwYXJlbnROb2RlLnN0eWxlLmZvbnRTdHlsZSAgICAgPSAnbm9ybWFsJztcclxuICAgICAgICBwYXJlbnROb2RlLnN0eWxlLmZvbnRXZWlnaHQgICAgPSAnbm9ybWFsJztcclxuICAgICAgICBwYXJlbnROb2RlLnN0eWxlLmxldHRlclNwYWNpbmcgPSAnMCc7XHJcbiAgICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZChub2RlKTtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBhcmVudE5vZGUpO1xyXG5cclxuICAgICAgICAvLyBSZW1lbWJlciB3aWR0aCB3aXRoIG5vIGFwcGxpZWQgd2ViIGZvbnRcclxuICAgICAgICB2YXIgd2lkdGggPSBub2RlLm9mZnNldFdpZHRoO1xyXG4gICAgICAgIG5vZGUuc3R5bGUuZm9udEZhbWlseSA9IGZvbnQgKyAnLCAnK2ZhbWlseTtcclxuICAgICAgICByZXR1cm4ge25vZGU6bm9kZSwgdzp3aWR0aCwgcGFyZW50OnBhcmVudE5vZGV9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNoZWNrTG9hZGVkRm9udHMoKSB7XHJcbiAgICAgICAgdmFyIGksIGxlbiA9IHRoaXMuZm9udHMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBub2RlLCB3O1xyXG4gICAgICAgIHZhciBsb2FkZWRDb3VudCA9IGxlbjtcclxuICAgICAgICBmb3IoaT0wO2k8bGVuOyBpKz0gMSl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZm9udHNbaV0ubG9hZGVkKXtcclxuICAgICAgICAgICAgICAgIGxvYWRlZENvdW50IC09IDE7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih0aGlzLmZvbnRzW2ldLmZPcmlnaW4gPT09ICd0JyB8fCB0aGlzLmZvbnRzW2ldLm9yaWdpbiA9PT0gMil7XHJcbiAgICAgICAgICAgICAgICBpZih3aW5kb3cuVHlwZWtpdCAmJiB3aW5kb3cuVHlwZWtpdC5sb2FkICYmIHRoaXMudHlwZWtpdExvYWRlZCA9PT0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBla2l0TG9hZGVkID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB0cnl7d2luZG93LlR5cGVraXQubG9hZCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBla2l0TG9hZGVkID0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7fWNhdGNoKGUpe31cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMudHlwZWtpdExvYWRlZCA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9udHNbaV0ubG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMuZm9udHNbaV0uZk9yaWdpbiA9PT0gJ24nIHx8IHRoaXMuZm9udHNbaV0ub3JpZ2luID09PSAwKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZm9udHNbaV0ubG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSBlbHNle1xyXG4gICAgICAgICAgICAgICAgbm9kZSA9IHRoaXMuZm9udHNbaV0ubW9ub0Nhc2Uubm9kZTtcclxuICAgICAgICAgICAgICAgIHcgPSB0aGlzLmZvbnRzW2ldLm1vbm9DYXNlLnc7XHJcbiAgICAgICAgICAgICAgICBpZihub2RlLm9mZnNldFdpZHRoICE9PSB3KXtcclxuICAgICAgICAgICAgICAgICAgICBsb2FkZWRDb3VudCAtPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9udHNbaV0ubG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLmZvbnRzW2ldLnNhbnNDYXNlLm5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdyA9IHRoaXMuZm9udHNbaV0uc2Fuc0Nhc2UudztcclxuICAgICAgICAgICAgICAgICAgICBpZihub2RlLm9mZnNldFdpZHRoICE9PSB3KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGVkQ291bnQgLT0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mb250c1tpXS5sb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZm9udHNbaV0ubG9hZGVkKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvbnRzW2ldLnNhbnNDYXNlLnBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9udHNbaV0uc2Fuc0Nhc2UucGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvbnRzW2ldLm1vbm9DYXNlLnBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9udHNbaV0ubW9ub0Nhc2UucGFyZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYobG9hZGVkQ291bnQgIT09IDAgJiYgRGF0ZS5ub3coKSAtIHRoaXMuaW5pdFRpbWUgPCBtYXhXYWl0aW5nVGltZSl7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5jaGVja0xvYWRlZEZvbnRzLmJpbmQodGhpcyksMjApO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhpcy5pc0xvYWRlZCA9IHRydWU7fS5iaW5kKHRoaXMpLDApO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlSGVscGVyKGRlZiwgZm9udERhdGEpe1xyXG4gICAgICAgIHZhciB0SGVscGVyID0gY3JlYXRlTlMoJ3RleHQnKTtcclxuICAgICAgICB0SGVscGVyLnN0eWxlLmZvbnRTaXplID0gJzEwMHB4JztcclxuICAgICAgICAvL3RIZWxwZXIuc3R5bGUuZm9udEZhbWlseSA9IGZvbnREYXRhLmZGYW1pbHk7XHJcbiAgICAgICAgdEhlbHBlci5zZXRBdHRyaWJ1dGUoJ2ZvbnQtZmFtaWx5JywgZm9udERhdGEuZkZhbWlseSk7XHJcbiAgICAgICAgdEhlbHBlci5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc3R5bGUnLCBmb250RGF0YS5mU3R5bGUpO1xyXG4gICAgICAgIHRIZWxwZXIuc2V0QXR0cmlidXRlKCdmb250LXdlaWdodCcsIGZvbnREYXRhLmZXZWlnaHQpO1xyXG4gICAgICAgIHRIZWxwZXIudGV4dENvbnRlbnQgPSAnMSc7XHJcbiAgICAgICAgaWYoZm9udERhdGEuZkNsYXNzKXtcclxuICAgICAgICAgICAgdEhlbHBlci5zdHlsZS5mb250RmFtaWx5ID0gJ2luaGVyaXQnO1xyXG4gICAgICAgICAgICB0SGVscGVyLmNsYXNzTmFtZSA9IGZvbnREYXRhLmZDbGFzcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0SGVscGVyLnN0eWxlLmZvbnRGYW1pbHkgPSBmb250RGF0YS5mRmFtaWx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWYuYXBwZW5kQ2hpbGQodEhlbHBlcik7XHJcbiAgICAgICAgdmFyIHRDYW52YXNIZWxwZXIgPSBjcmVhdGVUYWcoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgdENhbnZhc0hlbHBlci5mb250ID0gZm9udERhdGEuZldlaWdodCArICcgJyArIGZvbnREYXRhLmZTdHlsZSArICcgMTAwcHggJysgZm9udERhdGEuZkZhbWlseTtcclxuICAgICAgICAvL3RDYW52YXNIZWxwZXIuZm9udCA9ICcgMTAwcHggJysgZm9udERhdGEuZkZhbWlseTtcclxuICAgICAgICByZXR1cm4gdEhlbHBlcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRGb250cyhmb250RGF0YSwgZGVmcyl7XHJcbiAgICAgICAgaWYoIWZvbnREYXRhKXtcclxuICAgICAgICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5jaGFycyl7XHJcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmZvbnRzID0gZm9udERhdGEubGlzdDtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIHZhciBmb250QXJyID0gZm9udERhdGEubGlzdDtcclxuICAgICAgICB2YXIgaSwgbGVuID0gZm9udEFyci5sZW5ndGg7XHJcbiAgICAgICAgdmFyIF9wZW5kaW5nRm9udHMgPSBsZW47XHJcbiAgICAgICAgZm9yKGk9MDsgaTxsZW47IGkrPSAxKXtcclxuICAgICAgICAgICAgZm9udEFycltpXS5sb2FkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZm9udEFycltpXS5tb25vQ2FzZSA9IHNldFVwTm9kZShmb250QXJyW2ldLmZGYW1pbHksJ21vbm9zcGFjZScpO1xyXG4gICAgICAgICAgICBmb250QXJyW2ldLnNhbnNDYXNlID0gc2V0VXBOb2RlKGZvbnRBcnJbaV0uZkZhbWlseSwnc2Fucy1zZXJpZicpO1xyXG4gICAgICAgICAgICBpZighZm9udEFycltpXS5mUGF0aCkge1xyXG4gICAgICAgICAgICAgICAgZm9udEFycltpXS5sb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgX3BlbmRpbmdGb250cyAtPSAxO1xyXG4gICAgICAgICAgICB9ZWxzZSBpZihmb250QXJyW2ldLmZPcmlnaW4gPT09ICdwJyB8fCBmb250QXJyW2ldLm9yaWdpbiA9PT0gMyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IGNyZWF0ZVRhZygnc3R5bGUnKTtcclxuICAgICAgICAgICAgICAgIHMudHlwZSA9IFwidGV4dC9jc3NcIjtcclxuICAgICAgICAgICAgICAgIHMuaW5uZXJIVE1MID0gXCJAZm9udC1mYWNlIHtcIiArIFwiZm9udC1mYW1pbHk6IFwiK2ZvbnRBcnJbaV0uZkZhbWlseStcIjsgZm9udC1zdHlsZTogbm9ybWFsOyBzcmM6IHVybCgnXCIrZm9udEFycltpXS5mUGF0aCtcIicpO31cIjtcclxuICAgICAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQocyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZihmb250QXJyW2ldLmZPcmlnaW4gPT09ICdnJyB8fCBmb250QXJyW2ldLm9yaWdpbiA9PT0gMSl7XHJcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGNyZWF0ZVRhZygnbGluaycpO1xyXG4gICAgICAgICAgICAgICAgbC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG4gICAgICAgICAgICAgICAgbC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuICAgICAgICAgICAgICAgIGwuaHJlZiA9IGZvbnRBcnJbaV0uZlBhdGg7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGwpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYoZm9udEFycltpXS5mT3JpZ2luID09PSAndCcgfHwgZm9udEFycltpXS5vcmlnaW4gPT09IDIpe1xyXG4gICAgICAgICAgICAgICAgdmFyIHNjID0gY3JlYXRlVGFnKCdzY3JpcHQnKTtcclxuICAgICAgICAgICAgICAgIHNjLnNldEF0dHJpYnV0ZSgnc3JjJyxmb250QXJyW2ldLmZQYXRoKTtcclxuICAgICAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoc2MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvbnRBcnJbaV0uaGVscGVyID0gY3JlYXRlSGVscGVyKGRlZnMsZm9udEFycltpXSk7XHJcbiAgICAgICAgICAgIGZvbnRBcnJbaV0uY2FjaGUgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5mb250cy5wdXNoKGZvbnRBcnJbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3BlbmRpbmdGb250cyA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvL09uIHNvbWUgY2FzZXMgZXZlbiBpZiB0aGUgZm9udCBpcyBsb2FkZWQsIGl0IHdvbid0IGxvYWQgY29ycmVjdGx5IHdoZW4gbWVhc3VyaW5nIHRleHQgb24gY2FudmFzLlxyXG4gICAgICAgICAgICAvL0FkZGluZyB0aGlzIHRpbWVvdXQgc2VlbXMgdG8gZml4IGl0XHJcbiAgICAgICAgICAgc2V0VGltZW91dCh0aGlzLmNoZWNrTG9hZGVkRm9udHMuYmluZCh0aGlzKSwgMTAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkQ2hhcnMoY2hhcnMpe1xyXG4gICAgICAgIGlmKCFjaGFycyl7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoIXRoaXMuY2hhcnMpe1xyXG4gICAgICAgICAgICB0aGlzLmNoYXJzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpLCBsZW4gPSBjaGFycy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGosIGpMZW4gPSB0aGlzLmNoYXJzLmxlbmd0aCwgZm91bmQ7XHJcbiAgICAgICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgIGZvdW5kID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHdoaWxlKGo8akxlbil7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmNoYXJzW2pdLnN0eWxlID09PSBjaGFyc1tpXS5zdHlsZSAmJiB0aGlzLmNoYXJzW2pdLmZGYW1pbHkgPT09IGNoYXJzW2ldLmZGYW1pbHkgJiYgdGhpcy5jaGFyc1tqXS5jaCA9PT0gY2hhcnNbaV0uY2gpe1xyXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGogKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZighZm91bmQpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFycy5wdXNoKGNoYXJzW2ldKTtcclxuICAgICAgICAgICAgICAgIGpMZW4gKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDaGFyRGF0YShjaGFyLCBzdHlsZSwgZm9udCl7XHJcbiAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLmNoYXJzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSggaSA8IGxlbikge1xyXG4gICAgICAgICAgICBpZih0aGlzLmNoYXJzW2ldLmNoID09PSBjaGFyICYmIHRoaXMuY2hhcnNbaV0uc3R5bGUgPT09IHN0eWxlICYmIHRoaXMuY2hhcnNbaV0uZkZhbWlseSA9PT0gZm9udCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFyc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNzaW5nIGNoYXJhY3RlciBmcm9tIGV4cG9ydGVkIGNoYXJhY3RlcnMgbGlzdDogJywgY2hhciwgc3R5bGUsIGZvbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW1wdHlDaGFyO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1lYXN1cmVUZXh0KGNoYXIsIGZvbnROYW1lLCBzaXplKSB7XHJcbiAgICAgICAgdmFyIGZvbnREYXRhID0gdGhpcy5nZXRGb250QnlOYW1lKGZvbnROYW1lKTtcclxuICAgICAgICB2YXIgaW5kZXggPSBjaGFyLmNoYXJDb2RlQXQoMCk7XHJcbiAgICAgICAgaWYoIWZvbnREYXRhLmNhY2hlW2luZGV4ICsgMV0pIHtcclxuICAgICAgICAgICAgdmFyIHRIZWxwZXIgPSBmb250RGF0YS5oZWxwZXI7XHJcbiAgICAgICAgICAgIC8vQ2FudmFzIHZlcnNpb25cclxuICAgICAgICAgICAgLy9mb250RGF0YS5jYWNoZVtpbmRleF0gPSB0SGVscGVyLm1lYXN1cmVUZXh0KGNoYXIpLndpZHRoIC8gMTAwO1xyXG4gICAgICAgICAgICAvL1NWRyB2ZXJzaW9uXHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2codEhlbHBlci5nZXRCQm94KCkud2lkdGgpXHJcbiAgICAgICAgICAgIC8qdEhlbHBlci50ZXh0Q29udGVudCA9ICd8JyArIGNoYXIgKyAnfCc7XHJcbiAgICAgICAgICAgIHZhciBkb3VibGVTaXplID0gdEhlbHBlci5nZXRDb21wdXRlZFRleHRMZW5ndGgoKTtcclxuICAgICAgICAgICAgdEhlbHBlci50ZXh0Q29udGVudCA9ICd8fCc7XHJcbiAgICAgICAgICAgIHZhciBzaW5nbGVTaXplID0gdEhlbHBlci5nZXRDb21wdXRlZFRleHRMZW5ndGgoKTtcclxuICAgICAgICAgICAgZm9udERhdGEuY2FjaGVbaW5kZXggKyAxXSA9IChkb3VibGVTaXplIC0gc2luZ2xlU2l6ZSkvMTAwOyovXHJcbiAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRIZWxwZXIudGV4dENvbnRlbnQgPSBjaGFyO1xyXG4gICAgICAgICAgICBmb250RGF0YS5jYWNoZVtpbmRleCArIDFdID0gKHRIZWxwZXIuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkpLzEwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZvbnREYXRhLmNhY2hlW2luZGV4ICsgMV0gKiBzaXplO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldEZvbnRCeU5hbWUobmFtZSl7XHJcbiAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLmZvbnRzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZShpPGxlbil7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZm9udHNbaV0uZk5hbWUgPT09IG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvbnRzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9udHNbMF07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q29tYmluZWRDaGFyYWN0ZXJDb2RlcygpIHtcclxuICAgICAgICByZXR1cm4gY29tYmluZWRDaGFyYWN0ZXJzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxvYWRlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc0xvYWRlZDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgRm9udCA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5mb250cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2hhcnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudHlwZWtpdExvYWRlZCA9IDA7XHJcbiAgICAgICAgdGhpcy5pc0xvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaW5pdFRpbWUgPSBEYXRlLm5vdygpO1xyXG4gICAgfTtcclxuICAgIC8vVE9ETzogZm9yIG5vdyBJJ20gYWRkaW5nIHRoZXNlIG1ldGhvZHMgdG8gdGhlIENsYXNzIGFuZCBub3QgdGhlIHByb3RvdHlwZS4gVGhpbmsgb2YgYSBiZXR0ZXIgd2F5IHRvIGltcGxlbWVudCBpdC4gXHJcbiAgICBGb250LmdldENvbWJpbmVkQ2hhcmFjdGVyQ29kZXMgPSBnZXRDb21iaW5lZENoYXJhY3RlckNvZGVzO1xyXG5cclxuICAgIEZvbnQucHJvdG90eXBlLmFkZENoYXJzID0gYWRkQ2hhcnM7XHJcbiAgICBGb250LnByb3RvdHlwZS5hZGRGb250cyA9IGFkZEZvbnRzO1xyXG4gICAgRm9udC5wcm90b3R5cGUuZ2V0Q2hhckRhdGEgPSBnZXRDaGFyRGF0YTtcclxuICAgIEZvbnQucHJvdG90eXBlLmdldEZvbnRCeU5hbWUgPSBnZXRGb250QnlOYW1lO1xyXG4gICAgRm9udC5wcm90b3R5cGUubWVhc3VyZVRleHQgPSBtZWFzdXJlVGV4dDtcclxuICAgIEZvbnQucHJvdG90eXBlLmNoZWNrTG9hZGVkRm9udHMgPSBjaGVja0xvYWRlZEZvbnRzO1xyXG4gICAgRm9udC5wcm90b3R5cGUubG9hZGVkID0gbG9hZGVkO1xyXG5cclxuICAgIHJldHVybiBGb250O1xyXG5cclxufSgpKTtcbnZhciBQcm9wZXJ0eUZhY3RvcnkgPSAoZnVuY3Rpb24oKXtcclxuXHJcbiAgICB2YXIgaW5pdEZyYW1lID0gaW5pdGlhbERlZmF1bHRGcmFtZTtcclxuICAgIHZhciBtYXRoX2FicyA9IE1hdGguYWJzO1xyXG5cclxuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlVmFsdWUoZnJhbWVOdW0sIGNhY2hpbmcpIHtcclxuICAgICAgICB2YXIgb2Zmc2V0VGltZSA9IHRoaXMub2Zmc2V0VGltZTtcclxuICAgICAgICB2YXIgbmV3VmFsdWU7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcFR5cGUgPT09ICdtdWx0aWRpbWVuc2lvbmFsJykge1xyXG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCB0aGlzLnB2Lmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpdGVyYXRpb25JbmRleCA9IGNhY2hpbmcubGFzdEluZGV4O1xyXG4gICAgICAgIHZhciBpID0gaXRlcmF0aW9uSW5kZXg7XHJcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMua2V5ZnJhbWVzLmxlbmd0aCAtIDEsIGZsYWcgPSB0cnVlO1xyXG4gICAgICAgIHZhciBrZXlEYXRhLCBuZXh0S2V5RGF0YTtcclxuXHJcbiAgICAgICAgd2hpbGUgKGZsYWcpIHtcclxuICAgICAgICAgICAga2V5RGF0YSA9IHRoaXMua2V5ZnJhbWVzW2ldO1xyXG4gICAgICAgICAgICBuZXh0S2V5RGF0YSA9IHRoaXMua2V5ZnJhbWVzW2kgKyAxXTtcclxuICAgICAgICAgICAgaWYgKGkgPT09IGxlbiAtIDEgJiYgZnJhbWVOdW0gPj0gbmV4dEtleURhdGEudCAtIG9mZnNldFRpbWUpe1xyXG4gICAgICAgICAgICAgICAgaWYoa2V5RGF0YS5oKXtcclxuICAgICAgICAgICAgICAgICAgICBrZXlEYXRhID0gbmV4dEtleURhdGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRpb25JbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoKG5leHRLZXlEYXRhLnQgLSBvZmZzZXRUaW1lKSA+IGZyYW1lTnVtKXtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdGlvbkluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpIDwgbGVuIC0gMSl7XHJcbiAgICAgICAgICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRpb25JbmRleCA9IDA7XHJcbiAgICAgICAgICAgICAgICBmbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBrLCBrTGVuLCBwZXJjLCBqTGVuLCBqLCBmbmM7XHJcbiAgICAgICAgdmFyIG5leHRLZXlUaW1lID0gbmV4dEtleURhdGEudCAtIG9mZnNldFRpbWU7XHJcbiAgICAgICAgdmFyIGtleVRpbWUgPSBrZXlEYXRhLnQgLSBvZmZzZXRUaW1lO1xyXG4gICAgICAgIGlmIChrZXlEYXRhLnRvKSB7XHJcbiAgICAgICAgICAgIGlmICgha2V5RGF0YS5iZXppZXJEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBiZXouYnVpbGRCZXppZXJEYXRhKGtleURhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBiZXppZXJEYXRhID0ga2V5RGF0YS5iZXppZXJEYXRhO1xyXG4gICAgICAgICAgICBpZiAoZnJhbWVOdW0gPj0gbmV4dEtleVRpbWUgfHwgZnJhbWVOdW0gPCBrZXlUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kID0gZnJhbWVOdW0gPj0gbmV4dEtleVRpbWUgPyBiZXppZXJEYXRhLnBvaW50cy5sZW5ndGggLSAxIDogMDtcclxuICAgICAgICAgICAgICAgIGtMZW4gPSBiZXppZXJEYXRhLnBvaW50c1tpbmRdLnBvaW50Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBrTGVuOyBrICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVtrXSA9IGJlemllckRhdGEucG9pbnRzW2luZF0ucG9pbnRba107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBjYWNoaW5nLl9sYXN0QmV6aWVyRGF0YSA9IG51bGw7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5RGF0YS5fX2ZuY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICBmbmMgPSBrZXlEYXRhLl9fZm5jdDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm5jID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcoa2V5RGF0YS5vLngsIGtleURhdGEuby55LCBrZXlEYXRhLmkueCwga2V5RGF0YS5pLnksIGtleURhdGEubikuZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGtleURhdGEuX19mbmN0ID0gZm5jO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGVyYyA9IGZuYygoZnJhbWVOdW0gLSBrZXlUaW1lKSAvIChuZXh0S2V5VGltZSAtIGtleVRpbWUpKTtcclxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZUluTGluZSA9IGJlemllckRhdGEuc2VnbWVudExlbmd0aCpwZXJjO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50UGVyYztcclxuICAgICAgICAgICAgICAgIHZhciBhZGRlZExlbmd0aCA9ICAoY2FjaGluZy5sYXN0RnJhbWUgPCBmcmFtZU51bSAmJiBjYWNoaW5nLl9sYXN0QmV6aWVyRGF0YSA9PT0gYmV6aWVyRGF0YSkgPyBjYWNoaW5nLl9sYXN0QWRkZWRMZW5ndGggOiAwO1xyXG4gICAgICAgICAgICAgICAgaiA9ICAoY2FjaGluZy5sYXN0RnJhbWUgPCBmcmFtZU51bSAmJiBjYWNoaW5nLl9sYXN0QmV6aWVyRGF0YSA9PT0gYmV6aWVyRGF0YSkgPyBjYWNoaW5nLl9sYXN0UG9pbnQgOiAwO1xyXG4gICAgICAgICAgICAgICAgZmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBqTGVuID0gYmV6aWVyRGF0YS5wb2ludHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGZsYWcpIHtcclxuICAgICAgICAgICAgICAgICAgICBhZGRlZExlbmd0aCArPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wYXJ0aWFsTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZUluTGluZSA9PT0gMCB8fCBwZXJjID09PSAwIHx8IGogPT09IGJlemllckRhdGEucG9pbnRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAga0xlbiA9IGJlemllckRhdGEucG9pbnRzW2pdLnBvaW50Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVba10gPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wb2ludFtrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRpc3RhbmNlSW5MaW5lID49IGFkZGVkTGVuZ3RoICYmIGRpc3RhbmNlSW5MaW5lIDwgYWRkZWRMZW5ndGggKyBiZXppZXJEYXRhLnBvaW50c1tqICsgMV0ucGFydGlhbExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50UGVyYyA9IChkaXN0YW5jZUluTGluZSAtIGFkZGVkTGVuZ3RoKSAvIGJlemllckRhdGEucG9pbnRzW2ogKyAxXS5wYXJ0aWFsTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrTGVuID0gYmV6aWVyRGF0YS5wb2ludHNbal0ucG9pbnQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVtrXSA9IGJlemllckRhdGEucG9pbnRzW2pdLnBvaW50W2tdICsgKGJlemllckRhdGEucG9pbnRzW2ogKyAxXS5wb2ludFtrXSAtIGJlemllckRhdGEucG9pbnRzW2pdLnBvaW50W2tdKSAqIHNlZ21lbnRQZXJjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IGpMZW4gLSAxKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaiArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYWNoaW5nLl9sYXN0UG9pbnQgPSBqO1xyXG4gICAgICAgICAgICAgICAgY2FjaGluZy5fbGFzdEFkZGVkTGVuZ3RoID0gYWRkZWRMZW5ndGggLSBiZXppZXJEYXRhLnBvaW50c1tqXS5wYXJ0aWFsTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgY2FjaGluZy5fbGFzdEJlemllckRhdGEgPSBiZXppZXJEYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG91dFgsIG91dFksIGluWCwgaW5ZLCBrZXlWYWx1ZTtcclxuICAgICAgICAgICAgbGVuID0ga2V5RGF0YS5zLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2ggJiYga2V5RGF0YS5oICE9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWVOdW0gPj0gbmV4dEtleVRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVswXSA9IGtleURhdGEuZVswXTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVsxXSA9IGtleURhdGEuZVsxXTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVsyXSA9IGtleURhdGEuZVsyXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJhbWVOdW0gPD0ga2V5VGltZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlWzBdID0ga2V5RGF0YS5zWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlWzFdID0ga2V5RGF0YS5zWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlWzJdID0ga2V5RGF0YS5zWzJdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcXVhdFN0YXJ0ID0gY3JlYXRlUXVhdGVybmlvbihrZXlEYXRhLnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBxdWF0RW5kID0gY3JlYXRlUXVhdGVybmlvbihrZXlEYXRhLmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lID0gKGZyYW1lTnVtIC0ga2V5VGltZSkgLyAobmV4dEtleVRpbWUgLSBrZXlUaW1lKTtcclxuICAgICAgICAgICAgICAgICAgICBxdWF0ZXJuaW9uVG9FdWxlcihuZXdWYWx1ZSwgc2xlcnAocXVhdFN0YXJ0LCBxdWF0RW5kLCB0aW1lKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleURhdGEuaCAhPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhbWVOdW0gPj0gbmV4dEtleVRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcmMgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoZnJhbWVOdW0gPCBrZXlUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJjID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGtleURhdGEuby54LmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgha2V5RGF0YS5fX2ZuY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RGF0YS5fX2ZuY3QgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFrZXlEYXRhLl9fZm5jdFtpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRYID0ga2V5RGF0YS5vLnhbaV0gfHwga2V5RGF0YS5vLnhbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dFkgPSBrZXlEYXRhLm8ueVtpXSB8fCBrZXlEYXRhLm8ueVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5YID0ga2V5RGF0YS5pLnhbaV0gfHwga2V5RGF0YS5pLnhbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluWSA9IGtleURhdGEuaS55W2ldIHx8IGtleURhdGEuaS55WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbmMgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyhvdXRYLCBvdXRZLCBpblgsIGluWSkuZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlEYXRhLl9fZm5jdFtpXSA9IGZuYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbmMgPSBrZXlEYXRhLl9fZm5jdFtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgha2V5RGF0YS5fX2ZuY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0WCA9IGtleURhdGEuby54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRZID0ga2V5RGF0YS5vLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluWCA9IGtleURhdGEuaS54O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblkgPSBrZXlEYXRhLmkueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm5jID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcob3V0WCwgb3V0WSwgaW5YLCBpblkpLmdldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5RGF0YS5fX2ZuY3QgPSBmbmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm5jID0ga2V5RGF0YS5fX2ZuY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyYyA9IGZuYygoZnJhbWVOdW0gLSBrZXlUaW1lKSAvIChuZXh0S2V5VGltZSAtIGtleVRpbWUgKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGtleVZhbHVlID0ga2V5RGF0YS5oID09PSAxID8ga2V5RGF0YS5zW2ldIDoga2V5RGF0YS5zW2ldICsgKGtleURhdGEuZVtpXSAtIGtleURhdGEuc1tpXSkgKiBwZXJjO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAobGVuID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0ga2V5VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVbaV0gPSBrZXlWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2FjaGluZy5sYXN0SW5kZXggPSBpdGVyYXRpb25JbmRleDtcclxuICAgICAgICByZXR1cm4gbmV3VmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy9iYXNlZCBvbiBAVG9qaSdzIGh0dHBzOi8vZ2l0aHViLmNvbS90b2ppL2dsLW1hdHJpeC9cclxuICAgIGZ1bmN0aW9uIHNsZXJwKGEsIGIsIHQpIHtcclxuICAgICAgICB2YXIgb3V0ID0gW107XHJcbiAgICAgICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcclxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM11cclxuXHJcbiAgICAgICAgdmFyIG9tZWdhLCBjb3NvbSwgc2lub20sIHNjYWxlMCwgc2NhbGUxO1xyXG5cclxuICAgICAgICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7XHJcbiAgICAgICAgaWYgKGNvc29tIDwgMC4wKSB7XHJcbiAgICAgICAgICAgIGNvc29tID0gLWNvc29tO1xyXG4gICAgICAgICAgICBieCA9IC1ieDtcclxuICAgICAgICAgICAgYnkgPSAtYnk7XHJcbiAgICAgICAgICAgIGJ6ID0gLWJ6O1xyXG4gICAgICAgICAgICBidyA9IC1idztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCgxLjAgLSBjb3NvbSkgPiAwLjAwMDAwMSkge1xyXG4gICAgICAgICAgICBvbWVnYSA9IE1hdGguYWNvcyhjb3NvbSk7XHJcbiAgICAgICAgICAgIHNpbm9tID0gTWF0aC5zaW4ob21lZ2EpO1xyXG4gICAgICAgICAgICBzY2FsZTAgPSBNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTtcclxuICAgICAgICAgICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7XHJcbiAgICAgICAgICAgIHNjYWxlMSA9IHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XHJcbiAgICAgICAgb3V0WzFdID0gc2NhbGUwICogYXkgKyBzY2FsZTEgKiBieTtcclxuICAgICAgICBvdXRbMl0gPSBzY2FsZTAgKiBheiArIHNjYWxlMSAqIGJ6O1xyXG4gICAgICAgIG91dFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XHJcblxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcXVhdGVybmlvblRvRXVsZXIob3V0LCBxdWF0KSB7XHJcbiAgICAgICAgdmFyIHF4ID0gcXVhdFswXTtcclxuICAgICAgICB2YXIgcXkgPSBxdWF0WzFdO1xyXG4gICAgICAgIHZhciBxeiA9IHF1YXRbMl07XHJcbiAgICAgICAgdmFyIHF3ID0gcXVhdFszXTtcclxuICAgICAgICB2YXIgaGVhZGluZyA9IE1hdGguYXRhbjIoMipxeSpxdy0yKnF4KnF6ICwgMSAtIDIqcXkqcXkgLSAyKnF6KnF6KVxyXG4gICAgICAgIHZhciBhdHRpdHVkZSA9IE1hdGguYXNpbigyKnF4KnF5ICsgMipxeipxdykgXHJcbiAgICAgICAgdmFyIGJhbmsgPSBNYXRoLmF0YW4yKDIqcXgqcXctMipxeSpxeiAsIDEgLSAyKnF4KnF4IC0gMipxeipxeik7XHJcbiAgICAgICAgb3V0WzBdID0gaGVhZGluZy9kZWdUb1JhZHM7XHJcbiAgICAgICAgb3V0WzFdID0gYXR0aXR1ZGUvZGVnVG9SYWRzO1xyXG4gICAgICAgIG91dFsyXSA9IGJhbmsvZGVnVG9SYWRzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVF1YXRlcm5pb24odmFsdWVzKSB7XHJcbiAgICAgICAgdmFyIGhlYWRpbmcgPSB2YWx1ZXNbMF0gKiBkZWdUb1JhZHM7XHJcbiAgICAgICAgdmFyIGF0dGl0dWRlID0gdmFsdWVzWzFdICogZGVnVG9SYWRzO1xyXG4gICAgICAgIHZhciBiYW5rID0gdmFsdWVzWzJdICogZGVnVG9SYWRzO1xyXG4gICAgICAgIHZhciBjMSA9IE1hdGguY29zKGhlYWRpbmcgLyAyKTtcclxuICAgICAgICB2YXIgYzIgPSBNYXRoLmNvcyhhdHRpdHVkZSAvIDIpO1xyXG4gICAgICAgIHZhciBjMyA9IE1hdGguY29zKGJhbmsgLyAyKTtcclxuICAgICAgICB2YXIgczEgPSBNYXRoLnNpbihoZWFkaW5nIC8gMik7XHJcbiAgICAgICAgdmFyIHMyID0gTWF0aC5zaW4oYXR0aXR1ZGUgLyAyKTtcclxuICAgICAgICB2YXIgczMgPSBNYXRoLnNpbihiYW5rIC8gMik7XHJcbiAgICAgICAgdmFyIHcgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XHJcbiAgICAgICAgdmFyIHggPSBzMSAqIHMyICogYzMgKyBjMSAqIGMyICogczM7XHJcbiAgICAgICAgdmFyIHkgPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XHJcbiAgICAgICAgdmFyIHogPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XHJcblxyXG4gICAgICAgIHJldHVybiBbeCx5LHosd107XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVBdEN1cnJlbnRUaW1lKCl7XHJcbiAgICAgICAgdmFyIGZyYW1lTnVtID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLSB0aGlzLm9mZnNldFRpbWU7XHJcbiAgICAgICAgdmFyIGluaXRUaW1lID0gdGhpcy5rZXlmcmFtZXNbMF0udCAtIHRoaXMub2Zmc2V0VGltZTtcclxuICAgICAgICB2YXIgZW5kVGltZSA9IHRoaXMua2V5ZnJhbWVzW3RoaXMua2V5ZnJhbWVzLmxlbmd0aC0gMV0udC10aGlzLm9mZnNldFRpbWU7XHJcbiAgICAgICAgaWYoIShmcmFtZU51bSA9PT0gdGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgfHwgKHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lICE9PSBpbml0RnJhbWUgJiYgKCh0aGlzLl9jYWNoaW5nLmxhc3RGcmFtZSA+PSBlbmRUaW1lICYmIGZyYW1lTnVtID49IGVuZFRpbWUpIHx8ICh0aGlzLl9jYWNoaW5nLmxhc3RGcmFtZSA8IGluaXRUaW1lICYmIGZyYW1lTnVtIDwgaW5pdFRpbWUpKSkpKXtcclxuICAgICAgICAgICAgaWYodGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgPj0gZnJhbWVOdW0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hpbmcuX2xhc3RCZXppZXJEYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hpbmcubGFzdEluZGV4ID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHJlbmRlclJlc3VsdCA9IHRoaXMuaW50ZXJwb2xhdGVWYWx1ZShmcmFtZU51bSwgdGhpcy5fY2FjaGluZyk7XHJcbiAgICAgICAgICAgIHRoaXMucHYgPSByZW5kZXJSZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lID0gZnJhbWVOdW07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHY7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0VlZhbHVlKHZhbCkge1xyXG4gICAgICAgIHZhciBtdWx0aXBsaWVkVmFsdWU7XHJcbiAgICAgICAgaWYodGhpcy5wcm9wVHlwZSA9PT0gJ3VuaWRpbWVuc2lvbmFsJykge1xyXG4gICAgICAgICAgICBtdWx0aXBsaWVkVmFsdWUgPSB2YWwgKiB0aGlzLm11bHQ7XHJcbiAgICAgICAgICAgIGlmKG1hdGhfYWJzKHRoaXMudiAtIG11bHRpcGxpZWRWYWx1ZSkgPiAwLjAwMDAxKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnYgPSBtdWx0aXBsaWVkVmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tZGYgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLnYubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICAgICAgICAgICAgbXVsdGlwbGllZFZhbHVlID0gdmFsW2ldICogdGhpcy5tdWx0O1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGhfYWJzKHRoaXMudltpXSAtIG11bHRpcGxpZWRWYWx1ZSkgPiAwLjAwMDAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52W2ldID0gbXVsdGlwbGllZFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZSgpIHtcclxuICAgICAgICBpZih0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQgfHwgIXRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfSAgICAgICAgXHJcbiAgICAgICAgaWYodGhpcy5sb2NrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0VlZhbHVlKHRoaXMucHYpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9jayA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fbWRmID0gdGhpcy5faXNGaXJzdEZyYW1lO1xyXG4gICAgICAgIHZhciBtdWx0aXBsaWVkVmFsdWU7XHJcbiAgICAgICAgdmFyIGksIGxlbiA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcclxuICAgICAgICB2YXIgZmluYWxWYWx1ZSA9IHRoaXMua2YgPyB0aGlzLnB2IDogdGhpcy5kYXRhLms7XHJcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgZmluYWxWYWx1ZSA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlW2ldKGZpbmFsVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFZWYWx1ZShmaW5hbFZhbHVlKTtcclxuICAgICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxvY2sgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZEVmZmVjdChlZmZlY3RGdW5jdGlvbikge1xyXG4gICAgICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlLnB1c2goZWZmZWN0RnVuY3Rpb24pO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBWYWx1ZVByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcil7XHJcbiAgICAgICAgdGhpcy5wcm9wVHlwZSA9ICd1bmlkaW1lbnNpb25hbCc7XHJcbiAgICAgICAgdGhpcy5tdWx0ID0gbXVsdCB8fCAxO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy52ID0gbXVsdCA/IGRhdGEuayAqIG11bHQgOiBkYXRhLms7XHJcbiAgICAgICAgdGhpcy5wdiA9IGRhdGEuaztcclxuICAgICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcclxuICAgICAgICB0aGlzLmsgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmtmID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy52ZWwgPSAwO1xyXG4gICAgICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlID0gW107XHJcbiAgICAgICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcclxuICAgICAgICB0aGlzLnNldFZWYWx1ZSA9IHNldFZWYWx1ZTtcclxuICAgICAgICB0aGlzLmFkZEVmZmVjdCA9IGFkZEVmZmVjdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBNdWx0aURpbWVuc2lvbmFsUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKSB7XHJcbiAgICAgICAgdGhpcy5wcm9wVHlwZSA9ICdtdWx0aWRpbWVuc2lvbmFsJztcclxuICAgICAgICB0aGlzLm11bHQgPSBtdWx0IHx8IDE7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xyXG4gICAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcclxuICAgICAgICB0aGlzLmsgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmtmID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5mcmFtZUlkID0gLTE7XHJcbiAgICAgICAgdmFyIGksIGxlbiA9IGRhdGEuay5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy52ID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XHJcbiAgICAgICAgdGhpcy5wdiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xyXG4gICAgICAgIHZhciBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcclxuICAgICAgICB0aGlzLnZlbCA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICB0aGlzLnZbaV0gPSBkYXRhLmtbaV0gKiB0aGlzLm11bHQ7XHJcbiAgICAgICAgICAgIHRoaXMucHZbaV0gPSBkYXRhLmtbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbXTtcclxuICAgICAgICB0aGlzLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcclxuICAgICAgICB0aGlzLnNldFZWYWx1ZSA9IHNldFZWYWx1ZTtcclxuICAgICAgICB0aGlzLmFkZEVmZmVjdCA9IGFkZEVmZmVjdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBLZXlmcmFtZWRWYWx1ZVByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcikge1xyXG4gICAgICAgIHRoaXMucHJvcFR5cGUgPSAndW5pZGltZW5zaW9uYWwnO1xyXG4gICAgICAgIHRoaXMua2V5ZnJhbWVzID0gZGF0YS5rO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0VGltZSA9IGVsZW0uZGF0YS5zdDtcclxuICAgICAgICB0aGlzLmZyYW1lSWQgPSAtMTtcclxuICAgICAgICB0aGlzLl9jYWNoaW5nID0ge2xhc3RGcmFtZTogaW5pdEZyYW1lLCBsYXN0SW5kZXg6IDAsIHZhbHVlOiAwLCBfbGFzdEJlemllckRhdGE6IG51bGx9O1xyXG4gICAgICAgIHRoaXMuayA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5rZiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLm11bHQgPSBtdWx0IHx8IDE7XHJcbiAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XHJcbiAgICAgICAgdGhpcy52ID0gaW5pdEZyYW1lO1xyXG4gICAgICAgIHRoaXMucHYgPSBpbml0RnJhbWU7XHJcbiAgICAgICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcclxuICAgICAgICB0aGlzLnNldFZWYWx1ZSA9IHNldFZWYWx1ZTtcclxuICAgICAgICB0aGlzLmludGVycG9sYXRlVmFsdWUgPSBpbnRlcnBvbGF0ZVZhbHVlO1xyXG4gICAgICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlID0gW2dldFZhbHVlQXRDdXJyZW50VGltZS5iaW5kKHRoaXMpXTtcclxuICAgICAgICB0aGlzLmFkZEVmZmVjdCA9IGFkZEVmZmVjdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBLZXlmcmFtZWRNdWx0aWRpbWVuc2lvbmFsUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKXtcclxuICAgICAgICB0aGlzLnByb3BUeXBlID0gJ211bHRpZGltZW5zaW9uYWwnO1xyXG4gICAgICAgIHZhciBpLCBsZW4gPSBkYXRhLmsubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzLCBlLHRvLHRpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEua1tpXS50byAmJiBkYXRhLmtbaV0ucyAmJiBkYXRhLmtbaV0uZSkge1xyXG4gICAgICAgICAgICAgICAgcyA9IGRhdGEua1tpXS5zO1xyXG4gICAgICAgICAgICAgICAgZSA9IGRhdGEua1tpXS5lO1xyXG4gICAgICAgICAgICAgICAgdG8gPSBkYXRhLmtbaV0udG87XHJcbiAgICAgICAgICAgICAgICB0aSA9IGRhdGEua1tpXS50aTtcclxuICAgICAgICAgICAgICAgIGlmKChzLmxlbmd0aCA9PT0gMiAmJiAhKHNbMF0gPT09IGVbMF0gJiYgc1sxXSA9PT0gZVsxXSkgJiYgYmV6LnBvaW50T25MaW5lMkQoc1swXSxzWzFdLGVbMF0sZVsxXSxzWzBdICsgdG9bMF0sc1sxXSArIHRvWzFdKSAmJiBiZXoucG9pbnRPbkxpbmUyRChzWzBdLHNbMV0sZVswXSxlWzFdLGVbMF0gKyB0aVswXSxlWzFdICsgdGlbMV0pKSB8fCAocy5sZW5ndGggPT09IDMgJiYgIShzWzBdID09PSBlWzBdICYmIHNbMV0gPT09IGVbMV0gJiYgc1syXSA9PT0gZVsyXSkgJiYgYmV6LnBvaW50T25MaW5lM0Qoc1swXSxzWzFdLHNbMl0sZVswXSxlWzFdLGVbMl0sc1swXSArIHRvWzBdLHNbMV0gKyB0b1sxXSxzWzJdICsgdG9bMl0pICYmIGJlei5wb2ludE9uTGluZTNEKHNbMF0sc1sxXSxzWzJdLGVbMF0sZVsxXSxlWzJdLGVbMF0gKyB0aVswXSxlWzFdICsgdGlbMV0sZVsyXSArIHRpWzJdKSkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEua1tpXS50byA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5rW2ldLnRpID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHNbMF0gPT09IGVbMF0gJiYgc1sxXSA9PT0gZVsxXSAmJiB0b1swXSA9PT0gMCAmJiB0b1sxXSA9PT0gMCAmJiB0aVswXSA9PT0gMCAmJiB0aVsxXSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHMubGVuZ3RoID09PSAyIHx8IChzWzJdID09PSBlWzJdICYmIHRvWzJdID09PSAwICYmIHRpWzJdID09PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmtbaV0udG8gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmtbaV0udGkgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtnZXRWYWx1ZUF0Q3VycmVudFRpbWUuYmluZCh0aGlzKV07XHJcbiAgICAgICAgdGhpcy5rZXlmcmFtZXMgPSBkYXRhLms7XHJcbiAgICAgICAgdGhpcy5vZmZzZXRUaW1lID0gZWxlbS5kYXRhLnN0O1xyXG4gICAgICAgIHRoaXMuayA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5rZiA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm11bHQgPSBtdWx0IHx8IDE7XHJcbiAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcclxuICAgICAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XHJcbiAgICAgICAgdGhpcy5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XHJcbiAgICAgICAgdGhpcy5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XHJcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0ZVZhbHVlID0gaW50ZXJwb2xhdGVWYWx1ZTtcclxuICAgICAgICB0aGlzLmZyYW1lSWQgPSAtMTtcclxuICAgICAgICB2YXIgYXJyTGVuID0gZGF0YS5rWzBdLnMubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMudiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBhcnJMZW4pO1xyXG4gICAgICAgIHRoaXMucHYgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgYXJyTGVuKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyTGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgdGhpcy52W2ldID0gaW5pdEZyYW1lO1xyXG4gICAgICAgICAgICB0aGlzLnB2W2ldID0gaW5pdEZyYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jYWNoaW5nPXtsYXN0RnJhbWU6aW5pdEZyYW1lLGxhc3RJbmRleDowLHZhbHVlOmNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBhcnJMZW4pfTtcclxuICAgICAgICB0aGlzLmFkZEVmZmVjdCA9IGFkZEVmZmVjdDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRQcm9wKGVsZW0sZGF0YSx0eXBlLCBtdWx0LCBjb250YWluZXIpIHtcclxuICAgICAgICB2YXIgcDtcclxuICAgICAgICBpZihkYXRhLmEgPT09IDApe1xyXG4gICAgICAgICAgICBpZih0eXBlID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBwID0gbmV3IFZhbHVlUHJvcGVydHkoZWxlbSxkYXRhLG11bHQsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwID0gbmV3IE11bHRpRGltZW5zaW9uYWxQcm9wZXJ0eShlbGVtLGRhdGEsIG11bHQsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYoZGF0YS5hID09PSAxKXtcclxuICAgICAgICAgICAgaWYodHlwZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgcCA9IG5ldyBLZXlmcmFtZWRWYWx1ZVByb3BlcnR5KGVsZW0sZGF0YSxtdWx0LCBjb250YWluZXIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcCA9IG5ldyBLZXlmcmFtZWRNdWx0aWRpbWVuc2lvbmFsUHJvcGVydHkoZWxlbSxkYXRhLCBtdWx0LCBjb250YWluZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmKCFkYXRhLmsubGVuZ3RoKXtcclxuICAgICAgICAgICAgcCA9IG5ldyBWYWx1ZVByb3BlcnR5KGVsZW0sZGF0YSwgbXVsdCwgY29udGFpbmVyKTtcclxuICAgICAgICB9ZWxzZSBpZih0eXBlb2YoZGF0YS5rWzBdKSA9PT0gJ251bWJlcicpe1xyXG4gICAgICAgICAgICBwID0gbmV3IE11bHRpRGltZW5zaW9uYWxQcm9wZXJ0eShlbGVtLGRhdGEsIG11bHQsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHN3aXRjaCh0eXBlKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBwID0gbmV3IEtleWZyYW1lZFZhbHVlUHJvcGVydHkoZWxlbSxkYXRhLG11bHQsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgcCA9IG5ldyBLZXlmcmFtZWRNdWx0aWRpbWVuc2lvbmFsUHJvcGVydHkoZWxlbSxkYXRhLG11bHQsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYocC5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoKXtcclxuICAgICAgICAgICAgY29udGFpbmVyLmFkZER5bmFtaWNQcm9wZXJ0eShwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG9iID0ge1xyXG4gICAgICAgIGdldFByb3A6IGdldFByb3BcclxuICAgIH07XHJcbiAgICByZXR1cm4gb2I7XHJcbn0oKSk7XG52YXIgVHJhbnNmb3JtUHJvcGVydHlGYWN0b3J5ID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuICAgIGZ1bmN0aW9uIGFwcGx5VG9NYXRyaXgobWF0KSB7XHJcbiAgICAgICAgdmFyIF9tZGYgPSB0aGlzLl9tZGY7XHJcbiAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcclxuICAgICAgICB0aGlzLl9tZGYgPSB0aGlzLl9tZGYgfHwgX21kZjtcclxuICAgICAgICBpZiAodGhpcy5hKSB7XHJcbiAgICAgICAgICAgIG1hdC50cmFuc2xhdGUoLXRoaXMuYS52WzBdLCAtdGhpcy5hLnZbMV0sIHRoaXMuYS52WzJdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucykge1xyXG4gICAgICAgICAgICBtYXQuc2NhbGUodGhpcy5zLnZbMF0sIHRoaXMucy52WzFdLCB0aGlzLnMudlsyXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNrKSB7XHJcbiAgICAgICAgICAgIG1hdC5za2V3RnJvbUF4aXMoLXRoaXMuc2sudiwgdGhpcy5zYS52KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucikge1xyXG4gICAgICAgICAgICBtYXQucm90YXRlKC10aGlzLnIudik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWF0LnJvdGF0ZVooLXRoaXMucnoudikucm90YXRlWSh0aGlzLnJ5LnYpLnJvdGF0ZVgodGhpcy5yeC52KS5yb3RhdGVaKC10aGlzLm9yLnZbMl0pLnJvdGF0ZVkodGhpcy5vci52WzFdKS5yb3RhdGVYKHRoaXMub3IudlswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRhdGEucC5zKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEucC56KSB7XHJcbiAgICAgICAgICAgICAgICBtYXQudHJhbnNsYXRlKHRoaXMucHgudiwgdGhpcy5weS52LCAtdGhpcy5wei52KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1hdC50cmFuc2xhdGUodGhpcy5weC52LCB0aGlzLnB5LnYsIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWF0LnRyYW5zbGF0ZSh0aGlzLnAudlswXSwgdGhpcy5wLnZbMV0sIC10aGlzLnAudlsyXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0tleXMoZm9yY2VSZW5kZXIpe1xyXG4gICAgICAgIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGlzLl9pc0RpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlY2FsY3VsYXRlTWF0cml4KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzRGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLl9tZGYgfHwgZm9yY2VSZW5kZXIpIHtcclxuICAgICAgICAgICAgdGhpcy52LmNsb25lRnJvbVByb3BzKHRoaXMucHJlLnByb3BzKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudi50cmFuc2xhdGUoLXRoaXMuYS52WzBdLCAtdGhpcy5hLnZbMV0sIHRoaXMuYS52WzJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCAyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnYuc2NhbGUodGhpcy5zLnZbMF0sIHRoaXMucy52WzFdLCB0aGlzLnMudlsyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuc2sgJiYgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgMykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52LnNrZXdGcm9tQXhpcygtdGhpcy5zay52LCB0aGlzLnNhLnYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnIgJiYgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgNCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52LnJvdGF0ZSgtdGhpcy5yLnYpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnIgJiYgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgNCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnYucm90YXRlWigtdGhpcy5yei52KS5yb3RhdGVZKHRoaXMucnkudikucm90YXRlWCh0aGlzLnJ4LnYpLnJvdGF0ZVooLXRoaXMub3IudlsyXSkucm90YXRlWSh0aGlzLm9yLnZbMV0pLnJvdGF0ZVgodGhpcy5vci52WzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvT3JpZW50ZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2MSx2MiwgZnJhbWVSYXRlID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5wICYmIHRoaXMucC5rZXlmcmFtZXMgJiYgdGhpcy5wLmdldFZhbHVlQXRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucC5fY2FjaGluZy5sYXN0RnJhbWUrdGhpcy5wLm9mZnNldFRpbWUgPD0gdGhpcy5wLmtleWZyYW1lc1swXS50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gdGhpcy5wLmdldFZhbHVlQXRUaW1lKCh0aGlzLnAua2V5ZnJhbWVzWzBdLnQgKyAwLjAxKSAvIGZyYW1lUmF0ZSwwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSB0aGlzLnAuZ2V0VmFsdWVBdFRpbWUodGhpcy5wLmtleWZyYW1lc1swXS50IC8gZnJhbWVSYXRlLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYodGhpcy5wLl9jYWNoaW5nLmxhc3RGcmFtZSt0aGlzLnAub2Zmc2V0VGltZSA+PSB0aGlzLnAua2V5ZnJhbWVzW3RoaXMucC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2MSA9IHRoaXMucC5nZXRWYWx1ZUF0VGltZSgodGhpcy5wLmtleWZyYW1lc1t0aGlzLnAua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLyBmcmFtZVJhdGUpLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdjIgPSB0aGlzLnAuZ2V0VmFsdWVBdFRpbWUoKHRoaXMucC5rZXlmcmFtZXNbdGhpcy5wLmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC0gMC4wMSkgLyBmcmFtZVJhdGUsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYxID0gdGhpcy5wLnB2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2MiA9IHRoaXMucC5nZXRWYWx1ZUF0VGltZSgodGhpcy5wLl9jYWNoaW5nLmxhc3RGcmFtZSt0aGlzLnAub2Zmc2V0VGltZSAtIDAuMDEpIC8gZnJhbWVSYXRlLCB0aGlzLnAub2Zmc2V0VGltZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMucHggJiYgdGhpcy5weC5rZXlmcmFtZXMgJiYgdGhpcy5weS5rZXlmcmFtZXMgJiYgdGhpcy5weC5nZXRWYWx1ZUF0VGltZSAmJiB0aGlzLnB5LmdldFZhbHVlQXRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdjEgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2MiA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBweCA9IHRoaXMucHgsIHB5ID0gdGhpcy5weSwgZnJhbWVSYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChweC5fY2FjaGluZy5sYXN0RnJhbWUrcHgub2Zmc2V0VGltZSA8PSBweC5rZXlmcmFtZXNbMF0udCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2MVswXSA9IHB4LmdldFZhbHVlQXRUaW1lKChweC5rZXlmcmFtZXNbMF0udCArIDAuMDEpIC8gZnJhbWVSYXRlLDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2MVsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKChweS5rZXlmcmFtZXNbMF0udCArIDAuMDEpIC8gZnJhbWVSYXRlLDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2MlswXSA9IHB4LmdldFZhbHVlQXRUaW1lKChweC5rZXlmcmFtZXNbMF0udCkgLyBmcmFtZVJhdGUsMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYyWzFdID0gcHkuZ2V0VmFsdWVBdFRpbWUoKHB5LmtleWZyYW1lc1swXS50KSAvIGZyYW1lUmF0ZSwwKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYocHguX2NhY2hpbmcubGFzdEZyYW1lK3B4Lm9mZnNldFRpbWUgPj0gcHgua2V5ZnJhbWVzW3B4LmtleWZyYW1lcy5sZW5ndGggLSAxXS50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYxWzBdID0gcHguZ2V0VmFsdWVBdFRpbWUoKHB4LmtleWZyYW1lc1tweC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAvIGZyYW1lUmF0ZSksMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYxWzFdID0gcHkuZ2V0VmFsdWVBdFRpbWUoKHB5LmtleWZyYW1lc1tweS5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAvIGZyYW1lUmF0ZSksMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHYyWzBdID0gcHguZ2V0VmFsdWVBdFRpbWUoKHB4LmtleWZyYW1lc1tweC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAtIDAuMDEpIC8gZnJhbWVSYXRlLDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2MlsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKChweS5rZXlmcmFtZXNbcHkua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLSAwLjAxKSAvIGZyYW1lUmF0ZSwwKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2MSA9IFtweC5wdiwgcHkucHZdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2MlswXSA9IHB4LmdldFZhbHVlQXRUaW1lKChweC5fY2FjaGluZy5sYXN0RnJhbWUrcHgub2Zmc2V0VGltZSAtIDAuMDEpIC8gZnJhbWVSYXRlLHB4Lm9mZnNldFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2MlsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKChweS5fY2FjaGluZy5sYXN0RnJhbWUrcHkub2Zmc2V0VGltZSAtIDAuMDEpIC8gZnJhbWVSYXRlLHB5Lm9mZnNldFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudi5yb3RhdGUoLU1hdGguYXRhbjIodjFbMV0gLSB2MlsxXSwgdjFbMF0gLSB2MlswXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHRoaXMuZGF0YS5wLnMpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5kYXRhLnAueikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudi50cmFuc2xhdGUodGhpcy5weC52LCB0aGlzLnB5LnYsIC10aGlzLnB6LnYpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnYudHJhbnNsYXRlKHRoaXMucHgudiwgdGhpcy5weS52LCAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnYudHJhbnNsYXRlKHRoaXMucC52WzBdLHRoaXMucC52WzFdLC10aGlzLnAudlsyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcmVjYWxjdWxhdGVNYXRyaXgoKSB7XHJcbiAgICAgICAgaWYoIXRoaXMuYS5rKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlLnRyYW5zbGF0ZSgtdGhpcy5hLnZbMF0sIC10aGlzLmEudlsxXSwgdGhpcy5hLnZbMl0pO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoIXRoaXMucy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJlLnNjYWxlKHRoaXMucy52WzBdLCB0aGlzLnMudlsxXSwgdGhpcy5zLnZbMl0pO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSAyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5zaykge1xyXG4gICAgICAgICAgICBpZighdGhpcy5zay5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICYmICF0aGlzLnNhLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJlLnNrZXdGcm9tQXhpcygtdGhpcy5zay52LCB0aGlzLnNhLnYpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSAzO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnIpIHtcclxuICAgICAgICAgICAgaWYoIXRoaXMuci5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByZS5yb3RhdGUoLXRoaXMuci52KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA9IDQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYoIXRoaXMucnouZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCAmJiAhdGhpcy5yeS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICYmICF0aGlzLnJ4LmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggJiYgIXRoaXMub3IuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLnByZS5yb3RhdGVaKC10aGlzLnJ6LnYpLnJvdGF0ZVkodGhpcy5yeS52KS5yb3RhdGVYKHRoaXMucngudikucm90YXRlWigtdGhpcy5vci52WzJdKS5yb3RhdGVZKHRoaXMub3IudlsxXSkucm90YXRlWCh0aGlzLm9yLnZbMF0pO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSA0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhdXRvT3JpZW50KCl7XHJcbiAgICAgICAgLy9cclxuICAgICAgICAvL3ZhciBwcmV2UCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGREeW5hbWljUHJvcGVydHkocHJvcCkge1xyXG4gICAgICAgIHRoaXMuX2FkZER5bmFtaWNQcm9wZXJ0eShwcm9wKTtcclxuICAgICAgICB0aGlzLmVsZW0uYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApO1xyXG4gICAgICAgIHRoaXMuX2lzRGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVByb3BlcnR5KGVsZW0sZGF0YSxjb250YWluZXIpe1xyXG4gICAgICAgIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgICAgICAgdGhpcy5mcmFtZUlkID0gLTE7XHJcbiAgICAgICAgdGhpcy5wcm9wVHlwZSA9ICd0cmFuc2Zvcm0nO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy52ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgIC8vUHJlY2FsY3VsYXRlZCBtYXRyaXggd2l0aCBub24gYW5pbWF0ZWQgcHJvcGVydGllc1xyXG4gICAgICAgIHRoaXMucHJlID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA9IDA7XHJcbiAgICAgICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGNvbnRhaW5lciB8fCBlbGVtKTtcclxuICAgICAgICBpZihkYXRhLnAucyl7XHJcbiAgICAgICAgICAgIHRoaXMucHggPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLGRhdGEucC54LDAsMCx0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5weSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS5wLnksMCwwLHRoaXMpO1xyXG4gICAgICAgICAgICBpZihkYXRhLnAueil7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB6ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSxkYXRhLnAueiwwLDAsdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSxkYXRhLnAsMSwwLHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihkYXRhLnIpIHtcclxuICAgICAgICAgICAgdGhpcy5yID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yLCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xyXG4gICAgICAgIH0gZWxzZSBpZihkYXRhLnJ4KSB7XHJcbiAgICAgICAgICAgIHRoaXMucnggPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnJ4LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLnJ5ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yeSwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5yeiA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucnosIDAsIGRlZ1RvUmFkcywgdGhpcyk7XHJcbiAgICAgICAgICAgIGlmKGRhdGEub3Iua1swXS50aSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGksIGxlbiA9IGRhdGEub3Iuay5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLm9yLmtbaV0udG8gPSBkYXRhLm9yLmtbaV0udGkgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub3IgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm9yLCAxLCBkZWdUb1JhZHMsIHRoaXMpO1xyXG4gICAgICAgICAgICAvL3NoIEluZGljYXRlcyBpdCBuZWVkcyB0byBiZSBjYXBwZWQgYmV0d2VlbiAtMTgwIGFuZCAxODBcclxuICAgICAgICAgICAgdGhpcy5vci5zaCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGRhdGEuc2spe1xyXG4gICAgICAgICAgICB0aGlzLnNrID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zaywgMCwgZGVnVG9SYWRzLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5zYSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuc2EsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGRhdGEuYSkge1xyXG4gICAgICAgICAgICB0aGlzLmEgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLGRhdGEuYSwxLDAsdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGRhdGEucykge1xyXG4gICAgICAgICAgICB0aGlzLnMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLGRhdGEucywxLDAuMDEsdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE9wYWNpdHkgaXMgbm90IHBhcnQgb2YgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzLCB0aGF0J3Mgd2h5IGl0IHdvbid0IHVzZSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLiBUaGF0IHdheSB0cmFuc2Zvcm1zIHdvbid0IGdldCB1cGRhdGVkIGlmIG9wYWNpdHkgY2hhbmdlcy5cclxuICAgICAgICBpZihkYXRhLm8pe1xyXG4gICAgICAgICAgICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLGRhdGEubywwLDAuMDEsZWxlbSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vID0ge19tZGY6ZmFsc2UsdjoxfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgaWYoIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKXtcclxuICAgICAgICAgICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgVHJhbnNmb3JtUHJvcGVydHkucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGFwcGx5VG9NYXRyaXg6IGFwcGx5VG9NYXRyaXgsXHJcbiAgICAgICAgZ2V0VmFsdWU6IHByb2Nlc3NLZXlzLFxyXG4gICAgICAgIHByZWNhbGN1bGF0ZU1hdHJpeDogcHJlY2FsY3VsYXRlTWF0cml4LFxyXG4gICAgICAgIGF1dG9PcmllbnQ6IGF1dG9PcmllbnRcclxuICAgIH1cclxuXHJcbiAgICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFRyYW5zZm9ybVByb3BlcnR5KTtcclxuICAgIFRyYW5zZm9ybVByb3BlcnR5LnByb3RvdHlwZS5hZGREeW5hbWljUHJvcGVydHkgPSBhZGREeW5hbWljUHJvcGVydHk7XHJcbiAgICBUcmFuc2Zvcm1Qcm9wZXJ0eS5wcm90b3R5cGUuX2FkZER5bmFtaWNQcm9wZXJ0eSA9IER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lci5wcm90b3R5cGUuYWRkRHluYW1pY1Byb3BlcnR5O1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFRyYW5zZm9ybVByb3BlcnR5KGVsZW0sZGF0YSxjb250YWluZXIpe1xyXG4gICAgICAgIHJldHVybiBuZXcgVHJhbnNmb3JtUHJvcGVydHkoZWxlbSxkYXRhLGNvbnRhaW5lcik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXRUcmFuc2Zvcm1Qcm9wZXJ0eTogZ2V0VHJhbnNmb3JtUHJvcGVydHlcclxuICAgIH07XHJcblxyXG59KCkpO1xuZnVuY3Rpb24gU2hhcGVQYXRoKCl7XHJcblx0dGhpcy5jID0gZmFsc2U7XHJcblx0dGhpcy5fbGVuZ3RoID0gMDtcclxuXHR0aGlzLl9tYXhMZW5ndGggPSA4O1xyXG5cdHRoaXMudiA9IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKTtcclxuXHR0aGlzLm8gPSBjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCk7XHJcblx0dGhpcy5pID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpO1xyXG59XHJcblxyXG5TaGFwZVBhdGgucHJvdG90eXBlLnNldFBhdGhEYXRhID0gZnVuY3Rpb24oY2xvc2VkLCBsZW4pIHtcclxuXHR0aGlzLmMgPSBjbG9zZWQ7XHJcblx0dGhpcy5zZXRMZW5ndGgobGVuKTtcclxuXHR2YXIgaSA9IDA7XHJcblx0d2hpbGUoaSA8IGxlbil7XHJcblx0XHR0aGlzLnZbaV0gPSBwb2ludF9wb29sLm5ld0VsZW1lbnQoKTtcclxuXHRcdHRoaXMub1tpXSA9IHBvaW50X3Bvb2wubmV3RWxlbWVudCgpO1xyXG5cdFx0dGhpcy5pW2ldID0gcG9pbnRfcG9vbC5uZXdFbGVtZW50KCk7XHJcblx0XHRpICs9IDE7XHJcblx0fVxyXG59O1xyXG5cclxuU2hhcGVQYXRoLnByb3RvdHlwZS5zZXRMZW5ndGggPSBmdW5jdGlvbihsZW4pIHtcclxuXHR3aGlsZSh0aGlzLl9tYXhMZW5ndGggPCBsZW4pIHtcclxuXHRcdHRoaXMuZG91YmxlQXJyYXlMZW5ndGgoKTtcclxuXHR9XHJcblx0dGhpcy5fbGVuZ3RoID0gbGVuO1xyXG59O1xyXG5cclxuU2hhcGVQYXRoLnByb3RvdHlwZS5kb3VibGVBcnJheUxlbmd0aCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMudiA9IHRoaXMudi5jb25jYXQoY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpKTtcclxuXHR0aGlzLmkgPSB0aGlzLmkuY29uY2F0KGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKSk7XHJcblx0dGhpcy5vID0gdGhpcy5vLmNvbmNhdChjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCkpO1xyXG5cdHRoaXMuX21heExlbmd0aCAqPSAyO1xyXG59O1xyXG5cclxuU2hhcGVQYXRoLnByb3RvdHlwZS5zZXRYWUF0ID0gZnVuY3Rpb24oeCwgeSwgdHlwZSwgcG9zLCByZXBsYWNlKSB7XHJcblx0dmFyIGFycjtcclxuXHR0aGlzLl9sZW5ndGggPSBNYXRoLm1heCh0aGlzLl9sZW5ndGgsIHBvcyArIDEpO1xyXG5cdGlmKHRoaXMuX2xlbmd0aCA+PSB0aGlzLl9tYXhMZW5ndGgpIHtcclxuXHRcdHRoaXMuZG91YmxlQXJyYXlMZW5ndGgoKTtcclxuXHR9XHJcblx0c3dpdGNoKHR5cGUpe1xyXG5cdFx0Y2FzZSAndic6XHJcblx0XHRcdGFyciA9IHRoaXMudjtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlICdpJzpcclxuXHRcdFx0YXJyID0gdGhpcy5pO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ28nOlxyXG5cdFx0XHRhcnIgPSB0aGlzLm87XHJcblx0XHRcdGJyZWFrO1xyXG5cdH1cclxuXHRpZighYXJyW3Bvc10gfHwgKGFycltwb3NdICYmICFyZXBsYWNlKSl7XHJcblx0XHRhcnJbcG9zXSA9IHBvaW50X3Bvb2wubmV3RWxlbWVudCgpO1xyXG5cdH1cclxuXHRhcnJbcG9zXVswXSA9IHg7XHJcblx0YXJyW3Bvc11bMV0gPSB5O1xyXG59O1xyXG5cclxuU2hhcGVQYXRoLnByb3RvdHlwZS5zZXRUcmlwbGVBdCA9IGZ1bmN0aW9uKHZYLHZZLG9YLG9ZLGlYLGlZLHBvcywgcmVwbGFjZSkge1xyXG5cdHRoaXMuc2V0WFlBdCh2WCx2WSwndicscG9zLCByZXBsYWNlKTtcclxuXHR0aGlzLnNldFhZQXQob1gsb1ksJ28nLHBvcywgcmVwbGFjZSk7XHJcblx0dGhpcy5zZXRYWUF0KGlYLGlZLCdpJyxwb3MsIHJlcGxhY2UpO1xyXG59O1xyXG5cclxuU2hhcGVQYXRoLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIG5ld1BhdGggPSBuZXcgU2hhcGVQYXRoKCk7XHJcblx0bmV3UGF0aC5zZXRQYXRoRGF0YSh0aGlzLmMsIHRoaXMuX2xlbmd0aCk7XHJcblx0dmFyIHZlcnRpY2VzID0gdGhpcy52LCBvdXRQb2ludHMgPSB0aGlzLm8sIGluUG9pbnRzID0gdGhpcy5pO1xyXG5cdHZhciBpbml0ID0gMDtcclxuXHRpZiAodGhpcy5jKSB7XHJcblx0XHRuZXdQYXRoLnNldFRyaXBsZUF0KHZlcnRpY2VzWzBdWzBdLCB2ZXJ0aWNlc1swXVsxXSwgaW5Qb2ludHNbMF1bMF0sIGluUG9pbnRzWzBdWzFdLCBvdXRQb2ludHNbMF1bMF0sIG91dFBvaW50c1swXVsxXSwgMCwgZmFsc2UpO1xyXG4gICAgICAgIGluaXQgPSAxO1xyXG4gICAgfVxyXG4gICAgdmFyIGNudCA9IHRoaXMuX2xlbmd0aCAtIDE7XHJcbiAgICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoO1xyXG5cclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpID0gaW5pdDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICBcdG5ld1BhdGguc2V0VHJpcGxlQXQodmVydGljZXNbY250XVswXSwgdmVydGljZXNbY250XVsxXSwgaW5Qb2ludHNbY250XVswXSwgaW5Qb2ludHNbY250XVsxXSwgb3V0UG9pbnRzW2NudF1bMF0sIG91dFBvaW50c1tjbnRdWzFdLCBpLCBmYWxzZSk7XHJcbiAgICAgICAgY250IC09IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3UGF0aDtcclxufTtcbnZhciBTaGFwZVByb3BlcnR5RmFjdG9yeSA9IChmdW5jdGlvbigpe1xyXG5cclxuICAgIHZhciBpbml0RnJhbWUgPSAtOTk5OTk5O1xyXG5cclxuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlU2hhcGUoZnJhbWVOdW0sIHByZXZpb3VzVmFsdWUsIGNhY2hpbmcpIHtcclxuICAgICAgICB2YXIgaXRlcmF0aW9uSW5kZXggPSBjYWNoaW5nLmxhc3RJbmRleDtcclxuICAgICAgICB2YXIga2V5UHJvcFMsa2V5UHJvcEUsaXNIb2xkLCBqLCBrLCBqTGVuLCBrTGVuLCBwZXJjLCB2ZXJ0ZXhWYWx1ZTtcclxuICAgICAgICB2YXIga2YgPSB0aGlzLmtleWZyYW1lcztcclxuICAgICAgICBpZihmcmFtZU51bSA8IGtmWzBdLnQtdGhpcy5vZmZzZXRUaW1lKXtcclxuICAgICAgICAgICAga2V5UHJvcFMgPSBrZlswXS5zWzBdO1xyXG4gICAgICAgICAgICBpc0hvbGQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpdGVyYXRpb25JbmRleCA9IDA7XHJcbiAgICAgICAgfWVsc2UgaWYoZnJhbWVOdW0gPj0ga2Zba2YubGVuZ3RoIC0gMV0udC10aGlzLm9mZnNldFRpbWUpe1xyXG4gICAgICAgICAgICBpZihrZltrZi5sZW5ndGggLSAyXS5oID09PSAxKXtcclxuICAgICAgICAgICAgICAgIGtleVByb3BTID0ga2Zba2YubGVuZ3RoIC0gMV0uc1swXTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBrZXlQcm9wUyA9IGtmW2tmLmxlbmd0aCAtIDJdLmVbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaXNIb2xkID0gdHJ1ZTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdmFyIGkgPSBpdGVyYXRpb25JbmRleDtcclxuICAgICAgICAgICAgdmFyIGxlbiA9IGtmLmxlbmd0aC0gMSxmbGFnID0gdHJ1ZSxrZXlEYXRhLG5leHRLZXlEYXRhO1xyXG4gICAgICAgICAgICB3aGlsZShmbGFnKXtcclxuICAgICAgICAgICAgICAgIGtleURhdGEgPSBrZltpXTtcclxuICAgICAgICAgICAgICAgIG5leHRLZXlEYXRhID0ga2ZbaSsxXTtcclxuICAgICAgICAgICAgICAgIGlmKChuZXh0S2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSA+IGZyYW1lTnVtKXtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKGkgPCBsZW4gLSAxKXtcclxuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaXNIb2xkID0ga2V5RGF0YS5oID09PSAxO1xyXG4gICAgICAgICAgICBpdGVyYXRpb25JbmRleCA9IGk7XHJcbiAgICAgICAgICAgIGlmKCFpc0hvbGQpe1xyXG4gICAgICAgICAgICAgICAgaWYoZnJhbWVOdW0gPj0gbmV4dEtleURhdGEudC10aGlzLm9mZnNldFRpbWUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHBlcmMgPSAxO1xyXG4gICAgICAgICAgICAgICAgfWVsc2UgaWYoZnJhbWVOdW0gPCBrZXlEYXRhLnQtdGhpcy5vZmZzZXRUaW1lKXtcclxuICAgICAgICAgICAgICAgICAgICBwZXJjID0gMDtcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmbmM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoa2V5RGF0YS5fX2ZuY3Qpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmbmMgPSBrZXlEYXRhLl9fZm5jdDtcclxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm5jID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcoa2V5RGF0YS5vLngsa2V5RGF0YS5vLnksa2V5RGF0YS5pLngsa2V5RGF0YS5pLnkpLmdldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5RGF0YS5fX2ZuY3QgPSBmbmM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBlcmMgPSBmbmMoKGZyYW1lTnVtLShrZXlEYXRhLnQtdGhpcy5vZmZzZXRUaW1lKSkvKChuZXh0S2V5RGF0YS50LXRoaXMub2Zmc2V0VGltZSktKGtleURhdGEudC10aGlzLm9mZnNldFRpbWUpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBrZXlQcm9wRSA9IGtleURhdGEuZVswXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBrZXlQcm9wUyA9IGtleURhdGEuc1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgakxlbiA9IHByZXZpb3VzVmFsdWUuX2xlbmd0aDtcclxuICAgICAgICBrTGVuID0ga2V5UHJvcFMuaVswXS5sZW5ndGg7XHJcbiAgICAgICAgY2FjaGluZy5sYXN0SW5kZXggPSBpdGVyYXRpb25JbmRleDtcclxuXHJcbiAgICAgICAgZm9yKGo9MDtqPGpMZW47ais9MSl7XHJcbiAgICAgICAgICAgIGZvcihrPTA7azxrTGVuO2srPTEpe1xyXG4gICAgICAgICAgICAgICAgdmVydGV4VmFsdWUgPSBpc0hvbGQgPyBrZXlQcm9wUy5pW2pdW2tdIDogIGtleVByb3BTLmlbal1ba10rKGtleVByb3BFLmlbal1ba10ta2V5UHJvcFMuaVtqXVtrXSkqcGVyYztcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWUuaVtqXVtrXSA9IHZlcnRleFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4VmFsdWUgPSBpc0hvbGQgPyBrZXlQcm9wUy5vW2pdW2tdIDogIGtleVByb3BTLm9bal1ba10rKGtleVByb3BFLm9bal1ba10ta2V5UHJvcFMub1tqXVtrXSkqcGVyYztcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWUub1tqXVtrXSA9IHZlcnRleFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgdmVydGV4VmFsdWUgPSBpc0hvbGQgPyBrZXlQcm9wUy52W2pdW2tdIDogIGtleVByb3BTLnZbal1ba10rKGtleVByb3BFLnZbal1ba10ta2V5UHJvcFMudltqXVtrXSkqcGVyYztcclxuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWUudltqXVtrXSA9IHZlcnRleFZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlU2hhcGVDdXJyZW50VGltZSgpe1xyXG4gICAgICAgIHZhciBmcmFtZU51bSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lIC0gdGhpcy5vZmZzZXRUaW1lO1xyXG4gICAgICAgIHZhciBpbml0VGltZSA9IHRoaXMua2V5ZnJhbWVzWzBdLnQgLSB0aGlzLm9mZnNldFRpbWU7XHJcbiAgICAgICAgdmFyIGVuZFRpbWUgPSB0aGlzLmtleWZyYW1lc1t0aGlzLmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC0gdGhpcy5vZmZzZXRUaW1lO1xyXG4gICAgICAgIHZhciBsYXN0RnJhbWUgPSB0aGlzLl9jYWNoaW5nLmxhc3RGcmFtZTtcclxuICAgICAgICBpZighKGxhc3RGcmFtZSAhPT0gaW5pdEZyYW1lICYmICgobGFzdEZyYW1lIDwgaW5pdFRpbWUgJiYgZnJhbWVOdW0gPCBpbml0VGltZSkgfHwgKGxhc3RGcmFtZSA+IGVuZFRpbWUgJiYgZnJhbWVOdW0gPiBlbmRUaW1lKSkpKXtcclxuICAgICAgICAgICAgLy8vL1xyXG4gICAgICAgICAgICB0aGlzLl9jYWNoaW5nLmxhc3RJbmRleCA9IGxhc3RGcmFtZSA8IGZyYW1lTnVtID8gdGhpcy5fY2FjaGluZy5sYXN0SW5kZXggOiAwO1xyXG4gICAgICAgICAgICB0aGlzLmludGVycG9sYXRlU2hhcGUoZnJhbWVOdW0sIHRoaXMucHYsIHRoaXMuX2NhY2hpbmcpO1xyXG4gICAgICAgICAgICAvLy8vXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lID0gZnJhbWVOdW07XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHY7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVzZXRTaGFwZSgpe1xyXG4gICAgICAgIHRoaXMucGF0aHMgPSB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNoYXBlc0VxdWFsKHNoYXBlMSwgc2hhcGUyKSB7XHJcbiAgICAgICAgaWYoc2hhcGUxLl9sZW5ndGggIT09IHNoYXBlMi5fbGVuZ3RoIHx8IHNoYXBlMS5jICE9PSBzaGFwZTIuYyl7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGksIGxlbiA9IHNoYXBlMS5fbGVuZ3RoO1xyXG4gICAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmKHNoYXBlMS52W2ldWzBdICE9PSBzaGFwZTIudltpXVswXSB8fCBzaGFwZTEudltpXVsxXSAhPT0gc2hhcGUyLnZbaV1bMV0gfHwgc2hhcGUxLm9baV1bMF0gIT09IHNoYXBlMi5vW2ldWzBdIHx8IHNoYXBlMS5vW2ldWzFdICE9PSBzaGFwZTIub1tpXVsxXSB8fCBzaGFwZTEuaVtpXVswXSAhPT0gc2hhcGUyLmlbaV1bMF0gfHwgc2hhcGUxLmlbaV1bMV0gIT09IHNoYXBlMi5pW2ldWzFdKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlKCkge1xyXG4gICAgICAgIGlmKHRoaXMubG9jayB8fCB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxvY2sgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XHJcbiAgICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGZpbmFsVmFsdWUgPSB0aGlzLmtmID8gdGhpcy5wdiA6IHRoaXMuZGF0YS5rcyA/IHRoaXMuZGF0YS5rcy5rIDogdGhpcy5kYXRhLnB0Lms7XHJcbiAgICAgICAgdmFyIGksIGxlbiA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcclxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5lZmZlY3RzU2VxdWVuY2VbaV0oZmluYWxWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKCFzaGFwZXNFcXVhbCh0aGlzLnYsIGZpbmFsVmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudiA9IHNoYXBlX3Bvb2wuY2xvbmUoZmluYWxWYWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xyXG4gICAgICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uLmFkZFNoYXBlKHRoaXMudik7XHJcbiAgICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aHMgPSB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxvY2sgPSBmYWxzZTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKXtcclxuICAgICAgICB0aGlzLnByb3BUeXBlID0gJ3NoYXBlJztcclxuICAgICAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBlbGVtO1xyXG4gICAgICAgIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLmsgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmtmID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHBhdGhEYXRhID0gdHlwZSA9PT0gMyA/IGRhdGEucHQuayA6IGRhdGEua3MuaztcclxuICAgICAgICB0aGlzLnYgPSBzaGFwZV9wb29sLmNsb25lKHBhdGhEYXRhKTtcclxuICAgICAgICB0aGlzLnB2ID0gc2hhcGVfcG9vbC5jbG9uZSh0aGlzLnYpO1xyXG4gICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZUNvbGxlY3Rpb25fcG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcclxuICAgICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcclxuICAgICAgICB0aGlzLnBhdGhzLmFkZFNoYXBlKHRoaXMudik7XHJcbiAgICAgICAgdGhpcy5yZXNldCA9IHJlc2V0U2hhcGU7XHJcbiAgICAgICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRFZmZlY3QoZWZmZWN0RnVuY3Rpb24pIHtcclxuICAgICAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZS5wdXNoKGVmZmVjdEZ1bmN0aW9uKTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGREeW5hbWljUHJvcGVydHkodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuaW50ZXJwb2xhdGVTaGFwZSA9IGludGVycG9sYXRlU2hhcGU7XHJcbiAgICBTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XHJcbiAgICBTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XHJcbiAgICBTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XHJcblxyXG4gICAgZnVuY3Rpb24gS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eShlbGVtLGRhdGEsdHlwZSl7XHJcbiAgICAgICAgdGhpcy5wcm9wVHlwZSA9ICdzaGFwZSc7XHJcbiAgICAgICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xyXG4gICAgICAgIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBlbGVtO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0VGltZSA9IGVsZW0uZGF0YS5zdDtcclxuICAgICAgICB0aGlzLmtleWZyYW1lcyA9IHR5cGUgPT09IDMgPyBkYXRhLnB0LmsgOiBkYXRhLmtzLms7XHJcbiAgICAgICAgdGhpcy5rID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmtmID0gdHJ1ZTtcclxuICAgICAgICB2YXIgaSwgbGVuID0gdGhpcy5rZXlmcmFtZXNbMF0uc1swXS5pLmxlbmd0aDtcclxuICAgICAgICB2YXIgakxlbiA9IHRoaXMua2V5ZnJhbWVzWzBdLnNbMF0uaVswXS5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy52ID0gc2hhcGVfcG9vbC5uZXdFbGVtZW50KCk7XHJcbiAgICAgICAgdGhpcy52LnNldFBhdGhEYXRhKHRoaXMua2V5ZnJhbWVzWzBdLnNbMF0uYywgbGVuKTtcclxuICAgICAgICB0aGlzLnB2ID0gc2hhcGVfcG9vbC5jbG9uZSh0aGlzLnYpO1xyXG4gICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZUNvbGxlY3Rpb25fcG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcclxuICAgICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcclxuICAgICAgICB0aGlzLnBhdGhzLmFkZFNoYXBlKHRoaXMudik7XHJcbiAgICAgICAgdGhpcy5sYXN0RnJhbWUgPSBpbml0RnJhbWU7XHJcbiAgICAgICAgdGhpcy5yZXNldCA9IHJlc2V0U2hhcGU7XHJcbiAgICAgICAgdGhpcy5fY2FjaGluZyA9IHtsYXN0RnJhbWU6IGluaXRGcmFtZSwgbGFzdEluZGV4OiAwfTtcclxuICAgICAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtpbnRlcnBvbGF0ZVNoYXBlQ3VycmVudFRpbWUuYmluZCh0aGlzKV07XHJcbiAgICB9XHJcbiAgICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XHJcbiAgICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5pbnRlcnBvbGF0ZVNoYXBlID0gaW50ZXJwb2xhdGVTaGFwZTtcclxuICAgIEtleWZyYW1lZFNoYXBlUHJvcGVydHkucHJvdG90eXBlLmFkZEVmZmVjdCA9IGFkZEVmZmVjdDtcclxuXHJcbiAgICB2YXIgRWxsU2hhcGVQcm9wZXJ0eSA9IChmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICB2YXIgY1BvaW50ID0gcm91bmRDb3JuZXI7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIEVsbFNoYXBlUHJvcGVydHkoZWxlbSxkYXRhKSB7XHJcbiAgICAgICAgICAgIC8qdGhpcy52ID0ge1xyXG4gICAgICAgICAgICAgICAgdjogY3JlYXRlU2l6ZWRBcnJheSg0KSxcclxuICAgICAgICAgICAgICAgIGk6IGNyZWF0ZVNpemVkQXJyYXkoNCksXHJcbiAgICAgICAgICAgICAgICBvOiBjcmVhdGVTaXplZEFycmF5KDQpLFxyXG4gICAgICAgICAgICAgICAgYzogdHJ1ZVxyXG4gICAgICAgICAgICB9OyovXHJcbiAgICAgICAgICAgIHRoaXMudiA9IHNoYXBlX3Bvb2wubmV3RWxlbWVudCgpO1xyXG4gICAgICAgICAgICB0aGlzLnYuc2V0UGF0aERhdGEodHJ1ZSwgNCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZUNvbGxlY3Rpb25fcG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5wYXRocyA9IHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICAgICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy52KTtcclxuICAgICAgICAgICAgdGhpcy5kID0gZGF0YS5kO1xyXG4gICAgICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xyXG4gICAgICAgICAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XHJcbiAgICAgICAgICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS5wLDEsMCx0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSxkYXRhLnMsMSwwLHRoaXMpO1xyXG4gICAgICAgICAgICBpZih0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmsgPSB0cnVlO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHRoaXMuayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb252ZXJ0RWxsVG9QYXRoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBFbGxTaGFwZVByb3BlcnR5LnByb3RvdHlwZSA9IHtcclxuICAgICAgICAgICAgcmVzZXQ6IHJlc2V0U2hhcGUsXHJcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoKXtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fbWRmKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnZlcnRFbGxUb1BhdGgoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29udmVydEVsbFRvUGF0aDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcDAgPSB0aGlzLnAudlswXSwgcDEgPSB0aGlzLnAudlsxXSwgczAgPSB0aGlzLnMudlswXS8yLCBzMSA9IHRoaXMucy52WzFdLzI7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2N3ID0gdGhpcy5kICE9PSAzO1xyXG4gICAgICAgICAgICAgICAgdmFyIF92ID0gdGhpcy52O1xyXG4gICAgICAgICAgICAgICAgX3YudlswXVswXSA9IHAwO1xyXG4gICAgICAgICAgICAgICAgX3YudlswXVsxXSA9IHAxIC0gczE7XHJcbiAgICAgICAgICAgICAgICBfdi52WzFdWzBdID0gX2N3ID8gcDAgKyBzMCA6IHAwIC0gczA7XHJcbiAgICAgICAgICAgICAgICBfdi52WzFdWzFdID0gcDE7XHJcbiAgICAgICAgICAgICAgICBfdi52WzJdWzBdID0gcDA7XHJcbiAgICAgICAgICAgICAgICBfdi52WzJdWzFdID0gcDEgKyBzMTtcclxuICAgICAgICAgICAgICAgIF92LnZbM11bMF0gPSBfY3cgPyBwMCAtIHMwIDogcDAgKyBzMDtcclxuICAgICAgICAgICAgICAgIF92LnZbM11bMV0gPSBwMTtcclxuICAgICAgICAgICAgICAgIF92LmlbMF1bMF0gPSBfY3cgPyBwMCAtIHMwICogY1BvaW50IDogcDAgKyBzMCAqIGNQb2ludDtcclxuICAgICAgICAgICAgICAgIF92LmlbMF1bMV0gPSBwMSAtIHMxO1xyXG4gICAgICAgICAgICAgICAgX3YuaVsxXVswXSA9IF9jdyA/IHAwICsgczAgOiBwMCAtIHMwO1xyXG4gICAgICAgICAgICAgICAgX3YuaVsxXVsxXSA9IHAxIC0gczEgKiBjUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICBfdi5pWzJdWzBdID0gX2N3ID8gcDAgKyBzMCAqIGNQb2ludCA6IHAwIC0gczAgKiBjUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICBfdi5pWzJdWzFdID0gcDEgKyBzMTtcclxuICAgICAgICAgICAgICAgIF92LmlbM11bMF0gPSBfY3cgPyBwMCAtIHMwIDogcDAgKyBzMDtcclxuICAgICAgICAgICAgICAgIF92LmlbM11bMV0gPSBwMSArIHMxICogY1BvaW50O1xyXG4gICAgICAgICAgICAgICAgX3Yub1swXVswXSA9IF9jdyA/IHAwICsgczAgKiBjUG9pbnQgOiBwMCAtIHMwICogY1BvaW50O1xyXG4gICAgICAgICAgICAgICAgX3Yub1swXVsxXSA9IHAxIC0gczE7XHJcbiAgICAgICAgICAgICAgICBfdi5vWzFdWzBdID0gX2N3ID8gcDAgKyBzMCA6IHAwIC0gczA7XHJcbiAgICAgICAgICAgICAgICBfdi5vWzFdWzFdID0gcDEgKyBzMSAqIGNQb2ludDtcclxuICAgICAgICAgICAgICAgIF92Lm9bMl1bMF0gPSBfY3cgPyBwMCAtIHMwICogY1BvaW50IDogcDAgKyBzMCAqIGNQb2ludDtcclxuICAgICAgICAgICAgICAgIF92Lm9bMl1bMV0gPSBwMSArIHMxO1xyXG4gICAgICAgICAgICAgICAgX3Yub1szXVswXSA9IF9jdyA/IHAwIC0gczAgOiBwMCArIHMwO1xyXG4gICAgICAgICAgICAgICAgX3Yub1szXVsxXSA9IHAxIC0gczEgKiBjUG9pbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgRWxsU2hhcGVQcm9wZXJ0eSk7XHJcblxyXG4gICAgICAgIHJldHVybiBFbGxTaGFwZVByb3BlcnR5O1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICB2YXIgU3RhclNoYXBlUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIFN0YXJTaGFwZVByb3BlcnR5KGVsZW0sZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLnYgPSBzaGFwZV9wb29sLm5ld0VsZW1lbnQoKTtcclxuICAgICAgICAgICAgdGhpcy52LnNldFBhdGhEYXRhKHRydWUsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xyXG4gICAgICAgICAgICB0aGlzLmQgPSBkYXRhLmQ7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcclxuICAgICAgICAgICAgaWYoZGF0YS5zeSA9PT0gMSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlyID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSxkYXRhLmlyLDAsMCx0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLGRhdGEuaXMsMCwwLjAxLHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb252ZXJ0VG9QYXRoID0gdGhpcy5jb252ZXJ0U3RhclRvUGF0aDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udmVydFRvUGF0aCA9IHRoaXMuY29udmVydFBvbHlnb25Ub1BhdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wdCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS5wdCwwLDAsdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS5wLDEsMCx0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5yID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSxkYXRhLnIsMCxkZWdUb1JhZHMsdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMub3IgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLGRhdGEub3IsMCwwLHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLm9zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSxkYXRhLm9zLDAsMC4wMSx0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlQ29sbGVjdGlvbl9wb29sLm5ld1NoYXBlQ29sbGVjdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uLmFkZFNoYXBlKHRoaXMudik7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aHMgPSB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xyXG4gICAgICAgICAgICBpZih0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmsgPSB0cnVlO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHRoaXMuayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb252ZXJ0VG9QYXRoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBTdGFyU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgICAgIHJlc2V0OiByZXNldFNoYXBlLFxyXG4gICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fbWRmKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnZlcnRUb1BhdGgoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29udmVydFN0YXJUb1BhdGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG51bVB0cyA9IE1hdGguZmxvb3IodGhpcy5wdC52KSoyO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5QSSoyL251bVB0cztcclxuICAgICAgICAgICAgICAgIC8qdGhpcy52LnYubGVuZ3RoID0gbnVtUHRzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52LmkubGVuZ3RoID0gbnVtUHRzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52Lm8ubGVuZ3RoID0gbnVtUHRzOyovXHJcbiAgICAgICAgICAgICAgICB2YXIgbG9uZ0ZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxvbmdSYWQgPSB0aGlzLm9yLnY7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hvcnRSYWQgPSB0aGlzLmlyLnY7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9uZ1JvdW5kID0gdGhpcy5vcy52O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNob3J0Um91bmQgPSB0aGlzLmlzLnY7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9uZ1BlcmltU2VnbWVudCA9IDIqTWF0aC5QSSpsb25nUmFkLyhudW1QdHMqMik7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hvcnRQZXJpbVNlZ21lbnQgPSAyKk1hdGguUEkqc2hvcnRSYWQvKG51bVB0cyoyKTtcclxuICAgICAgICAgICAgICAgIHZhciBpLCByYWQscm91bmRuZXNzLHBlcmltU2VnbWVudCwgY3VycmVudEFuZyA9IC1NYXRoLlBJLyAyO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFuZyArPSB0aGlzLnIudjtcclxuICAgICAgICAgICAgICAgIHZhciBkaXIgPSB0aGlzLmRhdGEuZCA9PT0gMyA/IC0xIDogMTtcclxuICAgICAgICAgICAgICAgIHRoaXMudi5fbGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIGZvcihpPTA7aTxudW1QdHM7aSs9MSl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFkID0gbG9uZ0ZsYWcgPyBsb25nUmFkIDogc2hvcnRSYWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcm91bmRuZXNzID0gbG9uZ0ZsYWcgPyBsb25nUm91bmQgOiBzaG9ydFJvdW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIHBlcmltU2VnbWVudCA9IGxvbmdGbGFnID8gbG9uZ1BlcmltU2VnbWVudCA6IHNob3J0UGVyaW1TZWdtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB4ID0gcmFkICogTWF0aC5jb3MoY3VycmVudEFuZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkgPSByYWQgKiBNYXRoLnNpbihjdXJyZW50QW5nKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3ggPSB4ID09PSAwICYmIHkgPT09IDAgPyAwIDogeS9NYXRoLnNxcnQoeCp4ICsgeSp5KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3kgPSB4ID09PSAwICYmIHkgPT09IDAgPyAwIDogLXgvTWF0aC5zcXJ0KHgqeCArIHkqeSk7XHJcbiAgICAgICAgICAgICAgICAgICAgeCArPSAgKyB0aGlzLnAudlswXTtcclxuICAgICAgICAgICAgICAgICAgICB5ICs9ICArIHRoaXMucC52WzFdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdCh4LHkseC1veCpwZXJpbVNlZ21lbnQqcm91bmRuZXNzKmRpcix5LW95KnBlcmltU2VnbWVudCpyb3VuZG5lc3MqZGlyLHgrb3gqcGVyaW1TZWdtZW50KnJvdW5kbmVzcypkaXIseStveSpwZXJpbVNlZ21lbnQqcm91bmRuZXNzKmRpciwgaSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qdGhpcy52LnZbaV0gPSBbeCx5XTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnYuaVtpXSA9IFt4K294KnBlcmltU2VnbWVudCpyb3VuZG5lc3MqZGlyLHkrb3kqcGVyaW1TZWdtZW50KnJvdW5kbmVzcypkaXJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudi5vW2ldID0gW3gtb3gqcGVyaW1TZWdtZW50KnJvdW5kbmVzcypkaXIseS1veSpwZXJpbVNlZ21lbnQqcm91bmRuZXNzKmRpcl07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52Ll9sZW5ndGggPSBudW1QdHM7Ki9cclxuICAgICAgICAgICAgICAgICAgICBsb25nRmxhZyA9ICFsb25nRmxhZztcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QW5nICs9IGFuZ2xlKmRpcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29udmVydFBvbHlnb25Ub1BhdGg6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG51bVB0cyA9IE1hdGguZmxvb3IodGhpcy5wdC52KTtcclxuICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguUEkqMi9udW1QdHM7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmFkID0gdGhpcy5vci52O1xyXG4gICAgICAgICAgICAgICAgdmFyIHJvdW5kbmVzcyA9IHRoaXMub3MudjtcclxuICAgICAgICAgICAgICAgIHZhciBwZXJpbVNlZ21lbnQgPSAyKk1hdGguUEkqcmFkLyhudW1QdHMqNCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSwgY3VycmVudEFuZyA9IC1NYXRoLlBJLyAyO1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpciA9IHRoaXMuZGF0YS5kID09PSAzID8gLTEgOiAxO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEFuZyArPSB0aGlzLnIudjtcclxuICAgICAgICAgICAgICAgIHRoaXMudi5fbGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIGZvcihpPTA7aTxudW1QdHM7aSs9MSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSByYWQgKiBNYXRoLmNvcyhjdXJyZW50QW5nKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IHJhZCAqIE1hdGguc2luKGN1cnJlbnRBbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBveCA9IHggPT09IDAgJiYgeSA9PT0gMCA/IDAgOiB5L01hdGguc3FydCh4KnggKyB5KnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBveSA9IHggPT09IDAgJiYgeSA9PT0gMCA/IDAgOiAteC9NYXRoLnNxcnQoeCp4ICsgeSp5KTtcclxuICAgICAgICAgICAgICAgICAgICB4ICs9ICArIHRoaXMucC52WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgKz0gICsgdGhpcy5wLnZbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHgseSx4LW94KnBlcmltU2VnbWVudCpyb3VuZG5lc3MqZGlyLHktb3kqcGVyaW1TZWdtZW50KnJvdW5kbmVzcypkaXIseCtveCpwZXJpbVNlZ21lbnQqcm91bmRuZXNzKmRpcix5K295KnBlcmltU2VnbWVudCpyb3VuZG5lc3MqZGlyLCBpLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QW5nICs9IGFuZ2xlKmRpcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucGF0aHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMucGF0aHNbMF0gPSB0aGlzLnY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU3RhclNoYXBlUHJvcGVydHkpO1xyXG5cclxuICAgICAgICByZXR1cm4gU3RhclNoYXBlUHJvcGVydHk7XHJcbiAgICB9KCkpO1xyXG5cclxuICAgIHZhciBSZWN0U2hhcGVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgIGZ1bmN0aW9uIFJlY3RTaGFwZVByb3BlcnR5KGVsZW0sZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzLnYgPSBzaGFwZV9wb29sLm5ld0VsZW1lbnQoKTtcclxuICAgICAgICAgICAgdGhpcy52LmMgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVDb2xsZWN0aW9uX3Bvb2wubmV3U2hhcGVDb2xsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy52KTtcclxuICAgICAgICAgICAgdGhpcy5wYXRocyA9IHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgICAgICAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcclxuICAgICAgICAgICAgdGhpcy5mcmFtZUlkID0gLTE7XHJcbiAgICAgICAgICAgIHRoaXMuZCA9IGRhdGEuZDtcclxuICAgICAgICAgICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xyXG4gICAgICAgICAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLGRhdGEucCwxLDAsdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS5zLDEsMCx0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5yID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSxkYXRhLnIsMCwwLHRoaXMpO1xyXG4gICAgICAgICAgICBpZih0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmsgPSB0cnVlO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHRoaXMuayA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb252ZXJ0UmVjdFRvUGF0aCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgUmVjdFNoYXBlUHJvcGVydHkucHJvdG90eXBlID0ge1xyXG4gICAgICAgICAgICBjb252ZXJ0UmVjdFRvUGF0aDogZnVuY3Rpb24gKCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgcDAgPSB0aGlzLnAudlswXSwgcDEgPSB0aGlzLnAudlsxXSwgdjAgPSB0aGlzLnMudlswXS8yLCB2MSA9IHRoaXMucy52WzFdLzI7XHJcbiAgICAgICAgICAgICAgICB2YXIgcm91bmQgPSBibV9taW4odjAsdjEsdGhpcy5yLnYpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNQb2ludCA9IHJvdW5kKigxLXJvdW5kQ29ybmVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudi5fbGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmQgPT09IDIgfHwgdGhpcy5kID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwK3YwLCBwMS12MStyb3VuZCxwMCt2MCwgcDEtdjErcm91bmQscDArdjAscDEtdjErY1BvaW50LDAsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCt2MCwgcDErdjEtcm91bmQscDArdjAsIHAxK3YxLWNQb2ludCxwMCt2MCwgcDErdjEtcm91bmQsMSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYocm91bmQhPT0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCt2MC1yb3VuZCwgcDErdjEscDArdjAtcm91bmQscDErdjEscDArdjAtY1BvaW50LHAxK3YxLDIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAtdjArcm91bmQscDErdjEscDAtdjArY1BvaW50LHAxK3YxLHAwLXYwK3JvdW5kLHAxK3YxLDMsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAtdjAscDErdjEtcm91bmQscDAtdjAscDErdjEtcm91bmQscDAtdjAscDErdjEtY1BvaW50LDQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAtdjAscDEtdjErcm91bmQscDAtdjAscDEtdjErY1BvaW50LHAwLXYwLHAxLXYxK3JvdW5kLDUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAtdjArcm91bmQscDEtdjEscDAtdjArcm91bmQscDEtdjEscDAtdjArY1BvaW50LHAxLXYxLDYsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDArdjAtcm91bmQscDEtdjEscDArdjAtY1BvaW50LHAxLXYxLHAwK3YwLXJvdW5kLHAxLXYxLDcsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMC12MCxwMSt2MSxwMC12MCtjUG9pbnQscDErdjEscDAtdjAscDErdjEsMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMC12MCxwMS12MSxwMC12MCxwMS12MStjUG9pbnQscDAtdjAscDEtdjEsMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwK3YwLHAxLXYxK3JvdW5kLHAwK3YwLHAxLXYxK2NQb2ludCxwMCt2MCxwMS12MStyb3VuZCwwLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihyb3VuZCE9PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwK3YwLXJvdW5kLHAxLXYxLHAwK3YwLXJvdW5kLHAxLXYxLHAwK3YwLWNQb2ludCxwMS12MSwxLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwLXYwK3JvdW5kLHAxLXYxLHAwLXYwK2NQb2ludCxwMS12MSxwMC12MCtyb3VuZCxwMS12MSwyLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwLXYwLHAxLXYxK3JvdW5kLHAwLXYwLHAxLXYxK3JvdW5kLHAwLXYwLHAxLXYxK2NQb2ludCwzLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwLXYwLHAxK3YxLXJvdW5kLHAwLXYwLHAxK3YxLWNQb2ludCxwMC12MCxwMSt2MS1yb3VuZCw0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwLXYwK3JvdW5kLHAxK3YxLHAwLXYwK3JvdW5kLHAxK3YxLHAwLXYwK2NQb2ludCxwMSt2MSw1LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwK3YwLXJvdW5kLHAxK3YxLHAwK3YwLWNQb2ludCxwMSt2MSxwMCt2MC1yb3VuZCxwMSt2MSw2LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwK3YwLHAxK3YxLXJvdW5kLHAwK3YwLHAxK3YxLXJvdW5kLHAwK3YwLHAxK3YxLWNQb2ludCw3LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAtdjAscDEtdjEscDAtdjArY1BvaW50LHAxLXYxLHAwLXYwLHAxLXYxLDEsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAtdjAscDErdjEscDAtdjAscDErdjEtY1BvaW50LHAwLXYwLHAxK3YxLDIsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDArdjAscDErdjEscDArdjAtY1BvaW50LHAxK3YxLHAwK3YwLHAxK3YxLDMsIHRydWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihmcmFtZU51bSl7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fbWRmKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnZlcnRSZWN0VG9QYXRoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICByZXNldDogcmVzZXRTaGFwZVxyXG4gICAgICAgIH1cclxuICAgICAgICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFJlY3RTaGFwZVByb3BlcnR5KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIFJlY3RTaGFwZVByb3BlcnR5O1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTaGFwZVByb3AoZWxlbSxkYXRhLHR5cGUpe1xyXG4gICAgICAgIHZhciBwcm9wO1xyXG4gICAgICAgIGlmKHR5cGUgPT09IDMgfHwgdHlwZSA9PT0gNCl7XHJcbiAgICAgICAgICAgIHZhciBkYXRhUHJvcCA9IHR5cGUgPT09IDMgPyBkYXRhLnB0IDogZGF0YS5rcztcclxuICAgICAgICAgICAgdmFyIGtleXMgPSBkYXRhUHJvcC5rO1xyXG4gICAgICAgICAgICBpZihkYXRhUHJvcC5hID09PSAxIHx8IGtleXMubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgIHByb3AgPSBuZXcgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBwcm9wID0gbmV3IFNoYXBlUHJvcGVydHkoZWxlbSwgZGF0YSwgdHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZSBpZih0eXBlID09PSA1KXtcclxuICAgICAgICAgICAgcHJvcCA9IG5ldyBSZWN0U2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhKTtcclxuICAgICAgICB9ZWxzZSBpZih0eXBlID09PSA2KXtcclxuICAgICAgICAgICAgcHJvcCA9IG5ldyBFbGxTaGFwZVByb3BlcnR5KGVsZW0sIGRhdGEpO1xyXG4gICAgICAgIH1lbHNlIGlmKHR5cGUgPT09IDcpe1xyXG4gICAgICAgICAgICBwcm9wID0gbmV3IFN0YXJTaGFwZVByb3BlcnR5KGVsZW0sIGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihwcm9wLmspe1xyXG4gICAgICAgICAgICBlbGVtLmFkZER5bmFtaWNQcm9wZXJ0eShwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb3A7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0Q29uc3RydWN0b3JGdW5jdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gU2hhcGVQcm9wZXJ0eTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRLZXlmcmFtZWRDb25zdHJ1Y3RvckZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBLZXlmcmFtZWRTaGFwZVByb3BlcnR5O1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBvYiA9IHt9O1xyXG4gICAgb2IuZ2V0U2hhcGVQcm9wID0gZ2V0U2hhcGVQcm9wO1xyXG4gICAgb2IuZ2V0Q29uc3RydWN0b3JGdW5jdGlvbiA9IGdldENvbnN0cnVjdG9yRnVuY3Rpb247XHJcbiAgICBvYi5nZXRLZXlmcmFtZWRDb25zdHJ1Y3RvckZ1bmN0aW9uID0gZ2V0S2V5ZnJhbWVkQ29uc3RydWN0b3JGdW5jdGlvbjtcclxuICAgIHJldHVybiBvYjtcclxufSgpKTtcbnZhciBTaGFwZU1vZGlmaWVycyA9IChmdW5jdGlvbigpe1xyXG4gICAgdmFyIG9iID0ge307XHJcbiAgICB2YXIgbW9kaWZpZXJzID0ge307XHJcbiAgICBvYi5yZWdpc3Rlck1vZGlmaWVyID0gcmVnaXN0ZXJNb2RpZmllcjtcclxuICAgIG9iLmdldE1vZGlmaWVyID0gZ2V0TW9kaWZpZXI7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJNb2RpZmllcihubSxmYWN0b3J5KXtcclxuICAgICAgICBpZighbW9kaWZpZXJzW25tXSl7XHJcbiAgICAgICAgICAgIG1vZGlmaWVyc1tubV0gPSBmYWN0b3J5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRNb2RpZmllcihubSxlbGVtLCBkYXRhKXtcclxuICAgICAgICByZXR1cm4gbmV3IG1vZGlmaWVyc1tubV0oZWxlbSwgZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG9iO1xyXG59KCkpO1xyXG5cclxuZnVuY3Rpb24gU2hhcGVNb2RpZmllcigpe31cclxuU2hhcGVNb2RpZmllci5wcm90b3R5cGUuaW5pdE1vZGlmaWVyUHJvcGVydGllcyA9IGZ1bmN0aW9uKCl7fTtcclxuU2hhcGVNb2RpZmllci5wcm90b3R5cGUuYWRkU2hhcGVUb01vZGlmaWVyID0gZnVuY3Rpb24oKXt9O1xyXG5TaGFwZU1vZGlmaWVyLnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgaWYoIXRoaXMuY2xvc2VkKXtcclxuICAgICAgICB2YXIgc2hhcGVEYXRhID0ge3NoYXBlOmRhdGEuc2gsIGRhdGE6IGRhdGEsIGxvY2FsU2hhcGVDb2xsZWN0aW9uOnNoYXBlQ29sbGVjdGlvbl9wb29sLm5ld1NoYXBlQ29sbGVjdGlvbigpfTtcclxuICAgICAgICB0aGlzLnNoYXBlcy5wdXNoKHNoYXBlRGF0YSk7XHJcbiAgICAgICAgdGhpcy5hZGRTaGFwZVRvTW9kaWZpZXIoc2hhcGVEYXRhKTtcclxuICAgICAgICBpZih0aGlzLl9pc0FuaW1hdGVkKSB7XHJcbiAgICAgICAgICAgIGRhdGEuc2V0QXNBbmltYXRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuU2hhcGVNb2RpZmllci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGVsZW0sZGF0YSl7XHJcbiAgICB0aGlzLnNoYXBlcyA9IFtdO1xyXG4gICAgdGhpcy5lbGVtID0gZWxlbTtcclxuICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcclxuICAgIHRoaXMuaW5pdE1vZGlmaWVyUHJvcGVydGllcyhlbGVtLGRhdGEpO1xyXG4gICAgdGhpcy5mcmFtZUlkID0gaW5pdGlhbERlZmF1bHRGcmFtZTtcclxuICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLmsgPSBmYWxzZTtcclxuICAgIGlmKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKXtcclxuICAgICAgICB0aGlzLmsgPSB0cnVlO1xyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcclxuICAgIH1cclxufTtcclxuU2hhcGVNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc0tleXMgPSBmdW5jdGlvbigpe1xyXG4gICAgaWYodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkKXtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xyXG4gICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcclxufTtcclxuXHJcbmV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU2hhcGVNb2RpZmllcik7XG5mdW5jdGlvbiBUcmltTW9kaWZpZXIoKXtcclxufVxyXG5leHRlbmRQcm90b3R5cGUoW1NoYXBlTW9kaWZpZXJdLCBUcmltTW9kaWZpZXIpO1xyXG5UcmltTW9kaWZpZXIucHJvdG90eXBlLmluaXRNb2RpZmllclByb3BlcnRpZXMgPSBmdW5jdGlvbihlbGVtLCBkYXRhKSB7XHJcbiAgICB0aGlzLnMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnMsIDAsIDAuMDEsIHRoaXMpO1xyXG4gICAgdGhpcy5lID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5lLCAwLCAwLjAxLCB0aGlzKTtcclxuICAgIHRoaXMubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubywgMCwgMCwgdGhpcyk7XHJcbiAgICB0aGlzLnNWYWx1ZSA9IDA7XHJcbiAgICB0aGlzLmVWYWx1ZSA9IDA7XHJcbiAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5wcm9jZXNzS2V5cztcclxuICAgIHRoaXMubSA9IGRhdGEubTtcclxuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMucy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoIHx8ICEhdGhpcy5lLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggfHwgISF0aGlzLm8uZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcclxufTtcclxuXHJcblRyaW1Nb2RpZmllci5wcm90b3R5cGUuYWRkU2hhcGVUb01vZGlmaWVyID0gZnVuY3Rpb24oc2hhcGVEYXRhKXtcclxuICAgIHNoYXBlRGF0YS5wYXRoc0RhdGEgPSBbXTtcclxufTtcclxuXHJcblRyaW1Nb2RpZmllci5wcm90b3R5cGUuY2FsY3VsYXRlU2hhcGVFZGdlcyA9IGZ1bmN0aW9uKHMsIGUsIHNoYXBlTGVuZ3RoLCBhZGRlZExlbmd0aCwgdG90YWxNb2RpZmllckxlbmd0aCkge1xyXG4gICAgdmFyIHNlZ21lbnRzID0gW107XHJcbiAgICBpZiAoZSA8PSAxKSB7XHJcbiAgICAgICAgc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgIHM6IHMsXHJcbiAgICAgICAgICAgIGU6IGVcclxuICAgICAgICB9KTtcclxuICAgIH0gZWxzZSBpZiAocyA+PSAxKSB7XHJcbiAgICAgICAgc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgIHM6IHMgLSAxLFxyXG4gICAgICAgICAgICBlOiBlIC0gMVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBzZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgczogcyxcclxuICAgICAgICAgICAgZTogMVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNlZ21lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICBzOiAwLFxyXG4gICAgICAgICAgICBlOiBlIC0gMVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgdmFyIHNoYXBlU2VnbWVudHMgPSBbXTtcclxuICAgIHZhciBpLCBsZW4gPSBzZWdtZW50cy5sZW5ndGgsIHNlZ21lbnRPYjtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgIHNlZ21lbnRPYiA9IHNlZ21lbnRzW2ldO1xyXG4gICAgICAgIGlmIChzZWdtZW50T2IuZSAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPCBhZGRlZExlbmd0aCB8fCBzZWdtZW50T2IucyAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPiBhZGRlZExlbmd0aCArIHNoYXBlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZVMsIHNoYXBlRTtcclxuICAgICAgICAgICAgaWYgKHNlZ21lbnRPYi5zICogdG90YWxNb2RpZmllckxlbmd0aCA8PSBhZGRlZExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgc2hhcGVTID0gMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNoYXBlUyA9IChzZWdtZW50T2IucyAqIHRvdGFsTW9kaWZpZXJMZW5ndGggLSBhZGRlZExlbmd0aCkgLyBzaGFwZUxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihzZWdtZW50T2IuZSAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPj0gYWRkZWRMZW5ndGggKyBzaGFwZUxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgc2hhcGVFID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNoYXBlRSA9ICgoc2VnbWVudE9iLmUgKiB0b3RhbE1vZGlmaWVyTGVuZ3RoIC0gYWRkZWRMZW5ndGgpIC8gc2hhcGVMZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNoYXBlU2VnbWVudHMucHVzaChbc2hhcGVTLCBzaGFwZUVdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIXNoYXBlU2VnbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgc2hhcGVTZWdtZW50cy5wdXNoKFswLCAwXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2hhcGVTZWdtZW50cztcclxufTtcclxuXHJcblRyaW1Nb2RpZmllci5wcm90b3R5cGUucmVsZWFzZVBhdGhzRGF0YSA9IGZ1bmN0aW9uKHBhdGhzRGF0YSkge1xyXG4gICAgdmFyIGksIGxlbiA9IHBhdGhzRGF0YS5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBzZWdtZW50c19sZW5ndGhfcG9vbC5yZWxlYXNlKHBhdGhzRGF0YVtpXSk7XHJcbiAgICB9XHJcbiAgICBwYXRoc0RhdGEubGVuZ3RoID0gMDtcclxuICAgIHJldHVybiBwYXRoc0RhdGE7XHJcbn07XHJcblxyXG5UcmltTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NTaGFwZXMgPSBmdW5jdGlvbihfaXNGaXJzdEZyYW1lKSB7XHJcbiAgICB2YXIgcywgZTtcclxuICAgIGlmICh0aGlzLl9tZGYgfHwgX2lzRmlyc3RGcmFtZSkge1xyXG4gICAgICAgIHZhciBvID0gKHRoaXMuby52ICUgMzYwKSAvIDM2MDtcclxuICAgICAgICBpZiAobyA8IDApIHtcclxuICAgICAgICAgICAgbyArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzID0gdGhpcy5zLnYgKyBvO1xyXG4gICAgICAgIGUgPSB0aGlzLmUudiArIG87XHJcbiAgICAgICAgaWYgKHMgPT09IGUpIHtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzID4gZSkge1xyXG4gICAgICAgICAgICB2YXIgX3MgPSBzO1xyXG4gICAgICAgICAgICBzID0gZTtcclxuICAgICAgICAgICAgZSA9IF9zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzID0gTWF0aC5yb3VuZChzKjEwMDApLzEwMDA7XHJcbiAgICAgICAgZSA9IE1hdGgucm91bmQoZSoxMDAwKS8xMDAwO1xyXG4gICAgICAgIHRoaXMuc1ZhbHVlID0gcztcclxuICAgICAgICB0aGlzLmVWYWx1ZSA9IGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHMgPSB0aGlzLnNWYWx1ZTtcclxuICAgICAgICBlID0gdGhpcy5lVmFsdWU7XHJcbiAgICB9XHJcbiAgICB2YXIgc2hhcGVQYXRocztcclxuICAgIHZhciBpLCBsZW4gPSB0aGlzLnNoYXBlcy5sZW5ndGgsIGosIGpMZW47XHJcbiAgICB2YXIgcGF0aHNEYXRhLCBwYXRoRGF0YSwgdG90YWxTaGFwZUxlbmd0aCwgdG90YWxNb2RpZmllckxlbmd0aCA9IDA7XHJcblxyXG4gICAgaWYgKGUgPT09IHMpIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFwZXNbaV0ubG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xyXG4gICAgICAgICAgICB0aGlzLnNoYXBlc1tpXS5zaGFwZS5fbWRmID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zaGFwZXNbaV0uc2hhcGUucGF0aHMgPSB0aGlzLnNoYXBlc1tpXS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKCEoKGUgPT09IDEgJiYgcyA9PT0gMCkgfHwgKGU9PT0wICYmIHMgPT09IDEpKSl7XHJcbiAgICAgICAgdmFyIHNlZ21lbnRzID0gW10sIHNoYXBlRGF0YSwgbG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIHNoYXBlRGF0YSA9IHRoaXMuc2hhcGVzW2ldO1xyXG4gICAgICAgICAgICAvLyBpZiBzaGFwZSBoYXNuJ3QgY2hhbmdlZCBhbmQgdHJpbSBwcm9wZXJ0aWVzIGhhdmVuJ3QgY2hhbmdlZCwgY2FjaGVkIHByZXZpb3VzIHBhdGggY2FuIGJlIHVzZWRcclxuICAgICAgICAgICAgaWYgKCFzaGFwZURhdGEuc2hhcGUuX21kZiAmJiAhdGhpcy5fbWRmICYmICFfaXNGaXJzdEZyYW1lICYmIHRoaXMubSAhPT0gMikge1xyXG4gICAgICAgICAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2hhcGVQYXRocyA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocztcclxuICAgICAgICAgICAgICAgIGpMZW4gPSBzaGFwZVBhdGhzLl9sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB0b3RhbFNoYXBlTGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICghc2hhcGVEYXRhLnNoYXBlLl9tZGYgJiYgc2hhcGVEYXRhLnBhdGhzRGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbFNoYXBlTGVuZ3RoID0gc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhdGhzRGF0YSA9IHRoaXMucmVsZWFzZVBhdGhzRGF0YShzaGFwZURhdGEucGF0aHNEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhEYXRhID0gYmV6LmdldFNlZ21lbnRzTGVuZ3RoKHNoYXBlUGF0aHMuc2hhcGVzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aHNEYXRhLnB1c2gocGF0aERhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbFNoYXBlTGVuZ3RoICs9IHBhdGhEYXRhLnRvdGFsTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCA9IHRvdGFsU2hhcGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVEYXRhLnBhdGhzRGF0YSA9IHBhdGhzRGF0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB0b3RhbE1vZGlmaWVyTGVuZ3RoICs9IHRvdGFsU2hhcGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBzaGFwZURhdGEuc2hhcGUuX21kZiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNoYXBlUyA9IHMsIHNoYXBlRSA9IGUsIGFkZGVkTGVuZ3RoID0gMCwgZWRnZXM7XHJcbiAgICAgICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcclxuICAgICAgICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07XHJcbiAgICAgICAgICAgIGlmIChzaGFwZURhdGEuc2hhcGUuX21kZikge1xyXG4gICAgICAgICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZURhdGEubG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICAgICAgICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5yZWxlYXNlU2hhcGVzKCk7XHJcbiAgICAgICAgICAgICAgICAvL2lmIG0gPT09IDIgbWVhbnMgcGF0aHMgYXJlIHRyaW1tZWQgaW5kaXZpZHVhbGx5IHNvIGVkZ2VzIG5lZWQgdG8gYmUgZm91bmQgZm9yIHRoaXMgc3BlY2lmaWMgc2hhcGUgcmVsYXRpdmUgdG8gd2hvZWwgZ3JvdXBcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm0gPT09IDIgJiYgbGVuID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzID0gdGhpcy5jYWxjdWxhdGVTaGFwZUVkZ2VzKHMsIGUsIHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoLCBhZGRlZExlbmd0aCwgdG90YWxNb2RpZmllckxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRMZW5ndGggKz0gc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VzID0gW1tzaGFwZVMsIHNoYXBlRV1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgakxlbiA9IGVkZ2VzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZVMgPSBlZGdlc1tqXVswXTtcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZUUgPSBlZGdlc1tqXVsxXTtcclxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaGFwZUUgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6c2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGggKiBzaGFwZVMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlOnNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogc2hhcGVFXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGVTID49IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzOnNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogKHNoYXBlUyAtIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZTpzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aCAqIChzaGFwZUUgLSAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6c2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGggKiBzaGFwZVMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlOnNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50cy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM6MCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGU6c2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGggKiAoc2hhcGVFIC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdTaGFwZXNEYXRhID0gdGhpcy5hZGRTaGFwZXMoc2hhcGVEYXRhLHNlZ21lbnRzWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudHNbMF0ucyAhPT0gc2VnbWVudHNbMF0uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RTaGFwZUluQ29sbGVjdGlvbiA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5zaGFwZXNbc2hhcGVEYXRhLnNoYXBlLnBhdGhzLl9sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0U2hhcGVJbkNvbGxlY3Rpb24uYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0U2hhcGUgPSBuZXdTaGFwZXNEYXRhLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUGF0aHMobmV3U2hhcGVzRGF0YSwgbG9jYWxTaGFwZUNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NoYXBlc0RhdGEgPSB0aGlzLmFkZFNoYXBlcyhzaGFwZURhdGEsIHNlZ21lbnRzWzFdLCBsYXN0U2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFBhdGhzKG5ld1NoYXBlc0RhdGEsIGxvY2FsU2hhcGVDb2xsZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTaGFwZXNEYXRhID0gdGhpcy5hZGRTaGFwZXMoc2hhcGVEYXRhLCBzZWdtZW50c1sxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUGF0aHMobmV3U2hhcGVzRGF0YSwgbG9jYWxTaGFwZUNvbGxlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHNoYXBlRGF0YS5zaGFwZS5wYXRocyA9IGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0aGlzLl9tZGYpIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgLy9SZWxlYXNpZ24gVHJpbSBDYWNoZWQgcGF0aHMgZGF0YSB3aGVuIG5vIHRyaW0gYXBwbGllZCBpbiBjYXNlIHNoYXBlcyBhcmUgbW9kaWZpZWQgaW5iZXR3ZWVuLlxyXG4gICAgICAgICAgICAvL0Rvbid0IHJlbW92ZSB0aGlzIGV2ZW4gaWYgaXQncyBsb3NpbmcgY2FjaGVkIGluZm8uXHJcbiAgICAgICAgICAgIHRoaXMuc2hhcGVzW2ldLnBhdGhzRGF0YS5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnNoYXBlc1tpXS5zaGFwZS5fbWRmID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5UcmltTW9kaWZpZXIucHJvdG90eXBlLmFkZFBhdGhzID0gZnVuY3Rpb24obmV3UGF0aHMsIGxvY2FsU2hhcGVDb2xsZWN0aW9uKSB7XHJcbiAgICB2YXIgaSwgbGVuID0gbmV3UGF0aHMubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUobmV3UGF0aHNbaV0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5hZGRTZWdtZW50ID0gZnVuY3Rpb24ocHQxLCBwdDIsIHB0MywgcHQ0LCBzaGFwZVBhdGgsIHBvcywgbmV3U2hhcGUpIHtcclxuICAgIHNoYXBlUGF0aC5zZXRYWUF0KHB0MlswXSwgcHQyWzFdLCAnbycsIHBvcyk7XHJcbiAgICBzaGFwZVBhdGguc2V0WFlBdChwdDNbMF0sIHB0M1sxXSwgJ2knLCBwb3MgKyAxKTtcclxuICAgIGlmKG5ld1NoYXBlKXtcclxuICAgICAgICBzaGFwZVBhdGguc2V0WFlBdChwdDFbMF0sIHB0MVsxXSwgJ3YnLCBwb3MpO1xyXG4gICAgfVxyXG4gICAgc2hhcGVQYXRoLnNldFhZQXQocHQ0WzBdLCBwdDRbMV0sICd2JywgcG9zICsgMSk7XHJcbn07XHJcblxyXG5UcmltTW9kaWZpZXIucHJvdG90eXBlLmFkZFNlZ21lbnRGcm9tQXJyYXkgPSBmdW5jdGlvbihwb2ludHMsIHNoYXBlUGF0aCwgcG9zLCBuZXdTaGFwZSkge1xyXG4gICAgc2hhcGVQYXRoLnNldFhZQXQocG9pbnRzWzFdLCBwb2ludHNbNV0sICdvJywgcG9zKTtcclxuICAgIHNoYXBlUGF0aC5zZXRYWUF0KHBvaW50c1syXSwgcG9pbnRzWzZdLCAnaScsIHBvcyArIDEpO1xyXG4gICAgaWYobmV3U2hhcGUpe1xyXG4gICAgICAgIHNoYXBlUGF0aC5zZXRYWUF0KHBvaW50c1swXSwgcG9pbnRzWzRdLCAndicsIHBvcyk7XHJcbiAgICB9XHJcbiAgICBzaGFwZVBhdGguc2V0WFlBdChwb2ludHNbM10sIHBvaW50c1s3XSwgJ3YnLCBwb3MgKyAxKTtcclxufTtcclxuXHJcblRyaW1Nb2RpZmllci5wcm90b3R5cGUuYWRkU2hhcGVzID0gZnVuY3Rpb24oc2hhcGVEYXRhLCBzaGFwZVNlZ21lbnQsIHNoYXBlUGF0aCkge1xyXG4gICAgdmFyIHBhdGhzRGF0YSA9IHNoYXBlRGF0YS5wYXRoc0RhdGE7XHJcbiAgICB2YXIgc2hhcGVQYXRocyA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5zaGFwZXM7XHJcbiAgICB2YXIgaSwgbGVuID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLl9sZW5ndGgsIGosIGpMZW47XHJcbiAgICB2YXIgYWRkZWRMZW5ndGggPSAwO1xyXG4gICAgdmFyIGN1cnJlbnRMZW5ndGhEYXRhLHNlZ21lbnRDb3VudDtcclxuICAgIHZhciBsZW5ndGhzO1xyXG4gICAgdmFyIHNlZ21lbnQ7XHJcbiAgICB2YXIgc2hhcGVzID0gW107XHJcbiAgICB2YXIgaW5pdFBvcztcclxuICAgIHZhciBuZXdTaGFwZSA9IHRydWU7XHJcbiAgICBpZiAoIXNoYXBlUGF0aCkge1xyXG4gICAgICAgIHNoYXBlUGF0aCA9IHNoYXBlX3Bvb2wubmV3RWxlbWVudCgpO1xyXG4gICAgICAgIHNlZ21lbnRDb3VudCA9IDA7XHJcbiAgICAgICAgaW5pdFBvcyA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNlZ21lbnRDb3VudCA9IHNoYXBlUGF0aC5fbGVuZ3RoO1xyXG4gICAgICAgIGluaXRQb3MgPSBzaGFwZVBhdGguX2xlbmd0aDtcclxuICAgIH1cclxuICAgIHNoYXBlcy5wdXNoKHNoYXBlUGF0aCk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBsZW5ndGhzID0gcGF0aHNEYXRhW2ldLmxlbmd0aHM7XHJcbiAgICAgICAgc2hhcGVQYXRoLmMgPSBzaGFwZVBhdGhzW2ldLmM7XHJcbiAgICAgICAgakxlbiA9IHNoYXBlUGF0aHNbaV0uYyA/IGxlbmd0aHMubGVuZ3RoIDogbGVuZ3Rocy5sZW5ndGggKyAxO1xyXG4gICAgICAgIGZvciAoaiA9IDE7IGogPCBqTGVuOyBqICs9MSkge1xyXG4gICAgICAgICAgICBjdXJyZW50TGVuZ3RoRGF0YSA9IGxlbmd0aHNbai0xXTtcclxuICAgICAgICAgICAgaWYgKGFkZGVkTGVuZ3RoICsgY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGggPCBzaGFwZVNlZ21lbnQucykge1xyXG4gICAgICAgICAgICAgICAgYWRkZWRMZW5ndGggKz0gY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBzaGFwZVBhdGguYyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYoYWRkZWRMZW5ndGggPiBzaGFwZVNlZ21lbnQuZSkge1xyXG4gICAgICAgICAgICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlU2VnbWVudC5zIDw9IGFkZGVkTGVuZ3RoICYmIHNoYXBlU2VnbWVudC5lID49IGFkZGVkTGVuZ3RoICsgY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNlZ21lbnQoc2hhcGVQYXRoc1tpXS52W2ogLSAxXSwgc2hhcGVQYXRoc1tpXS5vW2ogLSAxXSwgc2hhcGVQYXRoc1tpXS5pW2pdLCBzaGFwZVBhdGhzW2ldLnZbal0sIHNoYXBlUGF0aCwgc2VnbWVudENvdW50LCBuZXdTaGFwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2hhcGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudCA9IGJlei5nZXROZXdTZWdtZW50KHNoYXBlUGF0aHNbaV0udltqIC0gMV0sIHNoYXBlUGF0aHNbaV0udltqXSwgc2hhcGVQYXRoc1tpXS5vW2ogLSAxXSwgc2hhcGVQYXRoc1tpXS5pW2pdLCAoc2hhcGVTZWdtZW50LnMgLSBhZGRlZExlbmd0aCkvY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGgsKHNoYXBlU2VnbWVudC5lIC0gYWRkZWRMZW5ndGgpL2N1cnJlbnRMZW5ndGhEYXRhLmFkZGVkTGVuZ3RoLCBsZW5ndGhzW2otMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkU2VnbWVudEZyb21BcnJheShzZWdtZW50LCBzaGFwZVBhdGgsIHNlZ21lbnRDb3VudCwgbmV3U2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuYWRkU2VnbWVudChzZWdtZW50LnB0MSwgc2VnbWVudC5wdDMsIHNlZ21lbnQucHQ0LCBzZWdtZW50LnB0Miwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTaGFwZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhZGRlZExlbmd0aCArPSBjdXJyZW50TGVuZ3RoRGF0YS5hZGRlZExlbmd0aDtcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRDb3VudCArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFwZVBhdGhzW2ldLmMgJiYgbGVuZ3Rocy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY3VycmVudExlbmd0aERhdGEgPSBsZW5ndGhzW2ogLSAxXTtcclxuICAgICAgICAgICAgaWYgKGFkZGVkTGVuZ3RoIDw9IHNoYXBlU2VnbWVudC5lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VnbWVudExlbmd0aCA9IGxlbmd0aHNbaiAtIDFdLmFkZGVkTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNoYXBlU2VnbWVudC5zIDw9IGFkZGVkTGVuZ3RoICYmIHNoYXBlU2VnbWVudC5lID49IGFkZGVkTGVuZ3RoICsgc2VnbWVudExlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkU2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLm9baiAtIDFdLCBzaGFwZVBhdGhzW2ldLmlbMF0sIHNoYXBlUGF0aHNbaV0udlswXSwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdTaGFwZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWdtZW50ID0gYmV6LmdldE5ld1NlZ21lbnQoc2hhcGVQYXRoc1tpXS52W2ogLSAxXSwgc2hhcGVQYXRoc1tpXS52WzBdLCBzaGFwZVBhdGhzW2ldLm9baiAtIDFdLCBzaGFwZVBhdGhzW2ldLmlbMF0sIChzaGFwZVNlZ21lbnQucyAtIGFkZGVkTGVuZ3RoKSAvIHNlZ21lbnRMZW5ndGgsIChzaGFwZVNlZ21lbnQuZSAtIGFkZGVkTGVuZ3RoKSAvIHNlZ21lbnRMZW5ndGgsIGxlbmd0aHNbaiAtIDFdKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFNlZ21lbnRGcm9tQXJyYXkoc2VnbWVudCwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzLmFkZFNlZ21lbnQoc2VnbWVudC5wdDEsIHNlZ21lbnQucHQzLCBzZWdtZW50LnB0NCwgc2VnbWVudC5wdDIsIHNoYXBlUGF0aCwgc2VnbWVudENvdW50LCBuZXdTaGFwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3U2hhcGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBzaGFwZVBhdGguYyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhZGRlZExlbmd0aCArPSBjdXJyZW50TGVuZ3RoRGF0YS5hZGRlZExlbmd0aDtcclxuICAgICAgICAgICAgc2VnbWVudENvdW50ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaGFwZVBhdGguX2xlbmd0aCkge1xyXG4gICAgICAgICAgICBzaGFwZVBhdGguc2V0WFlBdChzaGFwZVBhdGgudltpbml0UG9zXVswXSwgc2hhcGVQYXRoLnZbaW5pdFBvc11bMV0sICdpJywgaW5pdFBvcyk7XHJcbiAgICAgICAgICAgIHNoYXBlUGF0aC5zZXRYWUF0KHNoYXBlUGF0aC52W3NoYXBlUGF0aC5fbGVuZ3RoIC0gMV1bMF0sIHNoYXBlUGF0aC52W3NoYXBlUGF0aC5fbGVuZ3RoIC0gMV1bMV0sJ28nLCBzaGFwZVBhdGguX2xlbmd0aCAtIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWRkZWRMZW5ndGggPiBzaGFwZVNlZ21lbnQuZSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGkgPCBsZW4gLSAxKSB7XHJcbiAgICAgICAgICAgIHNoYXBlUGF0aCA9IHNoYXBlX3Bvb2wubmV3RWxlbWVudCgpO1xyXG4gICAgICAgICAgICBuZXdTaGFwZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHNoYXBlcy5wdXNoKHNoYXBlUGF0aCk7XHJcbiAgICAgICAgICAgIHNlZ21lbnRDb3VudCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNoYXBlcztcclxufTtcclxuXHJcblxyXG5TaGFwZU1vZGlmaWVycy5yZWdpc3Rlck1vZGlmaWVyKCd0bScsIFRyaW1Nb2RpZmllcik7XG5mdW5jdGlvbiBSb3VuZENvcm5lcnNNb2RpZmllcigpe31cclxuZXh0ZW5kUHJvdG90eXBlKFtTaGFwZU1vZGlmaWVyXSxSb3VuZENvcm5lcnNNb2RpZmllcik7XHJcblJvdW5kQ29ybmVyc01vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24oZWxlbSxkYXRhKXtcclxuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLnByb2Nlc3NLZXlzO1xyXG4gICAgdGhpcy5yZCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS5yLDAsbnVsbCx0aGlzKTtcclxuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMucmQuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcclxufTtcclxuXHJcblJvdW5kQ29ybmVyc01vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzUGF0aCA9IGZ1bmN0aW9uKHBhdGgsIHJvdW5kKXtcclxuICAgIHZhciBjbG9uZWRfcGF0aCA9IHNoYXBlX3Bvb2wubmV3RWxlbWVudCgpO1xyXG4gICAgY2xvbmVkX3BhdGguYyA9IHBhdGguYztcclxuICAgIHZhciBpLCBsZW4gPSBwYXRoLl9sZW5ndGg7XHJcbiAgICB2YXIgY3VycmVudFYsY3VycmVudEksY3VycmVudE8sY2xvc2VyViwgbmV3VixuZXdPLG5ld0ksZGlzdGFuY2UsbmV3UG9zUGVyYyxpbmRleCA9IDA7XHJcbiAgICB2YXIgdlgsdlksb1gsb1ksaVgsaVk7XHJcbiAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgIGN1cnJlbnRWID0gcGF0aC52W2ldO1xyXG4gICAgICAgIGN1cnJlbnRPID0gcGF0aC5vW2ldO1xyXG4gICAgICAgIGN1cnJlbnRJID0gcGF0aC5pW2ldO1xyXG4gICAgICAgIGlmKGN1cnJlbnRWWzBdPT09Y3VycmVudE9bMF0gJiYgY3VycmVudFZbMV09PT1jdXJyZW50T1sxXSAmJiBjdXJyZW50VlswXT09PWN1cnJlbnRJWzBdICYmIGN1cnJlbnRWWzFdPT09Y3VycmVudElbMV0pe1xyXG4gICAgICAgICAgICBpZigoaT09PTAgfHwgaSA9PT0gbGVuIC0gMSkgJiYgIXBhdGguYyl7XHJcbiAgICAgICAgICAgICAgICBjbG9uZWRfcGF0aC5zZXRUcmlwbGVBdChjdXJyZW50VlswXSxjdXJyZW50VlsxXSxjdXJyZW50T1swXSxjdXJyZW50T1sxXSxjdXJyZW50SVswXSxjdXJyZW50SVsxXSxpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAvKmNsb25lZF9wYXRoLnZbaW5kZXhdID0gY3VycmVudFY7XHJcbiAgICAgICAgICAgICAgICBjbG9uZWRfcGF0aC5vW2luZGV4XSA9IGN1cnJlbnRPO1xyXG4gICAgICAgICAgICAgICAgY2xvbmVkX3BhdGguaVtpbmRleF0gPSBjdXJyZW50STsqL1xyXG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmKGk9PT0wKXtcclxuICAgICAgICAgICAgICAgICAgICBjbG9zZXJWID0gcGF0aC52W2xlbi0xXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VyViA9IHBhdGgudltpLTFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coY3VycmVudFZbMF0tY2xvc2VyVlswXSwyKStNYXRoLnBvdyhjdXJyZW50VlsxXS1jbG9zZXJWWzFdLDIpKTtcclxuICAgICAgICAgICAgICAgIG5ld1Bvc1BlcmMgPSBkaXN0YW5jZSA/IE1hdGgubWluKGRpc3RhbmNlLzIscm91bmQpL2Rpc3RhbmNlIDogMDtcclxuICAgICAgICAgICAgICAgIHZYID0gaVggPSBjdXJyZW50VlswXSsoY2xvc2VyVlswXS1jdXJyZW50VlswXSkqbmV3UG9zUGVyYztcclxuICAgICAgICAgICAgICAgIHZZID0gaVkgPSBjdXJyZW50VlsxXS0oY3VycmVudFZbMV0tY2xvc2VyVlsxXSkqbmV3UG9zUGVyYztcclxuICAgICAgICAgICAgICAgIG9YID0gdlgtKHZYLWN1cnJlbnRWWzBdKSpyb3VuZENvcm5lcjtcclxuICAgICAgICAgICAgICAgIG9ZID0gdlktKHZZLWN1cnJlbnRWWzFdKSpyb3VuZENvcm5lcjtcclxuICAgICAgICAgICAgICAgIGNsb25lZF9wYXRoLnNldFRyaXBsZUF0KHZYLHZZLG9YLG9ZLGlYLGlZLGluZGV4KTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoaSA9PT0gbGVuIC0gMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VyViA9IHBhdGgudlswXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VyViA9IHBhdGgudltpKzFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coY3VycmVudFZbMF0tY2xvc2VyVlswXSwyKStNYXRoLnBvdyhjdXJyZW50VlsxXS1jbG9zZXJWWzFdLDIpKTtcclxuICAgICAgICAgICAgICAgIG5ld1Bvc1BlcmMgPSBkaXN0YW5jZSA/IE1hdGgubWluKGRpc3RhbmNlLzIscm91bmQpL2Rpc3RhbmNlIDogMDtcclxuICAgICAgICAgICAgICAgIHZYID0gb1ggPSBjdXJyZW50VlswXSsoY2xvc2VyVlswXS1jdXJyZW50VlswXSkqbmV3UG9zUGVyYztcclxuICAgICAgICAgICAgICAgIHZZID0gb1kgPSBjdXJyZW50VlsxXSsoY2xvc2VyVlsxXS1jdXJyZW50VlsxXSkqbmV3UG9zUGVyYztcclxuICAgICAgICAgICAgICAgIGlYID0gdlgtKHZYLWN1cnJlbnRWWzBdKSpyb3VuZENvcm5lcjtcclxuICAgICAgICAgICAgICAgIGlZID0gdlktKHZZLWN1cnJlbnRWWzFdKSpyb3VuZENvcm5lcjtcclxuICAgICAgICAgICAgICAgIGNsb25lZF9wYXRoLnNldFRyaXBsZUF0KHZYLHZZLG9YLG9ZLGlYLGlZLGluZGV4KTtcclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjbG9uZWRfcGF0aC5zZXRUcmlwbGVBdChwYXRoLnZbaV1bMF0scGF0aC52W2ldWzFdLHBhdGgub1tpXVswXSxwYXRoLm9baV1bMV0scGF0aC5pW2ldWzBdLHBhdGguaVtpXVsxXSxpbmRleCk7XHJcbiAgICAgICAgICAgIGluZGV4ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsb25lZF9wYXRoO1xyXG59O1xyXG5cclxuUm91bmRDb3JuZXJzTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NTaGFwZXMgPSBmdW5jdGlvbihfaXNGaXJzdEZyYW1lKXtcclxuICAgIHZhciBzaGFwZVBhdGhzO1xyXG4gICAgdmFyIGksIGxlbiA9IHRoaXMuc2hhcGVzLmxlbmd0aDtcclxuICAgIHZhciBqLCBqTGVuO1xyXG4gICAgdmFyIHJkID0gdGhpcy5yZC52O1xyXG5cclxuICAgIGlmKHJkICE9PSAwKXtcclxuICAgICAgICB2YXIgc2hhcGVEYXRhLCBuZXdQYXRocywgbG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICAgICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07XHJcbiAgICAgICAgICAgIG5ld1BhdGhzID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzO1xyXG4gICAgICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlRGF0YS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcclxuICAgICAgICAgICAgaWYoISghc2hhcGVEYXRhLnNoYXBlLl9tZGYgJiYgIXRoaXMuX21kZiAmJiAhX2lzRmlyc3RGcmFtZSkpe1xyXG4gICAgICAgICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xyXG4gICAgICAgICAgICAgICAgc2hhcGVEYXRhLnNoYXBlLl9tZGYgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgc2hhcGVQYXRocyA9IHNoYXBlRGF0YS5zaGFwZS5wYXRocy5zaGFwZXM7XHJcbiAgICAgICAgICAgICAgICBqTGVuID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLl9sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3Ioaj0wO2o8akxlbjtqKz0xKXtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnByb2Nlc3NQYXRoKHNoYXBlUGF0aHNbal0scmQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzaGFwZURhdGEuc2hhcGUucGF0aHMgPSBzaGFwZURhdGEubG9jYWxTaGFwZUNvbGxlY3Rpb247XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuICAgIGlmKCF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCl7XHJcbiAgICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TaGFwZU1vZGlmaWVycy5yZWdpc3Rlck1vZGlmaWVyKCdyZCcsUm91bmRDb3JuZXJzTW9kaWZpZXIpO1xuZnVuY3Rpb24gUmVwZWF0ZXJNb2RpZmllcigpe31cclxuZXh0ZW5kUHJvdG90eXBlKFtTaGFwZU1vZGlmaWVyXSwgUmVwZWF0ZXJNb2RpZmllcik7XHJcblxyXG5SZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24oZWxlbSxkYXRhKXtcclxuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLnByb2Nlc3NLZXlzO1xyXG4gICAgdGhpcy5jID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSxkYXRhLmMsMCxudWxsLHRoaXMpO1xyXG4gICAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSxkYXRhLm8sMCxudWxsLHRoaXMpO1xyXG4gICAgdGhpcy50ciA9IFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eShlbGVtLGRhdGEudHIsdGhpcyk7XHJcbiAgICB0aGlzLnNvID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSxkYXRhLnRyLnNvLDAsMC4wMSx0aGlzKTtcclxuICAgIHRoaXMuZW8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLGRhdGEudHIuZW8sMCwwLjAxLHRoaXMpO1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIGlmKCF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCl7XHJcbiAgICAgICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcclxuICAgIH1cclxuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoO1xyXG4gICAgdGhpcy5wTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgdGhpcy5yTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgdGhpcy5zTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgdGhpcy50TWF0cml4ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgdGhpcy5tYXRyaXggPSBuZXcgTWF0cml4KCk7XHJcbn07XHJcblxyXG5SZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5hcHBseVRyYW5zZm9ybXMgPSBmdW5jdGlvbihwTWF0cml4LCByTWF0cml4LCBzTWF0cml4LCB0cmFuc2Zvcm0sIHBlcmMsIGludil7XHJcbiAgICB2YXIgZGlyID0gaW52ID8gLTEgOiAxO1xyXG4gICAgdmFyIHNjYWxlWCA9IHRyYW5zZm9ybS5zLnZbMF0gKyAoMSAtIHRyYW5zZm9ybS5zLnZbMF0pICogKDEgLSBwZXJjKTtcclxuICAgIHZhciBzY2FsZVkgPSB0cmFuc2Zvcm0ucy52WzFdICsgKDEgLSB0cmFuc2Zvcm0ucy52WzFdKSAqICgxIC0gcGVyYyk7XHJcbiAgICBwTWF0cml4LnRyYW5zbGF0ZSh0cmFuc2Zvcm0ucC52WzBdICogZGlyICogcGVyYywgdHJhbnNmb3JtLnAudlsxXSAqIGRpciAqIHBlcmMsIHRyYW5zZm9ybS5wLnZbMl0pO1xyXG4gICAgck1hdHJpeC50cmFuc2xhdGUoLXRyYW5zZm9ybS5hLnZbMF0sIC10cmFuc2Zvcm0uYS52WzFdLCB0cmFuc2Zvcm0uYS52WzJdKTtcclxuICAgIHJNYXRyaXgucm90YXRlKC10cmFuc2Zvcm0uci52ICogZGlyICogcGVyYyk7XHJcbiAgICByTWF0cml4LnRyYW5zbGF0ZSh0cmFuc2Zvcm0uYS52WzBdLCB0cmFuc2Zvcm0uYS52WzFdLCB0cmFuc2Zvcm0uYS52WzJdKTtcclxuICAgIHNNYXRyaXgudHJhbnNsYXRlKC10cmFuc2Zvcm0uYS52WzBdLCAtdHJhbnNmb3JtLmEudlsxXSwgdHJhbnNmb3JtLmEudlsyXSk7XHJcbiAgICBzTWF0cml4LnNjYWxlKGludiA/IDEvc2NhbGVYIDogc2NhbGVYLCBpbnYgPyAxL3NjYWxlWSA6IHNjYWxlWSk7XHJcbiAgICBzTWF0cml4LnRyYW5zbGF0ZSh0cmFuc2Zvcm0uYS52WzBdLCB0cmFuc2Zvcm0uYS52WzFdLCB0cmFuc2Zvcm0uYS52WzJdKTtcclxufTtcclxuXHJcblJlcGVhdGVyTW9kaWZpZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihlbGVtLCBhcnIsIHBvcywgZWxlbXNEYXRhKSB7XHJcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgdGhpcy5hcnIgPSBhcnI7XHJcbiAgICB0aGlzLnBvcyA9IHBvcztcclxuICAgIHRoaXMuZWxlbXNEYXRhID0gZWxlbXNEYXRhO1xyXG4gICAgdGhpcy5fY3VycmVudENvcGllcyA9IDA7XHJcbiAgICB0aGlzLl9lbGVtZW50cyA9IFtdO1xyXG4gICAgdGhpcy5fZ3JvdXBzID0gW107XHJcbiAgICB0aGlzLmZyYW1lSWQgPSAtMTtcclxuICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcclxuICAgIHRoaXMuaW5pdE1vZGlmaWVyUHJvcGVydGllcyhlbGVtLGFycltwb3NdKTtcclxuICAgIHZhciBjb250ID0gMDtcclxuICAgIHdoaWxlKHBvcz4wKXtcclxuICAgICAgICBwb3MgLT0gMTtcclxuICAgICAgICAvL3RoaXMuX2VsZW1lbnRzLnVuc2hpZnQoYXJyLnNwbGljZShwb3MsMSlbMF0pO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnRzLnVuc2hpZnQoYXJyW3Bvc10pO1xyXG4gICAgICAgIGNvbnQgKz0gMTtcclxuICAgIH1cclxuICAgIGlmKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKXtcclxuICAgICAgICB0aGlzLmsgPSB0cnVlO1xyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcclxuICAgIH1cclxufTtcclxuXHJcblJlcGVhdGVyTW9kaWZpZXIucHJvdG90eXBlLnJlc2V0RWxlbWVudHMgPSBmdW5jdGlvbihlbGVtZW50cyl7XHJcbiAgICB2YXIgaSwgbGVuID0gZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBlbGVtZW50c1tpXS5fcHJvY2Vzc2VkID0gZmFsc2U7XHJcbiAgICAgICAgaWYoZWxlbWVudHNbaV0udHkgPT09ICdncicpe1xyXG4gICAgICAgICAgICB0aGlzLnJlc2V0RWxlbWVudHMoZWxlbWVudHNbaV0uaXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblJlcGVhdGVyTW9kaWZpZXIucHJvdG90eXBlLmNsb25lRWxlbWVudHMgPSBmdW5jdGlvbihlbGVtZW50cyl7XHJcbiAgICB2YXIgaSwgbGVuID0gZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgdmFyIG5ld0VsZW1lbnRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShlbGVtZW50cykpO1xyXG4gICAgdGhpcy5yZXNldEVsZW1lbnRzKG5ld0VsZW1lbnRzKTtcclxuICAgIHJldHVybiBuZXdFbGVtZW50cztcclxufTtcclxuXHJcblJlcGVhdGVyTW9kaWZpZXIucHJvdG90eXBlLmNoYW5nZUdyb3VwUmVuZGVyID0gZnVuY3Rpb24oZWxlbWVudHMsIHJlbmRlckZsYWcpIHtcclxuICAgIHZhciBpLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7XHJcbiAgICBmb3IoaSA9IDA7IGkgPCBsZW4gOyBpICs9IDEpIHtcclxuICAgICAgICBlbGVtZW50c1tpXS5fcmVuZGVyID0gcmVuZGVyRmxhZztcclxuICAgICAgICBpZihlbGVtZW50c1tpXS50eSA9PT0gJ2dyJykge1xyXG4gICAgICAgICAgICB0aGlzLmNoYW5nZUdyb3VwUmVuZGVyKGVsZW1lbnRzW2ldLml0LCByZW5kZXJGbGFnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5SZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzU2hhcGVzID0gZnVuY3Rpb24oX2lzRmlyc3RGcmFtZSkge1xyXG4gICAgdmFyIGl0ZW1zLCBpdGVtc1RyYW5zZm9ybSwgaSwgZGlyLCBjb250O1xyXG4gICAgaWYodGhpcy5fbWRmIHx8IF9pc0ZpcnN0RnJhbWUpe1xyXG4gICAgICAgIHZhciBjb3BpZXMgPSBNYXRoLmNlaWwodGhpcy5jLnYpO1xyXG4gICAgICAgIGlmKHRoaXMuX2dyb3Vwcy5sZW5ndGggPCBjb3BpZXMpe1xyXG4gICAgICAgICAgICB3aGlsZSh0aGlzLl9ncm91cHMubGVuZ3RoIDwgY29waWVzKXtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cCA9IHtcclxuICAgICAgICAgICAgICAgICAgICBpdDp0aGlzLmNsb25lRWxlbWVudHModGhpcy5fZWxlbWVudHMpLFxyXG4gICAgICAgICAgICAgICAgICAgIHR5OidncidcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBncm91cC5pdC5wdXNoKHtcImFcIjp7XCJhXCI6MCxcIml4XCI6MSxcImtcIjpbMCwwXX0sXCJubVwiOlwiVHJhbnNmb3JtXCIsXCJvXCI6e1wiYVwiOjAsXCJpeFwiOjcsXCJrXCI6MTAwfSxcInBcIjp7XCJhXCI6MCxcIml4XCI6MixcImtcIjpbMCwwXX0sXCJyXCI6e1wiYVwiOjEsXCJpeFwiOjYsXCJrXCI6W3tzOjAsZTowLHQ6MH0se3M6MCxlOjAsdDoxfV19LFwic1wiOntcImFcIjowLFwiaXhcIjozLFwia1wiOlsxMDAsMTAwXX0sXCJzYVwiOntcImFcIjowLFwiaXhcIjo1LFwia1wiOjB9LFwic2tcIjp7XCJhXCI6MCxcIml4XCI6NCxcImtcIjowfSxcInR5XCI6XCJ0clwifSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIHRoaXMuYXJyLnNwbGljZSgwLDAsZ3JvdXApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JvdXBzLnNwbGljZSgwLDAsZ3JvdXApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudENvcGllcyArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbS5yZWxvYWRTaGFwZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udCA9IDA7XHJcbiAgICAgICAgdmFyIHJlbmRlckZsYWc7XHJcbiAgICAgICAgZm9yKGkgPSAwOyBpICA8PSB0aGlzLl9ncm91cHMubGVuZ3RoIC0gMTsgaSArPSAxKXtcclxuICAgICAgICAgICAgcmVuZGVyRmxhZyA9IGNvbnQgPCBjb3BpZXM7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyb3Vwc1tpXS5fcmVuZGVyID0gcmVuZGVyRmxhZztcclxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VHcm91cFJlbmRlcih0aGlzLl9ncm91cHNbaV0uaXQsIHJlbmRlckZsYWcpO1xyXG4gICAgICAgICAgICBjb250ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRDb3BpZXMgPSBjb3BpZXM7XHJcbiAgICAgICAgLy8vL1xyXG5cclxuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vLnY7XHJcbiAgICAgICAgdmFyIG9mZnNldE1vZHVsbyA9IG9mZnNldCUxO1xyXG4gICAgICAgIHZhciByb3VuZE9mZnNldCA9IG9mZnNldCA+IDAgPyBNYXRoLmZsb29yKG9mZnNldCkgOiBNYXRoLmNlaWwob2Zmc2V0KTtcclxuICAgICAgICB2YXIgaztcclxuICAgICAgICB2YXIgdE1hdCA9IHRoaXMudHIudi5wcm9wcztcclxuICAgICAgICB2YXIgcFByb3BzID0gdGhpcy5wTWF0cml4LnByb3BzO1xyXG4gICAgICAgIHZhciByUHJvcHMgPSB0aGlzLnJNYXRyaXgucHJvcHM7XHJcbiAgICAgICAgdmFyIHNQcm9wcyA9IHRoaXMuc01hdHJpeC5wcm9wcztcclxuICAgICAgICB0aGlzLnBNYXRyaXgucmVzZXQoKTtcclxuICAgICAgICB0aGlzLnJNYXRyaXgucmVzZXQoKTtcclxuICAgICAgICB0aGlzLnNNYXRyaXgucmVzZXQoKTtcclxuICAgICAgICB0aGlzLnRNYXRyaXgucmVzZXQoKTtcclxuICAgICAgICB0aGlzLm1hdHJpeC5yZXNldCgpO1xyXG4gICAgICAgIHZhciBpdGVyYXRpb24gPSAwO1xyXG5cclxuICAgICAgICBpZihvZmZzZXQgPiAwKSB7XHJcbiAgICAgICAgICAgIHdoaWxlKGl0ZXJhdGlvbjxyb3VuZE9mZnNldCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3Jtcyh0aGlzLnBNYXRyaXgsIHRoaXMuck1hdHJpeCwgdGhpcy5zTWF0cml4LCB0aGlzLnRyLCAxLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRpb24gKz0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihvZmZzZXRNb2R1bG8pe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybXModGhpcy5wTWF0cml4LCB0aGlzLnJNYXRyaXgsIHRoaXMuc01hdHJpeCwgdGhpcy50ciwgb2Zmc2V0TW9kdWxvLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBpdGVyYXRpb24gKz0gb2Zmc2V0TW9kdWxvO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmKG9mZnNldCA8IDApIHtcclxuICAgICAgICAgICAgd2hpbGUoaXRlcmF0aW9uPnJvdW5kT2Zmc2V0KXtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHRoaXMucE1hdHJpeCwgdGhpcy5yTWF0cml4LCB0aGlzLnNNYXRyaXgsIHRoaXMudHIsIDEsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaXRlcmF0aW9uIC09IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYob2Zmc2V0TW9kdWxvKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHRoaXMucE1hdHJpeCwgdGhpcy5yTWF0cml4LCB0aGlzLnNNYXRyaXgsIHRoaXMudHIsIC0gb2Zmc2V0TW9kdWxvLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIGl0ZXJhdGlvbiAtPSBvZmZzZXRNb2R1bG87XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaSA9IHRoaXMuZGF0YS5tID09PSAxID8gMCA6IHRoaXMuX2N1cnJlbnRDb3BpZXMgLSAxO1xyXG4gICAgICAgIGRpciA9IHRoaXMuZGF0YS5tID09PSAxID8gMSA6IC0xO1xyXG4gICAgICAgIGNvbnQgPSB0aGlzLl9jdXJyZW50Q29waWVzO1xyXG4gICAgICAgIHZhciBqLCBqTGVuO1xyXG4gICAgICAgIHdoaWxlKGNvbnQpe1xyXG4gICAgICAgICAgICBpdGVtcyA9IHRoaXMuZWxlbXNEYXRhW2ldLml0O1xyXG4gICAgICAgICAgICBpdGVtc1RyYW5zZm9ybSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnRyYW5zZm9ybS5tUHJvcHMudi5wcm9wcztcclxuICAgICAgICAgICAgakxlbiA9IGl0ZW1zVHJhbnNmb3JtLmxlbmd0aDtcclxuICAgICAgICAgICAgaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm1Qcm9wcy5fbWRmID0gdHJ1ZTtcclxuICAgICAgICAgICAgaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm9wLl9tZGYgPSB0cnVlO1xyXG4gICAgICAgICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ub3AudiA9IHRoaXMuc28udiArICh0aGlzLmVvLnYgLSB0aGlzLnNvLnYpICogKGkgLyAodGhpcy5fY3VycmVudENvcGllcyAtIDEpKTtcclxuICAgICAgICAgICAgaWYoaXRlcmF0aW9uICE9PSAwKXtcclxuICAgICAgICAgICAgICAgIGlmKChpICE9PSAwICYmIGRpciA9PT0gMSkgfHwgKGkgIT09IHRoaXMuX2N1cnJlbnRDb3BpZXMgLSAxICYmIGRpciA9PT0gLTEpKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3Jtcyh0aGlzLnBNYXRyaXgsIHRoaXMuck1hdHJpeCwgdGhpcy5zTWF0cml4LCB0aGlzLnRyLCAxLCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeC50cmFuc2Zvcm0oclByb3BzWzBdLHJQcm9wc1sxXSxyUHJvcHNbMl0sclByb3BzWzNdLHJQcm9wc1s0XSxyUHJvcHNbNV0sclByb3BzWzZdLHJQcm9wc1s3XSxyUHJvcHNbOF0sclByb3BzWzldLHJQcm9wc1sxMF0sclByb3BzWzExXSxyUHJvcHNbMTJdLHJQcm9wc1sxM10sclByb3BzWzE0XSxyUHJvcHNbMTVdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF0cml4LnRyYW5zZm9ybShzUHJvcHNbMF0sc1Byb3BzWzFdLHNQcm9wc1syXSxzUHJvcHNbM10sc1Byb3BzWzRdLHNQcm9wc1s1XSxzUHJvcHNbNl0sc1Byb3BzWzddLHNQcm9wc1s4XSxzUHJvcHNbOV0sc1Byb3BzWzEwXSxzUHJvcHNbMTFdLHNQcm9wc1sxMl0sc1Byb3BzWzEzXSxzUHJvcHNbMTRdLHNQcm9wc1sxNV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXgudHJhbnNmb3JtKHBQcm9wc1swXSxwUHJvcHNbMV0scFByb3BzWzJdLHBQcm9wc1szXSxwUHJvcHNbNF0scFByb3BzWzVdLHBQcm9wc1s2XSxwUHJvcHNbN10scFByb3BzWzhdLHBQcm9wc1s5XSxwUHJvcHNbMTBdLHBQcm9wc1sxMV0scFByb3BzWzEyXSxwUHJvcHNbMTNdLHBQcm9wc1sxNF0scFByb3BzWzE1XSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGZvcihqPTA7ajxqTGVuO2orPTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtc1RyYW5zZm9ybVtqXSA9IHRoaXMubWF0cml4LnByb3BzW2pdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXgucmVzZXQoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF0cml4LnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICBmb3Ioaj0wO2o8akxlbjtqKz0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNUcmFuc2Zvcm1bal0gPSB0aGlzLm1hdHJpeC5wcm9wc1tqXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpdGVyYXRpb24gKz0gMTtcclxuICAgICAgICAgICAgY29udCAtPSAxO1xyXG4gICAgICAgICAgICBpICs9IGRpcjtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnQgPSB0aGlzLl9jdXJyZW50Q29waWVzO1xyXG4gICAgICAgIGkgPSAwO1xyXG4gICAgICAgIGRpciA9IDE7XHJcbiAgICAgICAgd2hpbGUoY29udCl7XHJcbiAgICAgICAgICAgIGl0ZW1zID0gdGhpcy5lbGVtc0RhdGFbaV0uaXQ7XHJcbiAgICAgICAgICAgIGl0ZW1zVHJhbnNmb3JtID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm1Qcm9wcy52LnByb3BzO1xyXG4gICAgICAgICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ubVByb3BzLl9tZGYgPSBmYWxzZTtcclxuICAgICAgICAgICAgaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm9wLl9tZGYgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29udCAtPSAxO1xyXG4gICAgICAgICAgICBpICs9IGRpcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5SZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uKCl7fTtcclxuXHJcblNoYXBlTW9kaWZpZXJzLnJlZ2lzdGVyTW9kaWZpZXIoJ3JwJyxSZXBlYXRlck1vZGlmaWVyKTtcbmZ1bmN0aW9uIFNoYXBlQ29sbGVjdGlvbigpe1xyXG5cdHRoaXMuX2xlbmd0aCA9IDA7XHJcblx0dGhpcy5fbWF4TGVuZ3RoID0gNDtcclxuXHR0aGlzLnNoYXBlcyA9IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKTtcclxufVxyXG5cclxuU2hhcGVDb2xsZWN0aW9uLnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlRGF0YSl7XHJcblx0aWYodGhpcy5fbGVuZ3RoID09PSB0aGlzLl9tYXhMZW5ndGgpe1xyXG5cdFx0dGhpcy5zaGFwZXMgPSB0aGlzLnNoYXBlcy5jb25jYXQoY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpKTtcclxuXHRcdHRoaXMuX21heExlbmd0aCAqPSAyO1xyXG5cdH1cclxuXHR0aGlzLnNoYXBlc1t0aGlzLl9sZW5ndGhdID0gc2hhcGVEYXRhO1xyXG5cdHRoaXMuX2xlbmd0aCArPSAxO1xyXG59O1xyXG5cclxuU2hhcGVDb2xsZWN0aW9uLnByb3RvdHlwZS5yZWxlYXNlU2hhcGVzID0gZnVuY3Rpb24oKXtcclxuXHR2YXIgaTtcclxuXHRmb3IoaSA9IDA7IGkgPCB0aGlzLl9sZW5ndGg7IGkgKz0gMSkge1xyXG5cdFx0c2hhcGVfcG9vbC5yZWxlYXNlKHRoaXMuc2hhcGVzW2ldKTtcclxuXHR9XHJcblx0dGhpcy5fbGVuZ3RoID0gMDtcclxufTtcbmZ1bmN0aW9uIERhc2hQcm9wZXJ0eShlbGVtLCBkYXRhLCByZW5kZXJlciwgY29udGFpbmVyKSB7XHJcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgdGhpcy5mcmFtZUlkID0gLTE7XHJcbiAgICB0aGlzLmRhdGFQcm9wcyA9IGNyZWF0ZVNpemVkQXJyYXkoZGF0YS5sZW5ndGgpO1xyXG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG4gICAgdGhpcy5rID0gZmFsc2U7XHJcbiAgICB0aGlzLmRhc2hTdHIgPSAnJztcclxuICAgIHRoaXMuZGFzaEFycmF5ID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsICBkYXRhLmxlbmd0aCA/IGRhdGEubGVuZ3RoIC0gMSA6IDApO1xyXG4gICAgdGhpcy5kYXNob2Zmc2V0ID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsICAxKTtcclxuICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihjb250YWluZXIpO1xyXG4gICAgdmFyIGksIGxlbiA9IGRhdGEubGVuZ3RoIHx8IDAsIHByb3A7XHJcbiAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgIHByb3AgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLGRhdGFbaV0udiwwLCAwLCB0aGlzKTtcclxuICAgICAgICB0aGlzLmsgPSBwcm9wLmsgfHwgdGhpcy5rO1xyXG4gICAgICAgIHRoaXMuZGF0YVByb3BzW2ldID0ge246ZGF0YVtpXS5uLHA6cHJvcH07XHJcbiAgICB9XHJcbiAgICBpZighdGhpcy5rKXtcclxuICAgICAgICB0aGlzLmdldFZhbHVlKHRydWUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5faXNBbmltYXRlZCA9IHRoaXMuaztcclxufVxyXG5cclxuRGFzaFByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKGZvcmNlUmVuZGVyKSB7XHJcbiAgICBpZih0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQgJiYgIWZvcmNlUmVuZGVyKXtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xyXG4gICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcclxuICAgIHRoaXMuX21kZiA9IHRoaXMuX21kZiB8fCBmb3JjZVJlbmRlcjtcclxuICAgIGlmICh0aGlzLl9tZGYpIHtcclxuICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuZGF0YVByb3BzLmxlbmd0aDtcclxuICAgICAgICBpZih0aGlzLnJlbmRlcmVyID09PSAnc3ZnJykge1xyXG4gICAgICAgICAgICB0aGlzLmRhc2hTdHIgPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAgICAgaWYodGhpcy5kYXRhUHJvcHNbaV0ubiAhPSAnbycpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5yZW5kZXJlciA9PT0gJ3N2ZycpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhc2hTdHIgKz0gJyAnICsgdGhpcy5kYXRhUHJvcHNbaV0ucC52O1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXNoQXJyYXlbaV0gPSB0aGlzLmRhdGFQcm9wc1tpXS5wLnY7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXNob2Zmc2V0WzBdID0gdGhpcy5kYXRhUHJvcHNbaV0ucC52O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5leHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIERhc2hQcm9wZXJ0eSk7XG5mdW5jdGlvbiBHcmFkaWVudFByb3BlcnR5KGVsZW0sZGF0YSxjb250YWluZXIpe1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIHRoaXMuYyA9IGNyZWF0ZVR5cGVkQXJyYXkoJ3VpbnQ4YycsIGRhdGEucCo0KTtcclxuICAgIHZhciBjTGVuZ3RoID0gZGF0YS5rLmtbMF0ucyA/IChkYXRhLmsua1swXS5zLmxlbmd0aCAtIGRhdGEucCo0KSA6IGRhdGEuay5rLmxlbmd0aCAtIGRhdGEucCo0O1xyXG4gICAgdGhpcy5vID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGNMZW5ndGgpO1xyXG4gICAgdGhpcy5fY21kZiA9IGZhbHNlO1xyXG4gICAgdGhpcy5fb21kZiA9IGZhbHNlO1xyXG4gICAgdGhpcy5fY29sbGFwc2FibGUgPSB0aGlzLmNoZWNrQ29sbGFwc2FibGUoKTtcclxuICAgIHRoaXMuX2hhc09wYWNpdHkgPSBjTGVuZ3RoO1xyXG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGNvbnRhaW5lcik7XHJcbiAgICB0aGlzLnByb3AgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLGRhdGEuaywxLG51bGwsdGhpcyk7XHJcbiAgICB0aGlzLmsgPSB0aGlzLnByb3AuaztcclxuICAgIHRoaXMuZ2V0VmFsdWUodHJ1ZSk7XHJcbn1cclxuXHJcbkdyYWRpZW50UHJvcGVydHkucHJvdG90eXBlLmNvbXBhcmVQb2ludHMgPSBmdW5jdGlvbih2YWx1ZXMsIHBvaW50cykge1xyXG4gICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLm8ubGVuZ3RoLzIsIGRpZmY7XHJcbiAgICB3aGlsZShpIDwgbGVuKSB7XHJcbiAgICAgICAgZGlmZiA9IE1hdGguYWJzKHZhbHVlc1tpKjRdIC0gdmFsdWVzW3BvaW50cyo0ICsgaSoyXSk7XHJcbiAgICAgICAgaWYoZGlmZiA+IDAuMDEpe1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgKz0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59O1xyXG5cclxuR3JhZGllbnRQcm9wZXJ0eS5wcm90b3R5cGUuY2hlY2tDb2xsYXBzYWJsZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMuby5sZW5ndGgvMiAhPT0gdGhpcy5jLmxlbmd0aC80KSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuZGF0YS5rLmtbMF0ucykge1xyXG4gICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5kYXRhLmsuay5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbXBhcmVQb2ludHModGhpcy5kYXRhLmsua1tpXS5zLCB0aGlzLmRhdGEucCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmKCF0aGlzLmNvbXBhcmVQb2ludHModGhpcy5kYXRhLmsuaywgdGhpcy5kYXRhLnApKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcblxyXG5HcmFkaWVudFByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKGZvcmNlUmVuZGVyKXtcclxuICAgIHRoaXMucHJvcC5nZXRWYWx1ZSgpO1xyXG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XHJcbiAgICB0aGlzLl9jbWRmID0gZmFsc2U7XHJcbiAgICB0aGlzLl9vbWRmID0gZmFsc2U7XHJcbiAgICBpZih0aGlzLnByb3AuX21kZiB8fCBmb3JjZVJlbmRlcil7XHJcbiAgICAgICAgdmFyIGksIGxlbiA9IHRoaXMuZGF0YS5wKjQ7XHJcbiAgICAgICAgdmFyIG11bHQsIHZhbDtcclxuICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICBtdWx0ID0gaSU0ID09PSAwID8gMTAwIDogMjU1O1xyXG4gICAgICAgICAgICB2YWwgPSBNYXRoLnJvdW5kKHRoaXMucHJvcC52W2ldKm11bHQpO1xyXG4gICAgICAgICAgICBpZih0aGlzLmNbaV0gIT09IHZhbCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNbaV0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jbWRmID0gIWZvcmNlUmVuZGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMuby5sZW5ndGgpe1xyXG4gICAgICAgICAgICBsZW4gPSB0aGlzLnByb3Audi5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvcihpPXRoaXMuZGF0YS5wKjQ7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgICAgICAgICBtdWx0ID0gaSUyID09PSAwID8gMTAwIDogMTtcclxuICAgICAgICAgICAgICAgIHZhbCA9IGklMiA9PT0gMCA/ICBNYXRoLnJvdW5kKHRoaXMucHJvcC52W2ldKjEwMCk6dGhpcy5wcm9wLnZbaV07XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9baS10aGlzLmRhdGEucCo0XSAhPT0gdmFsKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9baS10aGlzLmRhdGEucCo0XSA9IHZhbDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbWRmID0gIWZvcmNlUmVuZGVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX21kZiA9ICFmb3JjZVJlbmRlcjtcclxuICAgIH1cclxufTtcclxuXHJcbmV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgR3JhZGllbnRQcm9wZXJ0eSk7XG52YXIgYnVpbGRTaGFwZVN0cmluZyA9IGZ1bmN0aW9uKHBhdGhOb2RlcywgbGVuZ3RoLCBjbG9zZWQsIG1hdCkge1xyXG5cdGlmKGxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfbyA9IHBhdGhOb2Rlcy5vO1xyXG4gICAgICAgIHZhciBfaSA9IHBhdGhOb2Rlcy5pO1xyXG4gICAgICAgIHZhciBfdiA9IHBhdGhOb2Rlcy52O1xyXG4gICAgICAgIHZhciBpLCBzaGFwZVN0cmluZyA9IFwiIE1cIiArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfdlswXVswXSwgX3ZbMF1bMV0pO1xyXG4gICAgICAgIGZvcihpID0gMTsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIHNoYXBlU3RyaW5nICs9IFwiIENcIiArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfb1tpIC0gMV1bMF0sIF9vW2kgLSAxXVsxXSkgKyBcIiBcIiArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfaVtpXVswXSwgX2lbaV1bMV0pICsgXCIgXCIgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX3ZbaV1bMF0sIF92W2ldWzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNsb3NlZCAmJiBsZW5ndGgpIHtcclxuICAgICAgICAgICAgc2hhcGVTdHJpbmcgKz0gXCIgQ1wiICsgbWF0LmFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKF9vW2kgLSAxXVswXSwgX29baSAtIDFdWzFdKSArIFwiIFwiICsgbWF0LmFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKF9pWzBdWzBdLCBfaVswXVsxXSkgKyBcIiBcIiArIG1hdC5hcHBseVRvUG9pbnRTdHJpbmdpZmllZChfdlswXVswXSwgX3ZbMF1bMV0pO1xyXG4gICAgICAgICAgICBzaGFwZVN0cmluZyArPSAneic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaGFwZVN0cmluZztcclxufVxudmFyIEltYWdlUHJlbG9hZGVyID0gKGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgdmFyIHByb3h5SW1hZ2UgPSAoZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgY2FudmFzID0gY3JlYXRlVGFnKCdjYW52YXMnKTtcclxuICAgICAgICBjYW52YXMud2lkdGggPSAxO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xyXG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gJyNGRjAwMDAnO1xyXG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcclxuICAgICAgICByZXR1cm4gY2FudmFzO1xyXG4gICAgfSgpKVxyXG5cclxuICAgIGZ1bmN0aW9uIGltYWdlTG9hZGVkKCl7XHJcbiAgICAgICAgdGhpcy5sb2FkZWRBc3NldHMgKz0gMTtcclxuICAgICAgICBpZih0aGlzLmxvYWRlZEFzc2V0cyA9PT0gdGhpcy50b3RhbEltYWdlcyl7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuaW1hZ2VzTG9hZGVkQ2IpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzTG9hZGVkQ2IobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0QXNzZXRzUGF0aChhc3NldERhdGEsIGFzc2V0c1BhdGgsIG9yaWdpbmFsX3BhdGgpIHtcclxuICAgICAgICB2YXIgcGF0aCA9ICcnO1xyXG4gICAgICAgIGlmIChhc3NldERhdGEuZSkge1xyXG4gICAgICAgICAgICBwYXRoID0gYXNzZXREYXRhLnA7XHJcbiAgICAgICAgfSBlbHNlIGlmKGFzc2V0c1BhdGgpIHtcclxuICAgICAgICAgICAgdmFyIGltYWdlUGF0aCA9IGFzc2V0RGF0YS5wO1xyXG4gICAgICAgICAgICBpZiAoaW1hZ2VQYXRoLmluZGV4T2YoJ2ltYWdlcy8nKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGltYWdlUGF0aCA9IGltYWdlUGF0aC5zcGxpdCgnLycpWzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhdGggPSBhc3NldHNQYXRoICsgaW1hZ2VQYXRoO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBhdGggPSBvcmlnaW5hbF9wYXRoO1xyXG4gICAgICAgICAgICBwYXRoICs9IGFzc2V0RGF0YS51ID8gYXNzZXREYXRhLnUgOiAnJztcclxuICAgICAgICAgICAgcGF0aCArPSBhc3NldERhdGEucDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlSW1hZ2VEYXRhKGFzc2V0RGF0YSkge1xyXG4gICAgICAgIHZhciBwYXRoID0gZ2V0QXNzZXRzUGF0aChhc3NldERhdGEsIHRoaXMuYXNzZXRzUGF0aCwgdGhpcy5wYXRoKTtcclxuICAgICAgICB2YXIgaW1nID0gY3JlYXRlVGFnKCdpbWcnKTtcclxuICAgICAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcclxuICAgICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2ltYWdlTG9hZGVkLmJpbmQodGhpcyksIGZhbHNlKTtcclxuICAgICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgb2IuaW1nID0gcHJveHlJbWFnZTtcclxuICAgICAgICAgICAgdGhpcy5faW1hZ2VMb2FkZWQoKTtcclxuICAgICAgICB9LmJpbmQodGhpcyksIGZhbHNlKTtcclxuICAgICAgICBpbWcuc3JjID0gcGF0aDtcclxuICAgICAgICB2YXIgb2IgPSB7XHJcbiAgICAgICAgICAgIGltZzogaW1nLFxyXG4gICAgICAgICAgICBhc3NldERhdGE6IGFzc2V0RGF0YVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2I7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbG9hZEFzc2V0cyhhc3NldHMsIGNiKXtcclxuICAgICAgICB0aGlzLmltYWdlc0xvYWRlZENiID0gY2I7XHJcbiAgICAgICAgdmFyIGksIGxlbiA9IGFzc2V0cy5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmKCFhc3NldHNbaV0ubGF5ZXJzKXtcclxuICAgICAgICAgICAgICAgIHRoaXMudG90YWxJbWFnZXMgKz0gMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzLnB1c2godGhpcy5fY3JlYXRlSW1hZ2VEYXRhKGFzc2V0c1tpXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldFBhdGgocGF0aCl7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aCB8fCAnJztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRBc3NldHNQYXRoKHBhdGgpe1xyXG4gICAgICAgIHRoaXMuYXNzZXRzUGF0aCA9IHBhdGggfHwgJyc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0SW1hZ2UoYXNzZXREYXRhKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLmltYWdlcy5sZW5ndGg7XHJcbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW1hZ2VzW2ldLmFzc2V0RGF0YSA9PT0gYXNzZXREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbWFnZXNbaV0uaW1nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmltYWdlc0xvYWRlZENiID0gbnVsbDtcclxuICAgICAgICB0aGlzLmltYWdlcy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxvYWRlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b3RhbEltYWdlcyA9PT0gdGhpcy5sb2FkZWRBc3NldHM7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIEltYWdlUHJlbG9hZGVyKCl7XHJcbiAgICAgICAgdGhpcy5sb2FkQXNzZXRzID0gbG9hZEFzc2V0cztcclxuICAgICAgICB0aGlzLnNldEFzc2V0c1BhdGggPSBzZXRBc3NldHNQYXRoO1xyXG4gICAgICAgIHRoaXMuc2V0UGF0aCA9IHNldFBhdGg7XHJcbiAgICAgICAgdGhpcy5sb2FkZWQgPSBsb2FkZWQ7XHJcbiAgICAgICAgdGhpcy5kZXN0cm95ID0gZGVzdHJveTtcclxuICAgICAgICB0aGlzLmdldEltYWdlID0gZ2V0SW1hZ2U7XHJcbiAgICAgICAgdGhpcy5fY3JlYXRlSW1hZ2VEYXRhID0gY3JlYXRlSW1hZ2VEYXRhO1xyXG4gICAgICAgIHRoaXMuX2ltYWdlTG9hZGVkID0gaW1hZ2VMb2FkZWQ7XHJcbiAgICAgICAgdGhpcy5hc3NldHNQYXRoID0gJyc7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gJyc7XHJcbiAgICAgICAgdGhpcy50b3RhbEltYWdlcyA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2FkZWRBc3NldHMgPSAwO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VzTG9hZGVkQ2IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VzID0gW107XHJcbiAgICB9O1xyXG59KCkpO1xudmFyIGZlYXR1cmVTdXBwb3J0ID0gKGZ1bmN0aW9uKCl7XHJcblx0dmFyIG9iID0ge1xyXG5cdFx0bWFza1R5cGU6IHRydWVcclxuXHR9O1xyXG5cdGlmICgvTVNJRSAxMC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL01TSUUgOS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL3J2OjExLjAvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IC9FZGdlXFwvXFxkLi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcclxuXHQgICBvYi5tYXNrVHlwZSA9IGZhbHNlO1xyXG5cdH1cclxuXHRyZXR1cm4gb2I7XHJcbn0oKSk7XG52YXIgZmlsdGVyc0ZhY3RvcnkgPSAoZnVuY3Rpb24oKXtcclxuXHR2YXIgb2IgPSB7fTtcclxuXHRvYi5jcmVhdGVGaWx0ZXIgPSBjcmVhdGVGaWx0ZXI7XHJcblx0b2IuY3JlYXRlQWxwaGFUb0x1bWluYW5jZUZpbHRlciA9IGNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXI7XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZUZpbHRlcihmaWxJZCl7XHJcbiAgICAgICAgXHR2YXIgZmlsID0gY3JlYXRlTlMoJ2ZpbHRlcicpO1xyXG4gICAgICAgIFx0ZmlsLnNldEF0dHJpYnV0ZSgnaWQnLGZpbElkKTtcclxuICAgICAgICAgICAgICAgIGZpbC5zZXRBdHRyaWJ1dGUoJ2ZpbHRlclVuaXRzJywnb2JqZWN0Qm91bmRpbmdCb3gnKTtcclxuICAgICAgICAgICAgICAgIGZpbC5zZXRBdHRyaWJ1dGUoJ3gnLCcwJScpO1xyXG4gICAgICAgICAgICAgICAgZmlsLnNldEF0dHJpYnV0ZSgneScsJzAlJyk7XHJcbiAgICAgICAgICAgICAgICBmaWwuc2V0QXR0cmlidXRlKCd3aWR0aCcsJzEwMCUnKTtcclxuICAgICAgICAgICAgICAgIGZpbC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsJzEwMCUnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmaWw7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVBbHBoYVRvTHVtaW5hbmNlRmlsdGVyKCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmVDb2xvck1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XHJcbiAgICAgICAgICAgICAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsJ21hdHJpeCcpO1xyXG4gICAgICAgICAgICAgICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsJ3NSR0InKTtcclxuICAgICAgICAgICAgICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCcwIDAgMCAxIDAgIDAgMCAwIDEgMCAgMCAwIDAgMSAwICAwIDAgMCAxIDEnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmZUNvbG9yTWF0cml4O1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG9iO1xyXG59KCkpO1xudmFyIGFzc2V0TG9hZGVyID0gKGZ1bmN0aW9uKCl7XHJcblxyXG5cdGZ1bmN0aW9uIGZvcm1hdFJlc3BvbnNlKHhocikge1xyXG5cdFx0aWYoeGhyLnJlc3BvbnNlICYmIHR5cGVvZiB4aHIucmVzcG9uc2UgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdHJldHVybiB4aHIucmVzcG9uc2U7XHJcblx0XHR9IGVsc2UgaWYoeGhyLnJlc3BvbnNlICYmIHR5cGVvZiB4aHIucmVzcG9uc2UgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdHJldHVybiBKU09OLnBhcnNlKHhoci5yZXNwb25zZSk7XHJcblx0XHR9IGVsc2UgaWYoeGhyLnJlc3BvbnNlVGV4dCkge1xyXG5cdFx0XHRyZXR1cm4gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2UpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gbG9hZEFzc2V0KHBhdGgsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XHJcblx0XHR2YXIgcmVzcG9uc2U7XHJcblx0XHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblx0XHR4aHIub3BlbignR0VUJywgcGF0aCwgdHJ1ZSk7XHJcblx0XHQvLyBzZXQgcmVzcG9uc2VUeXBlIGFmdGVyIGNhbGxpbmcgb3BlbiBvciBJRSB3aWxsIGJyZWFrLlxyXG5cdFx0eGhyLnJlc3BvbnNlVHlwZSA9IFwianNvblwiO1xyXG5cdCAgICB4aHIuc2VuZCgpO1xyXG5cdCAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQpIHtcclxuXHQgICAgICAgICAgICBpZih4aHIuc3RhdHVzID09IDIwMCl7XHJcblx0ICAgICAgICAgICAgXHRyZXNwb25zZSA9IGZvcm1hdFJlc3BvbnNlKHhocik7XHJcblx0ICAgICAgICAgICAgXHRjYWxsYmFjayhyZXNwb25zZSk7XHJcblx0ICAgICAgICAgICAgfWVsc2V7XHJcblx0ICAgICAgICAgICAgICAgIHRyeXtcclxuXHQgICAgICAgICAgICBcdFx0cmVzcG9uc2UgPSBmb3JtYXRSZXNwb25zZSh4aHIpO1xyXG5cdCAgICAgICAgICAgIFx0XHRjYWxsYmFjayhyZXNwb25zZSk7XHJcblx0ICAgICAgICAgICAgICAgIH1jYXRjaChlcnIpe1xyXG5cdCAgICAgICAgICAgICAgICBcdGlmKGVycm9yQ2FsbGJhY2spIHtcclxuXHQgICAgICAgICAgICAgICAgXHRcdGVycm9yQ2FsbGJhY2soZXJyKTtcclxuXHQgICAgICAgICAgICAgICAgXHR9XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0fVxyXG5cdHJldHVybiB7XHJcblx0XHRsb2FkOiBsb2FkQXNzZXRcclxuXHR9XHJcbn0oKSlcclxuXG5mdW5jdGlvbiBUZXh0QW5pbWF0b3JQcm9wZXJ0eSh0ZXh0RGF0YSwgcmVuZGVyVHlwZSwgZWxlbSl7XHJcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xyXG5cdHRoaXMuX2hhc01hc2tlZFBhdGggPSBmYWxzZTtcclxuXHR0aGlzLl9mcmFtZUlkID0gLTE7XHJcblx0dGhpcy5fdGV4dERhdGEgPSB0ZXh0RGF0YTtcclxuXHR0aGlzLl9yZW5kZXJUeXBlID0gcmVuZGVyVHlwZTtcclxuICAgIHRoaXMuX2VsZW0gPSBlbGVtO1xyXG5cdHRoaXMuX2FuaW1hdG9yc0RhdGEgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMuX3RleHREYXRhLmEubGVuZ3RoKTtcclxuXHR0aGlzLl9wYXRoRGF0YSA9IHt9O1xyXG5cdHRoaXMuX21vcmVPcHRpb25zID0ge1xyXG5cdFx0YWxpZ25tZW50OiB7fVxyXG5cdH07XHJcblx0dGhpcy5yZW5kZXJlZExldHRlcnMgPSBbXTtcclxuICAgIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnID0gZmFsc2U7XHJcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XHJcblxyXG59XHJcblxyXG5UZXh0QW5pbWF0b3JQcm9wZXJ0eS5wcm90b3R5cGUuc2VhcmNoUHJvcGVydGllcyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgaSwgbGVuID0gdGhpcy5fdGV4dERhdGEuYS5sZW5ndGgsIGFuaW1hdG9yUHJvcHM7XHJcbiAgICB2YXIgZ2V0UHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wO1xyXG4gICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICBhbmltYXRvclByb3BzID0gdGhpcy5fdGV4dERhdGEuYVtpXTtcclxuICAgICAgICB0aGlzLl9hbmltYXRvcnNEYXRhW2ldID0gbmV3IFRleHRBbmltYXRvckRhdGFQcm9wZXJ0eSh0aGlzLl9lbGVtLCBhbmltYXRvclByb3BzLCB0aGlzKTtcclxuICAgIH1cclxuICAgIGlmKHRoaXMuX3RleHREYXRhLnAgJiYgJ20nIGluIHRoaXMuX3RleHREYXRhLnApe1xyXG4gICAgICAgIHRoaXMuX3BhdGhEYXRhID0ge1xyXG4gICAgICAgICAgICBmOiBnZXRQcm9wKHRoaXMuX2VsZW0sdGhpcy5fdGV4dERhdGEucC5mLDAsMCx0aGlzKSxcclxuICAgICAgICAgICAgbDogZ2V0UHJvcCh0aGlzLl9lbGVtLHRoaXMuX3RleHREYXRhLnAubCwwLDAsdGhpcyksXHJcbiAgICAgICAgICAgIHI6IHRoaXMuX3RleHREYXRhLnAucixcclxuICAgICAgICAgICAgbTogdGhpcy5fZWxlbS5tYXNrTWFuYWdlci5nZXRNYXNrUHJvcGVydHkodGhpcy5fdGV4dERhdGEucC5tKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5faGFzTWFza2VkUGF0aCA9IHRydWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX2hhc01hc2tlZFBhdGggPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHRoaXMuX21vcmVPcHRpb25zLmFsaWdubWVudCA9IGdldFByb3AodGhpcy5fZWxlbSx0aGlzLl90ZXh0RGF0YS5tLmEsMSwwLHRoaXMpO1xyXG59O1xyXG5cclxuVGV4dEFuaW1hdG9yUHJvcGVydHkucHJvdG90eXBlLmdldE1lYXN1cmVzID0gZnVuY3Rpb24oZG9jdW1lbnREYXRhLCBsZXR0ZXJzQ2hhbmdlZEZsYWcpe1xyXG4gICAgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgPSBsZXR0ZXJzQ2hhbmdlZEZsYWc7XHJcbiAgICBpZighdGhpcy5fbWRmICYmICF0aGlzLl9pc0ZpcnN0RnJhbWUgJiYgIWxldHRlcnNDaGFuZ2VkRmxhZyAmJiAoIXRoaXMuX2hhc01hc2tlZFBhdGggfHwgIXRoaXMuX3BhdGhEYXRhLm0uX21kZikpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcclxuICAgIHZhciBhbGlnbm1lbnQgPSB0aGlzLl9tb3JlT3B0aW9ucy5hbGlnbm1lbnQudjtcclxuICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLl9hbmltYXRvcnNEYXRhO1xyXG4gICAgdmFyIHRleHREYXRhID0gdGhpcy5fdGV4dERhdGE7XHJcbiAgICB2YXIgbWF0cml4SGVscGVyID0gdGhpcy5tSGVscGVyO1xyXG4gICAgdmFyIHJlbmRlclR5cGUgPSB0aGlzLl9yZW5kZXJUeXBlO1xyXG4gICAgdmFyIHJlbmRlcmVkTGV0dGVyc0NvdW50ID0gdGhpcy5yZW5kZXJlZExldHRlcnMubGVuZ3RoO1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICB2YXIgeFBvcyx5UG9zO1xyXG4gICAgdmFyIGksIGxlbjtcclxuICAgIHZhciBsZXR0ZXJzID0gZG9jdW1lbnREYXRhLmwsIHBhdGhJbmZvLCBjdXJyZW50TGVuZ3RoLCBjdXJyZW50UG9pbnQsIHNlZ21lbnRMZW5ndGgsIGZsYWcsIHBvaW50SW5kLCBzZWdtZW50SW5kLCBwcmV2UG9pbnQsIHBvaW50cywgc2VnbWVudHMsIHBhcnRpYWxMZW5ndGgsIHRvdGFsTGVuZ3RoLCBwZXJjLCB0YW5BbmdsZSwgbWFzaztcclxuICAgIGlmKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcclxuICAgICAgICBtYXNrID0gdGhpcy5fcGF0aERhdGEubTtcclxuICAgICAgICBpZighdGhpcy5fcGF0aERhdGEubiB8fCB0aGlzLl9wYXRoRGF0YS5fbWRmKXtcclxuICAgICAgICAgICAgdmFyIHBhdGhzID0gbWFzay52O1xyXG4gICAgICAgICAgICBpZih0aGlzLl9wYXRoRGF0YS5yKXtcclxuICAgICAgICAgICAgICAgIHBhdGhzID0gcGF0aHMucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbGVhc2UgYmV6aWVyIGRhdGEgY2FjaGVkIGZyb20gcHJldmlvdXMgcGF0aEluZm86IHRoaXMuX3BhdGhEYXRhLnBpXHJcbiAgICAgICAgICAgIHBhdGhJbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgdExlbmd0aDogMCxcclxuICAgICAgICAgICAgICAgIHNlZ21lbnRzOiBbXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBsZW4gPSBwYXRocy5fbGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgdmFyIHBhdGhEYXRhO1xyXG4gICAgICAgICAgICB0b3RhbExlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgcGF0aERhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgczogcGF0aHMudltpXSxcclxuICAgICAgICAgICAgICAgICAgICBlOiBwYXRocy52W2kgKyAxXSxcclxuICAgICAgICAgICAgICAgICAgICB0bzogW3BhdGhzLm9baV1bMF0gLSBwYXRocy52W2ldWzBdLCBwYXRocy5vW2ldWzFdIC0gcGF0aHMudltpXVsxXV0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGk6IFtwYXRocy5pW2kgKyAxXVswXSAtIHBhdGhzLnZbaSArIDFdWzBdLCBwYXRocy5pW2kgKyAxXVsxXSAtIHBhdGhzLnZbaSArIDFdWzFdXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGJlei5idWlsZEJlemllckRhdGEocGF0aERhdGEpO1xyXG4gICAgICAgICAgICAgICAgcGF0aEluZm8udExlbmd0aCArPSBwYXRoRGF0YS5iZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBwYXRoSW5mby5zZWdtZW50cy5wdXNoKHBhdGhEYXRhKTtcclxuICAgICAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IHBhdGhEYXRhLmJlemllckRhdGEuc2VnbWVudExlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gbGVuO1xyXG4gICAgICAgICAgICBpZiAobWFzay52LmMpIHtcclxuICAgICAgICAgICAgICAgIHBhdGhEYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHM6IHBhdGhzLnZbaV0sXHJcbiAgICAgICAgICAgICAgICAgICAgZTogcGF0aHMudlswXSxcclxuICAgICAgICAgICAgICAgICAgICB0bzogW3BhdGhzLm9baV1bMF0gLSBwYXRocy52W2ldWzBdLCBwYXRocy5vW2ldWzFdIC0gcGF0aHMudltpXVsxXV0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGk6IFtwYXRocy5pWzBdWzBdIC0gcGF0aHMudlswXVswXSwgcGF0aHMuaVswXVsxXSAtIHBhdGhzLnZbMF1bMV1dXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgYmV6LmJ1aWxkQmV6aWVyRGF0YShwYXRoRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBwYXRoSW5mby50TGVuZ3RoICs9IHBhdGhEYXRhLmJlemllckRhdGEuc2VnbWVudExlbmd0aDtcclxuICAgICAgICAgICAgICAgIHBhdGhJbmZvLnNlZ21lbnRzLnB1c2gocGF0aERhdGEpO1xyXG4gICAgICAgICAgICAgICAgdG90YWxMZW5ndGggKz0gcGF0aERhdGEuYmV6aWVyRGF0YS5zZWdtZW50TGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3BhdGhEYXRhLnBpID0gcGF0aEluZm87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhdGhJbmZvID0gdGhpcy5fcGF0aERhdGEucGk7XHJcblxyXG4gICAgICAgIGN1cnJlbnRMZW5ndGggPSB0aGlzLl9wYXRoRGF0YS5mLnY7XHJcbiAgICAgICAgc2VnbWVudEluZCA9IDA7XHJcbiAgICAgICAgcG9pbnRJbmQgPSAxO1xyXG4gICAgICAgIHNlZ21lbnRMZW5ndGggPSAwO1xyXG4gICAgICAgIGZsYWcgPSB0cnVlO1xyXG4gICAgICAgIHNlZ21lbnRzID0gcGF0aEluZm8uc2VnbWVudHM7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRMZW5ndGggPCAwICYmIG1hc2sudi5jKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXRoSW5mby50TGVuZ3RoIDwgTWF0aC5hYnMoY3VycmVudExlbmd0aCkpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggPSAtTWF0aC5hYnMoY3VycmVudExlbmd0aCkgJSBwYXRoSW5mby50TGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNlZ21lbnRJbmQgPSBzZWdtZW50cy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICBwb2ludHMgPSBzZWdtZW50c1tzZWdtZW50SW5kXS5iZXppZXJEYXRhLnBvaW50cztcclxuICAgICAgICAgICAgcG9pbnRJbmQgPSBwb2ludHMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRMZW5ndGggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IHBvaW50c1twb2ludEluZF0ucGFydGlhbExlbmd0aDtcclxuICAgICAgICAgICAgICAgIHBvaW50SW5kIC09IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRJbmQgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudEluZCAtPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50cyA9IHNlZ21lbnRzW3NlZ21lbnRJbmRdLmJlemllckRhdGEucG9pbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50SW5kID0gcG9pbnRzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvaW50cyA9IHNlZ21lbnRzW3NlZ21lbnRJbmRdLmJlemllckRhdGEucG9pbnRzO1xyXG4gICAgICAgIHByZXZQb2ludCA9IHBvaW50c1twb2ludEluZCAtIDFdO1xyXG4gICAgICAgIGN1cnJlbnRQb2ludCA9IHBvaW50c1twb2ludEluZF07XHJcbiAgICAgICAgcGFydGlhbExlbmd0aCA9IGN1cnJlbnRQb2ludC5wYXJ0aWFsTGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBsZW4gPSBsZXR0ZXJzLmxlbmd0aDtcclxuICAgIHhQb3MgPSAwO1xyXG4gICAgeVBvcyA9IDA7XHJcbiAgICB2YXIgeU9mZiA9IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKiAxLjIgKiAwLjcxNDtcclxuICAgIHZhciBmaXJzdExpbmUgPSB0cnVlO1xyXG4gICAgdmFyIGFuaW1hdG9yUHJvcHMsIGFuaW1hdG9yU2VsZWN0b3I7XHJcbiAgICB2YXIgaiwgakxlbjtcclxuICAgIHZhciBsZXR0ZXJWYWx1ZTtcclxuXHJcbiAgICBqTGVuID0gYW5pbWF0b3JzLmxlbmd0aDtcclxuICAgIHZhciBsYXN0TGV0dGVyO1xyXG5cclxuICAgIHZhciBtdWx0LCBpbmQgPSAtMSwgb2ZmZiwgeFBhdGhQb3MsIHlQYXRoUG9zO1xyXG4gICAgdmFyIGluaXRQYXRoUG9zID0gY3VycmVudExlbmd0aCxpbml0U2VnbWVudEluZCA9IHNlZ21lbnRJbmQsIGluaXRQb2ludEluZCA9IHBvaW50SW5kLCBjdXJyZW50TGluZSA9IC0xO1xyXG4gICAgdmFyIGVsZW1PcGFjaXR5O1xyXG4gICAgdmFyIHNjLHN3LGZjLGs7XHJcbiAgICB2YXIgbGluZUxlbmd0aCA9IDA7XHJcbiAgICB2YXIgbGV0dGVyU3csIGxldHRlclNjLCBsZXR0ZXJGYywgbGV0dGVyTSA9ICcnLCBsZXR0ZXJQID0gdGhpcy5kZWZhdWx0UHJvcHNBcnJheSwgbGV0dGVyTztcclxuXHJcbiAgICAvL1xyXG4gICAgaWYoZG9jdW1lbnREYXRhLmogPT09IDIgfHwgZG9jdW1lbnREYXRhLmogPT09IDEpIHtcclxuICAgICAgICB2YXIgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gMDtcclxuICAgICAgICB2YXIgYW5pbWF0b3JGaXJzdENoYXJPZmZzZXQgPSAwO1xyXG4gICAgICAgIHZhciBqdXN0aWZ5T2Zmc2V0TXVsdCA9IGRvY3VtZW50RGF0YS5qID09PSAyID8gLTAuNSA6IC0xO1xyXG4gICAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xyXG4gICAgICAgIHZhciBpc05ld0xpbmUgPSB0cnVlO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgaWYgKGxldHRlcnNbaV0ubikge1xyXG4gICAgICAgICAgICAgICAgaWYoYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ICs9IGFuaW1hdG9yRmlyc3RDaGFyT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGxhc3RJbmRleCA8IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXR0ZXJzW2xhc3RJbmRleF0uYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RJbmRleCArPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gMDtcclxuICAgICAgICAgICAgICAgIGlzTmV3TGluZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0b3JQcm9wcyA9IGFuaW1hdG9yc1tqXS5hO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLnQucHJvcFR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmV3TGluZSAmJiBkb2N1bWVudERhdGEuaiA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0b3JGaXJzdENoYXJPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBqdXN0aWZ5T2Zmc2V0TXVsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRvckp1c3RpZnlPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy50LnYqbXVsdFswXSAqIGp1c3RpZnlPZmZzZXRNdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMudC52Km11bHQgKiBqdXN0aWZ5T2Zmc2V0TXVsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlzTmV3TGluZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGFuaW1hdG9ySnVzdGlmeU9mZnNldCkge1xyXG4gICAgICAgICAgICBhbmltYXRvckp1c3RpZnlPZmZzZXQgKz0gYW5pbWF0b3JGaXJzdENoYXJPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlKGxhc3RJbmRleCA8IGkpIHtcclxuICAgICAgICAgICAgbGV0dGVyc1tsYXN0SW5kZXhdLmFuaW1hdG9ySnVzdGlmeU9mZnNldCA9IGFuaW1hdG9ySnVzdGlmeU9mZnNldDtcclxuICAgICAgICAgICAgbGFzdEluZGV4ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy9cclxuXHJcbiAgICBmb3IoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuXHJcbiAgICAgICAgbWF0cml4SGVscGVyLnJlc2V0KCk7XHJcbiAgICAgICAgZWxlbU9wYWNpdHkgPSAxO1xyXG4gICAgICAgIGlmKGxldHRlcnNbaV0ubikge1xyXG4gICAgICAgICAgICB4UG9zID0gMDtcclxuICAgICAgICAgICAgeVBvcyArPSBkb2N1bWVudERhdGEueU9mZnNldDtcclxuICAgICAgICAgICAgeVBvcyArPSBmaXJzdExpbmUgPyAxIDogMDtcclxuICAgICAgICAgICAgY3VycmVudExlbmd0aCA9IGluaXRQYXRoUG9zIDtcclxuICAgICAgICAgICAgZmlyc3RMaW5lID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxpbmVMZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBpZih0aGlzLl9oYXNNYXNrZWRQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdtZW50SW5kID0gaW5pdFNlZ21lbnRJbmQ7XHJcbiAgICAgICAgICAgICAgICBwb2ludEluZCA9IGluaXRQb2ludEluZDtcclxuICAgICAgICAgICAgICAgIHBvaW50cyA9IHNlZ21lbnRzW3NlZ21lbnRJbmRdLmJlemllckRhdGEucG9pbnRzO1xyXG4gICAgICAgICAgICAgICAgcHJldlBvaW50ID0gcG9pbnRzW3BvaW50SW5kIC0gMV07XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnQgPSBwb2ludHNbcG9pbnRJbmRdO1xyXG4gICAgICAgICAgICAgICAgcGFydGlhbExlbmd0aCA9IGN1cnJlbnRQb2ludC5wYXJ0aWFsTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgc2VnbWVudExlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0dGVyTyA9IGxldHRlclN3ID0gbGV0dGVyRmMgPSBsZXR0ZXJNID0gJyc7XHJcbiAgICAgICAgICAgIGxldHRlclAgPSB0aGlzLmRlZmF1bHRQcm9wc0FycmF5O1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICBpZih0aGlzLl9oYXNNYXNrZWRQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICBpZihjdXJyZW50TGluZSAhPT0gbGV0dGVyc1tpXS5saW5lKXtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goZG9jdW1lbnREYXRhLmope1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IHRvdGFsTGVuZ3RoIC0gZG9jdW1lbnREYXRhLmxpbmVXaWR0aHNbbGV0dGVyc1tpXS5saW5lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9ICh0b3RhbExlbmd0aCAtIGRvY3VtZW50RGF0YS5saW5lV2lkdGhzW2xldHRlcnNbaV0ubGluZV0pLzI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExpbmUgPSBsZXR0ZXJzW2ldLmxpbmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kICE9PSBsZXR0ZXJzW2ldLmluZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZXR0ZXJzW2luZF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBsZXR0ZXJzW2luZF0uZXh0cmE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gbGV0dGVyc1tpXS5hbiAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kID0gbGV0dGVyc1tpXS5pbmQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IGFsaWdubWVudFswXSAqIGxldHRlcnNbaV0uYW4gLyAyMDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0b3JPZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5wLnByb3BUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSx0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG11bHQubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdG9yT2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMucC52WzBdICogbXVsdFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0b3JPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy5wLnZbMF0gKiBtdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5hLnByb3BUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSx0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG11bHQubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdG9yT2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMuYS52WzBdICogbXVsdFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0b3JPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy5hLnZbMF0gKiBtdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGZsYWcpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnbWVudExlbmd0aCArIHBhcnRpYWxMZW5ndGggPj0gY3VycmVudExlbmd0aCArIGFuaW1hdG9yT2Zmc2V0IHx8ICFwb2ludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyYyA9IChjdXJyZW50TGVuZ3RoICsgYW5pbWF0b3JPZmZzZXQgLSBzZWdtZW50TGVuZ3RoKSAvIGN1cnJlbnRQb2ludC5wYXJ0aWFsTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4UGF0aFBvcyA9IHByZXZQb2ludC5wb2ludFswXSArIChjdXJyZW50UG9pbnQucG9pbnRbMF0gLSBwcmV2UG9pbnQucG9pbnRbMF0pICogcGVyYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgeVBhdGhQb3MgPSBwcmV2UG9pbnQucG9pbnRbMV0gKyAoY3VycmVudFBvaW50LnBvaW50WzFdIC0gcHJldlBvaW50LnBvaW50WzFdKSAqIHBlcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoLWFsaWdubWVudFswXSpsZXR0ZXJzW2ldLmFuLzIwMCwgLShhbGlnbm1lbnRbMV0gKiB5T2ZmIC8gMTAwKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50TGVuZ3RoICs9IGN1cnJlbnRQb2ludC5wYXJ0aWFsTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRJbmQgPj0gcG9pbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudEluZCArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWdtZW50c1tzZWdtZW50SW5kXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrLnYuYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludEluZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZ21lbnRJbmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBzZWdtZW50c1tzZWdtZW50SW5kXS5iZXppZXJEYXRhLnBvaW50cztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50TGVuZ3RoIC09IGN1cnJlbnRQb2ludC5wYXJ0aWFsTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0uYmV6aWVyRGF0YS5wb2ludHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldlBvaW50ID0gY3VycmVudFBvaW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFBvaW50ID0gcG9pbnRzW3BvaW50SW5kXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxMZW5ndGggPSBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9mZmYgPSBsZXR0ZXJzW2ldLmFuIC8gMiAtIGxldHRlcnNbaV0uYWRkO1xyXG4gICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgtb2ZmZiwgMCwgMCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvZmZmID0gbGV0dGVyc1tpXS5hbi8yIC0gbGV0dGVyc1tpXS5hZGQ7XHJcbiAgICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1vZmZmLDAsMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR3JvdXBpbmcgYWxpZ25tZW50XHJcbiAgICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKC1hbGlnbm1lbnRbMF0qbGV0dGVyc1tpXS5hbi8yMDAsIC1hbGlnbm1lbnRbMV0qeU9mZi8xMDAsIDApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsaW5lTGVuZ3RoICs9IGxldHRlcnNbaV0ubC8yO1xyXG4gICAgICAgICAgICBmb3Ioaj0wO2o8akxlbjtqKz0xKXtcclxuICAgICAgICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcclxuICAgICAgICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLnQucHJvcFR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSx0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9UaGlzIGNvbmRpdGlvbiBpcyB0byBwcmV2ZW50IGFwcGx5aW5nIHRyYWNraW5nIHRvIGZpcnN0IGNoYXJhY3RlciBpbiBlYWNoIGxpbmUuIE1pZ2h0IGJlIGJldHRlciB0byB1c2UgYSBib29sZWFuIFwiaXNOZXdMaW5lXCJcclxuICAgICAgICAgICAgICAgICAgICBpZih4UG9zICE9PSAwIHx8IGRvY3VtZW50RGF0YS5qICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBhbmltYXRvclByb3BzLnQudiptdWx0WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IGFuaW1hdG9yUHJvcHMudC52Km11bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4UG9zICs9IGFuaW1hdG9yUHJvcHMudC52Km11bHRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhQb3MgKz0gYW5pbWF0b3JQcm9wcy50LnYqbXVsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaW5lTGVuZ3RoICs9IGxldHRlcnNbaV0ubC8yO1xyXG4gICAgICAgICAgICBpZihkb2N1bWVudERhdGEuc3Ryb2tlV2lkdGhBbmltKSB7XHJcbiAgICAgICAgICAgICAgICBzdyA9IGRvY3VtZW50RGF0YS5zdyB8fCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGRvY3VtZW50RGF0YS5zdHJva2VDb2xvckFuaW0pIHtcclxuICAgICAgICAgICAgICAgIGlmKGRvY3VtZW50RGF0YS5zYyl7XHJcbiAgICAgICAgICAgICAgICAgICAgc2MgPSBbZG9jdW1lbnREYXRhLnNjWzBdLCBkb2N1bWVudERhdGEuc2NbMV0sIGRvY3VtZW50RGF0YS5zY1syXV07XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBzYyA9IFswLDAsMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZG9jdW1lbnREYXRhLmZpbGxDb2xvckFuaW0gJiYgZG9jdW1lbnREYXRhLmZjKSB7XHJcbiAgICAgICAgICAgICAgICBmYyA9IFtkb2N1bWVudERhdGEuZmNbMF0sIGRvY3VtZW50RGF0YS5mY1sxXSwgZG9jdW1lbnREYXRhLmZjWzJdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3Ioaj0wO2o8akxlbjtqKz0xKXtcclxuICAgICAgICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcclxuICAgICAgICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLmEucHJvcFR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSx0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKG11bHQubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgtYW5pbWF0b3JQcm9wcy5hLnZbMF0qbXVsdFswXSwgLWFuaW1hdG9yUHJvcHMuYS52WzFdKm11bHRbMV0sIGFuaW1hdG9yUHJvcHMuYS52WzJdKm11bHRbMl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoLWFuaW1hdG9yUHJvcHMuYS52WzBdKm11bHQsIC1hbmltYXRvclByb3BzLmEudlsxXSptdWx0LCBhbmltYXRvclByb3BzLmEudlsyXSptdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yKGo9MDtqPGpMZW47ais9MSl7XHJcbiAgICAgICAgICAgICAgICBhbmltYXRvclByb3BzID0gYW5pbWF0b3JzW2pdLmE7XHJcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5zLnByb3BUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xyXG4gICAgICAgICAgICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG11bHQubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnNjYWxlKDErKChhbmltYXRvclByb3BzLnMudlswXS0xKSptdWx0WzBdKSwxKygoYW5pbWF0b3JQcm9wcy5zLnZbMV0tMSkqbXVsdFsxXSksMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnNjYWxlKDErKChhbmltYXRvclByb3BzLnMudlswXS0xKSptdWx0KSwxKygoYW5pbWF0b3JQcm9wcy5zLnZbMV0tMSkqbXVsdCksMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvcihqPTA7ajxqTGVuO2orPTEpIHtcclxuICAgICAgICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcclxuICAgICAgICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcclxuICAgICAgICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuc2sucHJvcFR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihtdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIuc2tld0Zyb21BeGlzKC1hbmltYXRvclByb3BzLnNrLnYgKiBtdWx0WzBdLCBhbmltYXRvclByb3BzLnNhLnYgKiBtdWx0WzFdKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIuc2tld0Zyb21BeGlzKC1hbmltYXRvclByb3BzLnNrLnYgKiBtdWx0LCBhbmltYXRvclByb3BzLnNhLnYgKiBtdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5yLnByb3BUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVooLWFuaW1hdG9yUHJvcHMuci52ICogbXVsdFsyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVooLWFuaW1hdG9yUHJvcHMuci52ICogbXVsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMucnkucHJvcFR5cGUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVkoYW5pbWF0b3JQcm9wcy5yeS52Km11bHRbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlWShhbmltYXRvclByb3BzLnJ5LnYqbXVsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMucngucHJvcFR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihtdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlWChhbmltYXRvclByb3BzLnJ4LnYqbXVsdFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVgoYW5pbWF0b3JQcm9wcy5yeC52Km11bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLm8ucHJvcFR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihtdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtT3BhY2l0eSArPSAoKGFuaW1hdG9yUHJvcHMuby52KSptdWx0WzBdIC0gZWxlbU9wYWNpdHkpKm11bHRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbU9wYWNpdHkgKz0gKChhbmltYXRvclByb3BzLm8udikqbXVsdCAtIGVsZW1PcGFjaXR5KSptdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlV2lkdGhBbmltICYmIGFuaW1hdG9yUHJvcHMuc3cucHJvcFR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihtdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdyArPSBhbmltYXRvclByb3BzLnN3LnYqbXVsdFswXTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdyArPSBhbmltYXRvclByb3BzLnN3LnYqbXVsdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnREYXRhLnN0cm9rZUNvbG9yQW5pbSAmJiBhbmltYXRvclByb3BzLnNjLnByb3BUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGs9MDtrPDM7ays9MSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY1trXSA9IHNjW2tdICsgKGFuaW1hdG9yUHJvcHMuc2MudltrXSAtIHNjW2tdKSptdWx0WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nba10gPSBzY1trXSArIChhbmltYXRvclByb3BzLnNjLnZba10gLSBzY1trXSkqbXVsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudERhdGEuZmlsbENvbG9yQW5pbSAmJiBkb2N1bWVudERhdGEuZmMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihhbmltYXRvclByb3BzLmZjLnByb3BUeXBlKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGs9MDtrPDM7ays9MSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihtdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZjW2tdID0gZmNba10gKyAoYW5pbWF0b3JQcm9wcy5mYy52W2tdIC0gZmNba10pKm11bHRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZjW2tdID0gZmNba10gKyAoYW5pbWF0b3JQcm9wcy5mYy52W2tdIC0gZmNba10pKm11bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYW5pbWF0b3JQcm9wcy5maC5wcm9wVHlwZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG11bHQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYyA9IGFkZEh1ZVRvUkdCKGZjLGFuaW1hdG9yUHJvcHMuZmgudiptdWx0WzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZjID0gYWRkSHVlVG9SR0IoZmMsYW5pbWF0b3JQcm9wcy5maC52Km11bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGFuaW1hdG9yUHJvcHMuZnMucHJvcFR5cGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmMgPSBhZGRTYXR1cmF0aW9uVG9SR0IoZmMsYW5pbWF0b3JQcm9wcy5mcy52Km11bHRbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmMgPSBhZGRTYXR1cmF0aW9uVG9SR0IoZmMsYW5pbWF0b3JQcm9wcy5mcy52Km11bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGFuaW1hdG9yUHJvcHMuZmIucHJvcFR5cGUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmMgPSBhZGRCcmlnaHRuZXNzVG9SR0IoZmMsYW5pbWF0b3JQcm9wcy5mYi52Km11bHRbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmMgPSBhZGRCcmlnaHRuZXNzVG9SR0IoZmMsYW5pbWF0b3JQcm9wcy5mYi52Km11bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3Ioaj0wO2o8akxlbjtqKz0xKXtcclxuICAgICAgICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5wLnByb3BUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xyXG4gICAgICAgICAgICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobXVsdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgYW5pbWF0b3JQcm9wcy5wLnZbMV0gKiBtdWx0WzBdLCAtYW5pbWF0b3JQcm9wcy5wLnZbMl0gKiBtdWx0WzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgYW5pbWF0b3JQcm9wcy5wLnZbMV0gKiBtdWx0LCAtYW5pbWF0b3JQcm9wcy5wLnZbMl0gKiBtdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihtdWx0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShhbmltYXRvclByb3BzLnAudlswXSAqIG11bHRbMF0sIGFuaW1hdG9yUHJvcHMucC52WzFdICogbXVsdFsxXSwgLWFuaW1hdG9yUHJvcHMucC52WzJdICogbXVsdFsyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKGFuaW1hdG9yUHJvcHMucC52WzBdICogbXVsdCwgYW5pbWF0b3JQcm9wcy5wLnZbMV0gKiBtdWx0LCAtYW5pbWF0b3JQcm9wcy5wLnZbMl0gKiBtdWx0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoZG9jdW1lbnREYXRhLnN0cm9rZVdpZHRoQW5pbSl7XHJcbiAgICAgICAgICAgICAgICBsZXR0ZXJTdyA9IHN3IDwgMCA/IDAgOiBzdztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihkb2N1bWVudERhdGEuc3Ryb2tlQ29sb3JBbmltKXtcclxuICAgICAgICAgICAgICAgIGxldHRlclNjID0gJ3JnYignK01hdGgucm91bmQoc2NbMF0qMjU1KSsnLCcrTWF0aC5yb3VuZChzY1sxXSoyNTUpKycsJytNYXRoLnJvdW5kKHNjWzJdKjI1NSkrJyknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKGRvY3VtZW50RGF0YS5maWxsQ29sb3JBbmltICYmIGRvY3VtZW50RGF0YS5mYyl7XHJcbiAgICAgICAgICAgICAgICBsZXR0ZXJGYyA9ICdyZ2IoJytNYXRoLnJvdW5kKGZjWzBdKjI1NSkrJywnK01hdGgucm91bmQoZmNbMV0qMjU1KSsnLCcrTWF0aC5yb3VuZChmY1syXSoyNTUpKycpJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYodGhpcy5faGFzTWFza2VkUGF0aCkge1xyXG4gICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgwLC1kb2N1bWVudERhdGEubHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgYWxpZ25tZW50WzFdKnlPZmYvMTAwICsgeVBvcywwKTtcclxuICAgICAgICAgICAgICAgIGlmICh0ZXh0RGF0YS5wLnApIHtcclxuICAgICAgICAgICAgICAgICAgICB0YW5BbmdsZSA9IChjdXJyZW50UG9pbnQucG9pbnRbMV0gLSBwcmV2UG9pbnQucG9pbnRbMV0pIC8gKGN1cnJlbnRQb2ludC5wb2ludFswXSAtIHByZXZQb2ludC5wb2ludFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvdCA9IE1hdGguYXRhbih0YW5BbmdsZSkgKiAxODAgLyBNYXRoLlBJO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UG9pbnQucG9pbnRbMF0gPCBwcmV2UG9pbnQucG9pbnRbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm90ICs9IDE4MDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZSgtcm90ICogTWF0aC5QSSAvIDE4MCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKHhQYXRoUG9zLCB5UGF0aFBvcywgMCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50TGVuZ3RoIC09IGFsaWdubWVudFswXSpsZXR0ZXJzW2ldLmFuLzIwMDtcclxuICAgICAgICAgICAgICAgIGlmKGxldHRlcnNbaSsxXSAmJiBpbmQgIT09IGxldHRlcnNbaSsxXS5pbmQpe1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gbGV0dGVyc1tpXS5hbiAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBkb2N1bWVudERhdGEudHIvMTAwMCpkb2N1bWVudERhdGEuZmluYWxTaXplO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9ZWxzZXtcclxuXHJcbiAgICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKHhQb3MseVBvcywwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihkb2N1bWVudERhdGEucHMpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vbWF0cml4SGVscGVyLnRyYW5zbGF0ZShkb2N1bWVudERhdGEucHNbMF0sZG9jdW1lbnREYXRhLnBzWzFdLDApO1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLnBzWzBdLGRvY3VtZW50RGF0YS5wc1sxXSArIGRvY3VtZW50RGF0YS5hc2NlbnQsMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2goZG9jdW1lbnREYXRhLmope1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShsZXR0ZXJzW2ldLmFuaW1hdG9ySnVzdGlmeU9mZnNldCArIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ICsgKGRvY3VtZW50RGF0YS5ib3hXaWR0aCAtIGRvY3VtZW50RGF0YS5saW5lV2lkdGhzW2xldHRlcnNbaV0ubGluZV0pLDAsMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShsZXR0ZXJzW2ldLmFuaW1hdG9ySnVzdGlmeU9mZnNldCArIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ICsgKGRvY3VtZW50RGF0YS5ib3hXaWR0aCAtIGRvY3VtZW50RGF0YS5saW5lV2lkdGhzW2xldHRlcnNbaV0ubGluZV0pLzIsMCwwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKDAsLWRvY3VtZW50RGF0YS5scyk7XHJcbiAgICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKG9mZmYsMCwwKTtcclxuICAgICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoYWxpZ25tZW50WzBdKmxldHRlcnNbaV0uYW4vMjAwLGFsaWdubWVudFsxXSp5T2ZmLzEwMCwwKTtcclxuICAgICAgICAgICAgICAgIHhQb3MgKz0gbGV0dGVyc1tpXS5sICsgZG9jdW1lbnREYXRhLnRyLzEwMDAqZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihyZW5kZXJUeXBlID09PSAnaHRtbCcpe1xyXG4gICAgICAgICAgICAgICAgbGV0dGVyTSA9IG1hdHJpeEhlbHBlci50b0NTUygpO1xyXG4gICAgICAgICAgICB9ZWxzZSBpZihyZW5kZXJUeXBlID09PSAnc3ZnJyl7XHJcbiAgICAgICAgICAgICAgICBsZXR0ZXJNID0gbWF0cml4SGVscGVyLnRvMmRDU1MoKTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBsZXR0ZXJQID0gW21hdHJpeEhlbHBlci5wcm9wc1swXSxtYXRyaXhIZWxwZXIucHJvcHNbMV0sbWF0cml4SGVscGVyLnByb3BzWzJdLG1hdHJpeEhlbHBlci5wcm9wc1szXSxtYXRyaXhIZWxwZXIucHJvcHNbNF0sbWF0cml4SGVscGVyLnByb3BzWzVdLG1hdHJpeEhlbHBlci5wcm9wc1s2XSxtYXRyaXhIZWxwZXIucHJvcHNbN10sbWF0cml4SGVscGVyLnByb3BzWzhdLG1hdHJpeEhlbHBlci5wcm9wc1s5XSxtYXRyaXhIZWxwZXIucHJvcHNbMTBdLG1hdHJpeEhlbHBlci5wcm9wc1sxMV0sbWF0cml4SGVscGVyLnByb3BzWzEyXSxtYXRyaXhIZWxwZXIucHJvcHNbMTNdLG1hdHJpeEhlbHBlci5wcm9wc1sxNF0sbWF0cml4SGVscGVyLnByb3BzWzE1XV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0dGVyTyA9IGVsZW1PcGFjaXR5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYocmVuZGVyZWRMZXR0ZXJzQ291bnQgPD0gaSkge1xyXG4gICAgICAgICAgICBsZXR0ZXJWYWx1ZSA9IG5ldyBMZXR0ZXJQcm9wcyhsZXR0ZXJPLGxldHRlclN3LGxldHRlclNjLGxldHRlckZjLGxldHRlck0sbGV0dGVyUCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZWRMZXR0ZXJzLnB1c2gobGV0dGVyVmFsdWUpO1xyXG4gICAgICAgICAgICByZW5kZXJlZExldHRlcnNDb3VudCArPSAxO1xyXG4gICAgICAgICAgICB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0dGVyVmFsdWUgPSB0aGlzLnJlbmRlcmVkTGV0dGVyc1tpXTtcclxuICAgICAgICAgICAgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgPSBsZXR0ZXJWYWx1ZS51cGRhdGUobGV0dGVyTywgbGV0dGVyU3csIGxldHRlclNjLCBsZXR0ZXJGYywgbGV0dGVyTSwgbGV0dGVyUCkgfHwgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuVGV4dEFuaW1hdG9yUHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oKXtcclxuXHRpZih0aGlzLl9lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5fZnJhbWVJZCl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fZnJhbWVJZCA9IHRoaXMuX2VsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xyXG4gICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcclxufTtcclxuXHJcblRleHRBbmltYXRvclByb3BlcnR5LnByb3RvdHlwZS5tSGVscGVyID0gbmV3IE1hdHJpeCgpO1xyXG5UZXh0QW5pbWF0b3JQcm9wZXJ0eS5wcm90b3R5cGUuZGVmYXVsdFByb3BzQXJyYXkgPSBbXTtcclxuZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBUZXh0QW5pbWF0b3JQcm9wZXJ0eSk7XG5mdW5jdGlvbiBUZXh0QW5pbWF0b3JEYXRhUHJvcGVydHkoZWxlbSwgYW5pbWF0b3JQcm9wcywgY29udGFpbmVyKSB7XHJcblx0dmFyIGRlZmF1bHREYXRhID0ge3Byb3BUeXBlOmZhbHNlfTtcclxuXHR2YXIgZ2V0UHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wO1xyXG5cdHZhciB0ZXh0QW5pbWF0b3JfYW5pbWF0YWJsZXMgPSBhbmltYXRvclByb3BzLmE7XHJcblx0dGhpcy5hID0ge1xyXG5cdFx0cjogdGV4dEFuaW1hdG9yX2FuaW1hdGFibGVzLnIgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvcl9hbmltYXRhYmxlcy5yLCAwLCBkZWdUb1JhZHMsIGNvbnRhaW5lcikgOiBkZWZhdWx0RGF0YSxcclxuXHRcdHJ4OiB0ZXh0QW5pbWF0b3JfYW5pbWF0YWJsZXMucnggPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvcl9hbmltYXRhYmxlcy5yeCwgMCwgZGVnVG9SYWRzLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcblx0XHRyeTogdGV4dEFuaW1hdG9yX2FuaW1hdGFibGVzLnJ5ID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JfYW5pbWF0YWJsZXMucnksIDAsIGRlZ1RvUmFkcywgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG5cdFx0c2s6IHRleHRBbmltYXRvcl9hbmltYXRhYmxlcy5zayA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yX2FuaW1hdGFibGVzLnNrLCAwLCBkZWdUb1JhZHMsIGNvbnRhaW5lcikgOiBkZWZhdWx0RGF0YSxcclxuXHRcdHNhOiB0ZXh0QW5pbWF0b3JfYW5pbWF0YWJsZXMuc2EgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvcl9hbmltYXRhYmxlcy5zYSwgMCwgZGVnVG9SYWRzLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcblx0XHRzOiB0ZXh0QW5pbWF0b3JfYW5pbWF0YWJsZXMucyA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yX2FuaW1hdGFibGVzLnMsIDEsIDAuMDEsIGNvbnRhaW5lcikgOiBkZWZhdWx0RGF0YSxcclxuXHRcdGE6IHRleHRBbmltYXRvcl9hbmltYXRhYmxlcy5hID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JfYW5pbWF0YWJsZXMuYSwgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG5cdFx0bzogdGV4dEFuaW1hdG9yX2FuaW1hdGFibGVzLm8gPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvcl9hbmltYXRhYmxlcy5vLCAwLCAwLjAxLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcblx0XHRwOiB0ZXh0QW5pbWF0b3JfYW5pbWF0YWJsZXMucCA/IGdldFByb3AoZWxlbSx0ZXh0QW5pbWF0b3JfYW5pbWF0YWJsZXMucCwgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG5cdFx0c3c6IHRleHRBbmltYXRvcl9hbmltYXRhYmxlcy5zdyA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yX2FuaW1hdGFibGVzLnN3LCAwLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcblx0XHRzYzogdGV4dEFuaW1hdG9yX2FuaW1hdGFibGVzLnNjID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JfYW5pbWF0YWJsZXMuc2MsIDEsIDAsIGNvbnRhaW5lcikgOiBkZWZhdWx0RGF0YSxcclxuXHRcdGZjOiB0ZXh0QW5pbWF0b3JfYW5pbWF0YWJsZXMuZmMgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvcl9hbmltYXRhYmxlcy5mYywgMSwgMCwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG5cdFx0Zmg6IHRleHRBbmltYXRvcl9hbmltYXRhYmxlcy5maCA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yX2FuaW1hdGFibGVzLmZoLCAwLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXHJcblx0XHRmczogdGV4dEFuaW1hdG9yX2FuaW1hdGFibGVzLmZzID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JfYW5pbWF0YWJsZXMuZnMsIDAsIDAuMDEsIGNvbnRhaW5lcikgOiBkZWZhdWx0RGF0YSxcclxuXHRcdGZiOiB0ZXh0QW5pbWF0b3JfYW5pbWF0YWJsZXMuZmIgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvcl9hbmltYXRhYmxlcy5mYiwgMCwgMC4wMSwgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxyXG5cdFx0dDogdGV4dEFuaW1hdG9yX2FuaW1hdGFibGVzLnQgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvcl9hbmltYXRhYmxlcy50LCAwLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGFcclxuXHR9O1xyXG5cclxuXHR0aGlzLnMgPSBUZXh0U2VsZWN0b3JQcm9wLmdldFRleHRTZWxlY3RvclByb3AoZWxlbSxhbmltYXRvclByb3BzLnMsIGNvbnRhaW5lcik7XHJcbiAgICB0aGlzLnMudCA9IGFuaW1hdG9yUHJvcHMucy50O1xyXG59XG5mdW5jdGlvbiBMZXR0ZXJQcm9wcyhvLCBzdywgc2MsIGZjLCBtLCBwKXtcclxuICAgIHRoaXMubyA9IG87XHJcbiAgICB0aGlzLnN3ID0gc3c7XHJcbiAgICB0aGlzLnNjID0gc2M7XHJcbiAgICB0aGlzLmZjID0gZmM7XHJcbiAgICB0aGlzLm0gPSBtO1xyXG4gICAgdGhpcy5wID0gcDtcclxuICAgIHRoaXMuX21kZiA9IHtcclxuICAgIFx0bzogdHJ1ZSxcclxuICAgIFx0c3c6ICEhc3csXHJcbiAgICBcdHNjOiAhIXNjLFxyXG4gICAgXHRmYzogISFmYyxcclxuICAgIFx0bTogdHJ1ZSxcclxuICAgIFx0cDogdHJ1ZVxyXG4gICAgfTtcclxufVxyXG5cclxuTGV0dGVyUHJvcHMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKG8sIHN3LCBzYywgZmMsIG0sIHApIHtcclxuXHR0aGlzLl9tZGYubyA9IGZhbHNlO1xyXG5cdHRoaXMuX21kZi5zdyA9IGZhbHNlO1xyXG5cdHRoaXMuX21kZi5zYyA9IGZhbHNlO1xyXG5cdHRoaXMuX21kZi5mYyA9IGZhbHNlO1xyXG5cdHRoaXMuX21kZi5tID0gZmFsc2U7XHJcblx0dGhpcy5fbWRmLnAgPSBmYWxzZTtcclxuXHR2YXIgdXBkYXRlZCA9IGZhbHNlO1xyXG5cclxuXHRpZih0aGlzLm8gIT09IG8pIHtcclxuXHRcdHRoaXMubyA9IG87XHJcblx0XHR0aGlzLl9tZGYubyA9IHRydWU7XHJcblx0XHR1cGRhdGVkID0gdHJ1ZTtcclxuXHR9XHJcblx0aWYodGhpcy5zdyAhPT0gc3cpIHtcclxuXHRcdHRoaXMuc3cgPSBzdztcclxuXHRcdHRoaXMuX21kZi5zdyA9IHRydWU7XHJcblx0XHR1cGRhdGVkID0gdHJ1ZTtcclxuXHR9XHJcblx0aWYodGhpcy5zYyAhPT0gc2MpIHtcclxuXHRcdHRoaXMuc2MgPSBzYztcclxuXHRcdHRoaXMuX21kZi5zYyA9IHRydWU7XHJcblx0XHR1cGRhdGVkID0gdHJ1ZTtcclxuXHR9XHJcblx0aWYodGhpcy5mYyAhPT0gZmMpIHtcclxuXHRcdHRoaXMuZmMgPSBmYztcclxuXHRcdHRoaXMuX21kZi5mYyA9IHRydWU7XHJcblx0XHR1cGRhdGVkID0gdHJ1ZTtcclxuXHR9XHJcblx0aWYodGhpcy5tICE9PSBtKSB7XHJcblx0XHR0aGlzLm0gPSBtO1xyXG5cdFx0dGhpcy5fbWRmLm0gPSB0cnVlO1xyXG5cdFx0dXBkYXRlZCA9IHRydWU7XHJcblx0fVxyXG5cdGlmKHAubGVuZ3RoICYmICh0aGlzLnBbMF0gIT09IHBbMF0gfHwgdGhpcy5wWzFdICE9PSBwWzFdIHx8IHRoaXMucFs0XSAhPT0gcFs0XSB8fCB0aGlzLnBbNV0gIT09IHBbNV0gfHwgdGhpcy5wWzEyXSAhPT0gcFsxMl0gfHwgdGhpcy5wWzEzXSAhPT0gcFsxM10pKSB7XHJcblx0XHR0aGlzLnAgPSBwO1xyXG5cdFx0dGhpcy5fbWRmLnAgPSB0cnVlO1xyXG5cdFx0dXBkYXRlZCA9IHRydWU7XHJcblx0fVxyXG5cdHJldHVybiB1cGRhdGVkO1xyXG59O1xuZnVuY3Rpb24gVGV4dFByb3BlcnR5KGVsZW0sIGRhdGEpe1xyXG5cdHRoaXMuX2ZyYW1lSWQgPSBpbml0aWFsRGVmYXVsdEZyYW1lO1xyXG5cdHRoaXMucHYgPSAnJztcclxuXHR0aGlzLnYgPSAnJztcclxuXHR0aGlzLmtmID0gZmFsc2U7XHJcblx0dGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcclxuXHR0aGlzLl9tZGYgPSBmYWxzZTtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcblx0dGhpcy5lbGVtID0gZWxlbTtcclxuICAgIHRoaXMuY29tcCA9IHRoaXMuZWxlbS5jb21wO1xyXG5cdHRoaXMua2V5c0luZGV4ID0gMDtcclxuICAgIHRoaXMuY2FuUmVzaXplID0gZmFsc2U7XHJcbiAgICB0aGlzLm1pbmltdW1Gb250U2l6ZSA9IDE7XHJcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZSA9IFtdO1xyXG5cdHRoaXMuY3VycmVudERhdGEgPSB7XHJcblx0XHRhc2NlbnQ6IDAsXHJcbiAgICAgICAgYm94V2lkdGg6IHRoaXMuZGVmYXVsdEJveFdpZHRoLFxyXG4gICAgICAgIGY6ICcnLFxyXG4gICAgICAgIGZTdHlsZTogJycsXHJcbiAgICAgICAgZldlaWdodDogJycsXHJcbiAgICAgICAgZmM6ICcnLFxyXG4gICAgICAgIGo6ICcnLFxyXG4gICAgICAgIGp1c3RpZnlPZmZzZXQ6ICcnLFxyXG4gICAgICAgIGw6IFtdLFxyXG4gICAgICAgIGxoOiAwLFxyXG4gICAgICAgIGxpbmVXaWR0aHM6IFtdLFxyXG4gICAgICAgIGxzOiAnJyxcclxuICAgICAgICBvZjogJycsXHJcbiAgICAgICAgczogJycsXHJcbiAgICAgICAgc2M6ICcnLFxyXG4gICAgICAgIHN3OiAwLFxyXG4gICAgICAgIHQ6IDAsXHJcbiAgICAgICAgdHI6IDAsXHJcbiAgICAgICAgc3o6MCxcclxuICAgICAgICBwczpudWxsLFxyXG4gICAgICAgIGZpbGxDb2xvckFuaW06IGZhbHNlLFxyXG4gICAgICAgIHN0cm9rZUNvbG9yQW5pbTogZmFsc2UsXHJcbiAgICAgICAgc3Ryb2tlV2lkdGhBbmltOiBmYWxzZSxcclxuICAgICAgICB5T2Zmc2V0OiAwLFxyXG4gICAgICAgIGZpbmFsU2l6ZTowLFxyXG4gICAgICAgIGZpbmFsVGV4dDpbXSxcclxuICAgICAgICBmaW5hbExpbmVIZWlnaHQ6IDAsXHJcbiAgICAgICAgX19jb21wbGV0ZTogZmFsc2VcclxuXHJcblx0fTtcclxuICAgIHRoaXMuY29weURhdGEodGhpcy5jdXJyZW50RGF0YSwgdGhpcy5kYXRhLmQua1swXS5zKTtcclxuXHJcbiAgICBpZighdGhpcy5zZWFyY2hQcm9wZXJ0eSgpKSB7XHJcbiAgICAgICAgdGhpcy5jb21wbGV0ZVRleHREYXRhKHRoaXMuY3VycmVudERhdGEpO1xyXG4gICAgfVxyXG59XHJcblxyXG5UZXh0UHJvcGVydHkucHJvdG90eXBlLmRlZmF1bHRCb3hXaWR0aCA9IFswLDBdO1xyXG5cclxuVGV4dFByb3BlcnR5LnByb3RvdHlwZS5jb3B5RGF0YSA9IGZ1bmN0aW9uKG9iaiwgZGF0YSkge1xyXG4gICAgZm9yKHZhciBzIGluIGRhdGEpIHtcclxuICAgICAgICBpZihkYXRhLmhhc093blByb3BlcnR5KHMpKSB7XHJcbiAgICAgICAgICAgIG9ialtzXSA9IGRhdGFbc107XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuVGV4dFByb3BlcnR5LnByb3RvdHlwZS5zZXRDdXJyZW50RGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xyXG4gICAgaWYoIWRhdGEuX19jb21wbGV0ZSkge1xyXG4gICAgICAgIHRoaXMuY29tcGxldGVUZXh0RGF0YShkYXRhKTtcclxuICAgIH1cclxuICAgIHRoaXMuY3VycmVudERhdGEgPSBkYXRhO1xyXG4gICAgdGhpcy5jdXJyZW50RGF0YS5ib3hXaWR0aCA9IHRoaXMuY3VycmVudERhdGEuYm94V2lkdGggfHwgdGhpcy5kZWZhdWx0Qm94V2lkdGg7XHJcbiAgICB0aGlzLl9tZGYgPSB0cnVlO1xyXG59O1xyXG5cclxuVGV4dFByb3BlcnR5LnByb3RvdHlwZS5zZWFyY2hQcm9wZXJ0eSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoS2V5ZnJhbWVzKCk7XHJcbn07XHJcblxyXG5UZXh0UHJvcGVydHkucHJvdG90eXBlLnNlYXJjaEtleWZyYW1lcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5rZiA9IHRoaXMuZGF0YS5kLmsubGVuZ3RoID4gMTtcclxuICAgIGlmKHRoaXMua2YpIHtcclxuICAgICAgICB0aGlzLmFkZEVmZmVjdCh0aGlzLmdldEtleWZyYW1lVmFsdWUuYmluZCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5rZjtcclxufVxyXG5cclxuVGV4dFByb3BlcnR5LnByb3RvdHlwZS5hZGRFZmZlY3QgPSBmdW5jdGlvbihlZmZlY3RGdW5jdGlvbikge1xyXG5cdHRoaXMuZWZmZWN0c1NlcXVlbmNlLnB1c2goZWZmZWN0RnVuY3Rpb24pO1xyXG4gICAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcclxufTtcclxuXHJcblRleHRQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbihfZmluYWxWYWx1ZSkge1xyXG4gICAgaWYoKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCB8fCAhdGhpcy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoKSAmJiAhX2ZpbmFsVmFsdWUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgY3VycmVudFZhbHVlID0gdGhpcy5jdXJyZW50RGF0YTtcclxuICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLmtleXNJbmRleDtcclxuICAgIGlmKHRoaXMubG9jaykge1xyXG4gICAgICAgIHRoaXMuc2V0Q3VycmVudERhdGEodGhpcy5jdXJyZW50RGF0YSwgY3VycmVudFRleHRWYWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5sb2NrID0gdHJ1ZTtcclxuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xyXG4gICAgdmFyIG11bHRpcGxpZWRWYWx1ZTtcclxuICAgIHZhciBpLCBsZW4gPSB0aGlzLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGg7XHJcbiAgICB2YXIgZmluYWxWYWx1ZSA9IF9maW5hbFZhbHVlIHx8IHRoaXMuZGF0YS5kLmtbdGhpcy5rZXlzSW5kZXhdLnM7XHJcbiAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgIC8vQ2hlY2tpbmcgaWYgaW5kZXggY2hhbmdlZCB0byBwcmV2ZW50IGNyZWF0aW5nIGEgbmV3IG9iamVjdCBldmVyeSB0aW1lIHRoZSBleHByZXNzaW9uIHVwZGF0ZXMuXHJcbiAgICAgICAgaWYoY3VycmVudEluZGV4ICE9PSB0aGlzLmtleXNJbmRleCkge1xyXG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5lZmZlY3RzU2VxdWVuY2VbaV0oZmluYWxWYWx1ZSwgZmluYWxWYWx1ZS50KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5lZmZlY3RzU2VxdWVuY2VbaV0odGhpcy5jdXJyZW50RGF0YSwgZmluYWxWYWx1ZS50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZihjdXJyZW50VmFsdWUgIT09IGZpbmFsVmFsdWUpIHtcclxuICAgICAgICB0aGlzLnNldEN1cnJlbnREYXRhKGZpbmFsVmFsdWUpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5wdiA9IHRoaXMudiA9IHRoaXMuY3VycmVudERhdGE7XHJcbiAgICB0aGlzLmxvY2sgPSBmYWxzZTtcclxuICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XHJcbn1cclxuXHJcblRleHRQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0S2V5ZnJhbWVWYWx1ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHRleHRLZXlzID0gdGhpcy5kYXRhLmQuaywgdGV4dERvY3VtZW50RGF0YTtcclxuICAgIHZhciBmcmFtZU51bSA9IHRoaXMuZWxlbS5jb21wLnJlbmRlcmVkRnJhbWU7XHJcbiAgICB2YXIgaSA9IDAsIGxlbiA9IHRleHRLZXlzLmxlbmd0aDtcclxuICAgIHdoaWxlKGkgPD0gbGVuIC0gMSkge1xyXG4gICAgICAgIHRleHREb2N1bWVudERhdGEgPSB0ZXh0S2V5c1tpXS5zO1xyXG4gICAgICAgIGlmKGkgPT09IGxlbiAtIDEgfHwgdGV4dEtleXNbaSsxXS50ID4gZnJhbWVOdW0pe1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaSArPSAxO1xyXG4gICAgfVxyXG4gICAgaWYodGhpcy5rZXlzSW5kZXggIT09IGkpIHtcclxuICAgICAgICB0aGlzLmtleXNJbmRleCA9IGk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhLmQua1t0aGlzLmtleXNJbmRleF0ucztcclxufTtcclxuXHJcblRleHRQcm9wZXJ0eS5wcm90b3R5cGUuYnVpbGRGaW5hbFRleHQgPSBmdW5jdGlvbih0ZXh0KSB7XHJcbiAgICB2YXIgY29tYmluZWRDaGFyYWN0ZXJzID0gRm9udE1hbmFnZXIuZ2V0Q29tYmluZWRDaGFyYWN0ZXJDb2RlcygpO1xyXG4gICAgdmFyIGNoYXJhY3RlcnNBcnJheSA9IFtdO1xyXG4gICAgdmFyIGkgPSAwLCBsZW4gPSB0ZXh0Lmxlbmd0aDtcclxuICAgIHdoaWxlIChpIDwgbGVuKSB7XHJcbiAgICAgICAgaWYgKGNvbWJpbmVkQ2hhcmFjdGVycy5pbmRleE9mKHRleHQuY2hhckNvZGVBdChpKSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIGNoYXJhY3RlcnNBcnJheVtjaGFyYWN0ZXJzQXJyYXkubGVuZ3RoIC0gMV0gKz0gdGV4dC5jaGFyQXQoaSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2hhcmFjdGVyc0FycmF5LnB1c2godGV4dC5jaGFyQXQoaSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpICs9IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2hhcmFjdGVyc0FycmF5O1xyXG59XHJcblxyXG5UZXh0UHJvcGVydHkucHJvdG90eXBlLmNvbXBsZXRlVGV4dERhdGEgPSBmdW5jdGlvbihkb2N1bWVudERhdGEpIHtcclxuICAgIGRvY3VtZW50RGF0YS5fX2NvbXBsZXRlID0gdHJ1ZTtcclxuICAgIHZhciBmb250TWFuYWdlciA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyO1xyXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XHJcbiAgICB2YXIgbGV0dGVycyA9IFtdO1xyXG4gICAgdmFyIGksIGxlbjtcclxuICAgIHZhciBuZXdMaW5lRmxhZywgaW5kZXggPSAwLCB2YWw7XHJcbiAgICB2YXIgYW5jaG9yR3JvdXBpbmcgPSBkYXRhLm0uZztcclxuICAgIHZhciBjdXJyZW50U2l6ZSA9IDAsIGN1cnJlbnRQb3MgPSAwLCBjdXJyZW50TGluZSA9IDAsIGxpbmVXaWR0aHMgPSBbXTtcclxuICAgIHZhciBsaW5lV2lkdGggPSAwO1xyXG4gICAgdmFyIG1heExpbmVXaWR0aCA9IDA7XHJcbiAgICB2YXIgaiwgakxlbjtcclxuICAgIHZhciBmb250RGF0YSA9IGZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpO1xyXG4gICAgdmFyIGNoYXJEYXRhLCBjTGVuZ3RoID0gMDtcclxuICAgIHZhciBzdHlsZXMgPSBmb250RGF0YS5mU3R5bGUgPyBmb250RGF0YS5mU3R5bGUuc3BsaXQoJyAnKSA6IFtdO1xyXG5cclxuICAgIHZhciBmV2VpZ2h0ID0gJ25vcm1hbCcsIGZTdHlsZSA9ICdub3JtYWwnO1xyXG4gICAgbGVuID0gc3R5bGVzLmxlbmd0aDtcclxuICAgIHZhciBzdHlsZU5hbWU7XHJcbiAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgIHN0eWxlTmFtZSA9IHN0eWxlc1tpXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIHN3aXRjaChzdHlsZU5hbWUpIHtcclxuICAgICAgICAgICAgY2FzZSAnaXRhbGljJzpcclxuICAgICAgICAgICAgZlN0eWxlID0gJ2l0YWxpYyc7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdib2xkJzpcclxuICAgICAgICAgICAgZldlaWdodCA9ICc3MDAnO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnYmxhY2snOlxyXG4gICAgICAgICAgICBmV2VpZ2h0ID0gJzkwMCc7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdtZWRpdW0nOlxyXG4gICAgICAgICAgICBmV2VpZ2h0ID0gJzUwMCc7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdyZWd1bGFyJzpcclxuICAgICAgICAgICAgY2FzZSAnbm9ybWFsJzpcclxuICAgICAgICAgICAgZldlaWdodCA9ICc0MDAnO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbGlnaHQnOlxyXG4gICAgICAgICAgICBjYXNlICd0aGluJzpcclxuICAgICAgICAgICAgZldlaWdodCA9ICcyMDAnO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkb2N1bWVudERhdGEuZldlaWdodCA9IGZvbnREYXRhLmZXZWlnaHQgfHwgZldlaWdodDtcclxuICAgIGRvY3VtZW50RGF0YS5mU3R5bGUgPSBmU3R5bGU7XHJcbiAgICBsZW4gPSBkb2N1bWVudERhdGEudC5sZW5ndGg7XHJcbiAgICBkb2N1bWVudERhdGEuZmluYWxTaXplID0gZG9jdW1lbnREYXRhLnM7XHJcbiAgICBkb2N1bWVudERhdGEuZmluYWxUZXh0ID0gdGhpcy5idWlsZEZpbmFsVGV4dChkb2N1bWVudERhdGEudCk7XHJcbiAgICBkb2N1bWVudERhdGEuZmluYWxMaW5lSGVpZ2h0ID0gZG9jdW1lbnREYXRhLmxoO1xyXG4gICAgdmFyIHRyYWNraW5nT2Zmc2V0ID0gZG9jdW1lbnREYXRhLnRyLzEwMDAqZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcclxuICAgIHZhciBjaGFyQ29kZTtcclxuICAgIGlmKGRvY3VtZW50RGF0YS5zeil7XHJcbiAgICAgICAgdmFyIGZsYWcgPSB0cnVlO1xyXG4gICAgICAgIHZhciBib3hXaWR0aCA9IGRvY3VtZW50RGF0YS5zelswXTtcclxuICAgICAgICB2YXIgYm94SGVpZ2h0ID0gZG9jdW1lbnREYXRhLnN6WzFdO1xyXG4gICAgICAgIHZhciBjdXJyZW50SGVpZ2h0LCBmaW5hbFRleHQ7XHJcbiAgICAgICAgd2hpbGUoZmxhZykge1xyXG4gICAgICAgICAgICBmaW5hbFRleHQgPSB0aGlzLmJ1aWxkRmluYWxUZXh0KGRvY3VtZW50RGF0YS50KTtcclxuICAgICAgICAgICAgY2hhckNvZGUgPSBmaW5hbFRleHRbaV0uY2hhckNvZGVBdCgwKTtcclxuICAgICAgICAgICAgY3VycmVudEhlaWdodCA9IDA7XHJcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IDA7XHJcbiAgICAgICAgICAgIGxlbiA9IGZpbmFsVGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIHRyYWNraW5nT2Zmc2V0ID0gZG9jdW1lbnREYXRhLnRyLzEwMDAqZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcclxuICAgICAgICAgICAgdmFyIGxhc3RTcGFjZUluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgICAgICAgICBuZXdMaW5lRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYoZmluYWxUZXh0W2ldID09PSAnICcpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RTcGFjZUluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIH1lbHNlIGlmKGNoYXJDb2RlID09PSAxMyB8fCBjaGFyQ29kZSA9PT0gMyl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBuZXdMaW5lRmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEhlaWdodCArPSBkb2N1bWVudERhdGEuZmluYWxMaW5lSGVpZ2h0IHx8IGRvY3VtZW50RGF0YS5maW5hbFNpemUqMS4yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoZm9udE1hbmFnZXIuY2hhcnMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYXJEYXRhID0gZm9udE1hbmFnZXIuZ2V0Q2hhckRhdGEoZmluYWxUZXh0W2ldLCBmb250RGF0YS5mU3R5bGUsIGZvbnREYXRhLmZGYW1pbHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNMZW5ndGggPSBuZXdMaW5lRmxhZyA/IDAgOiBjaGFyRGF0YS53KmRvY3VtZW50RGF0YS5maW5hbFNpemUvMTAwO1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgLy90Q2FudmFzSGVscGVyLmZvbnQgPSBkb2N1bWVudERhdGEucyArICdweCAnKyBmb250RGF0YS5mRmFtaWx5O1xyXG4gICAgICAgICAgICAgICAgICAgIGNMZW5ndGggPSBmb250TWFuYWdlci5tZWFzdXJlVGV4dChmaW5hbFRleHRbaV0sIGRvY3VtZW50RGF0YS5mLCBkb2N1bWVudERhdGEuZmluYWxTaXplKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKGxpbmVXaWR0aCArIGNMZW5ndGggPiBib3hXaWR0aCAmJiBmaW5hbFRleHRbaV0gIT09ICcgJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobGFzdFNwYWNlSW5kZXggPT09IC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuICs9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGxhc3RTcGFjZUluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50SGVpZ2h0ICs9IGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQgfHwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSoxLjI7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxUZXh0LnNwbGljZShpLCBsYXN0U3BhY2VJbmRleCA9PT0gaSA/IDEgOiAwLFwiXFxyXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZmluYWxUZXh0ID0gZmluYWxUZXh0LnN1YnN0cigwLGkpICsgXCJcXHJcIiArIGZpbmFsVGV4dC5zdWJzdHIoaSA9PT0gbGFzdFNwYWNlSW5kZXggPyBpICsgMSA6IGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RTcGFjZUluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoID0gMDtcclxuICAgICAgICAgICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGggKz0gY0xlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lV2lkdGggKz0gdHJhY2tpbmdPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudEhlaWdodCArPSBmb250RGF0YS5hc2NlbnQqZG9jdW1lbnREYXRhLmZpbmFsU2l6ZS8xMDA7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuY2FuUmVzaXplICYmIGRvY3VtZW50RGF0YS5maW5hbFNpemUgPiB0aGlzLm1pbmltdW1Gb250U2l6ZSAmJiBib3hIZWlnaHQgPCBjdXJyZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudERhdGEuZmluYWxTaXplIC09IDE7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudERhdGEuZmluYWxMaW5lSGVpZ2h0ID0gZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAqIGRvY3VtZW50RGF0YS5saCAvIGRvY3VtZW50RGF0YS5zO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLmZpbmFsVGV4dCA9IGZpbmFsVGV4dDtcclxuICAgICAgICAgICAgICAgIGxlbiA9IGRvY3VtZW50RGF0YS5maW5hbFRleHQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuICAgIGxpbmVXaWR0aCA9IC0gdHJhY2tpbmdPZmZzZXQ7XHJcbiAgICBjTGVuZ3RoID0gMDtcclxuICAgIHZhciB1bmNvbGxhcHNlZFNwYWNlcyA9IDA7XHJcbiAgICB2YXIgY3VycmVudENoYXI7XHJcbiAgICBmb3IgKGkgPSAwO2kgPCBsZW4gO2kgKz0gMSkge1xyXG4gICAgICAgIG5ld0xpbmVGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgY3VycmVudENoYXIgPSBkb2N1bWVudERhdGEuZmluYWxUZXh0W2ldO1xyXG4gICAgICAgIGNoYXJDb2RlID0gY3VycmVudENoYXIuY2hhckNvZGVBdCgwKTtcclxuICAgICAgICBpZiAoY3VycmVudENoYXIgPT09ICcgJyl7XHJcbiAgICAgICAgICAgIHZhbCA9ICdcXHUwMEEwJztcclxuICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09PSAxMyB8fCBjaGFyQ29kZSA9PT0gMykge1xyXG4gICAgICAgICAgICB1bmNvbGxhcHNlZFNwYWNlcyA9IDA7XHJcbiAgICAgICAgICAgIGxpbmVXaWR0aHMucHVzaChsaW5lV2lkdGgpO1xyXG4gICAgICAgICAgICBtYXhMaW5lV2lkdGggPSBsaW5lV2lkdGggPiBtYXhMaW5lV2lkdGggPyBsaW5lV2lkdGggOiBtYXhMaW5lV2lkdGg7XHJcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IC0gMiAqIHRyYWNraW5nT2Zmc2V0O1xyXG4gICAgICAgICAgICB2YWwgPSAnJztcclxuICAgICAgICAgICAgbmV3TGluZUZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICBjdXJyZW50TGluZSArPSAxO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB2YWwgPSBkb2N1bWVudERhdGEuZmluYWxUZXh0W2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihmb250TWFuYWdlci5jaGFycyl7XHJcbiAgICAgICAgICAgIGNoYXJEYXRhID0gZm9udE1hbmFnZXIuZ2V0Q2hhckRhdGEoY3VycmVudENoYXIsIGZvbnREYXRhLmZTdHlsZSwgZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZikuZkZhbWlseSk7XHJcbiAgICAgICAgICAgIGNMZW5ndGggPSBuZXdMaW5lRmxhZyA/IDAgOiBjaGFyRGF0YS53KmRvY3VtZW50RGF0YS5maW5hbFNpemUvMTAwO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAvL3ZhciBjaGFyV2lkdGggPSBmb250TWFuYWdlci5tZWFzdXJlVGV4dCh2YWwsIGRvY3VtZW50RGF0YS5mLCBkb2N1bWVudERhdGEuZmluYWxTaXplKTtcclxuICAgICAgICAgICAgLy90Q2FudmFzSGVscGVyLmZvbnQgPSBkb2N1bWVudERhdGEuZmluYWxTaXplICsgJ3B4ICcrIGZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpLmZGYW1pbHk7XHJcbiAgICAgICAgICAgIGNMZW5ndGggPSBmb250TWFuYWdlci5tZWFzdXJlVGV4dCh2YWwsIGRvY3VtZW50RGF0YS5mLCBkb2N1bWVudERhdGEuZmluYWxTaXplKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgaWYoY3VycmVudENoYXIgPT09ICcgJyl7XHJcbiAgICAgICAgICAgIHVuY29sbGFwc2VkU3BhY2VzICs9IGNMZW5ndGggKyB0cmFja2luZ09mZnNldDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsaW5lV2lkdGggKz0gY0xlbmd0aCArIHRyYWNraW5nT2Zmc2V0ICsgdW5jb2xsYXBzZWRTcGFjZXM7XHJcbiAgICAgICAgICAgIHVuY29sbGFwc2VkU3BhY2VzID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0dGVycy5wdXNoKHtsOmNMZW5ndGgsYW46Y0xlbmd0aCxhZGQ6Y3VycmVudFNpemUsbjpuZXdMaW5lRmxhZywgYW5JbmRleGVzOltdLCB2YWw6IHZhbCwgbGluZTogY3VycmVudExpbmUsIGFuaW1hdG9ySnVzdGlmeU9mZnNldDogMH0pO1xyXG4gICAgICAgIGlmKGFuY2hvckdyb3VwaW5nID09IDIpe1xyXG4gICAgICAgICAgICBjdXJyZW50U2l6ZSArPSBjTGVuZ3RoO1xyXG4gICAgICAgICAgICBpZih2YWwgPT09ICcnIHx8IHZhbCA9PT0gJ1xcdTAwQTAnIHx8IGkgPT09IGxlbiAtIDEpe1xyXG4gICAgICAgICAgICAgICAgaWYodmFsID09PSAnJyB8fCB2YWwgPT09ICdcXHUwMEEwJyl7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNpemUgLT0gY0xlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHdoaWxlKGN1cnJlbnRQb3M8PWkpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldHRlcnNbY3VycmVudFBvc10uYW4gPSBjdXJyZW50U2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmluZCA9IGluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIGxldHRlcnNbY3VycmVudFBvc10uZXh0cmEgPSBjTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQb3MgKz0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGluZGV4ICs9IDE7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZSBpZihhbmNob3JHcm91cGluZyA9PSAzKXtcclxuICAgICAgICAgICAgY3VycmVudFNpemUgKz0gY0xlbmd0aDtcclxuICAgICAgICAgICAgaWYodmFsID09PSAnJyB8fCBpID09PSBsZW4gLSAxKXtcclxuICAgICAgICAgICAgICAgIGlmKHZhbCA9PT0gJycpe1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTaXplIC09IGNMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB3aGlsZShjdXJyZW50UG9zPD1pKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmFuID0gY3VycmVudFNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0dGVyc1tjdXJyZW50UG9zXS5pbmQgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmV4dHJhID0gY0xlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zICs9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50U2l6ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpbmRleCArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGxldHRlcnNbaW5kZXhdLmluZCA9IGluZGV4O1xyXG4gICAgICAgICAgICBsZXR0ZXJzW2luZGV4XS5leHRyYSA9IDA7XHJcbiAgICAgICAgICAgIGluZGV4ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZG9jdW1lbnREYXRhLmwgPSBsZXR0ZXJzO1xyXG4gICAgbWF4TGluZVdpZHRoID0gbGluZVdpZHRoID4gbWF4TGluZVdpZHRoID8gbGluZVdpZHRoIDogbWF4TGluZVdpZHRoO1xyXG4gICAgbGluZVdpZHRocy5wdXNoKGxpbmVXaWR0aCk7XHJcbiAgICBpZihkb2N1bWVudERhdGEuc3ope1xyXG4gICAgICAgIGRvY3VtZW50RGF0YS5ib3hXaWR0aCA9IGRvY3VtZW50RGF0YS5zelswXTtcclxuICAgICAgICBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCA9IDA7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgICBkb2N1bWVudERhdGEuYm94V2lkdGggPSBtYXhMaW5lV2lkdGg7XHJcbiAgICAgICAgc3dpdGNoKGRvY3VtZW50RGF0YS5qKXtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnREYXRhLmp1c3RpZnlPZmZzZXQgPSAtIGRvY3VtZW50RGF0YS5ib3hXaWR0aDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCA9IC0gZG9jdW1lbnREYXRhLmJveFdpZHRoLzI7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkb2N1bWVudERhdGEubGluZVdpZHRocyA9IGxpbmVXaWR0aHM7XHJcblxyXG4gICAgdmFyIGFuaW1hdG9ycyA9IGRhdGEuYSwgYW5pbWF0b3JEYXRhLCBsZXR0ZXJEYXRhO1xyXG4gICAgakxlbiA9IGFuaW1hdG9ycy5sZW5ndGg7XHJcbiAgICB2YXIgYmFzZWQsIGluZCwgaW5kZXhlcyA9IFtdO1xyXG4gICAgZm9yKGo9MDtqPGpMZW47ais9MSl7XHJcbiAgICAgICAgYW5pbWF0b3JEYXRhID0gYW5pbWF0b3JzW2pdO1xyXG4gICAgICAgIGlmKGFuaW1hdG9yRGF0YS5hLnNjKXtcclxuICAgICAgICAgICAgZG9jdW1lbnREYXRhLnN0cm9rZUNvbG9yQW5pbSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGFuaW1hdG9yRGF0YS5hLnN3KXtcclxuICAgICAgICAgICAgZG9jdW1lbnREYXRhLnN0cm9rZVdpZHRoQW5pbSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGFuaW1hdG9yRGF0YS5hLmZjIHx8IGFuaW1hdG9yRGF0YS5hLmZoIHx8IGFuaW1hdG9yRGF0YS5hLmZzIHx8IGFuaW1hdG9yRGF0YS5hLmZiKXtcclxuICAgICAgICAgICAgZG9jdW1lbnREYXRhLmZpbGxDb2xvckFuaW0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbmQgPSAwO1xyXG4gICAgICAgIGJhc2VkID0gYW5pbWF0b3JEYXRhLnMuYjtcclxuICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICBsZXR0ZXJEYXRhID0gbGV0dGVyc1tpXTtcclxuICAgICAgICAgICAgbGV0dGVyRGF0YS5hbkluZGV4ZXNbal0gPSBpbmQ7XHJcbiAgICAgICAgICAgIGlmKChiYXNlZCA9PSAxICYmIGxldHRlckRhdGEudmFsICE9PSAnJykgfHwgKGJhc2VkID09IDIgJiYgbGV0dGVyRGF0YS52YWwgIT09ICcnICYmIGxldHRlckRhdGEudmFsICE9PSAnXFx1MDBBMCcpIHx8IChiYXNlZCA9PSAzICYmIChsZXR0ZXJEYXRhLm4gfHwgbGV0dGVyRGF0YS52YWwgPT0gJ1xcdTAwQTAnIHx8IGkgPT0gbGVuIC0gMSkpIHx8IChiYXNlZCA9PSA0ICYmIChsZXR0ZXJEYXRhLm4gfHwgaSA9PSBsZW4gLSAxKSkpe1xyXG4gICAgICAgICAgICAgICAgaWYoYW5pbWF0b3JEYXRhLnMucm4gPT09IDEpe1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpbmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaW5kICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YS5hW2pdLnMudG90YWxDaGFycyA9IGluZDtcclxuICAgICAgICB2YXIgY3VycmVudEluZCA9IC0xLCBuZXdJbmQ7XHJcbiAgICAgICAgaWYoYW5pbWF0b3JEYXRhLnMucm4gPT09IDEpe1xyXG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSl7XHJcbiAgICAgICAgICAgICAgICBsZXR0ZXJEYXRhID0gbGV0dGVyc1tpXTtcclxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRJbmQgIT0gbGV0dGVyRGF0YS5hbkluZGV4ZXNbal0pe1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbmQgPSBsZXR0ZXJEYXRhLmFuSW5kZXhlc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdJbmQgPSBpbmRleGVzLnNwbGljZShNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqaW5kZXhlcy5sZW5ndGgpLDEpWzBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0dGVyRGF0YS5hbkluZGV4ZXNbal0gPSBuZXdJbmQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkb2N1bWVudERhdGEueU9mZnNldCA9IGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQgfHwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSoxLjI7XHJcbiAgICBkb2N1bWVudERhdGEubHMgPSBkb2N1bWVudERhdGEubHMgfHwgMDtcclxuICAgIGRvY3VtZW50RGF0YS5hc2NlbnQgPSBmb250RGF0YS5hc2NlbnQqZG9jdW1lbnREYXRhLmZpbmFsU2l6ZS8xMDA7XHJcbn07XHJcblxyXG5UZXh0UHJvcGVydHkucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50RGF0YSA9IGZ1bmN0aW9uKG5ld0RhdGEsIGluZGV4KSB7XHJcblx0aW5kZXggPSBpbmRleCA9PT0gdW5kZWZpbmVkID8gdGhpcy5rZXlzSW5kZXggOiBpbmRleDtcclxuICAgIHZhciBkRGF0YSA9IHRoaXMuY29weURhdGEoe30sIHRoaXMuZGF0YS5kLmtbaW5kZXhdLnMpO1xyXG4gICAgZERhdGEgPSB0aGlzLmNvcHlEYXRhKGREYXRhLCBuZXdEYXRhKTtcclxuICAgIHRoaXMuZGF0YS5kLmtbaW5kZXhdLnMgPSBkRGF0YTtcclxuICAgIHRoaXMucmVjYWxjdWxhdGUoaW5kZXgpO1xyXG4gICAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcclxufTtcclxuXHJcblRleHRQcm9wZXJ0eS5wcm90b3R5cGUucmVjYWxjdWxhdGUgPSBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgdmFyIGREYXRhID0gdGhpcy5kYXRhLmQua1tpbmRleF0ucztcclxuICAgIGREYXRhLl9fY29tcGxldGUgPSBmYWxzZTtcclxuICAgIHRoaXMua2V5c0luZGV4ID0gMDtcclxuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XHJcbiAgICB0aGlzLmdldFZhbHVlKGREYXRhKTtcclxufVxyXG5cclxuVGV4dFByb3BlcnR5LnByb3RvdHlwZS5jYW5SZXNpemVGb250ID0gZnVuY3Rpb24oX2NhblJlc2l6ZSkge1xyXG4gICAgdGhpcy5jYW5SZXNpemUgPSBfY2FuUmVzaXplO1xyXG4gICAgdGhpcy5yZWNhbGN1bGF0ZSh0aGlzLmtleXNJbmRleCk7XHJcbiAgICB0aGlzLmVsZW0uYWRkRHluYW1pY1Byb3BlcnR5KHRoaXMpO1xyXG59O1xyXG5cclxuVGV4dFByb3BlcnR5LnByb3RvdHlwZS5zZXRNaW5pbXVtRm9udFNpemUgPSBmdW5jdGlvbihfZm9udFZhbHVlKSB7XHJcbiAgICB0aGlzLm1pbmltdW1Gb250U2l6ZSA9IE1hdGguZmxvb3IoX2ZvbnRWYWx1ZSkgfHwgMTtcclxuICAgIHRoaXMucmVjYWxjdWxhdGUodGhpcy5rZXlzSW5kZXgpO1xyXG4gICAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcclxufTtcclxuXG52YXIgVGV4dFNlbGVjdG9yUHJvcCA9IChmdW5jdGlvbigpe1xyXG4gICAgdmFyIG1heCA9IE1hdGgubWF4O1xyXG4gICAgdmFyIG1pbiA9IE1hdGgubWluO1xyXG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcclxuXHJcbiAgICBmdW5jdGlvbiBUZXh0U2VsZWN0b3JQcm9wKGVsZW0sZGF0YSl7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFRleHRMZW5ndGggPSAtMTtcclxuICAgICAgICB0aGlzLmsgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgICAgICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xyXG4gICAgICAgIHRoaXMuZmluYWxTID0gMDtcclxuICAgICAgICB0aGlzLmZpbmFsRSA9IDA7XHJcbiAgICAgICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xyXG4gICAgICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS5zIHx8IHtrOjB9LDAsMCx0aGlzKTtcclxuICAgICAgICBpZignZScgaW4gZGF0YSl7XHJcbiAgICAgICAgICAgIHRoaXMuZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS5lLDAsMCx0aGlzKTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5lID0ge3Y6MTAwfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSxkYXRhLm8gfHwge2s6MH0sMCwwLHRoaXMpO1xyXG4gICAgICAgIHRoaXMueGUgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLGRhdGEueGUgfHwge2s6MH0sMCwwLHRoaXMpO1xyXG4gICAgICAgIHRoaXMubmUgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLGRhdGEubmUgfHwge2s6MH0sMCwwLHRoaXMpO1xyXG4gICAgICAgIHRoaXMuYSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS5hLDAsMC4wMSx0aGlzKTtcclxuICAgICAgICBpZighdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpe1xyXG4gICAgICAgICAgICB0aGlzLmdldFZhbHVlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIFRleHRTZWxlY3RvclByb3AucHJvdG90eXBlID0ge1xyXG4gICAgICAgIGdldE11bHQ6IGZ1bmN0aW9uKGluZCkge1xyXG4gICAgICAgICAgICBpZih0aGlzLl9jdXJyZW50VGV4dExlbmd0aCAhPT0gdGhpcy5lbGVtLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YS5sLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vdmFyIGVhc2VyID0gYmV6LmdldEVhc2luZ0N1cnZlKHRoaXMubmUudi8xMDAsMCwxLXRoaXMueGUudi8xMDAsMSk7XHJcbiAgICAgICAgICAgIHZhciBlYXNlciA9IEJlemllckZhY3RvcnkuZ2V0QmV6aWVyRWFzaW5nKHRoaXMubmUudi8xMDAsMCwxLXRoaXMueGUudi8xMDAsMSkuZ2V0O1xyXG4gICAgICAgICAgICB2YXIgbXVsdCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5maW5hbFM7XHJcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5maW5hbEU7XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5kYXRhLnNoO1xyXG4gICAgICAgICAgICBpZih0eXBlID09IDIpe1xyXG4gICAgICAgICAgICAgICAgaWYoZSA9PT0gcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdCA9IGluZCA+PSBlID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBtdWx0ID0gbWF4KDAsbWluKDAuNS8oZS1zKSArIChpbmQtcykvKGUtcyksMSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xyXG4gICAgICAgICAgICB9ZWxzZSBpZih0eXBlID09IDMpe1xyXG4gICAgICAgICAgICAgICAgaWYoZSA9PT0gcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdCA9IGluZCA+PSBlID8gMCA6IDE7XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBtdWx0ID0gMSAtIG1heCgwLG1pbigwLjUvKGUtcykgKyAoaW5kLXMpLyhlLXMpLDEpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBtdWx0ID0gZWFzZXIobXVsdCk7XHJcbiAgICAgICAgICAgIH1lbHNlIGlmKHR5cGUgPT0gNCl7XHJcbiAgICAgICAgICAgICAgICBpZihlID09PSBzKXtcclxuICAgICAgICAgICAgICAgICAgICBtdWx0ID0gMDtcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIG11bHQgPSBtYXgoMCxtaW4oMC41LyhlLXMpICsgKGluZC1zKS8oZS1zKSwxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYobXVsdDwwLjUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0ICo9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHQgPSAxIC0gMioobXVsdC0wLjUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG11bHQgPSBlYXNlcihtdWx0KTtcclxuICAgICAgICAgICAgfWVsc2UgaWYodHlwZSA9PSA1KXtcclxuICAgICAgICAgICAgICAgIGlmKGUgPT09IHMpe1xyXG4gICAgICAgICAgICAgICAgICAgIG11bHQgPSAwO1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvdCA9IGUgLSBzO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qaW5kICs9IDAuNTtcclxuICAgICAgICAgICAgICAgICAgICBtdWx0ID0gLTQvKHRvdCp0b3QpKihpbmQqaW5kKSsoNC90b3QpKmluZDsqL1xyXG4gICAgICAgICAgICAgICAgICAgIGluZCA9IG1pbihtYXgoMCxpbmQrMC41LXMpLGUtcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSAtdG90LzIraW5kO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gdG90LzI7XHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdCA9IE1hdGguc3FydCgxIC0gKHgqeCkvKGEqYSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xyXG4gICAgICAgICAgICB9ZWxzZSBpZih0eXBlID09IDYpe1xyXG4gICAgICAgICAgICAgICAgaWYoZSA9PT0gcyl7XHJcbiAgICAgICAgICAgICAgICAgICAgbXVsdCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBpbmQgPSBtaW4obWF4KDAsaW5kKzAuNS1zKSxlLXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIG11bHQgPSAoMSsoTWF0aC5jb3MoKE1hdGguUEkrTWF0aC5QSSoyKihpbmQpLyhlLXMpKSkpKS8yO1xyXG4gICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgIGluZCA9IE1hdGgubWluKE1hdGgubWF4KHMsaW5kKSxlLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgICBtdWx0ID0gKDErKE1hdGguY29zKChNYXRoLlBJK01hdGguUEkqMiooaW5kLXMpLyhlLTEtcykpKSkpLzI7XHJcbiAgICAgICAgICAgICAgICAgICAgIG11bHQgPSBNYXRoLm1heChtdWx0LCgxLyhlLTEtcykpLyhlLTEtcykpOyovXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBtdWx0ID0gZWFzZXIobXVsdCk7XHJcbiAgICAgICAgICAgIH1lbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmKGluZCA+PSBmbG9vcihzKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaW5kLXMgPCAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdCA9IDEgLSAocyAtIGluZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHQgPSBtYXgoMCxtaW4oZS1pbmQsMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG11bHQgPSBlYXNlcihtdWx0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbXVsdCp0aGlzLmEudjtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbihuZXdDaGFyc0ZsYWcpIHtcclxuICAgICAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcclxuICAgICAgICAgICAgdGhpcy5fbWRmID0gbmV3Q2hhcnNGbGFnIHx8IHRoaXMuX21kZjtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRleHRMZW5ndGggPSB0aGlzLmVsZW0udGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmwubGVuZ3RoIHx8IDA7XHJcbiAgICAgICAgICAgIGlmKG5ld0NoYXJzRmxhZyAmJiB0aGlzLmRhdGEuciA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lLnYgPSB0aGlzLl9jdXJyZW50VGV4dExlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZGl2aXNvciA9IHRoaXMuZGF0YS5yID09PSAyID8gMSA6IDEwMCAvIHRoaXMuZGF0YS50b3RhbENoYXJzO1xyXG4gICAgICAgICAgICB2YXIgbyA9IHRoaXMuby52L2Rpdmlzb3I7XHJcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zLnYvZGl2aXNvciArIG87XHJcbiAgICAgICAgICAgIHZhciBlID0gKHRoaXMuZS52L2Rpdmlzb3IpICsgbztcclxuICAgICAgICAgICAgaWYocz5lKXtcclxuICAgICAgICAgICAgICAgIHZhciBfcyA9IHM7XHJcbiAgICAgICAgICAgICAgICBzID0gZTtcclxuICAgICAgICAgICAgICAgIGUgPSBfcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZpbmFsUyA9IHM7XHJcbiAgICAgICAgICAgIHRoaXMuZmluYWxFID0gZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFRleHRTZWxlY3RvclByb3ApO1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFRleHRTZWxlY3RvclByb3AoZWxlbSwgZGF0YSxhcnIpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3RvclByb3AoZWxlbSwgZGF0YSwgYXJyKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldFRleHRTZWxlY3RvclByb3A6IGdldFRleHRTZWxlY3RvclByb3BcclxuICAgIH07XHJcbn0oKSk7XHJcblxyXG4gICAgXG52YXIgcG9vbF9mYWN0b3J5ID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiBmdW5jdGlvbihpbml0aWFsTGVuZ3RoLCBfY3JlYXRlLCBfcmVsZWFzZSwgX2Nsb25lKSB7XHJcblxyXG5cdFx0dmFyIF9sZW5ndGggPSAwO1xyXG5cdFx0dmFyIF9tYXhMZW5ndGggPSBpbml0aWFsTGVuZ3RoO1xyXG5cdFx0dmFyIHBvb2wgPSBjcmVhdGVTaXplZEFycmF5KF9tYXhMZW5ndGgpO1xyXG5cclxuXHRcdHZhciBvYiA9IHtcclxuXHRcdFx0bmV3RWxlbWVudDogbmV3RWxlbWVudCxcclxuXHRcdFx0cmVsZWFzZTogcmVsZWFzZVxyXG5cdFx0fTtcclxuXHJcblx0XHRmdW5jdGlvbiBuZXdFbGVtZW50KCl7XHJcblx0XHRcdHZhciBlbGVtZW50O1xyXG5cdFx0XHRpZihfbGVuZ3RoKXtcclxuXHRcdFx0XHRfbGVuZ3RoIC09IDE7XHJcblx0XHRcdFx0ZWxlbWVudCA9IHBvb2xbX2xlbmd0aF07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZWxlbWVudCA9IF9jcmVhdGUoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZWxlbWVudDtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZWxlYXNlKGVsZW1lbnQpIHtcclxuXHRcdFx0aWYoX2xlbmd0aCA9PT0gX21heExlbmd0aCkge1xyXG5cdFx0XHRcdHBvb2wgPSBwb29saW5nLmRvdWJsZShwb29sKTtcclxuXHRcdFx0XHRfbWF4TGVuZ3RoID0gX21heExlbmd0aCoyO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChfcmVsZWFzZSkge1xyXG5cdFx0XHRcdF9yZWxlYXNlKGVsZW1lbnQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHBvb2xbX2xlbmd0aF0gPSBlbGVtZW50O1xyXG5cdFx0XHRfbGVuZ3RoICs9IDE7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gY2xvbmUoKSB7XHJcblx0XHRcdHZhciBjbG9uZWRFbGVtZW50ID0gbmV3RWxlbWVudCgpO1xyXG5cdFx0XHRyZXR1cm4gX2Nsb25lKGNsb25lZEVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBvYjtcclxuXHR9O1xyXG59KCkpO1xyXG5cbnZhciBwb29saW5nID0gKGZ1bmN0aW9uKCl7XHJcblxyXG5cdGZ1bmN0aW9uIGRvdWJsZShhcnIpe1xyXG5cdFx0cmV0dXJuIGFyci5jb25jYXQoY3JlYXRlU2l6ZWRBcnJheShhcnIubGVuZ3RoKSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0ZG91YmxlOiBkb3VibGVcclxuXHR9O1xyXG59KCkpO1xudmFyIHBvaW50X3Bvb2wgPSAoZnVuY3Rpb24oKXtcclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlKCkge1xyXG5cdFx0cmV0dXJuIGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCAyKTtcclxuXHR9XHJcblx0cmV0dXJuIHBvb2xfZmFjdG9yeSg4LCBjcmVhdGUpO1xyXG59KCkpO1xudmFyIHNoYXBlX3Bvb2wgPSAoZnVuY3Rpb24oKXtcclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBTaGFwZVBhdGgoKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlbGVhc2Uoc2hhcGVQYXRoKSB7XHJcblx0XHR2YXIgbGVuID0gc2hhcGVQYXRoLl9sZW5ndGgsIGk7XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG5cdFx0XHRwb2ludF9wb29sLnJlbGVhc2Uoc2hhcGVQYXRoLnZbaV0pO1xyXG5cdFx0XHRwb2ludF9wb29sLnJlbGVhc2Uoc2hhcGVQYXRoLmlbaV0pO1xyXG5cdFx0XHRwb2ludF9wb29sLnJlbGVhc2Uoc2hhcGVQYXRoLm9baV0pO1xyXG5cdFx0XHRzaGFwZVBhdGgudltpXSA9IG51bGw7XHJcblx0XHRcdHNoYXBlUGF0aC5pW2ldID0gbnVsbDtcclxuXHRcdFx0c2hhcGVQYXRoLm9baV0gPSBudWxsO1xyXG5cdFx0fVxyXG5cdFx0c2hhcGVQYXRoLl9sZW5ndGggPSAwO1xyXG5cdFx0c2hhcGVQYXRoLmMgPSBmYWxzZTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNsb25lKHNoYXBlKSB7XHJcblx0XHR2YXIgY2xvbmVkID0gZmFjdG9yeS5uZXdFbGVtZW50KCk7XHJcblx0XHR2YXIgaSwgbGVuID0gc2hhcGUuX2xlbmd0aCA9PT0gdW5kZWZpbmVkID8gc2hhcGUudi5sZW5ndGggOiBzaGFwZS5fbGVuZ3RoO1xyXG5cdFx0Y2xvbmVkLnNldExlbmd0aChsZW4pO1xyXG5cdFx0Y2xvbmVkLmMgPSBzaGFwZS5jO1xyXG5cdFx0dmFyIHB0O1xyXG5cdFx0XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG5cdFx0XHRjbG9uZWQuc2V0VHJpcGxlQXQoc2hhcGUudltpXVswXSxzaGFwZS52W2ldWzFdLHNoYXBlLm9baV1bMF0sc2hhcGUub1tpXVsxXSxzaGFwZS5pW2ldWzBdLHNoYXBlLmlbaV1bMV0sIGkpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNsb25lZDtcclxuXHR9XHJcblxyXG5cdHZhciBmYWN0b3J5ID0gcG9vbF9mYWN0b3J5KDQsIGNyZWF0ZSwgcmVsZWFzZSk7XHJcblx0ZmFjdG9yeS5jbG9uZSA9IGNsb25lO1xyXG5cclxuXHRyZXR1cm4gZmFjdG9yeTtcclxufSgpKTtcbnZhciBzaGFwZUNvbGxlY3Rpb25fcG9vbCA9IChmdW5jdGlvbigpe1xyXG5cdHZhciBvYiA9IHtcclxuXHRcdG5ld1NoYXBlQ29sbGVjdGlvbjogbmV3U2hhcGVDb2xsZWN0aW9uLFxyXG5cdFx0cmVsZWFzZTogcmVsZWFzZVxyXG5cdH07XHJcblxyXG5cdHZhciBfbGVuZ3RoID0gMDtcclxuXHR2YXIgX21heExlbmd0aCA9IDQ7XHJcblx0dmFyIHBvb2wgPSBjcmVhdGVTaXplZEFycmF5KF9tYXhMZW5ndGgpO1xyXG5cclxuXHRmdW5jdGlvbiBuZXdTaGFwZUNvbGxlY3Rpb24oKXtcclxuXHRcdHZhciBzaGFwZUNvbGxlY3Rpb247XHJcblx0XHRpZihfbGVuZ3RoKXtcclxuXHRcdFx0X2xlbmd0aCAtPSAxO1xyXG5cdFx0XHRzaGFwZUNvbGxlY3Rpb24gPSBwb29sW19sZW5ndGhdO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c2hhcGVDb2xsZWN0aW9uID0gbmV3IFNoYXBlQ29sbGVjdGlvbigpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHNoYXBlQ29sbGVjdGlvbjtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlbGVhc2Uoc2hhcGVDb2xsZWN0aW9uKSB7XHJcblx0XHR2YXIgaSwgbGVuID0gc2hhcGVDb2xsZWN0aW9uLl9sZW5ndGg7XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG5cdFx0XHRzaGFwZV9wb29sLnJlbGVhc2Uoc2hhcGVDb2xsZWN0aW9uLnNoYXBlc1tpXSk7XHJcblx0XHR9XHJcblx0XHRzaGFwZUNvbGxlY3Rpb24uX2xlbmd0aCA9IDA7XHJcblxyXG5cdFx0aWYoX2xlbmd0aCA9PT0gX21heExlbmd0aCkge1xyXG5cdFx0XHRwb29sID0gcG9vbGluZy5kb3VibGUocG9vbCk7XHJcblx0XHRcdF9tYXhMZW5ndGggPSBfbWF4TGVuZ3RoKjI7XHJcblx0XHR9XHJcblx0XHRwb29sW19sZW5ndGhdID0gc2hhcGVDb2xsZWN0aW9uO1xyXG5cdFx0X2xlbmd0aCArPSAxO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG9iO1xyXG59KCkpO1xudmFyIHNlZ21lbnRzX2xlbmd0aF9wb29sID0gKGZ1bmN0aW9uKCl7XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZSgpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGxlbmd0aHM6IFtdLFxyXG5cdFx0XHR0b3RhbExlbmd0aDogMFxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlbGVhc2UoZWxlbWVudCkge1xyXG5cdFx0dmFyIGksIGxlbiA9IGVsZW1lbnQubGVuZ3Rocy5sZW5ndGg7XHJcblx0XHRmb3IoaT0wO2k8bGVuO2krPTEpIHtcclxuXHRcdFx0YmV6aWVyX2xlbmd0aF9wb29sLnJlbGVhc2UoZWxlbWVudC5sZW5ndGhzW2ldKTtcclxuXHRcdH1cclxuXHRcdGVsZW1lbnQubGVuZ3Rocy5sZW5ndGggPSAwO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBvb2xfZmFjdG9yeSg4LCBjcmVhdGUsIHJlbGVhc2UpO1xyXG59KCkpO1xudmFyIGJlemllcl9sZW5ndGhfcG9vbCA9IChmdW5jdGlvbigpe1xyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGUoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG4gICAgICAgICAgICBhZGRlZExlbmd0aDogMCxcclxuICAgICAgICAgICAgcGVyY2VudHM6IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBkZWZhdWx0Q3VydmVTZWdtZW50cyksXHJcbiAgICAgICAgICAgIGxlbmd0aHM6IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBkZWZhdWx0Q3VydmVTZWdtZW50cyksXHJcbiAgICAgICAgfTtcclxuXHR9XHJcblx0cmV0dXJuIHBvb2xfZmFjdG9yeSg4LCBjcmVhdGUpO1xyXG59KCkpO1xuZnVuY3Rpb24gQmFzZVJlbmRlcmVyKCl7fVxyXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLmNoZWNrTGF5ZXJzID0gZnVuY3Rpb24obnVtKXtcclxuICAgIHZhciBpLCBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGgsIGRhdGE7XHJcbiAgICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gdHJ1ZTtcclxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnRzW2ldKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmxheWVyc1tpXTtcclxuICAgICAgICAgICAgaWYoZGF0YS5pcCAtIGRhdGEuc3QgPD0gKG51bSAtIHRoaXMubGF5ZXJzW2ldLnN0KSAmJiBkYXRhLm9wIC0gZGF0YS5zdCA+IChudW0gLSB0aGlzLmxheWVyc1tpXS5zdCkpXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRJdGVtKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tcGxldGVMYXllcnMgPSB0aGlzLmVsZW1lbnRzW2ldID8gdGhpcy5jb21wbGV0ZUxheWVyczpmYWxzZTtcclxuICAgIH1cclxuICAgIHRoaXMuY2hlY2tQZW5kaW5nRWxlbWVudHMoKTtcclxufTtcclxuXHJcbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlSXRlbSA9IGZ1bmN0aW9uKGxheWVyKXtcclxuICAgIHN3aXRjaChsYXllci50eSl7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbWFnZShsYXllcik7XHJcbiAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVDb21wKGxheWVyKTtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNvbGlkKGxheWVyKTtcclxuICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU51bGwobGF5ZXIpO1xyXG4gICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2hhcGUobGF5ZXIpO1xyXG4gICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGV4dChsYXllcik7XHJcbiAgICAgICAgY2FzZSAxMzpcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ2FtZXJhKGxheWVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmNyZWF0ZU51bGwobGF5ZXIpO1xyXG59O1xyXG5cclxuQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDYW1lcmEgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3VcXCdyZSB1c2luZyBhIDNkIGNhbWVyYS4gVHJ5IHRoZSBodG1sIHJlbmRlcmVyLicpO1xyXG59O1xyXG5cclxuQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5idWlsZEFsbEl0ZW1zID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBpLCBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XHJcbiAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgIHRoaXMuYnVpbGRJdGVtKGkpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5jaGVja1BlbmRpbmdFbGVtZW50cygpO1xyXG59O1xyXG5cclxuQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5pbmNsdWRlTGF5ZXJzID0gZnVuY3Rpb24obmV3TGF5ZXJzKXtcclxuICAgIHRoaXMuY29tcGxldGVMYXllcnMgPSBmYWxzZTtcclxuICAgIHZhciBpLCBsZW4gPSBuZXdMYXllcnMubGVuZ3RoO1xyXG4gICAgdmFyIGosIGpMZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XHJcbiAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgIGogPSAwO1xyXG4gICAgICAgIHdoaWxlKGo8akxlbil7XHJcbiAgICAgICAgICAgIGlmKHRoaXMubGF5ZXJzW2pdLmlkID09IG5ld0xheWVyc1tpXS5pZCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxheWVyc1tqXSA9IG5ld0xheWVyc1tpXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGogKz0gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLnNldFByb2plY3RJbnRlcmZhY2UgPSBmdW5jdGlvbihwSW50ZXJmYWNlKXtcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlID0gcEludGVyZmFjZTtcclxufTtcclxuXHJcbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuaW5pdEl0ZW1zID0gZnVuY3Rpb24oKXtcclxuICAgIGlmKCF0aGlzLmdsb2JhbERhdGEucHJvZ3Jlc3NpdmVMb2FkKXtcclxuICAgICAgICB0aGlzLmJ1aWxkQWxsSXRlbXMoKTtcclxuICAgIH1cclxufTtcclxuQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5idWlsZEVsZW1lbnRQYXJlbnRpbmcgPSBmdW5jdGlvbihlbGVtZW50LCBwYXJlbnROYW1lLCBoaWVyYXJjaHkpIHtcclxuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnM7XHJcbiAgICB2YXIgaT0wLCBsZW4gPSBsYXllcnMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgICBpZiAobGF5ZXJzW2ldLmluZCA9PSBwYXJlbnROYW1lKSB7XHJcbiAgICAgICAgICAgIGlmICghZWxlbWVudHNbaV0gfHwgZWxlbWVudHNbaV0gPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRJdGVtKGkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRQZW5kaW5nRWxlbWVudChlbGVtZW50KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGhpZXJhcmNoeS5wdXNoKGVsZW1lbnRzW2ldKTtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnRzW2ldLnNldEFzUGFyZW50KCk7XHJcbiAgICAgICAgICAgICAgICBpZihsYXllcnNbaV0ucGFyZW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkRWxlbWVudFBhcmVudGluZyhlbGVtZW50LCBsYXllcnNbaV0ucGFyZW50LCBoaWVyYXJjaHkpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldEhpZXJhcmNoeShoaWVyYXJjaHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgKz0gMTtcclxuICAgIH1cclxufTtcclxuXHJcbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuYWRkUGVuZGluZ0VsZW1lbnQgPSBmdW5jdGlvbihlbGVtZW50KXtcclxuICAgIHRoaXMucGVuZGluZ0VsZW1lbnRzLnB1c2goZWxlbWVudCk7XHJcbn07XHJcblxyXG5CYXNlUmVuZGVyZXIucHJvdG90eXBlLnNlYXJjaEV4dHJhQ29tcG9zaXRpb25zID0gZnVuY3Rpb24oYXNzZXRzKXtcclxuICAgIHZhciBpLCBsZW4gPSBhc3NldHMubGVuZ3RoO1xyXG4gICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICBpZihhc3NldHNbaV0ueHQpe1xyXG4gICAgICAgICAgICB2YXIgY29tcCA9IHRoaXMuY3JlYXRlQ29tcChhc3NldHNbaV0pO1xyXG4gICAgICAgICAgICBjb21wLmluaXRFeHByZXNzaW9ucygpO1xyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5yZWdpc3RlckNvbXBvc2l0aW9uKGNvbXApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkJhc2VSZW5kZXJlci5wcm90b3R5cGUuc2V0dXBHbG9iYWxEYXRhID0gZnVuY3Rpb24oYW5pbURhdGEsIGZvbnRzQ29udGFpbmVyKSB7XHJcbiAgICB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIgPSBuZXcgRm9udE1hbmFnZXIoKTtcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5hZGRDaGFycyhhbmltRGF0YS5jaGFycyk7XHJcbiAgICB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuYWRkRm9udHMoYW5pbURhdGEuZm9udHMsIGZvbnRzQ29udGFpbmVyKTtcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS5nZXRBc3NldERhdGEgPSB0aGlzLmFuaW1hdGlvbkl0ZW0uZ2V0QXNzZXREYXRhLmJpbmQodGhpcy5hbmltYXRpb25JdGVtKTtcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS5nZXRBc3NldHNQYXRoID0gdGhpcy5hbmltYXRpb25JdGVtLmdldEFzc2V0c1BhdGguYmluZCh0aGlzLmFuaW1hdGlvbkl0ZW0pO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLmltYWdlTG9hZGVyID0gdGhpcy5hbmltYXRpb25JdGVtLmltYWdlUHJlbG9hZGVyO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lSWQgPSAwO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lUmF0ZSA9IGFuaW1EYXRhLmZyO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLm5tID0gYW5pbURhdGEubm07XHJcbiAgICB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUgPSB7XHJcbiAgICAgICAgdzogYW5pbURhdGEudyxcclxuICAgICAgICBoOiBhbmltRGF0YS5oXHJcbiAgICB9XHJcbn1cbmZ1bmN0aW9uIFNWR1JlbmRlcmVyKGFuaW1hdGlvbkl0ZW0sIGNvbmZpZyl7XHJcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0gPSBhbmltYXRpb25JdGVtO1xyXG4gICAgdGhpcy5sYXllcnMgPSBudWxsO1xyXG4gICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gLTE7XHJcbiAgICB0aGlzLnN2Z0VsZW1lbnQgPSBjcmVhdGVOUygnc3ZnJyk7XHJcbiAgICB2YXIgZGVmcyA9IGNyZWF0ZU5TKCAnZGVmcycpO1xyXG4gICAgdGhpcy5zdmdFbGVtZW50LmFwcGVuZENoaWxkKGRlZnMpO1xyXG4gICAgdmFyIG1hc2tFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcclxuICAgIHRoaXMuc3ZnRWxlbWVudC5hcHBlbmRDaGlsZChtYXNrRWxlbWVudCk7XHJcbiAgICB0aGlzLmxheWVyRWxlbWVudCA9IG1hc2tFbGVtZW50O1xyXG4gICAgdGhpcy5yZW5kZXJDb25maWcgPSB7XHJcbiAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogKGNvbmZpZyAmJiBjb25maWcucHJlc2VydmVBc3BlY3RSYXRpbykgfHwgJ3hNaWRZTWlkIG1lZXQnLFxyXG4gICAgICAgIGltYWdlUHJlc2VydmVBc3BlY3RSYXRpbzogKGNvbmZpZyAmJiBjb25maWcuaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvKSB8fCAneE1pZFlNaWQgc2xpY2UnLFxyXG4gICAgICAgIHByb2dyZXNzaXZlTG9hZDogKGNvbmZpZyAmJiBjb25maWcucHJvZ3Jlc3NpdmVMb2FkKSB8fCBmYWxzZSxcclxuICAgICAgICBoaWRlT25UcmFuc3BhcmVudDogKGNvbmZpZyAmJiBjb25maWcuaGlkZU9uVHJhbnNwYXJlbnQgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZSxcclxuICAgICAgICB2aWV3Qm94T25seTogKGNvbmZpZyAmJiBjb25maWcudmlld0JveE9ubHkpIHx8IGZhbHNlLFxyXG4gICAgICAgIHZpZXdCb3hTaXplOiAoY29uZmlnICYmIGNvbmZpZy52aWV3Qm94U2l6ZSkgfHwgZmFsc2UsXHJcbiAgICAgICAgY2xhc3NOYW1lOiAoY29uZmlnICYmIGNvbmZpZy5jbGFzc05hbWUpIHx8ICcnXHJcbiAgICB9O1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhID0ge1xyXG4gICAgICAgIF9tZGY6IGZhbHNlLFxyXG4gICAgICAgIGZyYW1lTnVtOiAtMSxcclxuICAgICAgICBkZWZzOiBkZWZzLFxyXG4gICAgICAgIHJlbmRlckNvbmZpZzogdGhpcy5yZW5kZXJDb25maWdcclxuICAgIH07XHJcbiAgICB0aGlzLmVsZW1lbnRzID0gW107XHJcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xyXG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMucmVuZGVyZXJUeXBlID0gJ3N2Zyc7XHJcblxyXG59XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0Jhc2VSZW5kZXJlcl0sU1ZHUmVuZGVyZXIpO1xyXG5cclxuU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZU51bGwgPSBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgcmV0dXJuIG5ldyBOdWxsRWxlbWVudChkYXRhLHRoaXMuZ2xvYmFsRGF0YSx0aGlzKTtcclxufTtcclxuXHJcblNWR1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVTaGFwZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICByZXR1cm4gbmV3IFNWR1NoYXBlRWxlbWVudChkYXRhLHRoaXMuZ2xvYmFsRGF0YSx0aGlzKTtcclxufTtcclxuXHJcblNWR1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVUZXh0ID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIHJldHVybiBuZXcgU1ZHVGV4dEVsZW1lbnQoZGF0YSx0aGlzLmdsb2JhbERhdGEsdGhpcyk7XHJcblxyXG59O1xyXG5cclxuU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUltYWdlID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIHJldHVybiBuZXcgSUltYWdlRWxlbWVudChkYXRhLHRoaXMuZ2xvYmFsRGF0YSx0aGlzKTtcclxufTtcclxuXHJcblNWR1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDb21wID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIHJldHVybiBuZXcgU1ZHQ29tcEVsZW1lbnQoZGF0YSx0aGlzLmdsb2JhbERhdGEsdGhpcyk7XHJcblxyXG59O1xyXG5cclxuU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZVNvbGlkID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIHJldHVybiBuZXcgSVNvbGlkRWxlbWVudChkYXRhLHRoaXMuZ2xvYmFsRGF0YSx0aGlzKTtcclxufTtcclxuXHJcblNWR1JlbmRlcmVyLnByb3RvdHlwZS5jb25maWdBbmltYXRpb24gPSBmdW5jdGlvbihhbmltRGF0YSl7XHJcbiAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd4bWxucycsJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyk7XHJcbiAgICBpZih0aGlzLnJlbmRlckNvbmZpZy52aWV3Qm94U2l6ZSkge1xyXG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLHRoaXMucmVuZGVyQ29uZmlnLnZpZXdCb3hTaXplKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsJzAgMCAnK2FuaW1EYXRhLncrJyAnK2FuaW1EYXRhLmgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKCF0aGlzLnJlbmRlckNvbmZpZy52aWV3Qm94T25seSkge1xyXG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyxhbmltRGF0YS53KTtcclxuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLGFuaW1EYXRhLmgpO1xyXG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS53aWR0aCA9ICcxMDAlJztcclxuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xyXG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwwLDApJztcclxuICAgIH1cclxuICAgIGlmKHRoaXMucmVuZGVyQ29uZmlnLmNsYXNzTmFtZSkge1xyXG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKTtcclxuICAgIH1cclxuICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLHRoaXMucmVuZGVyQ29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8pO1xyXG4gICAgLy90aGlzLmxheWVyRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwwLDApJztcclxuICAgIC8vdGhpcy5sYXllckVsZW1lbnQuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gdGhpcy5sYXllckVsZW1lbnQuc3R5bGUubW96VHJhbnNmb3JtT3JpZ2luID0gdGhpcy5sYXllckVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gdGhpcy5sYXllckVsZW1lbnQuc3R5bGVbJy13ZWJraXQtdHJhbnNmb3JtJ10gPSBcIjBweCAwcHggMHB4XCI7XHJcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLnN2Z0VsZW1lbnQpO1xyXG4gICAgLy9NYXNrIGFuaW1hdGlvblxyXG4gICAgdmFyIGRlZnMgPSB0aGlzLmdsb2JhbERhdGEuZGVmcztcclxuXHJcbiAgICB0aGlzLnNldHVwR2xvYmFsRGF0YShhbmltRGF0YSwgZGVmcyk7XHJcbiAgICB0aGlzLmdsb2JhbERhdGEucHJvZ3Jlc3NpdmVMb2FkID0gdGhpcy5yZW5kZXJDb25maWcucHJvZ3Jlc3NpdmVMb2FkO1xyXG4gICAgdGhpcy5kYXRhID0gYW5pbURhdGE7XHJcblxyXG4gICAgdmFyIG1hc2tFbGVtZW50ID0gY3JlYXRlTlMoICdjbGlwUGF0aCcpO1xyXG4gICAgdmFyIHJlY3QgPSBjcmVhdGVOUygncmVjdCcpO1xyXG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyxhbmltRGF0YS53KTtcclxuICAgIHJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLGFuaW1EYXRhLmgpO1xyXG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3gnLDApO1xyXG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3knLDApO1xyXG4gICAgdmFyIG1hc2tJZCA9ICdhbmltYXRpb25NYXNrXycrcmFuZG9tU3RyaW5nKDEwKTtcclxuICAgIG1hc2tFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBtYXNrSWQpO1xyXG4gICAgbWFza0VsZW1lbnQuYXBwZW5kQ2hpbGQocmVjdCk7XHJcbiAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjbGlwLXBhdGhcIiwgXCJ1cmwoXCIgKyBsb2NhdGlvbkhyZWYgKyBcIiNcIittYXNrSWQrXCIpXCIpO1xyXG5cclxuICAgIGRlZnMuYXBwZW5kQ2hpbGQobWFza0VsZW1lbnQpO1xyXG4gICAgdGhpcy5sYXllcnMgPSBhbmltRGF0YS5sYXllcnM7XHJcbiAgICB0aGlzLmVsZW1lbnRzID0gY3JlYXRlU2l6ZWRBcnJheShhbmltRGF0YS5sYXllcnMubGVuZ3RoKTtcclxufTtcclxuXHJcblxyXG5TVkdSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLmlubmVySFRNTCA9ICcnO1xyXG4gICAgdGhpcy5sYXllckVsZW1lbnQgPSBudWxsO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMgPSBudWxsO1xyXG4gICAgdmFyIGksIGxlbiA9IHRoaXMubGF5ZXJzID8gdGhpcy5sYXllcnMubGVuZ3RoIDogMDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmKHRoaXMuZWxlbWVudHNbaV0pe1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IDA7XHJcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XHJcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0gPSBudWxsO1xyXG59O1xyXG5cclxuU1ZHUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZUNvbnRhaW5lclNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbn07XHJcblxyXG5TVkdSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRJdGVtICA9IGZ1bmN0aW9uKHBvcyl7XHJcbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgaWYoZWxlbWVudHNbcG9zXSB8fCB0aGlzLmxheWVyc1twb3NdLnR5ID09IDk5KXtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBlbGVtZW50c1twb3NdID0gdHJ1ZTtcclxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5jcmVhdGVJdGVtKHRoaXMubGF5ZXJzW3Bvc10pO1xyXG5cclxuICAgIGVsZW1lbnRzW3Bvc10gPSBlbGVtZW50O1xyXG4gICAgaWYoZXhwcmVzc2lvbnNQbHVnaW4pe1xyXG4gICAgICAgIGlmKHRoaXMubGF5ZXJzW3Bvc10udHkgPT09IDApe1xyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5yZWdpc3RlckNvbXBvc2l0aW9uKGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbGVtZW50LmluaXRFeHByZXNzaW9ucygpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hcHBlbmRFbGVtZW50SW5Qb3MoZWxlbWVudCxwb3MpO1xyXG4gICAgaWYodGhpcy5sYXllcnNbcG9zXS50dCl7XHJcbiAgICAgICAgaWYoIXRoaXMuZWxlbWVudHNbcG9zIC0gMV0gfHwgdGhpcy5lbGVtZW50c1twb3MgLSAxXSA9PT0gdHJ1ZSl7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRJdGVtKHBvcyAtIDEpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZFBlbmRpbmdFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0TWF0dGUoZWxlbWVudHNbcG9zIC0gMV0ubGF5ZXJJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNoZWNrUGVuZGluZ0VsZW1lbnRzICA9IGZ1bmN0aW9uKCl7XHJcbiAgICB3aGlsZSh0aGlzLnBlbmRpbmdFbGVtZW50cy5sZW5ndGgpe1xyXG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wZW5kaW5nRWxlbWVudHMucG9wKCk7XHJcbiAgICAgICAgZWxlbWVudC5jaGVja1BhcmVudGluZygpO1xyXG4gICAgICAgIGlmKGVsZW1lbnQuZGF0YS50dCl7XHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHdoaWxlKGk8bGVuKXtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZWxlbWVudHNbaV0gPT09IGVsZW1lbnQpe1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0TWF0dGUodGhpcy5lbGVtZW50c1tpIC0gMV0ubGF5ZXJJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbihudW0pe1xyXG4gICAgaWYodGhpcy5yZW5kZXJlZEZyYW1lID09PSBudW0gfHwgdGhpcy5kZXN0cm95ZWQpe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmKG51bSA9PT0gbnVsbCl7XHJcbiAgICAgICAgbnVtID0gdGhpcy5yZW5kZXJlZEZyYW1lO1xyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gbnVtO1xyXG4gICAgfVxyXG4gICAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0nKTtcclxuICAgIC8vIGNvbnNvbGUubG9nKCdGUkFNRSAnLG51bSk7XHJcbiAgICB0aGlzLmdsb2JhbERhdGEuZnJhbWVOdW0gPSBudW07XHJcbiAgICB0aGlzLmdsb2JhbERhdGEuZnJhbWVJZCArPSAxO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UuY3VycmVudEZyYW1lID0gbnVtO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLl9tZGYgPSBmYWxzZTtcclxuICAgIHZhciBpLCBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XHJcbiAgICBpZighdGhpcy5jb21wbGV0ZUxheWVycyl7XHJcbiAgICAgICAgdGhpcy5jaGVja0xheWVycyhudW0pO1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBpZih0aGlzLmNvbXBsZXRlTGF5ZXJzIHx8IHRoaXMuZWxlbWVudHNbaV0pe1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnByZXBhcmVGcmFtZShudW0gLSB0aGlzLmxheWVyc1tpXS5zdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYodGhpcy5nbG9iYWxEYXRhLl9tZGYpIHtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgaWYodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucmVuZGVyRnJhbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblNWR1JlbmRlcmVyLnByb3RvdHlwZS5hcHBlbmRFbGVtZW50SW5Qb3MgPSBmdW5jdGlvbihlbGVtZW50LCBwb3Mpe1xyXG4gICAgdmFyIG5ld0VsZW1lbnQgPSBlbGVtZW50LmdldEJhc2VFbGVtZW50KCk7XHJcbiAgICBpZighbmV3RWxlbWVudCl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgdmFyIG5leHRFbGVtZW50O1xyXG4gICAgd2hpbGUoaTxwb3Mpe1xyXG4gICAgICAgIGlmKHRoaXMuZWxlbWVudHNbaV0gJiYgdGhpcy5lbGVtZW50c1tpXSE9PSB0cnVlICYmIHRoaXMuZWxlbWVudHNbaV0uZ2V0QmFzZUVsZW1lbnQoKSl7XHJcbiAgICAgICAgICAgIG5leHRFbGVtZW50ID0gdGhpcy5lbGVtZW50c1tpXS5nZXRCYXNlRWxlbWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpICs9IDE7XHJcbiAgICB9XHJcbiAgICBpZihuZXh0RWxlbWVudCl7XHJcbiAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuaW5zZXJ0QmVmb3JlKG5ld0VsZW1lbnQsIG5leHRFbGVtZW50KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQobmV3RWxlbWVudCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdSZW5kZXJlci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG59O1xyXG5cclxuU1ZHUmVuZGVyZXIucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5sYXllckVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbn07XHJcblxuZnVuY3Rpb24gTWFza0VsZW1lbnQoZGF0YSxlbGVtZW50LGdsb2JhbERhdGEpIHtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhID0gZ2xvYmFsRGF0YTtcclxuICAgIHRoaXMuc3RvcmVkRGF0YSA9IFtdO1xyXG4gICAgdGhpcy5tYXNrc1Byb3BlcnRpZXMgPSB0aGlzLmRhdGEubWFza3NQcm9wZXJ0aWVzIHx8IFtdO1xyXG4gICAgdGhpcy5tYXNrRWxlbWVudCA9IG51bGw7XHJcbiAgICB2YXIgZGVmcyA9IHRoaXMuZ2xvYmFsRGF0YS5kZWZzO1xyXG4gICAgdmFyIGksIGxlbiA9IHRoaXMubWFza3NQcm9wZXJ0aWVzID8gdGhpcy5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoIDogMDtcclxuICAgIHRoaXMudmlld0RhdGEgPSBjcmVhdGVTaXplZEFycmF5KGxlbik7XHJcbiAgICB0aGlzLnNvbGlkUGF0aCA9ICcnO1xyXG5cclxuXHJcbiAgICB2YXIgcGF0aCwgcHJvcGVydGllcyA9IHRoaXMubWFza3NQcm9wZXJ0aWVzO1xyXG4gICAgdmFyIGNvdW50ID0gMDtcclxuICAgIHZhciBjdXJyZW50TWFza3MgPSBbXTtcclxuICAgIHZhciBqLCBqTGVuO1xyXG4gICAgdmFyIGxheWVySWQgPSByYW5kb21TdHJpbmcoMTApO1xyXG4gICAgdmFyIHJlY3QsIGV4cGFuc29yLCBmZU1vcnBoLHg7XHJcbiAgICB2YXIgbWFza1R5cGUgPSAnY2xpcFBhdGgnLCBtYXNrUmVmID0gJ2NsaXAtcGF0aCc7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHJcbiAgICAgICAgaWYoKHByb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ2EnICYmIHByb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ24nKXx8IHByb3BlcnRpZXNbaV0uaW52IHx8IHByb3BlcnRpZXNbaV0uby5rICE9PSAxMDApe1xyXG4gICAgICAgICAgICBtYXNrVHlwZSA9ICdtYXNrJztcclxuICAgICAgICAgICAgbWFza1JlZiA9ICdtYXNrJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKChwcm9wZXJ0aWVzW2ldLm1vZGUgPT0gJ3MnIHx8IHByb3BlcnRpZXNbaV0ubW9kZSA9PSAnaScpICYmIGNvdW50ID09PSAwKXtcclxuICAgICAgICAgICAgcmVjdCA9IGNyZWF0ZU5TKCAncmVjdCcpO1xyXG4gICAgICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsICcjZmZmZmZmJyk7XHJcbiAgICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZWxlbWVudC5jb21wLmRhdGEudyB8fCAwKTtcclxuICAgICAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuZWxlbWVudC5jb21wLmRhdGEuaCB8fCAwKTtcclxuICAgICAgICAgICAgY3VycmVudE1hc2tzLnB1c2gocmVjdCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVjdCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXRoID0gY3JlYXRlTlMoICdwYXRoJyk7XHJcbiAgICAgICAgaWYocHJvcGVydGllc1tpXS5tb2RlID09ICduJykge1xyXG4gICAgICAgICAgICAvLyBUT0RPIG1vdmUgdGhpcyB0byBhIGZhY3Rvcnkgb3IgdG8gYSBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICB0aGlzLnZpZXdEYXRhW2ldID0ge1xyXG4gICAgICAgICAgICAgICAgb3A6IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMuZWxlbWVudCxwcm9wZXJ0aWVzW2ldLm8sMCwwLjAxLHRoaXMuZWxlbWVudCksXHJcbiAgICAgICAgICAgICAgICBwcm9wOiBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AodGhpcy5lbGVtZW50LHByb3BlcnRpZXNbaV0sMyksXHJcbiAgICAgICAgICAgICAgICBlbGVtOiBwYXRoLFxyXG4gICAgICAgICAgICAgICAgbGFzdFBhdGg6ICcnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQocGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb3VudCArPSAxO1xyXG5cclxuICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsIHByb3BlcnRpZXNbaV0ubW9kZSA9PT0gJ3MnID8gJyMwMDAwMDAnOicjZmZmZmZmJyk7XHJcbiAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcnVsZScsJ25vbnplcm8nKTtcclxuICAgICAgICB2YXIgZmlsdGVySUQ7XHJcblxyXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzW2ldLnguayAhPT0gMCkge1xyXG4gICAgICAgICAgICBtYXNrVHlwZSA9ICdtYXNrJztcclxuICAgICAgICAgICAgbWFza1JlZiA9ICdtYXNrJztcclxuICAgICAgICAgICAgeCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMuZWxlbWVudCxwcm9wZXJ0aWVzW2ldLngsMCxudWxsLHRoaXMuZWxlbWVudCk7XHJcbiAgICAgICAgICAgIGZpbHRlcklEID0gJ2ZpXycrcmFuZG9tU3RyaW5nKDEwKTtcclxuICAgICAgICAgICAgZXhwYW5zb3IgPSBjcmVhdGVOUygnZmlsdGVyJyk7XHJcbiAgICAgICAgICAgIGV4cGFuc29yLnNldEF0dHJpYnV0ZSgnaWQnLGZpbHRlcklEKTtcclxuICAgICAgICAgICAgZmVNb3JwaCA9IGNyZWF0ZU5TKCdmZU1vcnBob2xvZ3knKTtcclxuICAgICAgICAgICAgZmVNb3JwaC5zZXRBdHRyaWJ1dGUoJ29wZXJhdG9yJywnZGlsYXRlJyk7XHJcbiAgICAgICAgICAgIGZlTW9ycGguc2V0QXR0cmlidXRlKCdpbicsJ1NvdXJjZUdyYXBoaWMnKTtcclxuICAgICAgICAgICAgZmVNb3JwaC5zZXRBdHRyaWJ1dGUoJ3JhZGl1cycsJzAnKTtcclxuICAgICAgICAgICAgZXhwYW5zb3IuYXBwZW5kQ2hpbGQoZmVNb3JwaCk7XHJcbiAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoZXhwYW5zb3IpO1xyXG4gICAgICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgcHJvcGVydGllc1tpXS5tb2RlID09PSAncycgPyAnIzAwMDAwMCc6JyNmZmZmZmYnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBmZU1vcnBoID0gbnVsbDtcclxuICAgICAgICAgICAgeCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUT0RPIG1vdmUgdGhpcyB0byBhIGZhY3Rvcnkgb3IgdG8gYSBjb25zdHJ1Y3RvclxyXG4gICAgICAgIHRoaXMuc3RvcmVkRGF0YVtpXSA9IHtcclxuICAgICAgICAgICAgIGVsZW06IHBhdGgsXHJcbiAgICAgICAgICAgICB4OiB4LFxyXG4gICAgICAgICAgICAgZXhwYW46IGZlTW9ycGgsXHJcbiAgICAgICAgICAgIGxhc3RQYXRoOiAnJyxcclxuICAgICAgICAgICAgbGFzdE9wZXJhdG9yOicnLFxyXG4gICAgICAgICAgICBmaWx0ZXJJZDpmaWx0ZXJJRCxcclxuICAgICAgICAgICAgbGFzdFJhZGl1czowXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZihwcm9wZXJ0aWVzW2ldLm1vZGUgPT0gJ2knKXtcclxuICAgICAgICAgICAgakxlbiA9IGN1cnJlbnRNYXNrcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBnID0gY3JlYXRlTlMoJ2cnKTtcclxuICAgICAgICAgICAgZm9yKGo9MDtqPGpMZW47ais9MSl7XHJcbiAgICAgICAgICAgICAgICBnLmFwcGVuZENoaWxkKGN1cnJlbnRNYXNrc1tqXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1hc2sgPSBjcmVhdGVOUygnbWFzaycpO1xyXG4gICAgICAgICAgICBtYXNrLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywnYWxwaGEnKTtcclxuICAgICAgICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoJ2lkJyxsYXllcklkKydfJytjb3VudCk7XHJcbiAgICAgICAgICAgIG1hc2suYXBwZW5kQ2hpbGQocGF0aCk7XHJcbiAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQobWFzayk7XHJcbiAgICAgICAgICAgIGcuc2V0QXR0cmlidXRlKCdtYXNrJywndXJsKCcgKyBsb2NhdGlvbkhyZWYgKyAnIycrbGF5ZXJJZCsnXycrY291bnQrJyknKTtcclxuXHJcbiAgICAgICAgICAgIGN1cnJlbnRNYXNrcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBjdXJyZW50TWFza3MucHVzaChnKTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgY3VycmVudE1hc2tzLnB1c2gocGF0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHByb3BlcnRpZXNbaV0uaW52ICYmICF0aGlzLnNvbGlkUGF0aCl7XHJcbiAgICAgICAgICAgIHRoaXMuc29saWRQYXRoID0gdGhpcy5jcmVhdGVMYXllclNvbGlkUGF0aCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPIG1vdmUgdGhpcyB0byBhIGZhY3Rvcnkgb3IgdG8gYSBjb25zdHJ1Y3RvclxyXG4gICAgICAgIHRoaXMudmlld0RhdGFbaV0gPSB7XHJcbiAgICAgICAgICAgIGVsZW06IHBhdGgsXHJcbiAgICAgICAgICAgIGxhc3RQYXRoOiAnJyxcclxuICAgICAgICAgICAgb3A6IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMuZWxlbWVudCxwcm9wZXJ0aWVzW2ldLm8sMCwwLjAxLHRoaXMuZWxlbWVudCksXHJcbiAgICAgICAgICAgIHByb3A6U2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0U2hhcGVQcm9wKHRoaXMuZWxlbWVudCxwcm9wZXJ0aWVzW2ldLDMpLFxyXG4gICAgICAgICAgICBpbnZSZWN0OiByZWN0XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZighdGhpcy52aWV3RGF0YVtpXS5wcm9wLmspe1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdQYXRoKHByb3BlcnRpZXNbaV0sdGhpcy52aWV3RGF0YVtpXS5wcm9wLnYsdGhpcy52aWV3RGF0YVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubWFza0VsZW1lbnQgPSBjcmVhdGVOUyggbWFza1R5cGUpO1xyXG5cclxuICAgIGxlbiA9IGN1cnJlbnRNYXNrcy5sZW5ndGg7XHJcbiAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgIHRoaXMubWFza0VsZW1lbnQuYXBwZW5kQ2hpbGQoY3VycmVudE1hc2tzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICBpZihjb3VudCA+IDApe1xyXG4gICAgICAgIHRoaXMubWFza0VsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIGxheWVySWQpO1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC5tYXNrZWRFbGVtZW50LnNldEF0dHJpYnV0ZShtYXNrUmVmLCBcInVybChcIiArIGxvY2F0aW9uSHJlZiArIFwiI1wiICsgbGF5ZXJJZCArIFwiKVwiKTtcclxuICAgICAgICBkZWZzLmFwcGVuZENoaWxkKHRoaXMubWFza0VsZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMudmlld0RhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50LmFkZFJlbmRlcmFibGVDb21wb25lbnQodGhpcyk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5NYXNrRWxlbWVudC5wcm90b3R5cGUuZ2V0TWFza1Byb3BlcnR5ID0gZnVuY3Rpb24ocG9zKXtcclxuICAgIHJldHVybiB0aGlzLnZpZXdEYXRhW3Bvc10ucHJvcDtcclxufTtcclxuXHJcbk1hc2tFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChpc0ZpcnN0RnJhbWUpIHtcclxuICAgIHZhciBmaW5hbE1hdCA9IHRoaXMuZWxlbWVudC5maW5hbFRyYW5zZm9ybS5tYXQ7XHJcbiAgICB2YXIgaSwgbGVuID0gdGhpcy5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgaWYodGhpcy52aWV3RGF0YVtpXS5wcm9wLl9tZGYgfHwgaXNGaXJzdEZyYW1lKXtcclxuICAgICAgICAgICAgdGhpcy5kcmF3UGF0aCh0aGlzLm1hc2tzUHJvcGVydGllc1tpXSx0aGlzLnZpZXdEYXRhW2ldLnByb3Audix0aGlzLnZpZXdEYXRhW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy52aWV3RGF0YVtpXS5vcC5fbWRmIHx8IGlzRmlyc3RGcmFtZSl7XHJcbiAgICAgICAgICAgIHRoaXMudmlld0RhdGFbaV0uZWxlbS5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsdGhpcy52aWV3RGF0YVtpXS5vcC52KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5tYXNrc1Byb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ24nKXtcclxuICAgICAgICAgICAgaWYodGhpcy52aWV3RGF0YVtpXS5pbnZSZWN0ICYmICh0aGlzLmVsZW1lbnQuZmluYWxUcmFuc2Zvcm0ubVByb3AuX21kZiB8fCBpc0ZpcnN0RnJhbWUpKXtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld0RhdGFbaV0uaW52UmVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCAtZmluYWxNYXQucHJvcHNbMTJdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld0RhdGFbaV0uaW52UmVjdC5zZXRBdHRyaWJ1dGUoJ3knLCAtZmluYWxNYXQucHJvcHNbMTNdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih0aGlzLnN0b3JlZERhdGFbaV0ueCAmJiAodGhpcy5zdG9yZWREYXRhW2ldLnguX21kZiB8fCBpc0ZpcnN0RnJhbWUpKXtcclxuICAgICAgICAgICAgICAgIHZhciBmZU1vcnBoID0gdGhpcy5zdG9yZWREYXRhW2ldLmV4cGFuO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5zdG9yZWREYXRhW2ldLngudiA8IDApe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuc3RvcmVkRGF0YVtpXS5sYXN0T3BlcmF0b3IgIT09ICdlcm9kZScpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0ubGFzdE9wZXJhdG9yID0gJ2Vyb2RlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yZWREYXRhW2ldLmVsZW0uc2V0QXR0cmlidXRlKCdmaWx0ZXInLCd1cmwoJyArIGxvY2F0aW9uSHJlZiArICcjJyt0aGlzLnN0b3JlZERhdGFbaV0uZmlsdGVySWQrJyknKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZmVNb3JwaC5zZXRBdHRyaWJ1dGUoJ3JhZGl1cycsLXRoaXMuc3RvcmVkRGF0YVtpXS54LnYpO1xyXG4gICAgICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5zdG9yZWREYXRhW2ldLmxhc3RPcGVyYXRvciAhPT0gJ2RpbGF0ZScpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0ubGFzdE9wZXJhdG9yID0gJ2RpbGF0ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmVkRGF0YVtpXS5lbGVtLnNldEF0dHJpYnV0ZSgnZmlsdGVyJyxudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yZWREYXRhW2ldLmVsZW0uc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCB0aGlzLnN0b3JlZERhdGFbaV0ueC52KjIpO1xyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbk1hc2tFbGVtZW50LnByb3RvdHlwZS5nZXRNYXNrZWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLm1hc2tFbGVtZW50O1xyXG59O1xyXG5cclxuTWFza0VsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUxheWVyU29saWRQYXRoID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBwYXRoID0gJ00wLDAgJztcclxuICAgIHBhdGggKz0gJyBoJyArIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53IDtcclxuICAgIHBhdGggKz0gJyB2JyArIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oIDtcclxuICAgIHBhdGggKz0gJyBoLScgKyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudyA7XHJcbiAgICBwYXRoICs9ICcgdi0nICsgdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmggKyAnICc7XHJcbiAgICByZXR1cm4gcGF0aDtcclxufTtcclxuXHJcbk1hc2tFbGVtZW50LnByb3RvdHlwZS5kcmF3UGF0aCA9IGZ1bmN0aW9uKHBhdGhEYXRhLHBhdGhOb2Rlcyx2aWV3RGF0YSl7XHJcbiAgICB2YXIgcGF0aFN0cmluZyA9IFwiIE1cIitwYXRoTm9kZXMudlswXVswXSsnLCcrcGF0aE5vZGVzLnZbMF1bMV07XHJcbiAgICB2YXIgaSwgbGVuO1xyXG4gICAgbGVuID0gcGF0aE5vZGVzLl9sZW5ndGg7XHJcbiAgICBmb3IoaT0xO2k8bGVuO2krPTEpe1xyXG4gICAgICAgIC8vcGF0aFN0cmluZyArPSBcIiBDXCIrcGF0aE5vZGVzLm9baS0xXVswXSsnLCcrcGF0aE5vZGVzLm9baS0xXVsxXSArIFwiIFwiK3BhdGhOb2Rlcy5pW2ldWzBdKycsJytwYXRoTm9kZXMuaVtpXVsxXSArIFwiIFwiK3BhdGhOb2Rlcy52W2ldWzBdKycsJytwYXRoTm9kZXMudltpXVsxXTtcclxuICAgICAgICBwYXRoU3RyaW5nICs9IFwiIENcIitwYXRoTm9kZXMub1tpLTFdWzBdKycsJytwYXRoTm9kZXMub1tpLTFdWzFdICsgXCIgXCIrcGF0aE5vZGVzLmlbaV1bMF0rJywnK3BhdGhOb2Rlcy5pW2ldWzFdICsgXCIgXCIrcGF0aE5vZGVzLnZbaV1bMF0rJywnK3BhdGhOb2Rlcy52W2ldWzFdO1xyXG4gICAgfVxyXG4gICAgICAgIC8vcGF0aFN0cmluZyArPSBcIiBDXCIrcGF0aE5vZGVzLm9baS0xXVswXSsnLCcrcGF0aE5vZGVzLm9baS0xXVsxXSArIFwiIFwiK3BhdGhOb2Rlcy5pWzBdWzBdKycsJytwYXRoTm9kZXMuaVswXVsxXSArIFwiIFwiK3BhdGhOb2Rlcy52WzBdWzBdKycsJytwYXRoTm9kZXMudlswXVsxXTtcclxuICAgIGlmKHBhdGhOb2Rlcy5jICYmIGxlbiA+IDEpe1xyXG4gICAgICAgIHBhdGhTdHJpbmcgKz0gXCIgQ1wiK3BhdGhOb2Rlcy5vW2ktMV1bMF0rJywnK3BhdGhOb2Rlcy5vW2ktMV1bMV0gKyBcIiBcIitwYXRoTm9kZXMuaVswXVswXSsnLCcrcGF0aE5vZGVzLmlbMF1bMV0gKyBcIiBcIitwYXRoTm9kZXMudlswXVswXSsnLCcrcGF0aE5vZGVzLnZbMF1bMV07XHJcbiAgICB9XHJcbiAgICAvL3BhdGhOb2Rlcy5fX3JlbmRlcmVkU3RyaW5nID0gcGF0aFN0cmluZztcclxuXHJcbiAgICBpZih2aWV3RGF0YS5sYXN0UGF0aCAhPT0gcGF0aFN0cmluZyl7XHJcbiAgICAgICAgdmFyIHBhdGhTaGFwZVZhbHVlID0gJyc7XHJcbiAgICAgICAgaWYodmlld0RhdGEuZWxlbSl7XHJcbiAgICAgICAgICAgIGlmKHBhdGhOb2Rlcy5jKXtcclxuICAgICAgICAgICAgICAgIHBhdGhTaGFwZVZhbHVlID0gcGF0aERhdGEuaW52ID8gdGhpcy5zb2xpZFBhdGggKyBwYXRoU3RyaW5nIDogcGF0aFN0cmluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2aWV3RGF0YS5lbGVtLnNldEF0dHJpYnV0ZSgnZCcscGF0aFNoYXBlVmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2aWV3RGF0YS5sYXN0UGF0aCA9IHBhdGhTdHJpbmc7XHJcbiAgICB9XHJcbn07XHJcblxyXG5NYXNrRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhID0gbnVsbDtcclxuICAgIHRoaXMubWFza0VsZW1lbnQgPSBudWxsO1xyXG4gICAgdGhpcy5kYXRhID0gbnVsbDtcclxuICAgIHRoaXMubWFza3NQcm9wZXJ0aWVzID0gbnVsbDtcclxufTtcclxuXG4vKipcclxuICogQGZpbGUgXHJcbiAqIEhhbmRsZXMgQUUncyBsYXllciBwYXJlbnRpbmcgcHJvcGVydHkuXHJcbiAqXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gSGllcmFyY2h5RWxlbWVudCgpe31cclxuXHJcbkhpZXJhcmNoeUVsZW1lbnQucHJvdG90eXBlID0ge1xyXG5cdC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIFxyXG4gICAgICogSW5pdGlhbGl6ZXMgaGllcmFyY2h5IHByb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKi9cclxuXHRpbml0SGllcmFyY2h5OiBmdW5jdGlvbigpIHtcclxuXHRcdC8vZWxlbWVudCdzIHBhcmVudCBsaXN0XHJcblx0ICAgIHRoaXMuaGllcmFyY2h5ID0gW107XHJcblx0ICAgIC8vaWYgZWxlbWVudCBpcyBwYXJlbnQgb2YgYW5vdGhlciBsYXllciBfaXNQYXJlbnQgd2lsbCBiZSB0cnVlXHJcblx0ICAgIHRoaXMuX2lzUGFyZW50ID0gZmFsc2U7XHJcblx0ICAgIHRoaXMuY2hlY2tQYXJlbnRpbmcoKTtcclxuXHR9LFxyXG5cdC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIFxyXG4gICAgICogU2V0cyBsYXllcidzIGhpZXJhcmNoeS5cclxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGhpZXJhcmNoXHJcbiAgICAgKiBsYXllcidzIHBhcmVudCBsaXN0XHJcbiAgICAgKlxyXG4gICAgICovIFxyXG5cdHNldEhpZXJhcmNoeTogZnVuY3Rpb24oaGllcmFyY2h5KXtcclxuXHQgICAgdGhpcy5oaWVyYXJjaHkgPSBoaWVyYXJjaHk7XHJcblx0fSxcclxuXHQvKipcclxuICAgICAqIEBmdW5jdGlvbiBcclxuICAgICAqIFNldHMgbGF5ZXIgYXMgcGFyZW50LlxyXG4gICAgICpcclxuICAgICAqLyBcclxuXHRzZXRBc1BhcmVudDogZnVuY3Rpb24oKSB7XHJcblx0ICAgIHRoaXMuX2lzUGFyZW50ID0gdHJ1ZTtcclxuXHR9LFxyXG5cdC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIFxyXG4gICAgICogU2VhcmNoZXMgbGF5ZXIncyBwYXJlbnRpbmcgY2hhaW5cclxuICAgICAqXHJcbiAgICAgKi8gXHJcblx0Y2hlY2tQYXJlbnRpbmc6IGZ1bmN0aW9uKCl7XHJcblx0ICAgIGlmICh0aGlzLmRhdGEucGFyZW50ICE9PSB1bmRlZmluZWQpe1xyXG5cdCAgICAgICAgdGhpcy5jb21wLmJ1aWxkRWxlbWVudFBhcmVudGluZyh0aGlzLCB0aGlzLmRhdGEucGFyZW50LCBbXSk7XHJcblx0ICAgIH1cclxuXHR9XHJcbn07XG4vKipcclxuICogQGZpbGUgXHJcbiAqIEhhbmRsZXMgZWxlbWVudCdzIGxheWVyIGZyYW1lIHVwZGF0ZS5cclxuICogQ2hlY2tzIGxheWVyIGluIHBvaW50IGFuZCBvdXQgcG9pbnRcclxuICpcclxuICovXHJcblxyXG5mdW5jdGlvbiBGcmFtZUVsZW1lbnQoKXt9XHJcblxyXG5GcmFtZUVsZW1lbnQucHJvdG90eXBlID0ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZnVuY3Rpb24gXHJcbiAgICAgKiBJbml0aWFsaXplcyBmcmFtZSByZWxhdGVkIHByb3BlcnRpZXMuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBpbml0RnJhbWU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgLy9zZXQgdG8gdHJ1ZSB3aGVuIGlucG9pbnQgaXMgcmVuZGVyZWRcclxuICAgICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcclxuICAgICAgICAvL2xpc3Qgb2YgYW5pbWF0ZWQgcHJvcGVydGllc1xyXG4gICAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMgPSBbXTtcclxuICAgICAgICAvLyBJZiBsYXllciBoYXMgYmVlbiBtb2RpZmllZCBpbiBjdXJyZW50IHRpY2sgdGhpcyB3aWxsIGJlIHRydWVcclxuICAgICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcclxuICAgIH0sXHJcbiAgICAvKipcclxuICAgICAqIEBmdW5jdGlvbiBcclxuICAgICAqIENhbGN1bGF0ZXMgYWxsIGR5bmFtaWMgdmFsdWVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bVxyXG4gICAgICogY3VycmVudCBmcmFtZSBudW1iZXIgaW4gTGF5ZXIncyB0aW1lXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmlzaWJsZVxyXG4gICAgICogaWYgbGF5ZXJzIGlzIGN1cnJlbnRseSBpbiByYW5nZVxyXG4gICAgICogXHJcbiAgICAgKi9cclxuICAgIHByZXBhcmVQcm9wZXJ0aWVzOiBmdW5jdGlvbihudW0sIGlzVmlzaWJsZSkge1xyXG4gICAgICAgIHZhciBpLCBsZW4gPSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGkgPSAwO2kgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBpZiAoaXNWaXNpYmxlIHx8ICh0aGlzLl9pc1BhcmVudCAmJiB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLnByb3BUeXBlID09PSAndHJhbnNmb3JtJykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0uZ2V0VmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLl9tZGYpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuX21kZiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWRmID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBhZGREeW5hbWljUHJvcGVydHk6IGZ1bmN0aW9uKHByb3ApIHtcclxuICAgICAgICBpZih0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMucHVzaChwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XG5mdW5jdGlvbiBUcmFuc2Zvcm1FbGVtZW50KCl7fVxyXG5cclxuVHJhbnNmb3JtRWxlbWVudC5wcm90b3R5cGUgPSB7XHJcbiAgICBpbml0VHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmZpbmFsVHJhbnNmb3JtID0ge1xyXG4gICAgICAgICAgICBtUHJvcDogdGhpcy5kYXRhLmtzID8gVHJhbnNmb3JtUHJvcGVydHlGYWN0b3J5LmdldFRyYW5zZm9ybVByb3BlcnR5KHRoaXMsIHRoaXMuZGF0YS5rcywgdGhpcykgOiB7bzowfSxcclxuICAgICAgICAgICAgX21hdE1kZjogZmFsc2UsXHJcbiAgICAgICAgICAgIF9vcE1kZjogZmFsc2UsXHJcbiAgICAgICAgICAgIG1hdDogbmV3IE1hdHJpeCgpXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAodGhpcy5kYXRhLmFvKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3AuYXV0b09yaWVudGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vVE9ETzogY2hlY2sgVFlQRSAxMTogR3VpZGVkIGVsZW1lbnRzXHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YS50eSAhPT0gMTEpIHtcclxuICAgICAgICAgICAgLy90aGlzLmNyZWF0ZUVsZW1lbnRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlbmRlclRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX29wTWRmID0gdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5vLl9tZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lO1xyXG4gICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZiA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3AuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWU7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmhpZXJhcmNoeSkge1xyXG4gICAgICAgICAgICB2YXIgbWF0O1xyXG4gICAgICAgICAgICB2YXIgZmluYWxNYXQgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1hdDtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7XHJcbiAgICAgICAgICAgIC8vQ2hlY2tpbmcgaWYgYW55IG9mIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaWNlcyBpbiB0aGUgaGllcmFyY2h5IGNoYWluIGhhcyBjaGFuZ2VkLlxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZikge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3AuX21kZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmKSB7XHJcbiAgICAgICAgICAgICAgICBtYXQgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnYucHJvcHM7XHJcbiAgICAgICAgICAgICAgICBmaW5hbE1hdC5jbG9uZUZyb21Qcm9wcyhtYXQpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0ID0gdGhpcy5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3Audi5wcm9wcztcclxuICAgICAgICAgICAgICAgICAgICBmaW5hbE1hdC50cmFuc2Zvcm0obWF0WzBdLCBtYXRbMV0sIG1hdFsyXSwgbWF0WzNdLCBtYXRbNF0sIG1hdFs1XSwgbWF0WzZdLCBtYXRbN10sIG1hdFs4XSwgbWF0WzldLCBtYXRbMTBdLCBtYXRbMTFdLCBtYXRbMTJdLCBtYXRbMTNdLCBtYXRbMTRdLCBtYXRbMTVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBnbG9iYWxUb0xvY2FsOiBmdW5jdGlvbihwdCkge1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm1zID0gW107XHJcbiAgICAgICAgdHJhbnNmb3Jtcy5wdXNoKHRoaXMuZmluYWxUcmFuc2Zvcm0pO1xyXG4gICAgICAgIHZhciBmbGFnID0gdHJ1ZTtcclxuICAgICAgICB2YXIgY29tcCA9IHRoaXMuY29tcDtcclxuICAgICAgICB3aGlsZSAoZmxhZykge1xyXG4gICAgICAgICAgICBpZiAoY29tcC5maW5hbFRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXAuZGF0YS5oYXNNYXNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3Jtcy5zcGxpY2UoMCwgMCwgY29tcC5maW5hbFRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb21wID0gY29tcC5jb21wO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpLCBsZW4gPSB0cmFuc2Zvcm1zLmxlbmd0aCxwdE5ldztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgcHROZXcgPSB0cmFuc2Zvcm1zW2ldLm1hdC5hcHBseVRvUG9pbnRBcnJheSgwLCAwLCAwKTtcclxuICAgICAgICAgICAgLy9wdE5ldyA9IHRyYW5zZm9ybXNbaV0ubWF0LmFwcGx5VG9Qb2ludEFycmF5KHB0WzBdLHB0WzFdLHB0WzJdKTtcclxuICAgICAgICAgICAgcHQgPSBbcHRbMF0gLSBwdE5ld1swXSwgcHRbMV0gLSBwdE5ld1sxXSwgMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwdDtcclxuICAgIH0sXHJcbiAgICBtSGVscGVyOiBuZXcgTWF0cml4KClcclxufTtcbmZ1bmN0aW9uIFJlbmRlcmFibGVFbGVtZW50KCl7XHJcblxyXG59XHJcblxyXG5SZW5kZXJhYmxlRWxlbWVudC5wcm90b3R5cGUgPSB7XHJcbiAgICBpbml0UmVuZGVyYWJsZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy9sYXllcidzIHZpc2liaWxpdHkgcmVsYXRlZCB0byBpbnBvaW50IGFuZCBvdXRwb2ludC4gUmVuYW1lIGlzVmlzaWJsZSB0byBpc0luUmFuZ2VcclxuICAgICAgICB0aGlzLmlzSW5SYW5nZSA9IGZhbHNlO1xyXG4gICAgICAgIC8vbGF5ZXIncyBkaXNwbGF5IHN0YXRlXHJcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAvLyBJZiBsYXllcidzIHRyYW5zcGFyZW5jeSBlcXVhbHMgMCwgaXQgY2FuIGJlIGhpZGRlblxyXG4gICAgICAgIHRoaXMuaXNUcmFuc3BhcmVudCA9IGZhbHNlO1xyXG4gICAgICAgIC8vbGlzdCBvZiBhbmltYXRlZCBjb21wb25lbnRzXHJcbiAgICAgICAgdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cyA9IFtdO1xyXG4gICAgfSxcclxuICAgIGFkZFJlbmRlcmFibGVDb21wb25lbnQ6IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xyXG4gICAgICAgIGlmKHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnQpID09PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmFibGVDb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlUmVuZGVyYWJsZUNvbXBvbmVudDogZnVuY3Rpb24oY29tcG9uZW50KSB7XHJcbiAgICAgICAgaWYodGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMuc3BsaWNlKHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnQpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcHJlcGFyZVJlbmRlcmFibGVGcmFtZTogZnVuY3Rpb24obnVtKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja0xheWVyTGltaXRzKG51bSk7XHJcbiAgICB9LFxyXG4gICAgY2hlY2tUcmFuc3BhcmVuY3k6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYodGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5vLnYgPD0gMCkge1xyXG4gICAgICAgICAgICBpZighdGhpcy5pc1RyYW5zcGFyZW50ICYmIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJDb25maWcuaGlkZU9uVHJhbnNwYXJlbnQpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pc1RyYW5zcGFyZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMuaXNUcmFuc3BhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLmlzVHJhbnNwYXJlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5zaG93KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogQGZ1bmN0aW9uIFxyXG4gICAgICogSW5pdGlhbGl6ZXMgZnJhbWUgcmVsYXRlZCBwcm9wZXJ0aWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1cclxuICAgICAqIGN1cnJlbnQgZnJhbWUgbnVtYmVyIGluIExheWVyJ3MgdGltZVxyXG4gICAgICogXHJcbiAgICAgKi9cclxuICAgIGNoZWNrTGF5ZXJMaW1pdHM6IGZ1bmN0aW9uKG51bSkge1xyXG4gICAgICAgIGlmKHRoaXMuZGF0YS5pcCAtIHRoaXMuZGF0YS5zdCA8PSBudW0gJiYgdGhpcy5kYXRhLm9wIC0gdGhpcy5kYXRhLnN0ID4gbnVtKVxyXG4gICAgICAgIHtcclxuICAgICAgICAgICAgaWYodGhpcy5pc0luUmFuZ2UgIT09IHRydWUpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLl9tZGYgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbWRmID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNJblJhbmdlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2hvdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYodGhpcy5pc0luUmFuZ2UgIT09IGZhbHNlKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5fbWRmID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaXNJblJhbmdlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZW5kZXJSZW5kZXJhYmxlOiBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgaSwgbGVuID0gdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5sZW5ndGg7XHJcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50c1tpXS5yZW5kZXJGcmFtZSh0aGlzLl9pc0ZpcnN0RnJhbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKnRoaXMubWFza01hbmFnZXIucmVuZGVyRnJhbWUodGhpcy5maW5hbFRyYW5zZm9ybS5tYXQpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyYWJsZUVmZmVjdHNNYW5hZ2VyLnJlbmRlckZyYW1lKHRoaXMuX2lzRmlyc3RGcmFtZSk7Ki9cclxuICAgIH0sXHJcbiAgICBzb3VyY2VSZWN0QXRUaW1lOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRvcDowLFxyXG4gICAgICAgICAgICBsZWZ0OjAsXHJcbiAgICAgICAgICAgIHdpZHRoOjEwMCxcclxuICAgICAgICAgICAgaGVpZ2h0OjEwMFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgZ2V0TGF5ZXJTaXplOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmKHRoaXMuZGF0YS50eSA9PT0gNSl7XHJcbiAgICAgICAgICAgIHJldHVybiB7dzp0aGlzLmRhdGEudGV4dERhdGEud2lkdGgsaDp0aGlzLmRhdGEudGV4dERhdGEuaGVpZ2h0fTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgcmV0dXJuIHt3OnRoaXMuZGF0YS53aWR0aCxoOnRoaXMuZGF0YS5oZWlnaHR9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcbmZ1bmN0aW9uIFJlbmRlcmFibGVET01FbGVtZW50KCkge31cclxuXHJcbihmdW5jdGlvbigpe1xyXG4gICAgdmFyIF9wcm90b3R5cGUgPSB7XHJcbiAgICAgICAgaW5pdEVsZW1lbnQ6IGZ1bmN0aW9uKGRhdGEsZ2xvYmFsRGF0YSxjb21wKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdEZyYW1lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG4gICAgICAgICAgICB0aGlzLmluaXRUcmFuc2Zvcm0oZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdEhpZXJhcmNoeSgpO1xyXG4gICAgICAgICAgICB0aGlzLmluaXRSZW5kZXJhYmxlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdFJlbmRlcmVyRWxlbWVudCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHMoKTtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVDb250ZW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGlkZTogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmhpZGRlbiAmJiAoIXRoaXMuaXNJblJhbmdlIHx8IHRoaXMuaXNUcmFuc3BhcmVudCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gdGhpcy5iYXNlRWxlbWVudCB8fCB0aGlzLmxheWVyRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2hvdzogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJblJhbmdlICYmICF0aGlzLmlzVHJhbnNwYXJlbnQpe1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRhdGEuaGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IHRoaXMuYmFzZUVsZW1lbnQgfHwgdGhpcy5sYXllckVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW5kZXJGcmFtZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIC8vSWYgaXQgaXMgZXhwb3J0ZWQgYXMgaGlkZGVuIChkYXRhLmhkID09PSB0cnVlKSBubyBuZWVkIHRvIHJlbmRlclxyXG4gICAgICAgICAgICAvL0lmIGl0IGlzIG5vdCB2aXNpYmxlIG5vIG5lZWQgdG8gcmVuZGVyXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuaGQgfHwgdGhpcy5oaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclJlbmRlcmFibGUoKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVySW5uZXJDb250ZW50KCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZW5kZXJJbm5lckNvbnRlbnQ6IGZ1bmN0aW9uKCkge30sXHJcbiAgICAgICAgcHJlcGFyZUZyYW1lOiBmdW5jdGlvbihudW0pIHtcclxuICAgICAgICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMucHJlcGFyZVJlbmRlcmFibGVGcmFtZShudW0pO1xyXG4gICAgICAgICAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdGhpcy5pc0luUmFuZ2UpO1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrVHJhbnNwYXJlbmN5KCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICB0aGlzLmlubmVyRWxlbSA9ICBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lCYXNlRWxlbWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBleHRlbmRQcm90b3R5cGUoW1JlbmRlcmFibGVFbGVtZW50LCBjcmVhdGVQcm94eUZ1bmN0aW9uKF9wcm90b3R5cGUpXSwgUmVuZGVyYWJsZURPTUVsZW1lbnQpO1xyXG59KCkpO1xuZnVuY3Rpb24gUHJvY2Vzc2VkRWxlbWVudChlbGVtZW50LCBwb3NpdGlvbikge1xyXG5cdHRoaXMuZWxlbSA9IGVsZW1lbnQ7XHJcblx0dGhpcy5wb3MgPSBwb3NpdGlvbjtcclxufVxuZnVuY3Rpb24gU1ZHU3R5bGVEYXRhKGRhdGEsIGxldmVsKSB7XHJcblx0dGhpcy5kYXRhID0gZGF0YTtcclxuXHR0aGlzLnR5cGUgPSBkYXRhLnR5O1xyXG5cdHRoaXMuZCA9ICcnO1xyXG5cdHRoaXMubHZsID0gbGV2ZWw7XHJcblx0dGhpcy5fbWRmID0gZmFsc2U7XHJcblx0dGhpcy5jbG9zZWQgPSBkYXRhLmhkID09PSB0cnVlO1xyXG5cdHRoaXMucEVsZW0gPSBjcmVhdGVOUygncGF0aCcpO1xyXG5cdHRoaXMubXNFbGVtID0gbnVsbDtcclxufVxyXG5cclxuU1ZHU3R5bGVEYXRhLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMuZCA9ICcnO1xyXG5cdHRoaXMuX21kZiA9IGZhbHNlO1xyXG59O1xuZnVuY3Rpb24gU1ZHU2hhcGVEYXRhKHRyYW5zZm9ybWVycywgbGV2ZWwsIHNoYXBlKSB7XHJcbiAgICB0aGlzLmNhY2hlcyA9IFtdO1xyXG4gICAgdGhpcy5zdHlsZXMgPSBbXTtcclxuICAgIHRoaXMudHJhbnNmb3JtZXJzID0gdHJhbnNmb3JtZXJzO1xyXG4gICAgdGhpcy5sU3RyID0gJyc7XHJcbiAgICB0aGlzLnNoID0gc2hhcGU7XHJcbiAgICB0aGlzLmx2bCA9IGxldmVsO1xyXG4gICAgLy9UT0RPIGZpbmQgaWYgdGhlcmUgYXJlIHNvbWUgY2FzZXMgd2hlcmUgX2lzQW5pbWF0ZWQgY2FuIGJlIGZhbHNlLiBcclxuICAgIC8vIEZvciBub3csIHNpbmNlIHNoYXBlcyBhZGQgdXAgd2l0aCBvdGhlciBzaGFwZXMuIFRoZXkgaGF2ZSB0byBiZSBjYWxjdWxhdGVkIGV2ZXJ5IHRpbWUuXHJcbiAgICAvLyBPbmUgd2F5IG9mIGZpbmRpbmcgb3V0IGlzIGNoZWNraW5nIGlmIGFsbCBzdHlsZXMgYXNzb2NpYXRlZCB0byB0aGlzIHNoYXBlIGRlcGVuZCBvbmx5IG9mIHRoaXMgc2hhcGVcclxuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXNoYXBlLms7XHJcbiAgICAvLyBUT0RPOiBjb21tZW50aW5nIHRoaXMgZm9yIG5vdyBzaW5jZSBhbGwgc2hhcGVzIGFyZSBhbmltYXRlZFxyXG4gICAgdmFyIGkgPSAwLCBsZW4gPSB0cmFuc2Zvcm1lcnMubGVuZ3RoO1xyXG4gICAgd2hpbGUoaSA8IGxlbikge1xyXG4gICAgXHRpZih0cmFuc2Zvcm1lcnNbaV0ubVByb3BzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xyXG4gICAgXHRcdHRoaXMuX2lzQW5pbWF0ZWQgPSB0cnVlO1xyXG4gICAgXHRcdGJyZWFrO1xyXG4gICAgXHR9XHJcbiAgICBcdGkgKz0gMTtcclxuICAgIH1cclxufVxyXG5cclxuU1ZHU2hhcGVEYXRhLnByb3RvdHlwZS5zZXRBc0FuaW1hdGVkID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gdHJ1ZTtcclxufVxuZnVuY3Rpb24gU1ZHVHJhbnNmb3JtRGF0YShtUHJvcHMsIG9wLCBjb250YWluZXIpIHtcclxuXHR0aGlzLnRyYW5zZm9ybSA9IHtcclxuXHRcdG1Qcm9wczogbVByb3BzLFxyXG5cdFx0b3A6IG9wLFxyXG5cdFx0Y29udGFpbmVyOiBjb250YWluZXJcclxuXHR9O1xyXG5cdHRoaXMuZWxlbWVudHMgPSBbXTtcclxuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSB0aGlzLnRyYW5zZm9ybS5tUHJvcHMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoIHx8IHRoaXMudHJhbnNmb3JtLm9wLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGg7XHJcbn1cbmZ1bmN0aW9uIFNWR1N0cm9rZVN0eWxlRGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKXtcclxuXHR0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XHJcblx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzO1xyXG5cdHRoaXMubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS5vLDAsMC4wMSx0aGlzKTtcclxuXHR0aGlzLncgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLGRhdGEudywwLG51bGwsdGhpcyk7XHJcblx0dGhpcy5kID0gbmV3IERhc2hQcm9wZXJ0eShlbGVtLGRhdGEuZHx8e30sJ3N2ZycsdGhpcyk7XHJcblx0dGhpcy5jID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSxkYXRhLmMsMSwyNTUsdGhpcyk7XHJcblx0dGhpcy5zdHlsZSA9IHN0eWxlT2I7XHJcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLl9pc0FuaW1hdGVkO1xyXG59XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFNWR1N0cm9rZVN0eWxlRGF0YSk7XG5mdW5jdGlvbiBTVkdGaWxsU3R5bGVEYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2Ipe1xyXG5cdHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcclxuXHR0aGlzLmdldFZhbHVlID0gdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXM7XHJcblx0dGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSxkYXRhLm8sMCwwLjAxLHRoaXMpO1xyXG5cdHRoaXMuYyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS5jLDEsMjU1LHRoaXMpO1xyXG5cdHRoaXMuc3R5bGUgPSBzdHlsZU9iO1xyXG59XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFNWR0ZpbGxTdHlsZURhdGEpO1xuZnVuY3Rpb24gU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2Ipe1xyXG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xyXG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzO1xyXG4gICAgdGhpcy5pbml0R3JhZGllbnREYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpO1xyXG59XHJcblxyXG5TVkdHcmFkaWVudEZpbGxTdHlsZURhdGEucHJvdG90eXBlLmluaXRHcmFkaWVudERhdGEgPSBmdW5jdGlvbihlbGVtLCBkYXRhLCBzdHlsZU9iKXtcclxuICAgIHRoaXMubyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS5vLDAsMC4wMSx0aGlzKTtcclxuICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS5zLDEsbnVsbCx0aGlzKTtcclxuICAgIHRoaXMuZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS5lLDEsbnVsbCx0aGlzKTtcclxuICAgIHRoaXMuaCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS5ofHx7azowfSwwLDAuMDEsdGhpcyk7XHJcbiAgICB0aGlzLmEgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLGRhdGEuYXx8e2s6MH0sMCxkZWdUb1JhZHMsdGhpcyk7XHJcbiAgICB0aGlzLmcgPSBuZXcgR3JhZGllbnRQcm9wZXJ0eShlbGVtLGRhdGEuZyx0aGlzKTtcclxuICAgIHRoaXMuc3R5bGUgPSBzdHlsZU9iO1xyXG4gICAgdGhpcy5zdG9wcyA9IFtdO1xyXG4gICAgdGhpcy5zZXRHcmFkaWVudERhdGEoc3R5bGVPYi5wRWxlbSwgZGF0YSk7XHJcbiAgICB0aGlzLnNldEdyYWRpZW50T3BhY2l0eShkYXRhLCBzdHlsZU9iKTtcclxuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMuX2lzQW5pbWF0ZWQ7XHJcblxyXG59O1xyXG5cclxuU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhLnByb3RvdHlwZS5zZXRHcmFkaWVudERhdGEgPSBmdW5jdGlvbihwYXRoRWxlbWVudCxkYXRhKXtcclxuXHJcbiAgICB2YXIgZ3JhZGllbnRJZCA9ICdncl8nK3JhbmRvbVN0cmluZygxMCk7XHJcbiAgICB2YXIgZ2ZpbGwgPSBjcmVhdGVOUyhkYXRhLnQgPT09IDEgPyAnbGluZWFyR3JhZGllbnQnIDogJ3JhZGlhbEdyYWRpZW50Jyk7XHJcbiAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ2lkJyxncmFkaWVudElkKTtcclxuICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgnc3ByZWFkTWV0aG9kJywncGFkJyk7XHJcbiAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnLCd1c2VyU3BhY2VPblVzZScpO1xyXG4gICAgdmFyIHN0b3BzID0gW107XHJcbiAgICB2YXIgc3RvcCwgaiwgakxlbjtcclxuICAgIGpMZW4gPSBkYXRhLmcucCo0O1xyXG4gICAgZm9yKGo9MDtqPGpMZW47ais9NCl7XHJcbiAgICAgICAgc3RvcCA9IGNyZWF0ZU5TKCdzdG9wJyk7XHJcbiAgICAgICAgZ2ZpbGwuYXBwZW5kQ2hpbGQoc3RvcCk7XHJcbiAgICAgICAgc3RvcHMucHVzaChzdG9wKTtcclxuICAgIH1cclxuICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSggZGF0YS50eSA9PT0gJ2dmJyA/ICdmaWxsJzonc3Ryb2tlJywndXJsKCMnK2dyYWRpZW50SWQrJyknKTtcclxuICAgIFxyXG4gICAgdGhpcy5nZiA9IGdmaWxsO1xyXG4gICAgdGhpcy5jc3QgPSBzdG9wcztcclxufTtcclxuXHJcblNWR0dyYWRpZW50RmlsbFN0eWxlRGF0YS5wcm90b3R5cGUuc2V0R3JhZGllbnRPcGFjaXR5ID0gZnVuY3Rpb24oZGF0YSwgc3R5bGVPYil7XHJcbiAgICBpZih0aGlzLmcuX2hhc09wYWNpdHkgJiYgIXRoaXMuZy5fY29sbGFwc2FibGUpe1xyXG4gICAgICAgIHZhciBzdG9wLCBqLCBqTGVuO1xyXG4gICAgICAgIHZhciBtYXNrID0gY3JlYXRlTlMoXCJtYXNrXCIpO1xyXG4gICAgICAgIHZhciBtYXNrRWxlbWVudCA9IGNyZWF0ZU5TKCAncGF0aCcpO1xyXG4gICAgICAgIG1hc2suYXBwZW5kQ2hpbGQobWFza0VsZW1lbnQpO1xyXG4gICAgICAgIHZhciBvcGFjaXR5SWQgPSAnb3BfJytyYW5kb21TdHJpbmcoMTApO1xyXG4gICAgICAgIHZhciBtYXNrSWQgPSAnbWtfJytyYW5kb21TdHJpbmcoMTApO1xyXG4gICAgICAgIG1hc2suc2V0QXR0cmlidXRlKCdpZCcsbWFza0lkKTtcclxuICAgICAgICB2YXIgb3BGaWxsID0gY3JlYXRlTlMoZGF0YS50ID09PSAxID8gJ2xpbmVhckdyYWRpZW50JyA6ICdyYWRpYWxHcmFkaWVudCcpO1xyXG4gICAgICAgIG9wRmlsbC5zZXRBdHRyaWJ1dGUoJ2lkJyxvcGFjaXR5SWQpO1xyXG4gICAgICAgIG9wRmlsbC5zZXRBdHRyaWJ1dGUoJ3NwcmVhZE1ldGhvZCcsJ3BhZCcpO1xyXG4gICAgICAgIG9wRmlsbC5zZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnLCd1c2VyU3BhY2VPblVzZScpO1xyXG4gICAgICAgIGpMZW4gPSBkYXRhLmcuay5rWzBdLnMgPyBkYXRhLmcuay5rWzBdLnMubGVuZ3RoIDogZGF0YS5nLmsuay5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHN0b3BzID0gdGhpcy5zdG9wcztcclxuICAgICAgICBmb3Ioaj1kYXRhLmcucCo0O2o8akxlbjtqKz0yKXtcclxuICAgICAgICAgICAgc3RvcCA9IGNyZWF0ZU5TKCdzdG9wJyk7XHJcbiAgICAgICAgICAgIHN0b3Auc2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJywncmdiKDI1NSwyNTUsMjU1KScpO1xyXG4gICAgICAgICAgICBvcEZpbGwuYXBwZW5kQ2hpbGQoc3RvcCk7XHJcbiAgICAgICAgICAgIHN0b3BzLnB1c2goc3RvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hc2tFbGVtZW50LnNldEF0dHJpYnV0ZSggZGF0YS50eSA9PT0gJ2dmJyA/ICdmaWxsJzonc3Ryb2tlJywndXJsKCMnK29wYWNpdHlJZCsnKScpO1xyXG4gICAgICAgIHRoaXMub2YgPSBvcEZpbGw7XHJcbiAgICAgICAgdGhpcy5tcyA9IG1hc2s7XHJcbiAgICAgICAgdGhpcy5vc3QgPSBzdG9wcztcclxuICAgICAgICB0aGlzLm1hc2tJZCA9IG1hc2tJZDtcclxuICAgICAgICBzdHlsZU9iLm1zRWxlbSA9IG1hc2tFbGVtZW50O1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEpO1xuZnVuY3Rpb24gU1ZHR3JhZGllbnRTdHJva2VTdHlsZURhdGEoZWxlbSwgZGF0YSwgc3R5bGVPYil7XHJcblx0dGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xyXG5cdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcclxuXHR0aGlzLncgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLGRhdGEudywwLG51bGwsdGhpcyk7XHJcblx0dGhpcy5kID0gbmV3IERhc2hQcm9wZXJ0eShlbGVtLGRhdGEuZHx8e30sJ3N2ZycsdGhpcyk7XHJcbiAgICB0aGlzLmluaXRHcmFkaWVudERhdGEoZWxlbSwgZGF0YSwgc3R5bGVPYik7XHJcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLl9pc0FuaW1hdGVkO1xyXG59XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW1NWR0dyYWRpZW50RmlsbFN0eWxlRGF0YSwgRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU1ZHR3JhZGllbnRTdHJva2VTdHlsZURhdGEpO1xuZnVuY3Rpb24gU2hhcGVHcm91cERhdGEoKSB7XHJcblx0dGhpcy5pdCA9IFtdO1xyXG4gICAgdGhpcy5wcmV2Vmlld0RhdGEgPSBbXTtcclxuICAgIHRoaXMuZ3IgPSBjcmVhdGVOUygnZycpO1xyXG59XG52YXIgU1ZHRWxlbWVudHNSZW5kZXJlciA9IChmdW5jdGlvbigpIHtcclxuXHR2YXIgX2lkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeCgpO1xyXG5cdHZhciBfbWF0cml4SGVscGVyID0gbmV3IE1hdHJpeCgpO1xyXG5cclxuXHR2YXIgb2IgPSB7XHJcblx0XHRjcmVhdGVSZW5kZXJGdW5jdGlvbjogY3JlYXRlUmVuZGVyRnVuY3Rpb25cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZVJlbmRlckZ1bmN0aW9uKGRhdGEpIHtcclxuXHQgICAgdmFyIHR5ID0gZGF0YS50eTtcclxuXHQgICAgc3dpdGNoKGRhdGEudHkpIHtcclxuXHQgICAgICAgIGNhc2UgJ2ZsJzpcclxuXHQgICAgICAgIHJldHVybiByZW5kZXJGaWxsO1xyXG5cdCAgICAgICAgY2FzZSAnZ2YnOlxyXG5cdCAgICAgICAgcmV0dXJuIHJlbmRlckdyYWRpZW50O1xyXG5cdCAgICAgICAgY2FzZSAnZ3MnOlxyXG5cdCAgICAgICAgcmV0dXJuIHJlbmRlckdyYWRpZW50U3Ryb2tlO1xyXG5cdCAgICAgICAgY2FzZSAnc3QnOlxyXG5cdCAgICAgICAgcmV0dXJuIHJlbmRlclN0cm9rZTtcclxuXHQgICAgICAgIGNhc2UgJ3NoJzpcclxuXHQgICAgICAgIGNhc2UgJ2VsJzpcclxuXHQgICAgICAgIGNhc2UgJ3JjJzpcclxuXHQgICAgICAgIGNhc2UgJ3NyJzpcclxuXHQgICAgICAgIHJldHVybiByZW5kZXJQYXRoO1xyXG5cdCAgICAgICAgY2FzZSAndHInOlxyXG5cdCAgICAgICAgcmV0dXJuIHJlbmRlckNvbnRlbnRUcmFuc2Zvcm07XHJcblx0ICAgIH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlbmRlckNvbnRlbnRUcmFuc2Zvcm0oc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XHJcblx0ICAgIGlmKGlzRmlyc3RGcmFtZSB8fCBpdGVtRGF0YS50cmFuc2Zvcm0ub3AuX21kZil7XHJcblx0ICAgICAgICBpdGVtRGF0YS50cmFuc2Zvcm0uY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsaXRlbURhdGEudHJhbnNmb3JtLm9wLnYpO1xyXG5cdCAgICB9XHJcblx0ICAgIGlmKGlzRmlyc3RGcmFtZSB8fCBpdGVtRGF0YS50cmFuc2Zvcm0ubVByb3BzLl9tZGYpe1xyXG5cdCAgICAgICAgaXRlbURhdGEudHJhbnNmb3JtLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsaXRlbURhdGEudHJhbnNmb3JtLm1Qcm9wcy52LnRvMmRDU1MoKSk7XHJcblx0ICAgIH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHJlbmRlclBhdGgoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XHJcblx0ICAgIHZhciBqLCBqTGVuLHBhdGhTdHJpbmdUcmFuc2Zvcm1lZCxyZWRyYXcscGF0aE5vZGVzLGwsIGxMZW4gPSBpdGVtRGF0YS5zdHlsZXMubGVuZ3RoO1xyXG5cdCAgICB2YXIgbHZsID0gaXRlbURhdGEubHZsO1xyXG5cdCAgICB2YXIgcGF0aHMsIG1hdCwgcHJvcHMsIGl0ZXJhdGlvbnMsIGs7XHJcblx0ICAgIGZvcihsPTA7bDxsTGVuO2wrPTEpe1xyXG5cdCAgICAgICAgcmVkcmF3ID0gaXRlbURhdGEuc2guX21kZiB8fCBpc0ZpcnN0RnJhbWU7XHJcblx0ICAgICAgICBpZihpdGVtRGF0YS5zdHlsZXNbbF0ubHZsIDwgbHZsKXtcclxuXHQgICAgICAgICAgICBtYXQgPSBfbWF0cml4SGVscGVyLnJlc2V0KCk7XHJcblx0ICAgICAgICAgICAgaXRlcmF0aW9ucyA9IGx2bCAtIGl0ZW1EYXRhLnN0eWxlc1tsXS5sdmw7XHJcblx0ICAgICAgICAgICAgayA9IGl0ZW1EYXRhLnRyYW5zZm9ybWVycy5sZW5ndGgtMTtcclxuXHQgICAgICAgICAgICB3aGlsZSghcmVkcmF3ICYmIGl0ZXJhdGlvbnMgPiAwKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJlZHJhdyA9IGl0ZW1EYXRhLnRyYW5zZm9ybWVyc1trXS5tUHJvcHMuX21kZiB8fCByZWRyYXc7XHJcblx0ICAgICAgICAgICAgICAgIGl0ZXJhdGlvbnMgLS07XHJcblx0ICAgICAgICAgICAgICAgIGsgLS07XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIGlmKHJlZHJhdykge1xyXG5cdCAgICAgICAgICAgICAgICBpdGVyYXRpb25zID0gbHZsIC0gaXRlbURhdGEuc3R5bGVzW2xdLmx2bDtcclxuXHQgICAgICAgICAgICAgICAgayA9IGl0ZW1EYXRhLnRyYW5zZm9ybWVycy5sZW5ndGgtMTtcclxuXHQgICAgICAgICAgICAgICAgd2hpbGUoaXRlcmF0aW9ucyA+IDApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHByb3BzID0gaXRlbURhdGEudHJhbnNmb3JtZXJzW2tdLm1Qcm9wcy52LnByb3BzO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgbWF0LnRyYW5zZm9ybShwcm9wc1swXSxwcm9wc1sxXSxwcm9wc1syXSxwcm9wc1szXSxwcm9wc1s0XSxwcm9wc1s1XSxwcm9wc1s2XSxwcm9wc1s3XSxwcm9wc1s4XSxwcm9wc1s5XSxwcm9wc1sxMF0scHJvcHNbMTFdLHByb3BzWzEyXSxwcm9wc1sxM10scHJvcHNbMTRdLHByb3BzWzE1XSk7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpdGVyYXRpb25zIC0tO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgayAtLTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgbWF0ID0gX2lkZW50aXR5TWF0cml4O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgcGF0aHMgPSBpdGVtRGF0YS5zaC5wYXRocztcclxuXHQgICAgICAgIGpMZW4gPSBwYXRocy5fbGVuZ3RoO1xyXG5cdCAgICAgICAgaWYocmVkcmF3KXtcclxuXHQgICAgICAgICAgICBwYXRoU3RyaW5nVHJhbnNmb3JtZWQgPSAnJztcclxuXHQgICAgICAgICAgICBmb3Ioaj0wO2o8akxlbjtqKz0xKXtcclxuXHQgICAgICAgICAgICAgICAgcGF0aE5vZGVzID0gcGF0aHMuc2hhcGVzW2pdO1xyXG5cdCAgICAgICAgICAgICAgICBpZihwYXRoTm9kZXMgJiYgcGF0aE5vZGVzLl9sZW5ndGgpe1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcGF0aFN0cmluZ1RyYW5zZm9ybWVkICs9IGJ1aWxkU2hhcGVTdHJpbmcocGF0aE5vZGVzLCBwYXRoTm9kZXMuX2xlbmd0aCwgcGF0aE5vZGVzLmMsIG1hdCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgaXRlbURhdGEuY2FjaGVzW2xdID0gcGF0aFN0cmluZ1RyYW5zZm9ybWVkO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICBwYXRoU3RyaW5nVHJhbnNmb3JtZWQgPSBpdGVtRGF0YS5jYWNoZXNbbF07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBpdGVtRGF0YS5zdHlsZXNbbF0uZCArPSBzdHlsZURhdGEuaGQgPT09IHRydWUgPyAnJyA6IHBhdGhTdHJpbmdUcmFuc2Zvcm1lZDtcclxuXHQgICAgICAgIGl0ZW1EYXRhLnN0eWxlc1tsXS5fbWRmID0gcmVkcmF3IHx8IGl0ZW1EYXRhLnN0eWxlc1tsXS5fbWRmO1xyXG5cdCAgICB9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW5kZXJGaWxsIChzdHlsZURhdGEsaXRlbURhdGEsIGlzRmlyc3RGcmFtZSl7XHJcblx0ICAgIHZhciBzdHlsZUVsZW0gPSBpdGVtRGF0YS5zdHlsZTtcclxuXHJcblx0ICAgIGlmKGl0ZW1EYXRhLmMuX21kZiB8fCBpc0ZpcnN0RnJhbWUpe1xyXG5cdCAgICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnZmlsbCcsJ3JnYignK2JtX2Zsb29yKGl0ZW1EYXRhLmMudlswXSkrJywnK2JtX2Zsb29yKGl0ZW1EYXRhLmMudlsxXSkrJywnK2JtX2Zsb29yKGl0ZW1EYXRhLmMudlsyXSkrJyknKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZihpdGVtRGF0YS5vLl9tZGYgfHwgaXNGaXJzdEZyYW1lKXtcclxuXHQgICAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsaXRlbURhdGEuby52KTtcclxuXHQgICAgfVxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHJlbmRlckdyYWRpZW50U3Ryb2tlIChzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcclxuXHQgICAgcmVuZGVyR3JhZGllbnQoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKTtcclxuXHQgICAgcmVuZGVyU3Ryb2tlKHN0eWxlRGF0YSwgaXRlbURhdGEsIGlzRmlyc3RGcmFtZSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW5kZXJHcmFkaWVudChzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcclxuXHQgICAgdmFyIGdmaWxsID0gaXRlbURhdGEuZ2Y7XHJcblx0ICAgIHZhciBoYXNPcGFjaXR5ID0gaXRlbURhdGEuZy5faGFzT3BhY2l0eTtcclxuXHQgICAgdmFyIHB0MSA9IGl0ZW1EYXRhLnMudiwgcHQyID0gaXRlbURhdGEuZS52O1xyXG5cclxuXHQgICAgaWYgKGl0ZW1EYXRhLm8uX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcclxuXHQgICAgICAgIHZhciBhdHRyID0gc3R5bGVEYXRhLnR5ID09PSAnZ2YnID8gJ2ZpbGwtb3BhY2l0eScgOiAnc3Ryb2tlLW9wYWNpdHknO1xyXG5cdCAgICAgICAgaXRlbURhdGEuc3R5bGUucEVsZW0uc2V0QXR0cmlidXRlKGF0dHIsIGl0ZW1EYXRhLm8udik7XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKGl0ZW1EYXRhLnMuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcclxuXHQgICAgICAgIHZhciBhdHRyMSA9IHN0eWxlRGF0YS50ID09PSAxID8gJ3gxJyA6ICdjeCc7XHJcblx0ICAgICAgICB2YXIgYXR0cjIgPSBhdHRyMSA9PT0gJ3gxJyA/ICd5MScgOiAnY3knO1xyXG5cdCAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKGF0dHIxLCBwdDFbMF0pO1xyXG5cdCAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKGF0dHIyLCBwdDFbMV0pO1xyXG5cdCAgICAgICAgaWYgKGhhc09wYWNpdHkgJiYgIWl0ZW1EYXRhLmcuX2NvbGxhcHNhYmxlKSB7XHJcblx0ICAgICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKGF0dHIxLCBwdDFbMF0pO1xyXG5cdCAgICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZShhdHRyMiwgcHQxWzFdKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICB2YXIgc3RvcHMsIGksIGxlbiwgc3RvcDtcclxuXHQgICAgaWYgKGl0ZW1EYXRhLmcuX2NtZGYgfHwgaXNGaXJzdEZyYW1lKSB7XHJcblx0ICAgICAgICBzdG9wcyA9IGl0ZW1EYXRhLmNzdDtcclxuXHQgICAgICAgIHZhciBjVmFsdWVzID0gaXRlbURhdGEuZy5jO1xyXG5cdCAgICAgICAgbGVuID0gc3RvcHMubGVuZ3RoO1xyXG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKXtcclxuXHQgICAgICAgICAgICBzdG9wID0gc3RvcHNbaV07XHJcblx0ICAgICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ29mZnNldCcsIGNWYWx1ZXNbaSAqIDRdICsgJyUnKTtcclxuXHQgICAgICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicsJ3JnYignKyBjVmFsdWVzW2kgKiA0ICsgMV0gKyAnLCcgKyBjVmFsdWVzW2kgKiA0ICsgMl0gKyAnLCcrY1ZhbHVlc1tpICogNCArIDNdICsgJyknKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICBpZiAoaGFzT3BhY2l0eSAmJiAoaXRlbURhdGEuZy5fb21kZiB8fCBpc0ZpcnN0RnJhbWUpKSB7XHJcblx0ICAgICAgICB2YXIgb1ZhbHVlcyA9IGl0ZW1EYXRhLmcubztcclxuXHQgICAgICAgIGlmKGl0ZW1EYXRhLmcuX2NvbGxhcHNhYmxlKSB7XHJcblx0ICAgICAgICAgICAgc3RvcHMgPSBpdGVtRGF0YS5jc3Q7XHJcblx0ICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgIHN0b3BzID0gaXRlbURhdGEub3N0O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgbGVuID0gc3RvcHMubGVuZ3RoO1xyXG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcblx0ICAgICAgICAgICAgc3RvcCA9IHN0b3BzW2ldO1xyXG5cdCAgICAgICAgICAgIGlmKCFpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xyXG5cdCAgICAgICAgICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnb2Zmc2V0Jywgb1ZhbHVlc1tpICogMl0gKyAnJScpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnc3RvcC1vcGFjaXR5Jywgb1ZhbHVlc1tpICogMiArIDFdKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICBpZiAoc3R5bGVEYXRhLnQgPT09IDEpIHtcclxuXHQgICAgICAgIGlmIChpdGVtRGF0YS5lLl9tZGYgIHx8IGlzRmlyc3RGcmFtZSkge1xyXG5cdCAgICAgICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgneDInLCBwdDJbMF0pO1xyXG5cdCAgICAgICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgneTInLCBwdDJbMV0pO1xyXG5cdCAgICAgICAgICAgIGlmIChoYXNPcGFjaXR5ICYmICFpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xyXG5cdCAgICAgICAgICAgICAgICBpdGVtRGF0YS5vZi5zZXRBdHRyaWJ1dGUoJ3gyJywgcHQyWzBdKTtcclxuXHQgICAgICAgICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKCd5MicsIHB0MlsxXSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgdmFyIHJhZDtcclxuXHQgICAgICAgIGlmIChpdGVtRGF0YS5zLl9tZGYgfHwgaXRlbURhdGEuZS5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xyXG5cdCAgICAgICAgICAgIHJhZCA9IE1hdGguc3FydChNYXRoLnBvdyhwdDFbMF0gLSBwdDJbMF0sIDIpICsgTWF0aC5wb3cocHQxWzFdIC0gcHQyWzFdLCAyKSk7XHJcblx0ICAgICAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKCdyJywgcmFkKTtcclxuXHQgICAgICAgICAgICBpZihoYXNPcGFjaXR5ICYmICFpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSl7XHJcblx0ICAgICAgICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZSgncicsIHJhZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgaWYgKGl0ZW1EYXRhLmUuX21kZiB8fCBpdGVtRGF0YS5oLl9tZGYgfHwgaXRlbURhdGEuYS5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xyXG5cdCAgICAgICAgICAgIGlmICghcmFkKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJhZCA9IE1hdGguc3FydChNYXRoLnBvdyhwdDFbMF0gLSBwdDJbMF0sIDIpICsgTWF0aC5wb3cocHQxWzFdIC0gcHQyWzFdLCAyKSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHZhciBhbmcgPSBNYXRoLmF0YW4yKHB0MlsxXSAtIHB0MVsxXSwgcHQyWzBdIC0gcHQxWzBdKTtcclxuXHJcblx0ICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBpdGVtRGF0YS5oLnYgPj0gMSA/IDAuOTkgOiBpdGVtRGF0YS5oLnYgPD0gLTEgPyAtMC45OTogaXRlbURhdGEuaC52O1xyXG5cdCAgICAgICAgICAgIHZhciBkaXN0ID0gcmFkICogcGVyY2VudDtcclxuXHQgICAgICAgICAgICB2YXIgeCA9IE1hdGguY29zKGFuZyArIGl0ZW1EYXRhLmEudikgKiBkaXN0ICsgcHQxWzBdO1xyXG5cdCAgICAgICAgICAgIHZhciB5ID0gTWF0aC5zaW4oYW5nICsgaXRlbURhdGEuYS52KSAqIGRpc3QgKyBwdDFbMV07XHJcblx0ICAgICAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKCdmeCcsIHgpO1xyXG5cdCAgICAgICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgnZnknLCB5KTtcclxuXHQgICAgICAgICAgICBpZiAoaGFzT3BhY2l0eSAmJiAhaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcclxuXHQgICAgICAgICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKCdmeCcsIHgpO1xyXG5cdCAgICAgICAgICAgICAgICBpdGVtRGF0YS5vZi5zZXRBdHRyaWJ1dGUoJ2Z5JywgeSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgICAgLy9nZmlsbC5zZXRBdHRyaWJ1dGUoJ2Z5JywnMjAwJyk7XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiByZW5kZXJTdHJva2Uoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XHJcblx0ICAgIHZhciBzdHlsZUVsZW0gPSBpdGVtRGF0YS5zdHlsZTtcclxuXHQgICAgdmFyIGQgPSBpdGVtRGF0YS5kO1xyXG5cdCAgICBpZiAoZCAmJiAoZC5fbWRmIHx8IGlzRmlyc3RGcmFtZSkgJiYgZC5kYXNoU3RyKSB7XHJcblx0ICAgICAgICBzdHlsZUVsZW0ucEVsZW0uc2V0QXR0cmlidXRlKCdzdHJva2UtZGFzaGFycmF5JywgZC5kYXNoU3RyKTtcclxuXHQgICAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0JywgZC5kYXNob2Zmc2V0WzBdKTtcclxuXHQgICAgfVxyXG5cdCAgICBpZihpdGVtRGF0YS5jICYmIChpdGVtRGF0YS5jLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSl7XHJcblx0ICAgICAgICBzdHlsZUVsZW0ucEVsZW0uc2V0QXR0cmlidXRlKCdzdHJva2UnLCdyZ2IoJyArIGJtX2Zsb29yKGl0ZW1EYXRhLmMudlswXSkgKyAnLCcgKyBibV9mbG9vcihpdGVtRGF0YS5jLnZbMV0pICsgJywnICsgYm1fZmxvb3IoaXRlbURhdGEuYy52WzJdKSArICcpJyk7XHJcblx0ICAgIH1cclxuXHQgICAgaWYoaXRlbURhdGEuby5fbWRmIHx8IGlzRmlyc3RGcmFtZSl7XHJcblx0ICAgICAgICBzdHlsZUVsZW0ucEVsZW0uc2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScsIGl0ZW1EYXRhLm8udik7XHJcblx0ICAgIH1cclxuXHQgICAgaWYoaXRlbURhdGEudy5fbWRmIHx8IGlzRmlyc3RGcmFtZSl7XHJcblx0ICAgICAgICBzdHlsZUVsZW0ucEVsZW0uc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCBpdGVtRGF0YS53LnYpO1xyXG5cdCAgICAgICAgaWYoc3R5bGVFbGVtLm1zRWxlbSl7XHJcblx0ICAgICAgICAgICAgc3R5bGVFbGVtLm1zRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIGl0ZW1EYXRhLncudik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gb2I7XHJcbn0oKSlcbmZ1bmN0aW9uIFNoYXBlVHJhbnNmb3JtTWFuYWdlcigpIHtcclxuXHR0aGlzLnNlcXVlbmNlcyA9IHt9O1xyXG5cdHRoaXMuc2VxdWVuY2VMaXN0ID0gW107XHJcbiAgICB0aGlzLnRyYW5zZm9ybV9rZXlfY291bnQgPSAwO1xyXG59XHJcblxyXG5TaGFwZVRyYW5zZm9ybU1hbmFnZXIucHJvdG90eXBlID0ge1xyXG5cdGFkZFRyYW5zZm9ybVNlcXVlbmNlOiBmdW5jdGlvbih0cmFuc2Zvcm1zKSB7XHJcblx0XHR2YXIgaSwgbGVuID0gdHJhbnNmb3Jtcy5sZW5ndGg7XHJcblx0XHR2YXIga2V5ID0gJ18nO1xyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuXHRcdFx0a2V5ICs9IHRyYW5zZm9ybXNbaV0udHJhbnNmb3JtLmtleSArICdfJztcclxuXHRcdH1cclxuXHRcdHZhciBzZXF1ZW5jZSA9IHRoaXMuc2VxdWVuY2VzW2tleV07XHJcblx0XHRpZighc2VxdWVuY2UpIHtcclxuXHRcdFx0c2VxdWVuY2UgPSB7XHJcblx0XHRcdFx0dHJhbnNmb3JtczogW10uY29uY2F0KHRyYW5zZm9ybXMpLFxyXG5cdFx0XHRcdGZpbmFsVHJhbnNmb3JtOiBuZXcgTWF0cml4KCksXHJcblx0XHRcdFx0X21kZjogZmFsc2VcclxuXHRcdFx0fTtcclxuXHRcdFx0dGhpcy5zZXF1ZW5jZXNba2V5XSA9IHNlcXVlbmNlO1xyXG5cdFx0XHR0aGlzLnNlcXVlbmNlTGlzdC5wdXNoKHNlcXVlbmNlKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBzZXF1ZW5jZTtcclxuXHR9LFxyXG5cdHByb2Nlc3NTZXF1ZW5jZTogZnVuY3Rpb24oc2VxdWVuY2UsIGlzRmlyc3RGcmFtZSkge1xyXG5cdFx0dmFyIGkgPSAwLCBsZW4gPSBzZXF1ZW5jZS50cmFuc2Zvcm1zLmxlbmd0aCwgX21kZiA9IGlzRmlyc3RGcmFtZTtcclxuXHRcdHdoaWxlIChpIDwgbGVuICYmICFpc0ZpcnN0RnJhbWUpIHtcclxuXHRcdFx0aWYgKHNlcXVlbmNlLnRyYW5zZm9ybXNbaV0udHJhbnNmb3JtLm1Qcm9wcy5fbWRmKSB7XHJcblx0XHRcdFx0X21kZiA9IHRydWU7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0aSArPSAxXHJcblx0XHR9XHJcblx0XHRpZiAoX21kZikge1xyXG5cdFx0XHR2YXIgcHJvcHM7XHJcblx0XHRcdHNlcXVlbmNlLmZpbmFsVHJhbnNmb3JtLnJlc2V0KCk7XHJcblx0XHRcdGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XHJcblx0XHQgICAgICAgIHByb3BzID0gc2VxdWVuY2UudHJhbnNmb3Jtc1tpXS50cmFuc2Zvcm0ubVByb3BzLnYucHJvcHM7XHJcblx0XHQgICAgICAgIHNlcXVlbmNlLmZpbmFsVHJhbnNmb3JtLnRyYW5zZm9ybShwcm9wc1swXSxwcm9wc1sxXSxwcm9wc1syXSxwcm9wc1szXSxwcm9wc1s0XSxwcm9wc1s1XSxwcm9wc1s2XSxwcm9wc1s3XSxwcm9wc1s4XSxwcm9wc1s5XSxwcm9wc1sxMF0scHJvcHNbMTFdLHByb3BzWzEyXSxwcm9wc1sxM10scHJvcHNbMTRdLHByb3BzWzE1XSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHNlcXVlbmNlLl9tZGYgPSBfbWRmO1xyXG5cdFx0XHJcblx0fSxcclxuXHRwcm9jZXNzU2VxdWVuY2VzOiBmdW5jdGlvbihpc0ZpcnN0RnJhbWUpIHtcclxuXHRcdHZhciBpLCBsZW4gPSB0aGlzLnNlcXVlbmNlTGlzdC5sZW5ndGg7XHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuXHRcdFx0dGhpcy5wcm9jZXNzU2VxdWVuY2UodGhpcy5zZXF1ZW5jZUxpc3RbaV0sIGlzRmlyc3RGcmFtZSk7XHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblx0Z2V0TmV3S2V5OiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAnXycgKyB0aGlzLnRyYW5zZm9ybV9rZXlfY291bnQrKztcclxuXHR9XHJcbn1cbmZ1bmN0aW9uIEJhc2VFbGVtZW50KCl7XHJcbn1cclxuXHJcbkJhc2VFbGVtZW50LnByb3RvdHlwZSA9IHtcclxuICAgIGNoZWNrTWFza3M6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYoIXRoaXMuZGF0YS5oYXNNYXNrKXtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuZGF0YS5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlKGk8bGVuKSB7XHJcbiAgICAgICAgICAgIGlmKCh0aGlzLmRhdGEubWFza3NQcm9wZXJ0aWVzW2ldLm1vZGUgIT09ICduJyAmJiB0aGlzLmRhdGEubWFza3NQcm9wZXJ0aWVzW2ldLmNsICE9PSBmYWxzZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuICAgIGluaXRFeHByZXNzaW9uczogZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLmxheWVySW50ZXJmYWNlID0gTGF5ZXJFeHByZXNzaW9uSW50ZXJmYWNlKHRoaXMpO1xyXG4gICAgICAgIGlmKHRoaXMuZGF0YS5oYXNNYXNrICYmIHRoaXMubWFza01hbmFnZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXllckludGVyZmFjZS5yZWdpc3Rlck1hc2tJbnRlcmZhY2UodGhpcy5tYXNrTWFuYWdlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlZmZlY3RzSW50ZXJmYWNlID0gRWZmZWN0c0V4cHJlc3Npb25JbnRlcmZhY2UuY3JlYXRlRWZmZWN0c0ludGVyZmFjZSh0aGlzLHRoaXMubGF5ZXJJbnRlcmZhY2UpO1xyXG4gICAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UucmVnaXN0ZXJFZmZlY3RzSW50ZXJmYWNlKGVmZmVjdHNJbnRlcmZhY2UpO1xyXG5cclxuICAgICAgICBpZih0aGlzLmRhdGEudHkgPT09IDAgfHwgdGhpcy5kYXRhLnh0KXtcclxuICAgICAgICAgICAgdGhpcy5jb21wSW50ZXJmYWNlID0gQ29tcEV4cHJlc3Npb25JbnRlcmZhY2UodGhpcyk7XHJcbiAgICAgICAgfSBlbHNlIGlmKHRoaXMuZGF0YS50eSA9PT0gNCl7XHJcbiAgICAgICAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2Uuc2hhcGVJbnRlcmZhY2UgPSBTaGFwZUV4cHJlc3Npb25JbnRlcmZhY2UodGhpcy5zaGFwZXNEYXRhLHRoaXMuaXRlbXNEYXRhLHRoaXMubGF5ZXJJbnRlcmZhY2UpO1xyXG4gICAgICAgICAgICB0aGlzLmxheWVySW50ZXJmYWNlLmNvbnRlbnQgPSB0aGlzLmxheWVySW50ZXJmYWNlLnNoYXBlSW50ZXJmYWNlO1xyXG4gICAgICAgIH0gZWxzZSBpZih0aGlzLmRhdGEudHkgPT09IDUpe1xyXG4gICAgICAgICAgICB0aGlzLmxheWVySW50ZXJmYWNlLnRleHRJbnRlcmZhY2UgPSBUZXh0RXhwcmVzc2lvbkludGVyZmFjZSh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5sYXllckludGVyZmFjZS50ZXh0ID0gdGhpcy5sYXllckludGVyZmFjZS50ZXh0SW50ZXJmYWNlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBibGVuZE1vZGVFbnVtczoge1xyXG4gICAgICAgIDE6J211bHRpcGx5JyxcclxuICAgICAgICAyOidzY3JlZW4nLFxyXG4gICAgICAgIDM6J292ZXJsYXknLFxyXG4gICAgICAgIDQ6J2RhcmtlbicsXHJcbiAgICAgICAgNTonbGlnaHRlbicsXHJcbiAgICAgICAgNjonY29sb3ItZG9kZ2UnLFxyXG4gICAgICAgIDc6J2NvbG9yLWJ1cm4nLFxyXG4gICAgICAgIDg6J2hhcmQtbGlnaHQnLFxyXG4gICAgICAgIDk6J3NvZnQtbGlnaHQnLFxyXG4gICAgICAgIDEwOidkaWZmZXJlbmNlJyxcclxuICAgICAgICAxMTonZXhjbHVzaW9uJyxcclxuICAgICAgICAxMjonaHVlJyxcclxuICAgICAgICAxMzonc2F0dXJhdGlvbicsXHJcbiAgICAgICAgMTQ6J2NvbG9yJyxcclxuICAgICAgICAxNTonbHVtaW5vc2l0eSdcclxuICAgIH0sXHJcbiAgICBnZXRCbGVuZE1vZGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmxlbmRNb2RlRW51bXNbdGhpcy5kYXRhLmJtXSB8fCAnJztcclxuICAgIH0sXHJcbiAgICBzZXRCbGVuZE1vZGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdmFyIGJsZW5kTW9kZVZhbHVlID0gdGhpcy5nZXRCbGVuZE1vZGUoKTtcclxuICAgICAgICB2YXIgZWxlbSA9IHRoaXMuYmFzZUVsZW1lbnQgfHwgdGhpcy5sYXllckVsZW1lbnQ7XHJcblxyXG4gICAgICAgIGVsZW0uc3R5bGVbJ21peC1ibGVuZC1tb2RlJ10gPSBibGVuZE1vZGVWYWx1ZTtcclxuICAgIH0sXHJcbiAgICBpbml0QmFzZURhdGE6IGZ1bmN0aW9uKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApe1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YSA9IGdsb2JhbERhdGE7XHJcbiAgICAgICAgdGhpcy5jb21wID0gY29tcDtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMubGF5ZXJJZCA9ICdseV8nK3JhbmRvbVN0cmluZygxMCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9TdHJldGNoIGZhY3RvciBmb3Igb2xkIGFuaW1hdGlvbnMgbWlzc2luZyB0aGlzIHByb3BlcnR5LlxyXG4gICAgICAgIGlmKCF0aGlzLmRhdGEuc3Ipe1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEuc3IgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBlZmZlY3RzIG1hbmFnZXJcclxuICAgICAgICB0aGlzLmVmZmVjdHNNYW5hZ2VyID0gbmV3IEVmZmVjdHNNYW5hZ2VyKHRoaXMuZGF0YSx0aGlzLHRoaXMuZHluYW1pY1Byb3BlcnRpZXMpO1xyXG4gICAgICAgIFxyXG4gICAgfSxcclxuICAgIGdldFR5cGU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZTtcclxuICAgIH1cclxufVxuZnVuY3Rpb24gTnVsbEVsZW1lbnQoZGF0YSxnbG9iYWxEYXRhLGNvbXApe1xyXG4gICAgdGhpcy5pbml0RnJhbWUoKTtcclxuXHR0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxuICAgIHRoaXMuaW5pdEZyYW1lKCk7XHJcbiAgICB0aGlzLmluaXRUcmFuc2Zvcm0oZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgICB0aGlzLmluaXRIaWVyYXJjaHkoKTtcclxufVxyXG5cclxuTnVsbEVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uKG51bSkge1xyXG4gICAgdGhpcy5wcmVwYXJlUHJvcGVydGllcyhudW0sIHRydWUpO1xyXG59O1xyXG5cclxuTnVsbEVsZW1lbnQucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24oKSB7XHJcbn07XHJcblxyXG5OdWxsRWxlbWVudC5wcm90b3R5cGUuZ2V0QmFzZUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbk51bGxFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XHJcbn07XHJcblxyXG5OdWxsRWxlbWVudC5wcm90b3R5cGUuc291cmNlUmVjdEF0VGltZSA9IGZ1bmN0aW9uKCkge1xyXG59O1xyXG5cclxuTnVsbEVsZW1lbnQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpIHtcclxufTtcclxuXHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsVHJhbnNmb3JtRWxlbWVudCxIaWVyYXJjaHlFbGVtZW50LEZyYW1lRWxlbWVudF0sIE51bGxFbGVtZW50KTtcclxuXG5mdW5jdGlvbiBTVkdCYXNlRWxlbWVudCgpe1xyXG59XHJcblxyXG5TVkdCYXNlRWxlbWVudC5wcm90b3R5cGUgPSB7XHJcbiAgICBpbml0UmVuZGVyZXJFbGVtZW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmxheWVyRWxlbWVudCA9IGNyZWF0ZU5TKCdnJyk7XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlQ29udGFpbmVyRWxlbWVudHM6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5tYXR0ZUVsZW1lbnQgPSBjcmVhdGVOUygnZycpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5tYXNrZWRFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5fc2l6ZUNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgbGF5ZXJFbGVtZW50UGFyZW50ID0gbnVsbDtcclxuICAgICAgICAvL0lmIHRoaXMgbGF5ZXIgYWN0cyBhcyBhIG1hc2sgZm9yIHRoZSBmb2xsb3dpbmcgbGF5ZXJcclxuICAgICAgICB2YXIgZmlsSWQsIGZpbCwgZ2c7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YS50ZCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLnRkID09IDMgfHwgdGhpcy5kYXRhLnRkID09IDEpIHtcclxuICAgICAgICAgICAgICAgIHZhciBtYXNrZXIgPSBjcmVhdGVOUygnbWFzaycpO1xyXG4gICAgICAgICAgICAgICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmxheWVySWQpO1xyXG4gICAgICAgICAgICAgICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgdGhpcy5kYXRhLnRkID09IDMgPyAnbHVtaW5hbmNlJyA6ICdhbHBoYScpO1xyXG4gICAgICAgICAgICAgICAgbWFza2VyLmFwcGVuZENoaWxkKHRoaXMubGF5ZXJFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGxheWVyRWxlbWVudFBhcmVudCA9IG1hc2tlcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKG1hc2tlcik7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIG9ubHkgZm9yIElFIGFuZCBFZGdlIHdoZW4gbWFzayBpZiBvZiB0eXBlIGFscGhhXHJcbiAgICAgICAgICAgICAgICBpZiAoIWZlYXR1cmVTdXBwb3J0Lm1hc2tUeXBlICYmIHRoaXMuZGF0YS50ZCA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2x1bWluYW5jZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbElkID0gcmFuZG9tU3RyaW5nKDEwKTtcclxuICAgICAgICAgICAgICAgICAgICBmaWwgPSBmaWx0ZXJzRmFjdG9yeS5jcmVhdGVGaWx0ZXIoZmlsSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKGZpbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsLmFwcGVuZENoaWxkKGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2cgPSBjcmVhdGVOUygnZycpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdnLmFwcGVuZENoaWxkKHRoaXMubGF5ZXJFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBsYXllckVsZW1lbnRQYXJlbnQgPSBnZztcclxuICAgICAgICAgICAgICAgICAgICBtYXNrZXIuYXBwZW5kQ2hpbGQoZ2cpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdnLnNldEF0dHJpYnV0ZSgnZmlsdGVyJywndXJsKCcgKyBsb2NhdGlvbkhyZWYgKyAnIycgKyBmaWxJZCArICcpJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLmRhdGEudGQgPT0gMikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hc2tHcm91cCA9IGNyZWF0ZU5TKCdtYXNrJyk7XHJcbiAgICAgICAgICAgICAgICBtYXNrR3JvdXAuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMubGF5ZXJJZCk7XHJcbiAgICAgICAgICAgICAgICBtYXNrR3JvdXAuc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCdhbHBoYScpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG1hc2tHcm91cGVyID0gY3JlYXRlTlMoJ2cnKTtcclxuICAgICAgICAgICAgICAgIG1hc2tHcm91cC5hcHBlbmRDaGlsZChtYXNrR3JvdXBlcik7XHJcbiAgICAgICAgICAgICAgICBmaWxJZCA9IHJhbmRvbVN0cmluZygxMCk7XHJcbiAgICAgICAgICAgICAgICBmaWwgPSBmaWx0ZXJzRmFjdG9yeS5jcmVhdGVGaWx0ZXIoZmlsSWQpO1xyXG4gICAgICAgICAgICAgICAgLy8vL1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBmZUNvbG9yTWF0cml4ID0gY3JlYXRlTlMoJ2ZlQ29sb3JNYXRyaXgnKTtcclxuICAgICAgICAgICAgICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd0eXBlJywgJ21hdHJpeCcpO1xyXG4gICAgICAgICAgICAgICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdzUkdCJyk7XHJcbiAgICAgICAgICAgICAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndmFsdWVzJywnMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgLTEgMScpO1xyXG4gICAgICAgICAgICAgICAgZmlsLmFwcGVuZENoaWxkKGZlQ29sb3JNYXRyaXgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vLy9cclxuICAgICAgICAgICAgICAgIC8qdmFyIGZlQ1RyID0gY3JlYXRlTlMoJ2ZlQ29tcG9uZW50VHJhbnNmZXInKTtcclxuICAgICAgICAgICAgICAgIGZlQ1RyLnNldEF0dHJpYnV0ZSgnaW4nLCdTb3VyY2VHcmFwaGljJyk7XHJcbiAgICAgICAgICAgICAgICBmaWwuYXBwZW5kQ2hpbGQoZmVDVHIpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGZlRnVuYyA9IGNyZWF0ZU5TKCdmZUZ1bmNBJyk7XHJcbiAgICAgICAgICAgICAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKCd0eXBlJywndGFibGUnKTtcclxuICAgICAgICAgICAgICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywnMS4wIDAuMCcpO1xyXG4gICAgICAgICAgICAgICAgZmVDVHIuYXBwZW5kQ2hpbGQoZmVGdW5jKTsqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZmlsKTtcclxuICAgICAgICAgICAgICAgIHZhciBhbHBoYVJlY3QgPSBjcmVhdGVOUygncmVjdCcpO1xyXG4gICAgICAgICAgICAgICAgYWxwaGFSZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAgdGhpcy5jb21wLmRhdGEudyk7XHJcbiAgICAgICAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmNvbXAuZGF0YS5oKTtcclxuICAgICAgICAgICAgICAgIGFscGhhUmVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCcwJyk7XHJcbiAgICAgICAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCd5JywnMCcpO1xyXG4gICAgICAgICAgICAgICAgYWxwaGFSZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsJyNmZmZmZmYnKTtcclxuICAgICAgICAgICAgICAgIGFscGhhUmVjdC5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCcwJyk7XHJcbiAgICAgICAgICAgICAgICBtYXNrR3JvdXBlci5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsICd1cmwoJyArIGxvY2F0aW9uSHJlZiArICcjJytmaWxJZCsnKScpO1xyXG4gICAgICAgICAgICAgICAgbWFza0dyb3VwZXIuYXBwZW5kQ2hpbGQoYWxwaGFSZWN0KTtcclxuICAgICAgICAgICAgICAgIG1hc2tHcm91cGVyLmFwcGVuZENoaWxkKHRoaXMubGF5ZXJFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIGxheWVyRWxlbWVudFBhcmVudCA9IG1hc2tHcm91cGVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmZWF0dXJlU3VwcG9ydC5tYXNrVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tHcm91cC5zZXRBdHRyaWJ1dGUoJ21hc2stdHlwZScsICdsdW1pbmFuY2UnKTtcclxuICAgICAgICAgICAgICAgICAgICBmaWwuYXBwZW5kQ2hpbGQoZmlsdGVyc0ZhY3RvcnkuY3JlYXRlQWxwaGFUb0x1bWluYW5jZUZpbHRlcigpKTtcclxuICAgICAgICAgICAgICAgICAgICBnZyA9IGNyZWF0ZU5TKCdnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFza0dyb3VwZXIuYXBwZW5kQ2hpbGQoYWxwaGFSZWN0KTtcclxuICAgICAgICAgICAgICAgICAgICBnZy5hcHBlbmRDaGlsZCh0aGlzLmxheWVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJFbGVtZW50UGFyZW50ID0gZ2c7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFza0dyb3VwZXIuYXBwZW5kQ2hpbGQoZ2cpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQobWFza0dyb3VwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLnR0KSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF0dGVFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMubGF5ZXJFbGVtZW50KTtcclxuICAgICAgICAgICAgbGF5ZXJFbGVtZW50UGFyZW50ID0gdGhpcy5tYXR0ZUVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuYmFzZUVsZW1lbnQgPSB0aGlzLm1hdHRlRWxlbWVudDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmJhc2VFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRhdGEubG4pIHtcclxuICAgICAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuZGF0YS5sbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRhdGEuY2wpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHRoaXMuZGF0YS5jbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vQ2xpcHBpbmcgY29tcG9zaXRpb25zIHRvIGhpZGUgY29udGVudCB0aGF0IGV4Y2VlZHMgYm91bmRhcmllcy4gSWYgY29sbGFwc2VkIHRyYW5zZm9ybWF0aW9ucyBpcyBvbiwgY29tcG9uZW50IHNob3VsZCBub3QgYmUgY2xpcHBlZFxyXG4gICAgICAgIGlmICh0aGlzLmRhdGEudHkgPT09IDAgJiYgIXRoaXMuZGF0YS5oZCkge1xyXG4gICAgICAgICAgICB2YXIgY3AgPSBjcmVhdGVOUyggJ2NsaXBQYXRoJyk7XHJcbiAgICAgICAgICAgIHZhciBwdCA9IGNyZWF0ZU5TKCdwYXRoJyk7XHJcbiAgICAgICAgICAgIHB0LnNldEF0dHJpYnV0ZSgnZCcsJ00wLDAgTCcgKyB0aGlzLmRhdGEudyArICcsMCcgKyAnIEwnICsgdGhpcy5kYXRhLncgKyAnLCcgKyB0aGlzLmRhdGEuaCArICcgTDAsJyArIHRoaXMuZGF0YS5oICsgJ3onKTtcclxuICAgICAgICAgICAgdmFyIGNsaXBJZCA9ICdjcF8nK3JhbmRvbVN0cmluZyg4KTtcclxuICAgICAgICAgICAgY3Auc2V0QXR0cmlidXRlKCdpZCcsY2xpcElkKTtcclxuICAgICAgICAgICAgY3AuYXBwZW5kQ2hpbGQocHQpO1xyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChjcCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja01hc2tzKCkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjcEdyb3VwID0gY3JlYXRlTlMoJ2cnKTtcclxuICAgICAgICAgICAgICAgIGNwR3JvdXAuc2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnLCd1cmwoJyArIGxvY2F0aW9uSHJlZiArICcjJytjbGlwSWQgKyAnKScpO1xyXG4gICAgICAgICAgICAgICAgY3BHcm91cC5hcHBlbmRDaGlsZCh0aGlzLmxheWVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCA9IGNwR3JvdXA7XHJcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXJFbGVtZW50UGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJFbGVtZW50UGFyZW50LmFwcGVuZENoaWxkKHRoaXMudHJhbnNmb3JtZWRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXNlRWxlbWVudCA9IHRoaXMudHJhbnNmb3JtZWRFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnLCd1cmwoJyArIGxvY2F0aW9uSHJlZiArICcjJytjbGlwSWQrJyknKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5ibSAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldEJsZW5kTW9kZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LFxyXG4gICAgcmVuZGVyRWxlbWVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZikge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIHRoaXMuZmluYWxUcmFuc2Zvcm0ubWF0LnRvMmRDU1MoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmZpbmFsVHJhbnNmb3JtLl9vcE1kZikge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCB0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLm8udik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRlc3Ryb3lCYXNlRWxlbWVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy5sYXllckVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubWF0dGVFbGVtZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1hc2tNYW5hZ2VyLmRlc3Ryb3koKTtcclxuICAgIH0sXHJcbiAgICBnZXRCYXNlRWxlbWVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5oZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUVsZW1lbnQ7XHJcbiAgICB9LFxyXG4gICAgY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMubWFza01hbmFnZXIgPSBuZXcgTWFza0VsZW1lbnQodGhpcy5kYXRhLCB0aGlzLCB0aGlzLmdsb2JhbERhdGEpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyYWJsZUVmZmVjdHNNYW5hZ2VyID0gbmV3IFNWR0VmZmVjdHModGhpcyk7XHJcbiAgICB9LFxyXG4gICAgc2V0TWF0dGU6IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm1hdHRlRWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWF0dGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm1hc2tcIiwgXCJ1cmwoXCIgKyBsb2NhdGlvbkhyZWYgKyBcIiNcIiArIGlkICsgXCIpXCIpO1xyXG4gICAgfVxyXG59O1xuZnVuY3Rpb24gSVNoYXBlRWxlbWVudCgpe1xyXG59XHJcblxyXG5JU2hhcGVFbGVtZW50LnByb3RvdHlwZSA9IHtcclxuICAgIGFkZFNoYXBlVG9Nb2RpZmllcnM6IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICB2YXIgaSwgbGVuID0gdGhpcy5zaGFwZU1vZGlmaWVycy5sZW5ndGg7XHJcbiAgICAgICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAgICAgdGhpcy5zaGFwZU1vZGlmaWVyc1tpXS5hZGRTaGFwZShkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgaXNTaGFwZUluQW5pbWF0ZWRNb2RpZmllcnM6IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuc2hhcGVNb2RpZmllcnMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlKGkgPCBsZW4pIHtcclxuICAgICAgICAgICAgaWYodGhpcy5zaGFwZU1vZGlmaWVyc1tpXS5pc0FuaW1hdGVkV2l0aFNoYXBlKGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyTW9kaWZpZXJzOiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZighdGhpcy5zaGFwZU1vZGlmaWVycy5sZW5ndGgpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpLCBsZW4gPSB0aGlzLnNoYXBlcy5sZW5ndGg7XHJcbiAgICAgICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAgICAgdGhpcy5zaGFwZXNbaV0uc2gucmVzZXQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxlbiA9IHRoaXMuc2hhcGVNb2RpZmllcnMubGVuZ3RoO1xyXG4gICAgICAgIGZvcihpPWxlbi0xO2k+PTA7aS09MSl7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhcGVNb2RpZmllcnNbaV0ucHJvY2Vzc1NoYXBlcyh0aGlzLl9pc0ZpcnN0RnJhbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBsY0VudW06IHtcclxuICAgICAgICAnMSc6ICdidXR0JyxcclxuICAgICAgICAnMic6ICdyb3VuZCcsXHJcbiAgICAgICAgJzMnOiAnc3F1YXJlJ1xyXG4gICAgfSxcclxuICAgIGxqRW51bToge1xyXG4gICAgICAgICcxJzogJ21pdGVyJyxcclxuICAgICAgICAnMic6ICdyb3VuZCcsXHJcbiAgICAgICAgJzMnOiAnYmV2ZWwnXHJcbiAgICB9LFxyXG4gICAgc2VhcmNoUHJvY2Vzc2VkRWxlbWVudDogZnVuY3Rpb24oZWxlbSl7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5wcm9jZXNzZWRFbGVtZW50cztcclxuICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZShpIDwgbGVuKXtcclxuICAgICAgICAgICAgaWYoZWxlbWVudHNbaV0uZWxlbSA9PT0gZWxlbSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudHNbaV0ucG9zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgKz0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9LFxyXG4gICAgYWRkUHJvY2Vzc2VkRWxlbWVudDogZnVuY3Rpb24oZWxlbSwgcG9zKXtcclxuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLnByb2Nlc3NlZEVsZW1lbnRzO1xyXG4gICAgICAgIHZhciBpID0gZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlKGkpe1xyXG4gICAgICAgICAgICBpIC09IDE7XHJcbiAgICAgICAgICAgIGlmKGVsZW1lbnRzW2ldLmVsZW0gPT09IGVsZW0pe1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudHNbaV0ucG9zID0gcG9zO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZW1lbnRzLnB1c2gobmV3IFByb2Nlc3NlZEVsZW1lbnQoZWxlbSwgcG9zKSk7XHJcbiAgICB9LFxyXG4gICAgcHJlcGFyZUZyYW1lOiBmdW5jdGlvbihudW0pIHtcclxuICAgICAgICB0aGlzLnByZXBhcmVSZW5kZXJhYmxlRnJhbWUobnVtKTtcclxuICAgICAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdGhpcy5pc0luUmFuZ2UpO1xyXG4gICAgfVxyXG59O1xuZnVuY3Rpb24gSVRleHRFbGVtZW50KCl7XHJcbn1cclxuXHJcbklUZXh0RWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQgPSBmdW5jdGlvbihkYXRhLGdsb2JhbERhdGEsY29tcCl7XHJcbiAgICB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyA9IHRydWU7XHJcbiAgICB0aGlzLmluaXRGcmFtZSgpO1xyXG4gICAgdGhpcy5pbml0QmFzZURhdGEoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgICB0aGlzLnRleHRQcm9wZXJ0eSA9IG5ldyBUZXh0UHJvcGVydHkodGhpcywgZGF0YS50LCB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzKTtcclxuICAgIHRoaXMudGV4dEFuaW1hdG9yID0gbmV3IFRleHRBbmltYXRvclByb3BlcnR5KGRhdGEudCwgdGhpcy5yZW5kZXJUeXBlLCB0aGlzKTtcclxuICAgIHRoaXMuaW5pdFRyYW5zZm9ybShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxuICAgIHRoaXMuaW5pdEhpZXJhcmNoeSgpO1xyXG4gICAgdGhpcy5pbml0UmVuZGVyYWJsZSgpO1xyXG4gICAgdGhpcy5pbml0UmVuZGVyZXJFbGVtZW50KCk7XHJcbiAgICB0aGlzLmNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzKCk7XHJcbiAgICB0aGlzLmNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCk7XHJcbiAgICB0aGlzLmNyZWF0ZUNvbnRlbnQoKTtcclxuICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgdGhpcy50ZXh0QW5pbWF0b3Iuc2VhcmNoUHJvcGVydGllcyh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzKTtcclxufTtcclxuXHJcbklUZXh0RWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gZnVuY3Rpb24obnVtKSB7XHJcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcclxuICAgIHRoaXMucHJlcGFyZVJlbmRlcmFibGVGcmFtZShudW0pO1xyXG4gICAgdGhpcy5wcmVwYXJlUHJvcGVydGllcyhudW0sIHRoaXMuaXNJblJhbmdlKTtcclxuICAgIGlmKHRoaXMudGV4dFByb3BlcnR5Ll9tZGYgfHwgdGhpcy50ZXh0UHJvcGVydHkuX2lzRmlyc3RGcmFtZSkge1xyXG4gICAgICAgIHRoaXMuYnVpbGROZXdUZXh0KCk7XHJcbiAgICAgICAgdGhpcy50ZXh0UHJvcGVydHkuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudGV4dFByb3BlcnR5Ll9tZGYgPSBmYWxzZTtcclxuICAgIH1cclxufTtcclxuXHJcbklUZXh0RWxlbWVudC5wcm90b3R5cGUuY3JlYXRlUGF0aFNoYXBlID0gZnVuY3Rpb24obWF0cml4SGVscGVyLCBzaGFwZXMpIHtcclxuICAgIHZhciBqLGpMZW4gPSBzaGFwZXMubGVuZ3RoO1xyXG4gICAgdmFyIGssIGtMZW4sIHBhdGhOb2RlcztcclxuICAgIHZhciBzaGFwZVN0ciA9ICcnO1xyXG4gICAgZm9yKGo9MDtqPGpMZW47ais9MSl7XHJcbiAgICAgICAgcGF0aE5vZGVzID0gc2hhcGVzW2pdLmtzLms7XHJcbiAgICAgICAgc2hhcGVTdHIgKz0gYnVpbGRTaGFwZVN0cmluZyhwYXRoTm9kZXMsIHBhdGhOb2Rlcy5pLmxlbmd0aCwgdHJ1ZSwgbWF0cml4SGVscGVyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzaGFwZVN0cjtcclxufTtcclxuXHJcbklUZXh0RWxlbWVudC5wcm90b3R5cGUudXBkYXRlRG9jdW1lbnREYXRhID0gZnVuY3Rpb24obmV3RGF0YSwgaW5kZXgpIHtcclxuICAgIHRoaXMudGV4dFByb3BlcnR5LnVwZGF0ZURvY3VtZW50RGF0YShuZXdEYXRhLCBpbmRleCk7XHJcbn07XHJcblxyXG5JVGV4dEVsZW1lbnQucHJvdG90eXBlLmNhblJlc2l6ZUZvbnQgPSBmdW5jdGlvbihfY2FuUmVzaXplKSB7XHJcbiAgICB0aGlzLnRleHRQcm9wZXJ0eS5jYW5SZXNpemVGb250KF9jYW5SZXNpemUpO1xyXG59O1xyXG5cclxuSVRleHRFbGVtZW50LnByb3RvdHlwZS5zZXRNaW5pbXVtRm9udFNpemUgPSBmdW5jdGlvbihfZm9udFNpemUpIHtcclxuICAgIHRoaXMudGV4dFByb3BlcnR5LnNldE1pbmltdW1Gb250U2l6ZShfZm9udFNpemUpO1xyXG59O1xyXG5cclxuSVRleHRFbGVtZW50LnByb3RvdHlwZS5hcHBseVRleHRQcm9wZXJ0aWVzVG9NYXRyaXggPSBmdW5jdGlvbihkb2N1bWVudERhdGEsIG1hdHJpeEhlbHBlciwgbGluZU51bWJlciwgeFBvcywgeVBvcykge1xyXG4gICAgaWYoZG9jdW1lbnREYXRhLnBzKXtcclxuICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKGRvY3VtZW50RGF0YS5wc1swXSxkb2N1bWVudERhdGEucHNbMV0gKyBkb2N1bWVudERhdGEuYXNjZW50LDApO1xyXG4gICAgfVxyXG4gICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgwLC1kb2N1bWVudERhdGEubHMsMCk7XHJcbiAgICBzd2l0Y2goZG9jdW1lbnREYXRhLmope1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCArIChkb2N1bWVudERhdGEuYm94V2lkdGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsaW5lTnVtYmVyXSksMCwwKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ICsgKGRvY3VtZW50RGF0YS5ib3hXaWR0aCAtIGRvY3VtZW50RGF0YS5saW5lV2lkdGhzW2xpbmVOdW1iZXJdICkvMiwwLDApO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoeFBvcywgeVBvcywgMCk7XHJcbn07XHJcblxyXG5cclxuSVRleHRFbGVtZW50LnByb3RvdHlwZS5idWlsZENvbG9yID0gZnVuY3Rpb24oY29sb3JEYXRhKSB7XHJcbiAgICByZXR1cm4gJ3JnYignICsgTWF0aC5yb3VuZChjb2xvckRhdGFbMF0qMjU1KSArICcsJyArIE1hdGgucm91bmQoY29sb3JEYXRhWzFdKjI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKGNvbG9yRGF0YVsyXSoyNTUpICsgJyknO1xyXG59O1xyXG5cclxuSVRleHRFbGVtZW50LnByb3RvdHlwZS5lbXB0eVByb3AgPSBuZXcgTGV0dGVyUHJvcHMoKTtcclxuXHJcbklUZXh0RWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XHJcbiAgICBcclxufTtcbmZ1bmN0aW9uIElDb21wRWxlbWVudCgpe31cclxuXHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZURPTUVsZW1lbnRdLCBJQ29tcEVsZW1lbnQpO1xyXG5cclxuSUNvbXBFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IGZ1bmN0aW9uKGRhdGEsZ2xvYmFsRGF0YSxjb21wKSB7XHJcbiAgICB0aGlzLmluaXRGcmFtZSgpO1xyXG4gICAgdGhpcy5pbml0QmFzZURhdGEoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgICB0aGlzLmluaXRUcmFuc2Zvcm0oZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XHJcbiAgICB0aGlzLmluaXRSZW5kZXJhYmxlKCk7XHJcbiAgICB0aGlzLmluaXRIaWVyYXJjaHkoKTtcclxuICAgIHRoaXMuaW5pdFJlbmRlcmVyRWxlbWVudCgpO1xyXG4gICAgdGhpcy5jcmVhdGVDb250YWluZXJFbGVtZW50cygpO1xyXG4gICAgdGhpcy5jcmVhdGVSZW5kZXJhYmxlQ29tcG9uZW50cygpO1xyXG4gICAgaWYodGhpcy5kYXRhLnh0IHx8ICFnbG9iYWxEYXRhLnByb2dyZXNzaXZlTG9hZCl7XHJcbiAgICAgICAgdGhpcy5idWlsZEFsbEl0ZW1zKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmhpZGUoKTtcclxufTtcclxuXHJcbi8qSUNvbXBFbGVtZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24oKXtcclxuICAgIGlmKCF0aGlzLmhpZGRlbil7XHJcbiAgICAgICAgdGhpcy5oaWRlRWxlbWVudCgpO1xyXG4gICAgICAgIHZhciBpLGxlbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICAgIGZvciggaSA9IDA7IGkgPCBsZW47IGkrPTEgKXtcclxuICAgICAgICAgICAgaWYodGhpcy5lbGVtZW50c1tpXSl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTsqL1xyXG5cclxuSUNvbXBFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbihudW0pe1xyXG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XHJcbiAgICB0aGlzLnByZXBhcmVSZW5kZXJhYmxlRnJhbWUobnVtKTtcclxuICAgIHRoaXMucHJlcGFyZVByb3BlcnRpZXMobnVtLCB0aGlzLmlzSW5SYW5nZSk7XHJcbiAgICBpZighdGhpcy5pc0luUmFuZ2UgJiYgIXRoaXMuZGF0YS54dCl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy50bS5fcGxhY2Vob2xkZXIpIHtcclxuICAgICAgICB2YXIgdGltZVJlbWFwcGVkID0gdGhpcy50bS52O1xyXG4gICAgICAgIGlmKHRpbWVSZW1hcHBlZCA9PT0gdGhpcy5kYXRhLm9wKXtcclxuICAgICAgICAgICAgdGltZVJlbWFwcGVkID0gdGhpcy5kYXRhLm9wIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gdGltZVJlbWFwcGVkO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSBudW0vdGhpcy5kYXRhLnNyO1xyXG4gICAgfVxyXG4gICAgdmFyIGksbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XHJcbiAgICBpZighdGhpcy5jb21wbGV0ZUxheWVycyl7XHJcbiAgICAgICAgdGhpcy5jaGVja0xheWVycyh0aGlzLnJlbmRlcmVkRnJhbWUpO1xyXG4gICAgfVxyXG4gICAgLy9UaGlzIGl0ZXJhdGlvbiBuZWVkcyB0byBiZSBiYWNrd2FyZHMgYmVjYXVzZSBvZiBob3cgZXhwcmVzc2lvbnMgY29ubmVjdCBiZXR3ZWVuIGVhY2ggb3RoZXJcclxuICAgIGZvciggaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxICl7XHJcbiAgICAgICAgaWYodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKXtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5wcmVwYXJlRnJhbWUodGhpcy5yZW5kZXJlZEZyYW1lIC0gdGhpcy5sYXllcnNbaV0uc3QpO1xyXG4gICAgICAgICAgICBpZih0aGlzLmVsZW1lbnRzW2ldLl9tZGYpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5JQ29tcEVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGksbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xyXG4gICAgZm9yKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICl7XHJcbiAgICAgICAgaWYodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKXtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5yZW5kZXJGcmFtZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbklDb21wRWxlbWVudC5wcm90b3R5cGUuc2V0RWxlbWVudHMgPSBmdW5jdGlvbihlbGVtcyl7XHJcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbXM7XHJcbn07XHJcblxyXG5JQ29tcEVsZW1lbnQucHJvdG90eXBlLmdldEVsZW1lbnRzID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzO1xyXG59O1xyXG5cclxuSUNvbXBFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95RWxlbWVudHMgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGksbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xyXG4gICAgZm9yKCBpID0gMDsgaSA8IGxlbjsgaSs9MSApe1xyXG4gICAgICAgIGlmKHRoaXMuZWxlbWVudHNbaV0pe1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG5JQ29tcEVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5kZXN0cm95RWxlbWVudHMoKTtcclxuICAgIHRoaXMuZGVzdHJveUJhc2VFbGVtZW50KCk7XHJcbn07XHJcblxuZnVuY3Rpb24gSUltYWdlRWxlbWVudChkYXRhLGdsb2JhbERhdGEsY29tcCl7XHJcbiAgICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xyXG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLGdsb2JhbERhdGEsY29tcCk7XHJcbn1cclxuXHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsVHJhbnNmb3JtRWxlbWVudCxTVkdCYXNlRWxlbWVudCxIaWVyYXJjaHlFbGVtZW50LEZyYW1lRWxlbWVudCxSZW5kZXJhYmxlRE9NRWxlbWVudF0sIElJbWFnZUVsZW1lbnQpO1xyXG5cclxuSUltYWdlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uKCl7XHJcblxyXG4gICAgdmFyIGFzc2V0UGF0aCA9IHRoaXMuZ2xvYmFsRGF0YS5nZXRBc3NldHNQYXRoKHRoaXMuYXNzZXREYXRhKTtcclxuXHJcbiAgICB0aGlzLmlubmVyRWxlbSA9IGNyZWF0ZU5TKCdpbWFnZScpO1xyXG4gICAgdGhpcy5pbm5lckVsZW0uc2V0QXR0cmlidXRlKCd3aWR0aCcsdGhpcy5hc3NldERhdGEudytcInB4XCIpO1xyXG4gICAgdGhpcy5pbm5lckVsZW0uc2V0QXR0cmlidXRlKCdoZWlnaHQnLHRoaXMuYXNzZXREYXRhLmgrXCJweFwiKTtcclxuICAgIHRoaXMuaW5uZXJFbGVtLnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsdGhpcy5hc3NldERhdGEucHIgfHwgdGhpcy5nbG9iYWxEYXRhLnJlbmRlckNvbmZpZy5pbWFnZVByZXNlcnZlQXNwZWN0UmF0aW8pO1xyXG4gICAgdGhpcy5pbm5lckVsZW0uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCdocmVmJyxhc3NldFBhdGgpO1xyXG4gICAgXHJcbiAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmlubmVyRWxlbSk7XHJcbn07XHJcblxuZnVuY3Rpb24gSVNvbGlkRWxlbWVudChkYXRhLGdsb2JhbERhdGEsY29tcCl7XHJcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsZ2xvYmFsRGF0YSxjb21wKTtcclxufVxyXG5leHRlbmRQcm90b3R5cGUoW0lJbWFnZUVsZW1lbnRdLCBJU29saWRFbGVtZW50KTtcclxuXHJcbklTb2xpZEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbigpe1xyXG5cclxuICAgIHZhciByZWN0ID0gY3JlYXRlTlMoJ3JlY3QnKTtcclxuICAgIC8vLy9yZWN0LnN0eWxlLndpZHRoID0gdGhpcy5kYXRhLnN3O1xyXG4gICAgLy8vL3JlY3Quc3R5bGUuaGVpZ2h0ID0gdGhpcy5kYXRhLnNoO1xyXG4gICAgLy8vL3JlY3Quc3R5bGUuZmlsbCA9IHRoaXMuZGF0YS5zYztcclxuICAgIHJlY3Quc2V0QXR0cmlidXRlKCd3aWR0aCcsdGhpcy5kYXRhLnN3KTtcclxuICAgIHJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLHRoaXMuZGF0YS5zaCk7XHJcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsdGhpcy5kYXRhLnNjKTtcclxuICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHJlY3QpO1xyXG59O1xuZnVuY3Rpb24gU1ZHQ29tcEVsZW1lbnQoZGF0YSxnbG9iYWxEYXRhLGNvbXApe1xyXG4gICAgdGhpcy5sYXllcnMgPSBkYXRhLmxheWVycztcclxuICAgIHRoaXMuc3VwcG9ydHMzZCA9IHRydWU7XHJcbiAgICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gZmFsc2U7XHJcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xyXG4gICAgdGhpcy5lbGVtZW50cyA9IHRoaXMubGF5ZXJzID8gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLmxheWVycy5sZW5ndGgpIDogW107XHJcbiAgICAvL3RoaXMubGF5ZXJFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcclxuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSxnbG9iYWxEYXRhLGNvbXApO1xyXG4gICAgdGhpcy50bSA9IGRhdGEudG0gPyBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLGRhdGEudG0sMCxnbG9iYWxEYXRhLmZyYW1lUmF0ZSx0aGlzKSA6IHtfcGxhY2Vob2xkZXI6dHJ1ZX07XHJcbn1cclxuXHJcbmV4dGVuZFByb3RvdHlwZShbU1ZHUmVuZGVyZXIsIElDb21wRWxlbWVudCwgU1ZHQmFzZUVsZW1lbnRdLCBTVkdDb21wRWxlbWVudCk7XG5mdW5jdGlvbiBTVkdUZXh0RWxlbWVudChkYXRhLGdsb2JhbERhdGEsY29tcCl7XHJcbiAgICB0aGlzLnRleHRTcGFucyA9IFtdO1xyXG4gICAgdGhpcy5yZW5kZXJUeXBlID0gJ3N2Zyc7XHJcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsZ2xvYmFsRGF0YSxjb21wKTtcclxufVxyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCxUcmFuc2Zvcm1FbGVtZW50LFNWR0Jhc2VFbGVtZW50LEhpZXJhcmNoeUVsZW1lbnQsRnJhbWVFbGVtZW50LFJlbmRlcmFibGVET01FbGVtZW50LElUZXh0RWxlbWVudF0sIFNWR1RleHRFbGVtZW50KTtcclxuXHJcblNWR1RleHRFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24oKXtcclxuXHJcbiAgICBpZiAodGhpcy5kYXRhLnNpbmdsZVNoYXBlICYmICF0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuY2hhcnMpIHtcclxuICAgICAgICB0aGlzLnRleHRDb250YWluZXIgPSBjcmVhdGVOUygndGV4dCcpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuU1ZHVGV4dEVsZW1lbnQucHJvdG90eXBlLmJ1aWxkVGV4dENvbnRlbnRzID0gZnVuY3Rpb24odGV4dEFycmF5KSB7XHJcbiAgICB2YXIgaSA9IDAsIGxlbiA9IHRleHRBcnJheS5sZW5ndGg7XHJcbiAgICB2YXIgdGV4dENvbnRlbnRzID0gW10sIGN1cnJlbnRUZXh0Q29udGVudCA9ICcnO1xyXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgICAgICBpZih0ZXh0QXJyYXlbaV0gPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMTMpIHx8IHRleHRBcnJheVtpXSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgzKSkge1xyXG4gICAgICAgICAgICB0ZXh0Q29udGVudHMucHVzaChjdXJyZW50VGV4dENvbnRlbnQpO1xyXG4gICAgICAgICAgICBjdXJyZW50VGV4dENvbnRlbnQgPSAnJztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjdXJyZW50VGV4dENvbnRlbnQgKz0gdGV4dEFycmF5W2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpICs9IDE7XHJcbiAgICB9XHJcbiAgICB0ZXh0Q29udGVudHMucHVzaChjdXJyZW50VGV4dENvbnRlbnQpO1xyXG4gICAgcmV0dXJuIHRleHRDb250ZW50cztcclxufVxyXG5cclxuU1ZHVGV4dEVsZW1lbnQucHJvdG90eXBlLmJ1aWxkTmV3VGV4dCA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgaSwgbGVuO1xyXG5cclxuICAgIHZhciBkb2N1bWVudERhdGEgPSB0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YTtcclxuICAgIHRoaXMucmVuZGVyZWRMZXR0ZXJzID0gY3JlYXRlU2l6ZWRBcnJheShkb2N1bWVudERhdGEgPyBkb2N1bWVudERhdGEubC5sZW5ndGggOiAwKTtcclxuICAgIGlmKGRvY3VtZW50RGF0YS5mYykge1xyXG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsbCcsIHRoaXMuYnVpbGRDb2xvcihkb2N1bWVudERhdGEuZmMpKTtcclxuICAgIH1lbHNle1xyXG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsbCcsICdyZ2JhKDAsMCwwLDApJyk7XHJcbiAgICB9XHJcbiAgICBpZihkb2N1bWVudERhdGEuc2Mpe1xyXG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgdGhpcy5idWlsZENvbG9yKGRvY3VtZW50RGF0YS5zYykpO1xyXG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgZG9jdW1lbnREYXRhLnN3KTtcclxuICAgIH1cclxuICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSk7XHJcbiAgICB2YXIgZm9udERhdGEgPSB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZik7XHJcbiAgICBpZihmb250RGF0YS5mQ2xhc3Mpe1xyXG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLGZvbnREYXRhLmZDbGFzcyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZm9udC1mYW1pbHknLCBmb250RGF0YS5mRmFtaWx5KTtcclxuICAgICAgICB2YXIgZldlaWdodCA9IGRvY3VtZW50RGF0YS5mV2VpZ2h0LCBmU3R5bGUgPSBkb2N1bWVudERhdGEuZlN0eWxlO1xyXG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZm9udC1zdHlsZScsIGZTdHlsZSk7XHJcbiAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb250LXdlaWdodCcsIGZXZWlnaHQpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBsZXR0ZXJzID0gZG9jdW1lbnREYXRhLmwgfHwgW107XHJcbiAgICB2YXIgdXNlc0dseXBocyA9ICEhdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzO1xyXG4gICAgbGVuID0gbGV0dGVycy5sZW5ndGg7XHJcblxyXG4gICAgdmFyIHRTcGFuO1xyXG4gICAgdmFyIG1hdHJpeEhlbHBlciA9IHRoaXMubUhlbHBlcjtcclxuICAgIHZhciBzaGFwZXMsIHNoYXBlU3RyID0gJycsIHNpbmdsZVNoYXBlID0gdGhpcy5kYXRhLnNpbmdsZVNoYXBlO1xyXG4gICAgdmFyIHhQb3MgPSAwLCB5UG9zID0gMCwgZmlyc3RMaW5lID0gdHJ1ZTtcclxuICAgIHZhciB0cmFja2luZ09mZnNldCA9IGRvY3VtZW50RGF0YS50ci8xMDAwKmRvY3VtZW50RGF0YS5maW5hbFNpemU7XHJcbiAgICBpZihzaW5nbGVTaGFwZSAmJiAhdXNlc0dseXBocyAmJiAhZG9jdW1lbnREYXRhLnN6KSB7XHJcbiAgICAgICAgdmFyIHRFbGVtZW50ID0gdGhpcy50ZXh0Q29udGFpbmVyO1xyXG4gICAgICAgIHZhciBqdXN0aWZ5ID0gJ3N0YXJ0JztcclxuICAgICAgICBzd2l0Y2goZG9jdW1lbnREYXRhLmopIHtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAganVzdGlmeSA9ICdlbmQnO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIGp1c3RpZnkgPSAnbWlkZGxlJztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJyxqdXN0aWZ5KTtcclxuICAgICAgICB0RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2xldHRlci1zcGFjaW5nJyx0cmFja2luZ09mZnNldCk7XHJcbiAgICAgICAgdmFyIHRleHRDb250ZW50ID0gdGhpcy5idWlsZFRleHRDb250ZW50cyhkb2N1bWVudERhdGEuZmluYWxUZXh0KTtcclxuICAgICAgICBsZW4gPSB0ZXh0Q29udGVudC5sZW5ndGg7XHJcbiAgICAgICAgeVBvcyA9IGRvY3VtZW50RGF0YS5wcyA/IGRvY3VtZW50RGF0YS5wc1sxXSArIGRvY3VtZW50RGF0YS5hc2NlbnQgOiAwO1xyXG4gICAgICAgIGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgdFNwYW4gPSB0aGlzLnRleHRTcGFuc1tpXSB8fCBjcmVhdGVOUygndHNwYW4nKTtcclxuICAgICAgICAgICAgdFNwYW4udGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudFtpXTtcclxuICAgICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCd4JywgMCk7XHJcbiAgICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgneScsIHlQb3MpO1xyXG4gICAgICAgICAgICB0U3Bhbi5zdHlsZS5kaXNwbGF5ID0gJ2luaGVyaXQnO1xyXG4gICAgICAgICAgICB0RWxlbWVudC5hcHBlbmRDaGlsZCh0U3Bhbik7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dFNwYW5zW2ldID0gdFNwYW47XHJcbiAgICAgICAgICAgIHlQb3MgKz0gZG9jdW1lbnREYXRhLmZpbmFsTGluZUhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQodEVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgY2FjaGVkU3BhbnNMZW5ndGggPSB0aGlzLnRleHRTcGFucy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHNoYXBlRGF0YSwgY2hhckRhdGE7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGlmKCF1c2VzR2x5cGhzIHx8ICFzaW5nbGVTaGFwZSB8fCBpID09PSAwKXtcclxuICAgICAgICAgICAgICAgIHRTcGFuID0gY2FjaGVkU3BhbnNMZW5ndGggPiBpID8gdGhpcy50ZXh0U3BhbnNbaV0gOiBjcmVhdGVOUyh1c2VzR2x5cGhzPydwYXRoJzondGV4dCcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFNwYW5zTGVuZ3RoIDw9IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgJ2J1dHQnKTtcclxuICAgICAgICAgICAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsJ3JvdW5kJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdzdHJva2UtbWl0ZXJsaW1pdCcsJzQnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRleHRTcGFuc1tpXSA9IHRTcGFuO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHRTcGFuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRTcGFuLnN0eWxlLmRpc3BsYXkgPSAnaW5oZXJpdCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIG1hdHJpeEhlbHBlci5yZXNldCgpO1xyXG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIuc2NhbGUoZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMCwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMCk7XHJcbiAgICAgICAgICAgIGlmIChzaW5nbGVTaGFwZSkge1xyXG4gICAgICAgICAgICAgICAgaWYobGV0dGVyc1tpXS5uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeFBvcyA9IC10cmFja2luZ09mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICB5UG9zICs9IGRvY3VtZW50RGF0YS55T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHlQb3MgKz0gZmlyc3RMaW5lID8gMSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RMaW5lID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5VGV4dFByb3BlcnRpZXNUb01hdHJpeChkb2N1bWVudERhdGEsIG1hdHJpeEhlbHBlciwgbGV0dGVyc1tpXS5saW5lLCB4UG9zLCB5UG9zKTtcclxuICAgICAgICAgICAgICAgIHhQb3MgKz0gbGV0dGVyc1tpXS5sIHx8IDA7XHJcbiAgICAgICAgICAgICAgICAvL3hQb3MgKz0gbGV0dGVyc1tpXS52YWwgPT09ICcgJyA/IDAgOiB0cmFja2luZ09mZnNldDtcclxuICAgICAgICAgICAgICAgIHhQb3MgKz0gdHJhY2tpbmdPZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYodXNlc0dseXBocykge1xyXG4gICAgICAgICAgICAgICAgY2hhckRhdGEgPSB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Q2hhckRhdGEoZG9jdW1lbnREYXRhLmZpbmFsVGV4dFtpXSwgZm9udERhdGEuZlN0eWxlLCB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZikuZkZhbWlseSk7XHJcbiAgICAgICAgICAgICAgICBzaGFwZURhdGEgPSBjaGFyRGF0YSAmJiBjaGFyRGF0YS5kYXRhIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgc2hhcGVzID0gc2hhcGVEYXRhLnNoYXBlcyA/IHNoYXBlRGF0YS5zaGFwZXNbMF0uaXQgOiBbXTtcclxuICAgICAgICAgICAgICAgIGlmKCFzaW5nbGVTaGFwZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdkJyx0aGlzLmNyZWF0ZVBhdGhTaGFwZShtYXRyaXhIZWxwZXIsc2hhcGVzKSk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlU3RyICs9IHRoaXMuY3JlYXRlUGF0aFNoYXBlKG1hdHJpeEhlbHBlcixzaGFwZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYoc2luZ2xlU2hhcGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBtYXRyaXhIZWxwZXIucHJvcHNbMTJdICsgXCIsXCIgKyBtYXRyaXhIZWxwZXIucHJvcHNbMTNdICsgXCIpXCIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdFNwYW4udGV4dENvbnRlbnQgPSBsZXR0ZXJzW2ldLnZhbDtcclxuICAgICAgICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsIFwieG1sOnNwYWNlXCIsXCJwcmVzZXJ2ZVwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2luZ2xlU2hhcGUgJiYgdFNwYW4pIHtcclxuICAgICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdkJyxzaGFwZVN0cik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgd2hpbGUgKGkgPCB0aGlzLnRleHRTcGFucy5sZW5ndGgpe1xyXG4gICAgICAgIHRoaXMudGV4dFNwYW5zW2ldLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgaSArPSAxO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLl9zaXplQ2hhbmdlZCA9IHRydWU7XHJcbn07XHJcblxyXG5TVkdUZXh0RWxlbWVudC5wcm90b3R5cGUuc291cmNlUmVjdEF0VGltZSA9IGZ1bmN0aW9uKHRpbWUpe1xyXG4gICAgdGhpcy5wcmVwYXJlRnJhbWUodGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLSB0aGlzLmRhdGEuc3QpO1xyXG4gICAgdGhpcy5yZW5kZXJJbm5lckNvbnRlbnQoKTtcclxuICAgIGlmKHRoaXMuX3NpemVDaGFuZ2VkKXtcclxuICAgICAgICB0aGlzLl9zaXplQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciB0ZXh0Qm94ID0gdGhpcy5sYXllckVsZW1lbnQuZ2V0QkJveCgpO1xyXG4gICAgICAgIHRoaXMuYmJveCA9IHtcclxuICAgICAgICAgICAgdG9wOiB0ZXh0Qm94LnksXHJcbiAgICAgICAgICAgIGxlZnQ6IHRleHRCb3gueCxcclxuICAgICAgICAgICAgd2lkdGg6IHRleHRCb3gud2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGV4dEJveC5oZWlnaHRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuYmJveDtcclxufTtcclxuXHJcblNWR1RleHRFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbigpe1xyXG5cclxuICAgIGlmKCF0aGlzLmRhdGEuc2luZ2xlU2hhcGUpe1xyXG4gICAgICAgIHRoaXMudGV4dEFuaW1hdG9yLmdldE1lYXN1cmVzKHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLCB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyk7XHJcbiAgICAgICAgaWYodGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgfHwgdGhpcy50ZXh0QW5pbWF0b3IubGV0dGVyc0NoYW5nZWRGbGFnKXtcclxuICAgICAgICAgICAgdGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB2YXIgIGksbGVuO1xyXG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRMZXR0ZXJzID0gdGhpcy50ZXh0QW5pbWF0b3IucmVuZGVyZWRMZXR0ZXJzO1xyXG5cclxuICAgICAgICAgICAgdmFyIGxldHRlcnMgPSB0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YS5sO1xyXG5cclxuICAgICAgICAgICAgbGVuID0gbGV0dGVycy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXJlZExldHRlciwgdGV4dFNwYW47XHJcbiAgICAgICAgICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgICAgICAgICBpZihsZXR0ZXJzW2ldLm4pe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRMZXR0ZXIgPSByZW5kZXJlZExldHRlcnNbaV07XHJcbiAgICAgICAgICAgICAgICB0ZXh0U3BhbiA9IHRoaXMudGV4dFNwYW5zW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYocmVuZGVyZWRMZXR0ZXIuX21kZi5tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dFNwYW4uc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLHJlbmRlcmVkTGV0dGVyLm0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYocmVuZGVyZWRMZXR0ZXIuX21kZi5vKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dFNwYW4uc2V0QXR0cmlidXRlKCdvcGFjaXR5JyxyZW5kZXJlZExldHRlci5vKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKHJlbmRlcmVkTGV0dGVyLl9tZGYuc3cpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJyxyZW5kZXJlZExldHRlci5zdyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZihyZW5kZXJlZExldHRlci5fbWRmLnNjKXtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScscmVuZGVyZWRMZXR0ZXIuc2MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYocmVuZGVyZWRMZXR0ZXIuX21kZi5mYyl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dFNwYW4uc2V0QXR0cmlidXRlKCdmaWxsJyxyZW5kZXJlZExldHRlci5mYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XG5mdW5jdGlvbiBTVkdTaGFwZUVsZW1lbnQoZGF0YSxnbG9iYWxEYXRhLGNvbXApe1xyXG4gICAgLy9MaXN0IG9mIGRyYXdhYmxlIGVsZW1lbnRzXHJcbiAgICB0aGlzLnNoYXBlcyA9IFtdO1xyXG4gICAgLy8gRnVsbCBzaGFwZSBkYXRhXHJcbiAgICB0aGlzLnNoYXBlc0RhdGEgPSBkYXRhLnNoYXBlcztcclxuICAgIC8vTGlzdCBvZiBzdHlsZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gc2hhcGVzXHJcbiAgICB0aGlzLnN0eWxlc0xpc3QgPSBbXTtcclxuICAgIC8vTGlzdCBvZiBtb2RpZmllcnMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gc2hhcGVzXHJcbiAgICB0aGlzLnNoYXBlTW9kaWZpZXJzID0gW107XHJcbiAgICAvL0xpc3Qgb2YgaXRlbXMgaW4gc2hhcGUgdHJlZVxyXG4gICAgdGhpcy5pdGVtc0RhdGEgPSBbXTtcclxuICAgIC8vTGlzdCBvZiBpdGVtcyBpbiBwcmV2aW91cyBzaGFwZSB0cmVlXHJcbiAgICB0aGlzLnByb2Nlc3NlZEVsZW1lbnRzID0gW107XHJcbiAgICAvLyBMaXN0IG9mIGFuaW1hdGVkIGNvbXBvbmVudHNcclxuICAgIHRoaXMuYW5pbWF0ZWRDb250ZW50cyA9IFtdO1xyXG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLGdsb2JhbERhdGEsY29tcCk7XHJcbiAgICAvL01vdmluZyBhbnkgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGdldCB0b28gbXVjaCBhY2Nlc3MgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gYmVjYXVzZSBvZiB2OCB3YXkgb2YgaGFuZGxpbmcgbW9yZSB0aGFuIDEwIHByb3BlcnRpZXMuXHJcbiAgICAvLyBMaXN0IG9mIGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIGNyZWF0ZWRcclxuICAgIHRoaXMucHJldlZpZXdEYXRhID0gW107XHJcbiAgICAvL01vdmluZyBhbnkgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGdldCB0b28gbXVjaCBhY2Nlc3MgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gYmVjYXVzZSBvZiB2OCB3YXkgb2YgaGFuZGxpbmcgbW9yZSB0aGFuIDEwIHByb3BlcnRpZXMuXHJcbn1cclxuXHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsVHJhbnNmb3JtRWxlbWVudCxTVkdCYXNlRWxlbWVudCxJU2hhcGVFbGVtZW50LEhpZXJhcmNoeUVsZW1lbnQsRnJhbWVFbGVtZW50LFJlbmRlcmFibGVET01FbGVtZW50XSwgU1ZHU2hhcGVFbGVtZW50KTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuaW5pdFNlY29uZGFyeUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcclxufTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuaWRlbnRpdHlNYXRyaXggPSBuZXcgTWF0cml4KCk7XHJcblxyXG5TVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmJ1aWxkRXhwcmVzc2lvbkludGVyZmFjZSA9IGZ1bmN0aW9uKCl7fTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLnNlYXJjaFNoYXBlcyh0aGlzLnNoYXBlc0RhdGEsdGhpcy5pdGVtc0RhdGEsdGhpcy5wcmV2Vmlld0RhdGEsdGhpcy5sYXllckVsZW1lbnQsIDAsIFtdLCB0cnVlKTtcclxuICAgIHRoaXMuZmlsdGVyVW5pcXVlU2hhcGVzKCk7XHJcbn07XHJcblxyXG4vKlxyXG5UaGlzIG1ldGhvZCBzZWFyY2hlcyBmb3IgbXVsdGlwbGUgc2hhcGVzIHRoYXQgYWZmZWN0IGEgc2luZ2xlIGVsZW1lbnQgYW5kIG9uZSBvZiB0aGVtIGlzIGFuaW1hdGVkXHJcbiovXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuZmlsdGVyVW5pcXVlU2hhcGVzID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBpLCBsZW4gPSB0aGlzLnNoYXBlcy5sZW5ndGgsIHNoYXBlO1xyXG4gICAgdmFyIGosIGpMZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xyXG4gICAgdmFyIHN0eWxlLCBjb3VudCA9IDA7XHJcbiAgICB2YXIgdGVtcFNoYXBlcyA9IFtdO1xyXG4gICAgdmFyIGFyZUFuaW1hdGVkID0gZmFsc2U7XHJcbiAgICBmb3IoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcclxuICAgICAgICBzdHlsZSA9IHRoaXMuc3R5bGVzTGlzdFtqXTtcclxuICAgICAgICBhcmVBbmltYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRlbXBTaGFwZXMubGVuZ3RoID0gMDtcclxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBzaGFwZSA9IHRoaXMuc2hhcGVzW2ldO1xyXG4gICAgICAgICAgICBpZihzaGFwZS5zdHlsZXMuaW5kZXhPZihzdHlsZSkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wU2hhcGVzLnB1c2goc2hhcGUpO1xyXG4gICAgICAgICAgICAgICAgYXJlQW5pbWF0ZWQgPSBzaGFwZS5faXNBbmltYXRlZCB8fCBhcmVBbmltYXRlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0ZW1wU2hhcGVzLmxlbmd0aCA+IDEgJiYgYXJlQW5pbWF0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRTaGFwZXNBc0FuaW1hdGVkKHRlbXBTaGFwZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5zZXRTaGFwZXNBc0FuaW1hdGVkID0gZnVuY3Rpb24oc2hhcGVzKXtcclxuICAgIHZhciBpLCBsZW4gPSBzaGFwZXMubGVuZ3RoO1xyXG4gICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBzaGFwZXNbaV0uc2V0QXNBbmltYXRlZCgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5TVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVN0eWxlRWxlbWVudCA9IGZ1bmN0aW9uKGRhdGEsIGxldmVsKXtcclxuICAgIC8vVE9ETzogcHJldmVudCBkcmF3aW5nIG9mIGhpZGRlbiBzdHlsZXNcclxuICAgIHZhciBlbGVtZW50RGF0YTtcclxuICAgIHZhciBzdHlsZU9iID0gbmV3IFNWR1N0eWxlRGF0YShkYXRhLCBsZXZlbCk7XHJcblxyXG4gICAgdmFyIHBhdGhFbGVtZW50ID0gc3R5bGVPYi5wRWxlbTtcclxuICAgIGlmKGRhdGEudHkgPT09ICdzdCcpIHtcclxuICAgICAgICBlbGVtZW50RGF0YSA9IG5ldyBTVkdTdHJva2VTdHlsZURhdGEodGhpcywgZGF0YSwgc3R5bGVPYik7XHJcbiAgICB9IGVsc2UgaWYoZGF0YS50eSA9PT0gJ2ZsJykge1xyXG4gICAgICAgIGVsZW1lbnREYXRhID0gbmV3IFNWR0ZpbGxTdHlsZURhdGEodGhpcywgZGF0YSwgc3R5bGVPYik7XHJcbiAgICB9IGVsc2UgaWYoZGF0YS50eSA9PT0gJ2dmJyB8fCBkYXRhLnR5ID09PSAnZ3MnKSB7XHJcbiAgICAgICAgdmFyIGdyYWRpZW50Q29uc3RydWN0b3IgPSBkYXRhLnR5ID09PSAnZ2YnID8gU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhIDogU1ZHR3JhZGllbnRTdHJva2VTdHlsZURhdGE7XHJcbiAgICAgICAgZWxlbWVudERhdGEgPSBuZXcgZ3JhZGllbnRDb25zdHJ1Y3Rvcih0aGlzLCBkYXRhLCBzdHlsZU9iKTtcclxuICAgICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChlbGVtZW50RGF0YS5nZik7XHJcbiAgICAgICAgaWYgKGVsZW1lbnREYXRhLm1hc2tJZCkge1xyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChlbGVtZW50RGF0YS5tcyk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKGVsZW1lbnREYXRhLm9mKTtcclxuICAgICAgICAgICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdtYXNrJywndXJsKCMnICsgZWxlbWVudERhdGEubWFza0lkICsgJyknKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmKGRhdGEudHkgPT09ICdzdCcgfHwgZGF0YS50eSA9PT0gJ2dzJykge1xyXG4gICAgICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCB0aGlzLmxjRW51bVtkYXRhLmxjXSB8fCAncm91bmQnKTtcclxuICAgICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsdGhpcy5sakVudW1bZGF0YS5sal0gfHwgJ3JvdW5kJyk7XHJcbiAgICAgICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCcwJyk7XHJcbiAgICAgICAgaWYoZGF0YS5saiA9PT0gMSkge1xyXG4gICAgICAgICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1taXRlcmxpbWl0JyxkYXRhLm1sKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYoZGF0YS5yID09PSAyKSB7XHJcbiAgICAgICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCAnZXZlbm9kZCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmKGRhdGEubG4pe1xyXG4gICAgICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLGRhdGEubG4pO1xyXG4gICAgfVxyXG4gICAgaWYoZGF0YS5jbCl7XHJcbiAgICAgICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsZGF0YS5jbCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnN0eWxlc0xpc3QucHVzaChzdHlsZU9iKTtcclxuICAgIHRoaXMuYWRkVG9BbmltYXRlZENvbnRlbnRzKGRhdGEsIGVsZW1lbnREYXRhKTtcclxuICAgIHJldHVybiBlbGVtZW50RGF0YTtcclxufTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlR3JvdXBFbGVtZW50ID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgdmFyIGVsZW1lbnREYXRhID0gbmV3IFNoYXBlR3JvdXBEYXRhKCk7XHJcbiAgICBpZihkYXRhLmxuKXtcclxuICAgICAgICBlbGVtZW50RGF0YS5nci5zZXRBdHRyaWJ1dGUoJ2lkJyxkYXRhLmxuKTtcclxuICAgIH1cclxuICAgIHJldHVybiBlbGVtZW50RGF0YTtcclxufTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlVHJhbnNmb3JtRWxlbWVudCA9IGZ1bmN0aW9uKGRhdGEsIGNvbnRhaW5lcikge1xyXG4gICAgdmFyIHRyYW5zZm9ybVByb3BlcnR5ID0gVHJhbnNmb3JtUHJvcGVydHlGYWN0b3J5LmdldFRyYW5zZm9ybVByb3BlcnR5KHRoaXMsZGF0YSx0aGlzKTtcclxuICAgIHZhciBlbGVtZW50RGF0YSA9IG5ldyBTVkdUcmFuc2Zvcm1EYXRhKHRyYW5zZm9ybVByb3BlcnR5LCB0cmFuc2Zvcm1Qcm9wZXJ0eS5vLCBjb250YWluZXIpO1xyXG4gICAgdGhpcy5hZGRUb0FuaW1hdGVkQ29udGVudHMoZGF0YSwgZWxlbWVudERhdGEpO1xyXG4gICAgcmV0dXJuIGVsZW1lbnREYXRhO1xyXG59O1xyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTaGFwZUVsZW1lbnQgPSBmdW5jdGlvbihkYXRhLCBvd25UcmFuc2Zvcm1lcnMsIGxldmVsKSB7XHJcbiAgICB2YXIgdHkgPSA0O1xyXG4gICAgaWYoZGF0YS50eSA9PT0gJ3JjJyl7XHJcbiAgICAgICAgdHkgPSA1O1xyXG4gICAgfWVsc2UgaWYoZGF0YS50eSA9PT0gJ2VsJyl7XHJcbiAgICAgICAgdHkgPSA2O1xyXG4gICAgfWVsc2UgaWYoZGF0YS50eSA9PT0gJ3NyJyl7XHJcbiAgICAgICAgdHkgPSA3O1xyXG4gICAgfVxyXG4gICAgdmFyIHNoYXBlUHJvcGVydHkgPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AodGhpcyxkYXRhLHR5LHRoaXMpO1xyXG4gICAgdmFyIGVsZW1lbnREYXRhID0gbmV3IFNWR1NoYXBlRGF0YShvd25UcmFuc2Zvcm1lcnMsIGxldmVsLCBzaGFwZVByb3BlcnR5KTtcclxuICAgIHRoaXMuc2hhcGVzLnB1c2goZWxlbWVudERhdGEpO1xyXG4gICAgdGhpcy5hZGRTaGFwZVRvTW9kaWZpZXJzKGVsZW1lbnREYXRhKTtcclxuICAgIHRoaXMuYWRkVG9BbmltYXRlZENvbnRlbnRzKGRhdGEsIGVsZW1lbnREYXRhKTtcclxuICAgIHJldHVybiBlbGVtZW50RGF0YTtcclxufTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuYWRkVG9BbmltYXRlZENvbnRlbnRzID0gZnVuY3Rpb24oZGF0YSwgZWxlbWVudCkge1xyXG4gICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFuaW1hdGVkQ29udGVudHMubGVuZ3RoO1xyXG4gICAgd2hpbGUoaSA8IGxlbikge1xyXG4gICAgICAgIGlmKHRoaXMuYW5pbWF0ZWRDb250ZW50c1tpXS5lbGVtZW50ID09PSBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaSArPSAxO1xyXG4gICAgfVxyXG4gICAgdGhpcy5hbmltYXRlZENvbnRlbnRzLnB1c2goe1xyXG4gICAgICAgIGZuOiBTVkdFbGVtZW50c1JlbmRlcmVyLmNyZWF0ZVJlbmRlckZ1bmN0aW9uKGRhdGEpLFxyXG4gICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXHJcbiAgICAgICAgZGF0YTogZGF0YVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5TVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLnNldEVsZW1lbnRTdHlsZXMgPSBmdW5jdGlvbihlbGVtZW50RGF0YSl7XHJcbiAgICB2YXIgYXJyID0gZWxlbWVudERhdGEuc3R5bGVzO1xyXG4gICAgdmFyIGosIGpMZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xyXG4gICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgIGlmICghdGhpcy5zdHlsZXNMaXN0W2pdLmNsb3NlZCkge1xyXG4gICAgICAgICAgICBhcnIucHVzaCh0aGlzLnN0eWxlc0xpc3Rbal0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUucmVsb2FkU2hhcGVzID0gZnVuY3Rpb24oKXtcclxuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XHJcbiAgICB2YXIgaSwgbGVuID0gdGhpcy5pdGVtc0RhdGEubGVuZ3RoO1xyXG4gICAgZm9yKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgdGhpcy5wcmV2Vmlld0RhdGFbaV0gPSB0aGlzLml0ZW1zRGF0YVtpXTtcclxuICAgIH1cclxuICAgIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSx0aGlzLml0ZW1zRGF0YSx0aGlzLnByZXZWaWV3RGF0YSx0aGlzLmxheWVyRWxlbWVudCwgMCwgW10sIHRydWUpO1xyXG4gICAgdGhpcy5maWx0ZXJVbmlxdWVTaGFwZXMoKTtcclxuICAgIGxlbiA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoO1xyXG4gICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLmdldFZhbHVlKCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLnJlbmRlck1vZGlmaWVycygpO1xyXG59O1xyXG5cclxuU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5zZWFyY2hTaGFwZXMgPSBmdW5jdGlvbihhcnIsaXRlbXNEYXRhLHByZXZWaWV3RGF0YSxjb250YWluZXIsIGxldmVsLCB0cmFuc2Zvcm1lcnMsIHJlbmRlcil7XHJcbiAgICB2YXIgb3duVHJhbnNmb3JtZXJzID0gW10uY29uY2F0KHRyYW5zZm9ybWVycyk7XHJcbiAgICB2YXIgaSwgbGVuID0gYXJyLmxlbmd0aCAtIDE7XHJcbiAgICB2YXIgaiwgakxlbjtcclxuICAgIHZhciBvd25TdHlsZXMgPSBbXSwgb3duTW9kaWZpZXJzID0gW10sIHN0eWxlT2IsIGN1cnJlbnRUcmFuc2Zvcm0sIG1vZGlmaWVyLCBwcm9jZXNzZWRQb3M7XHJcbiAgICBmb3IoaT1sZW47aT49MDtpLT0xKXtcclxuICAgICAgICBwcm9jZXNzZWRQb3MgPSB0aGlzLnNlYXJjaFByb2Nlc3NlZEVsZW1lbnQoYXJyW2ldKTtcclxuICAgICAgICBpZighcHJvY2Vzc2VkUG9zKXtcclxuICAgICAgICAgICAgYXJyW2ldLl9yZW5kZXIgPSByZW5kZXI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaXRlbXNEYXRhW2ldID0gcHJldlZpZXdEYXRhW3Byb2Nlc3NlZFBvcyAtIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihhcnJbaV0udHkgPT0gJ2ZsJyB8fCBhcnJbaV0udHkgPT0gJ3N0JyB8fCBhcnJbaV0udHkgPT0gJ2dmJyB8fCBhcnJbaV0udHkgPT0gJ2dzJyl7XHJcbiAgICAgICAgICAgIGlmKCFwcm9jZXNzZWRQb3Mpe1xyXG4gICAgICAgICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVTdHlsZUVsZW1lbnQoYXJyW2ldLCBsZXZlbCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpdGVtc0RhdGFbaV0uc3R5bGUuY2xvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoYXJyW2ldLl9yZW5kZXIpe1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGl0ZW1zRGF0YVtpXS5zdHlsZS5wRWxlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3duU3R5bGVzLnB1c2goaXRlbXNEYXRhW2ldLnN0eWxlKTtcclxuICAgICAgICB9ZWxzZSBpZihhcnJbaV0udHkgPT0gJ2dyJyl7XHJcbiAgICAgICAgICAgIGlmKCFwcm9jZXNzZWRQb3Mpe1xyXG4gICAgICAgICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVHcm91cEVsZW1lbnQoYXJyW2ldKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGpMZW4gPSBpdGVtc0RhdGFbaV0uaXQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yKGo9MDtqPGpMZW47ais9MSl7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNEYXRhW2ldLnByZXZWaWV3RGF0YVtqXSA9IGl0ZW1zRGF0YVtpXS5pdFtqXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNlYXJjaFNoYXBlcyhhcnJbaV0uaXQsaXRlbXNEYXRhW2ldLml0LGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGEsaXRlbXNEYXRhW2ldLmdyLCBsZXZlbCArIDEsIG93blRyYW5zZm9ybWVycywgcmVuZGVyKTtcclxuICAgICAgICAgICAgaWYoYXJyW2ldLl9yZW5kZXIpe1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGl0ZW1zRGF0YVtpXS5ncik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ZWxzZSBpZihhcnJbaV0udHkgPT0gJ3RyJyl7XHJcbiAgICAgICAgICAgIGlmKCFwcm9jZXNzZWRQb3Mpe1xyXG4gICAgICAgICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVUcmFuc2Zvcm1FbGVtZW50KGFycltpXSwgY29udGFpbmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtID0gaXRlbXNEYXRhW2ldLnRyYW5zZm9ybTtcclxuICAgICAgICAgICAgb3duVHJhbnNmb3JtZXJzLnB1c2goY3VycmVudFRyYW5zZm9ybSk7XHJcbiAgICAgICAgfWVsc2UgaWYoYXJyW2ldLnR5ID09ICdzaCcgfHwgYXJyW2ldLnR5ID09ICdyYycgfHwgYXJyW2ldLnR5ID09ICdlbCcgfHwgYXJyW2ldLnR5ID09ICdzcicpe1xyXG4gICAgICAgICAgICBpZighcHJvY2Vzc2VkUG9zKXtcclxuICAgICAgICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IHRoaXMuY3JlYXRlU2hhcGVFbGVtZW50KGFycltpXSwgb3duVHJhbnNmb3JtZXJzLCBsZXZlbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZXRFbGVtZW50U3R5bGVzKGl0ZW1zRGF0YVtpXSk7XHJcblxyXG4gICAgICAgIH1lbHNlIGlmKGFycltpXS50eSA9PSAndG0nIHx8IGFycltpXS50eSA9PSAncmQnIHx8IGFycltpXS50eSA9PSAnbXMnKXtcclxuICAgICAgICAgICAgaWYoIXByb2Nlc3NlZFBvcyl7XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllciA9IFNoYXBlTW9kaWZpZXJzLmdldE1vZGlmaWVyKGFycltpXS50eSk7XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllci5pbml0KHRoaXMsYXJyW2ldKTtcclxuICAgICAgICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IG1vZGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGFwZU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVyID0gaXRlbXNEYXRhW2ldO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZXIuY2xvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3duTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgIH1lbHNlIGlmKGFycltpXS50eSA9PSAncnAnKXtcclxuICAgICAgICAgICAgaWYoIXByb2Nlc3NlZFBvcyl7XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllciA9IFNoYXBlTW9kaWZpZXJzLmdldE1vZGlmaWVyKGFycltpXS50eSk7XHJcbiAgICAgICAgICAgICAgICBpdGVtc0RhdGFbaV0gPSBtb2RpZmllcjtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVyLmluaXQodGhpcyxhcnIsaSxpdGVtc0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGFwZU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgIHJlbmRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVyID0gaXRlbXNEYXRhW2ldO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZXIuY2xvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvd25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkUHJvY2Vzc2VkRWxlbWVudChhcnJbaV0sIGkgKyAxKTtcclxuICAgIH1cclxuICAgIGxlbiA9IG93blN0eWxlcy5sZW5ndGg7XHJcbiAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgIG93blN0eWxlc1tpXS5jbG9zZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgbGVuID0gb3duTW9kaWZpZXJzLmxlbmd0aDtcclxuICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgb3duTW9kaWZpZXJzW2ldLmNsb3NlZCA9IHRydWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5yZW5kZXJNb2RpZmllcnMoKTtcclxuICAgIHZhciBpLCBsZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xyXG4gICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICB0aGlzLnN0eWxlc0xpc3RbaV0ucmVzZXQoKTtcclxuICAgIH1cclxuICAgIHRoaXMucmVuZGVyU2hhcGUoKTtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBpZiAodGhpcy5zdHlsZXNMaXN0W2ldLl9tZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XHJcbiAgICAgICAgICAgIGlmKHRoaXMuc3R5bGVzTGlzdFtpXS5tc0VsZW0pe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZXNMaXN0W2ldLm1zRWxlbS5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLnN0eWxlc0xpc3RbaV0uZCk7XHJcbiAgICAgICAgICAgICAgICAvL0FkZGluZyBNMCAwIGZpeGVzIHNhbWUgbWFzayBidWcgb24gYWxsIGJyb3dzZXJzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlc0xpc3RbaV0uZCA9ICdNMCAwJyArIHRoaXMuc3R5bGVzTGlzdFtpXS5kO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLnN0eWxlc0xpc3RbaV0uZCB8fCAnTTAgMCcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcblNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyU2hhcGUgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBpLCBsZW4gPSB0aGlzLmFuaW1hdGVkQ29udGVudHMubGVuZ3RoO1xyXG4gICAgdmFyIGFuaW1hdGVkQ29udGVudDtcclxuICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgYW5pbWF0ZWRDb250ZW50ID0gdGhpcy5hbmltYXRlZENvbnRlbnRzW2ldO1xyXG4gICAgICAgIGlmKCh0aGlzLl9pc0ZpcnN0RnJhbWUgfHwgYW5pbWF0ZWRDb250ZW50LmVsZW1lbnQuX2lzQW5pbWF0ZWQpICYmIGFuaW1hdGVkQ29udGVudC5kYXRhICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGFuaW1hdGVkQ29udGVudC5mbihhbmltYXRlZENvbnRlbnQuZGF0YSwgYW5pbWF0ZWRDb250ZW50LmVsZW1lbnQsIHRoaXMuX2lzRmlyc3RGcmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5TVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5kZXN0cm95QmFzZUVsZW1lbnQoKTtcclxuICAgIHRoaXMuc2hhcGVzRGF0YSA9IG51bGw7XHJcbiAgICB0aGlzLml0ZW1zRGF0YSA9IG51bGw7XHJcbn07XHJcblxuZnVuY3Rpb24gU1ZHVGludEZpbHRlcihmaWx0ZXIsIGZpbHRlck1hbmFnZXIpe1xyXG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcclxuICAgIHZhciBmZUNvbG9yTWF0cml4ID0gY3JlYXRlTlMoJ2ZlQ29sb3JNYXRyaXgnKTtcclxuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd0eXBlJywnbWF0cml4Jyk7XHJcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywnbGluZWFyUkdCJyk7XHJcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndmFsdWVzJywnMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMCAwIDAgMSAwJyk7XHJcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgncmVzdWx0JywnZjEnKTtcclxuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbG9yTWF0cml4KTtcclxuICAgIGZlQ29sb3JNYXRyaXggPSBjcmVhdGVOUygnZmVDb2xvck1hdHJpeCcpO1xyXG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCdtYXRyaXgnKTtcclxuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCdzUkdCJyk7XHJcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndmFsdWVzJywnMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAwJyk7XHJcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgncmVzdWx0JywnZjInKTtcclxuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbG9yTWF0cml4KTtcclxuICAgIHRoaXMubWF0cml4RmlsdGVyID0gZmVDb2xvck1hdHJpeDtcclxuICAgIGlmKGZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMl0ucC52ICE9PSAxMDAgfHwgZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1syXS5wLmspe1xyXG4gICAgICAgIHZhciBmZU1lcmdlID0gY3JlYXRlTlMoJ2ZlTWVyZ2UnKTtcclxuICAgICAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVNZXJnZSk7XHJcbiAgICAgICAgdmFyIGZlTWVyZ2VOb2RlO1xyXG4gICAgICAgIGZlTWVyZ2VOb2RlID0gY3JlYXRlTlMoJ2ZlTWVyZ2VOb2RlJyk7XHJcbiAgICAgICAgZmVNZXJnZU5vZGUuc2V0QXR0cmlidXRlKCdpbicsJ1NvdXJjZUdyYXBoaWMnKTtcclxuICAgICAgICBmZU1lcmdlLmFwcGVuZENoaWxkKGZlTWVyZ2VOb2RlKTtcclxuICAgICAgICBmZU1lcmdlTm9kZSA9IGNyZWF0ZU5TKCdmZU1lcmdlTm9kZScpO1xyXG4gICAgICAgIGZlTWVyZ2VOb2RlLnNldEF0dHJpYnV0ZSgnaW4nLCdmMicpO1xyXG4gICAgICAgIGZlTWVyZ2UuYXBwZW5kQ2hpbGQoZmVNZXJnZU5vZGUpO1xyXG4gICAgfVxyXG59XHJcblxyXG5TVkdUaW50RmlsdGVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uKGZvcmNlUmVuZGVyKXtcclxuICAgIGlmKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmKXtcclxuICAgICAgICB2YXIgY29sb3JCbGFjayA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnY7XHJcbiAgICAgICAgdmFyIGNvbG9yV2hpdGUgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC52O1xyXG4gICAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudi8xMDA7XHJcbiAgICAgICAgdGhpcy5tYXRyaXhGaWx0ZXIuc2V0QXR0cmlidXRlKCd2YWx1ZXMnLChjb2xvcldoaXRlWzBdLSBjb2xvckJsYWNrWzBdKSsnIDAgMCAwICcrIGNvbG9yQmxhY2tbMF0gKycgJysgKGNvbG9yV2hpdGVbMV0tIGNvbG9yQmxhY2tbMV0pICsnIDAgMCAwICcrIGNvbG9yQmxhY2tbMV0gKycgJysgKGNvbG9yV2hpdGVbMl0tIGNvbG9yQmxhY2tbMl0pICsnIDAgMCAwICcrIGNvbG9yQmxhY2tbMl0gKycgMCAwIDAgJyArIG9wYWNpdHkgKyAnIDAnKTtcclxuICAgIH1cclxufTtcbmZ1bmN0aW9uIFNWR0ZpbGxGaWx0ZXIoZmlsdGVyLCBmaWx0ZXJNYW5hZ2VyKXtcclxuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XHJcbiAgICB2YXIgZmVDb2xvck1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XHJcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsJ21hdHJpeCcpO1xyXG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsJ3NSR0InKTtcclxuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCcxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAnKTtcclxuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbG9yTWF0cml4KTtcclxuICAgIHRoaXMubWF0cml4RmlsdGVyID0gZmVDb2xvck1hdHJpeDtcclxufVxyXG5TVkdGaWxsRmlsdGVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uKGZvcmNlUmVuZGVyKXtcclxuICAgIGlmKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmKXtcclxuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMl0ucC52O1xyXG4gICAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzZdLnAudjtcclxuICAgICAgICB0aGlzLm1hdHJpeEZpbHRlci5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsJzAgMCAwIDAgJytjb2xvclswXSsnIDAgMCAwIDAgJytjb2xvclsxXSsnIDAgMCAwIDAgJytjb2xvclsyXSsnIDAgMCAwICcrb3BhY2l0eSsnIDAnKTtcclxuICAgIH1cclxufTtcbmZ1bmN0aW9uIFNWR1N0cm9rZUVmZmVjdChlbGVtLCBmaWx0ZXJNYW5hZ2VyKXtcclxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XHJcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgdGhpcy5wYXRocyA9IFtdO1xyXG59XHJcblxyXG5TVkdTdHJva2VFZmZlY3QucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbigpe1xyXG5cclxuICAgIHZhciBlbGVtQ2hpbGRyZW4gPSB0aGlzLmVsZW0ubGF5ZXJFbGVtZW50LmNoaWxkcmVuIHx8IHRoaXMuZWxlbS5sYXllckVsZW1lbnQuY2hpbGROb2RlcztcclxuICAgIHZhciBwYXRoLGdyb3VwUGF0aCwgaSwgbGVuO1xyXG4gICAgaWYodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzFdLnAudiA9PT0gMSl7XHJcbiAgICAgICAgbGVuID0gdGhpcy5lbGVtLm1hc2tNYW5hZ2VyLm1hc2tzUHJvcGVydGllcy5sZW5ndGg7XHJcbiAgICAgICAgaSA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC52IC0gMTtcclxuICAgICAgICBsZW4gPSBpICsgMTtcclxuICAgIH1cclxuICAgIGdyb3VwUGF0aCA9IGNyZWF0ZU5TKCdnJyk7IFxyXG4gICAgZ3JvdXBQYXRoLnNldEF0dHJpYnV0ZSgnZmlsbCcsJ25vbmUnKTtcclxuICAgIGdyb3VwUGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywncm91bmQnKTtcclxuICAgIGdyb3VwUGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0JywxKTtcclxuICAgIGZvcihpO2k8bGVuO2krPTEpe1xyXG4gICAgICAgIHBhdGggPSBjcmVhdGVOUygncGF0aCcpO1xyXG4gICAgICAgIGdyb3VwUGF0aC5hcHBlbmRDaGlsZChwYXRoKTtcclxuICAgICAgICB0aGlzLnBhdGhzLnB1c2goe3A6cGF0aCxtOml9KTtcclxuICAgIH1cclxuICAgIGlmKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAzKXtcclxuICAgICAgICB2YXIgbWFzayA9IGNyZWF0ZU5TKCdtYXNrJyk7XHJcbiAgICAgICAgdmFyIGlkID0gJ3N0bXNfJyArIHJhbmRvbVN0cmluZygxMCk7XHJcbiAgICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoJ2lkJyxpZCk7XHJcbiAgICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoJ21hc2stdHlwZScsJ2FscGhhJyk7XHJcbiAgICAgICAgbWFzay5hcHBlbmRDaGlsZChncm91cFBhdGgpO1xyXG4gICAgICAgIHRoaXMuZWxlbS5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQobWFzayk7XHJcbiAgICAgICAgdmFyIGcgPSBjcmVhdGVOUygnZycpO1xyXG4gICAgICAgIGcuc2V0QXR0cmlidXRlKCdtYXNrJywndXJsKCcgKyBsb2NhdGlvbkhyZWYgKyAnIycraWQrJyknKTtcclxuICAgICAgICBpZihlbGVtQ2hpbGRyZW5bMF0pe1xyXG4gICAgICAgICAgICBnLmFwcGVuZENoaWxkKGVsZW1DaGlsZHJlblswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWxlbS5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQoZyk7XHJcbiAgICAgICAgdGhpcy5tYXNrZXIgPSBtYXNrO1xyXG4gICAgICAgIGdyb3VwUGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsJyNmZmYnKTtcclxuICAgIH0gZWxzZSBpZih0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMTBdLnAudiA9PT0gMSB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMTBdLnAudiA9PT0gMil7XHJcbiAgICAgICAgaWYodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzEwXS5wLnYgPT09IDIpe1xyXG4gICAgICAgICAgICBlbGVtQ2hpbGRyZW4gPSB0aGlzLmVsZW0ubGF5ZXJFbGVtZW50LmNoaWxkcmVuIHx8IHRoaXMuZWxlbS5sYXllckVsZW1lbnQuY2hpbGROb2RlcztcclxuICAgICAgICAgICAgd2hpbGUoZWxlbUNoaWxkcmVuLmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW0ubGF5ZXJFbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1DaGlsZHJlblswXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChncm91cFBhdGgpO1xyXG4gICAgICAgIHRoaXMuZWxlbS5sYXllckVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdtYXNrJyk7XHJcbiAgICAgICAgZ3JvdXBQYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywnI2ZmZicpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICB0aGlzLnBhdGhNYXNrZXIgPSBncm91cFBhdGg7XHJcbn07XHJcblxyXG5TVkdTdHJva2VFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24oZm9yY2VSZW5kZXIpe1xyXG4gICAgaWYoIXRoaXMuaW5pdGlhbGl6ZWQpe1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgfVxyXG4gICAgdmFyIGksIGxlbiA9IHRoaXMucGF0aHMubGVuZ3RoO1xyXG4gICAgdmFyIG1hc2ssIHBhdGg7XHJcbiAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgIGlmKHRoaXMucGF0aHNbaV0ubSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hc2sgPSB0aGlzLmVsZW0ubWFza01hbmFnZXIudmlld0RhdGFbdGhpcy5wYXRoc1tpXS5tXTtcclxuICAgICAgICBwYXRoID0gdGhpcy5wYXRoc1tpXS5wO1xyXG4gICAgICAgIGlmKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmIHx8IG1hc2sucHJvcC5fbWRmKXtcclxuICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLG1hc2subGFzdFBhdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOV0ucC5fbWRmIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLl9tZGYgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzddLnAuX21kZiB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOF0ucC5fbWRmIHx8IG1hc2sucHJvcC5fbWRmKXtcclxuICAgICAgICAgICAgdmFyIGRhc2hhcnJheVZhbHVlO1xyXG4gICAgICAgICAgICBpZih0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbN10ucC52ICE9PSAwIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s4XS5wLnYgIT09IDEwMCl7XHJcbiAgICAgICAgICAgICAgICB2YXIgcyA9IE1hdGgubWluKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s3XS5wLnYsdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzhdLnAudikvMTAwO1xyXG4gICAgICAgICAgICAgICAgdmFyIGUgPSBNYXRoLm1heCh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbN10ucC52LHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s4XS5wLnYpLzEwMDtcclxuICAgICAgICAgICAgICAgIHZhciBsID0gcGF0aC5nZXRUb3RhbExlbmd0aCgpO1xyXG4gICAgICAgICAgICAgICAgZGFzaGFycmF5VmFsdWUgPSAnMCAwIDAgJyArIGwqcyArICcgJztcclxuICAgICAgICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gbCooZS1zKTtcclxuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gMSt0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNF0ucC52KjIqdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzldLnAudi8xMDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgdW5pdHMgPSBNYXRoLmZsb29yKGxpbmVMZW5ndGgvc2VnbWVudCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgajtcclxuICAgICAgICAgICAgICAgIGZvcihqPTA7ajx1bml0cztqKz0xKXtcclxuICAgICAgICAgICAgICAgICAgICBkYXNoYXJyYXlWYWx1ZSArPSAnMSAnICsgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAudioyKnRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s5XS5wLnYvMTAwICsgJyAnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGFzaGFycmF5VmFsdWUgKz0gJzAgJyArIGwqMTAgKyAnIDAgMCc7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkYXNoYXJyYXlWYWx1ZSA9ICcxICcgKyB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNF0ucC52KjIqdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzldLnAudi8xMDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLGRhc2hhcnJheVZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZihmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNF0ucC5fbWRmKXtcclxuICAgICAgICB0aGlzLnBhdGhNYXNrZXIuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLnYqMik7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s2XS5wLl9tZGYpe1xyXG4gICAgICAgIHRoaXMucGF0aE1hc2tlci5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s2XS5wLnYpO1xyXG4gICAgfVxyXG4gICAgaWYodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzEwXS5wLnYgPT09IDEgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzEwXS5wLnYgPT09IDIpe1xyXG4gICAgICAgIGlmKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1szXS5wLl9tZGYpe1xyXG4gICAgICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbM10ucC52O1xyXG4gICAgICAgICAgICB0aGlzLnBhdGhNYXNrZXIuc2V0QXR0cmlidXRlKCdzdHJva2UnLCdyZ2IoJytibV9mbG9vcihjb2xvclswXSoyNTUpKycsJytibV9mbG9vcihjb2xvclsxXSoyNTUpKycsJytibV9mbG9vcihjb2xvclsyXSoyNTUpKycpJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xuZnVuY3Rpb24gU1ZHVHJpdG9uZUZpbHRlcihmaWx0ZXIsIGZpbHRlck1hbmFnZXIpe1xyXG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcclxuICAgIHZhciBmZUNvbG9yTWF0cml4ID0gY3JlYXRlTlMoJ2ZlQ29sb3JNYXRyaXgnKTtcclxuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd0eXBlJywnbWF0cml4Jyk7XHJcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywnbGluZWFyUkdCJyk7XHJcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndmFsdWVzJywnMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMCAwIDAgMSAwJyk7XHJcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgncmVzdWx0JywnZjEnKTtcclxuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbG9yTWF0cml4KTtcclxuICAgIHZhciBmZUNvbXBvbmVudFRyYW5zZmVyID0gY3JlYXRlTlMoJ2ZlQ29tcG9uZW50VHJhbnNmZXInKTtcclxuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCdzUkdCJyk7XHJcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb21wb25lbnRUcmFuc2Zlcik7XHJcbiAgICB0aGlzLm1hdHJpeEZpbHRlciA9IGZlQ29tcG9uZW50VHJhbnNmZXI7XHJcbiAgICB2YXIgZmVGdW5jUiA9IGNyZWF0ZU5TKCdmZUZ1bmNSJyk7XHJcbiAgICBmZUZ1bmNSLnNldEF0dHJpYnV0ZSgndHlwZScsJ3RhYmxlJyk7XHJcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLmFwcGVuZENoaWxkKGZlRnVuY1IpO1xyXG4gICAgdGhpcy5mZUZ1bmNSID0gZmVGdW5jUjtcclxuICAgIHZhciBmZUZ1bmNHID0gY3JlYXRlTlMoJ2ZlRnVuY0cnKTtcclxuICAgIGZlRnVuY0cuc2V0QXR0cmlidXRlKCd0eXBlJywndGFibGUnKTtcclxuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuYXBwZW5kQ2hpbGQoZmVGdW5jRyk7XHJcbiAgICB0aGlzLmZlRnVuY0cgPSBmZUZ1bmNHO1xyXG4gICAgdmFyIGZlRnVuY0IgPSBjcmVhdGVOUygnZmVGdW5jQicpO1xyXG4gICAgZmVGdW5jQi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCd0YWJsZScpO1xyXG4gICAgZmVDb21wb25lbnRUcmFuc2Zlci5hcHBlbmRDaGlsZChmZUZ1bmNCKTtcclxuICAgIHRoaXMuZmVGdW5jQiA9IGZlRnVuY0I7XHJcbn1cclxuXHJcblNWR1RyaXRvbmVGaWx0ZXIucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24oZm9yY2VSZW5kZXIpe1xyXG4gICAgaWYoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYpe1xyXG4gICAgICAgIHZhciBjb2xvcjEgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC52O1xyXG4gICAgICAgIHZhciBjb2xvcjIgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC52O1xyXG4gICAgICAgIHZhciBjb2xvcjMgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMl0ucC52O1xyXG4gICAgICAgIHZhciB0YWJsZVIgPSBjb2xvcjNbMF0gKyAnICcgKyBjb2xvcjJbMF0gKyAnICcgKyBjb2xvcjFbMF07XHJcbiAgICAgICAgdmFyIHRhYmxlRyA9IGNvbG9yM1sxXSArICcgJyArIGNvbG9yMlsxXSArICcgJyArIGNvbG9yMVsxXTtcclxuICAgICAgICB2YXIgdGFibGVCID0gY29sb3IzWzJdICsgJyAnICsgY29sb3IyWzJdICsgJyAnICsgY29sb3IxWzJdO1xyXG4gICAgICAgIHRoaXMuZmVGdW5jUi5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdGFibGVSKTtcclxuICAgICAgICB0aGlzLmZlRnVuY0cuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsIHRhYmxlRyk7XHJcbiAgICAgICAgdGhpcy5mZUZ1bmNCLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB0YWJsZUIpO1xyXG4gICAgICAgIC8vdmFyIG9wYWNpdHkgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMl0ucC52LzEwMDtcclxuICAgICAgICAvL3RoaXMubWF0cml4RmlsdGVyLnNldEF0dHJpYnV0ZSgndmFsdWVzJywoY29sb3JXaGl0ZVswXS0gY29sb3JCbGFja1swXSkrJyAwIDAgMCAnKyBjb2xvckJsYWNrWzBdICsnICcrIChjb2xvcldoaXRlWzFdLSBjb2xvckJsYWNrWzFdKSArJyAwIDAgMCAnKyBjb2xvckJsYWNrWzFdICsnICcrIChjb2xvcldoaXRlWzJdLSBjb2xvckJsYWNrWzJdKSArJyAwIDAgMCAnKyBjb2xvckJsYWNrWzJdICsnIDAgMCAwICcgKyBvcGFjaXR5ICsgJyAwJyk7XHJcbiAgICB9XHJcbn07XG5mdW5jdGlvbiBTVkdQcm9MZXZlbHNGaWx0ZXIoZmlsdGVyLCBmaWx0ZXJNYW5hZ2VyKXtcclxuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XHJcbiAgICB2YXIgZWZmZWN0RWxlbWVudHMgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHM7XHJcbiAgICB2YXIgZmVDb21wb25lbnRUcmFuc2ZlciA9IGNyZWF0ZU5TKCdmZUNvbXBvbmVudFRyYW5zZmVyJyk7XHJcbiAgICB2YXIgZmVGdW5jUiwgZmVGdW5jRywgZmVGdW5jQjtcclxuICAgIFxyXG4gICAgaWYoZWZmZWN0RWxlbWVudHNbMTBdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxMF0ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzExXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTFdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1sxMl0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzEyXS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMTNdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxM10ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzE0XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTRdLnAudiAhPT0gMSl7XHJcbiAgICAgICAgdGhpcy5mZUZ1bmNSID0gdGhpcy5jcmVhdGVGZUZ1bmMoJ2ZlRnVuY1InLCBmZUNvbXBvbmVudFRyYW5zZmVyKTtcclxuICAgIH1cclxuICAgIGlmKGVmZmVjdEVsZW1lbnRzWzE3XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTddLnAudiAhPT0gMCB8fCBlZmZlY3RFbGVtZW50c1sxOF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzE4XS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMTldLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxOV0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzIwXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMjBdLnAudiAhPT0gMCB8fCBlZmZlY3RFbGVtZW50c1syMV0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzIxXS5wLnYgIT09IDEpe1xyXG4gICAgICAgIHRoaXMuZmVGdW5jRyA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNHJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XHJcbiAgICB9XHJcbiAgICBpZihlZmZlY3RFbGVtZW50c1syNF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzI0XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMjVdLnAuayB8fCBlZmZlY3RFbGVtZW50c1syNV0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzI2XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMjZdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1syN10ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzI3XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMjhdLnAuayB8fCBlZmZlY3RFbGVtZW50c1syOF0ucC52ICE9PSAxKXtcclxuICAgICAgICB0aGlzLmZlRnVuY0IgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jQicsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xyXG4gICAgfVxyXG4gICAgaWYoZWZmZWN0RWxlbWVudHNbMzFdLnAuayB8fCBlZmZlY3RFbGVtZW50c1szMV0ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzMyXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMzJdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1szM10ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzMzXS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMzRdLnAuayB8fCBlZmZlY3RFbGVtZW50c1szNF0ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzM1XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMzVdLnAudiAhPT0gMSl7XHJcbiAgICAgICAgdGhpcy5mZUZ1bmNBID0gdGhpcy5jcmVhdGVGZUZ1bmMoJ2ZlRnVuY0EnLCBmZUNvbXBvbmVudFRyYW5zZmVyKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYodGhpcy5mZUZ1bmNSIHx8IHRoaXMuZmVGdW5jRyB8fCB0aGlzLmZlRnVuY0IgfHwgdGhpcy5mZUZ1bmNBKXtcclxuICAgICAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywnc1JHQicpO1xyXG4gICAgICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbXBvbmVudFRyYW5zZmVyKTtcclxuICAgICAgICBmZUNvbXBvbmVudFRyYW5zZmVyID0gY3JlYXRlTlMoJ2ZlQ29tcG9uZW50VHJhbnNmZXInKTtcclxuICAgIH1cclxuXHJcbiAgICBpZihlZmZlY3RFbGVtZW50c1szXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbM10ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzRdLnAuayB8fCBlZmZlY3RFbGVtZW50c1s0XS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbNV0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzVdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1s2XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbNl0ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzddLnAuayB8fCBlZmZlY3RFbGVtZW50c1s3XS5wLnYgIT09IDEpe1xyXG5cclxuICAgICAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywnc1JHQicpO1xyXG4gICAgICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbXBvbmVudFRyYW5zZmVyKTtcclxuICAgICAgICB0aGlzLmZlRnVuY1JDb21wb3NlZCA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNSJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XHJcbiAgICAgICAgdGhpcy5mZUZ1bmNHQ29tcG9zZWQgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jRycsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xyXG4gICAgICAgIHRoaXMuZmVGdW5jQkNvbXBvc2VkID0gdGhpcy5jcmVhdGVGZUZ1bmMoJ2ZlRnVuY0InLCBmZUNvbXBvbmVudFRyYW5zZmVyKTtcclxuICAgIH1cclxufVxyXG5cclxuU1ZHUHJvTGV2ZWxzRmlsdGVyLnByb3RvdHlwZS5jcmVhdGVGZUZ1bmMgPSBmdW5jdGlvbih0eXBlLCBmZUNvbXBvbmVudFRyYW5zZmVyKSB7XHJcbiAgICB2YXIgZmVGdW5jID0gY3JlYXRlTlModHlwZSk7XHJcbiAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKCd0eXBlJywndGFibGUnKTtcclxuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuYXBwZW5kQ2hpbGQoZmVGdW5jKTtcclxuICAgIHJldHVybiBmZUZ1bmM7XHJcbn07XHJcblxyXG5TVkdQcm9MZXZlbHNGaWx0ZXIucHJvdG90eXBlLmdldFRhYmxlVmFsdWUgPSBmdW5jdGlvbihpbnB1dEJsYWNrLCBpbnB1dFdoaXRlLCBnYW1tYSwgb3V0cHV0QmxhY2ssIG91dHB1dFdoaXRlKSB7XHJcbiAgICB2YXIgY250ID0gMDtcclxuICAgIHZhciBzZWdtZW50cyA9IDI1NjtcclxuICAgIHZhciBwZXJjO1xyXG4gICAgdmFyIG1pbiA9IE1hdGgubWluKGlucHV0QmxhY2ssIGlucHV0V2hpdGUpO1xyXG4gICAgdmFyIG1heCA9IE1hdGgubWF4KGlucHV0QmxhY2ssIGlucHV0V2hpdGUpO1xyXG4gICAgdmFyIHRhYmxlID0gQXJyYXkuY2FsbChudWxsLHtsZW5ndGg6c2VnbWVudHN9KTtcclxuICAgIHZhciBjb2xvclZhbHVlO1xyXG4gICAgdmFyIHBvcyA9IDA7XHJcbiAgICB2YXIgb3V0cHV0RGVsdGEgPSBvdXRwdXRXaGl0ZSAtIG91dHB1dEJsYWNrOyBcclxuICAgIHZhciBpbnB1dERlbHRhID0gaW5wdXRXaGl0ZSAtIGlucHV0QmxhY2s7IFxyXG4gICAgd2hpbGUoY250IDw9IDI1Nikge1xyXG4gICAgICAgIHBlcmMgPSBjbnQvMjU2O1xyXG4gICAgICAgIGlmKHBlcmMgPD0gbWluKXtcclxuICAgICAgICAgICAgY29sb3JWYWx1ZSA9IGlucHV0RGVsdGEgPCAwID8gb3V0cHV0V2hpdGUgOiBvdXRwdXRCbGFjaztcclxuICAgICAgICB9IGVsc2UgaWYocGVyYyA+PSBtYXgpe1xyXG4gICAgICAgICAgICBjb2xvclZhbHVlID0gaW5wdXREZWx0YSA8IDAgPyBvdXRwdXRCbGFjayA6IG91dHB1dFdoaXRlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbG9yVmFsdWUgPSAob3V0cHV0QmxhY2sgKyBvdXRwdXREZWx0YSAqIE1hdGgucG93KChwZXJjIC0gaW5wdXRCbGFjaykgLyBpbnB1dERlbHRhLCAxIC8gZ2FtbWEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGFibGVbcG9zKytdID0gY29sb3JWYWx1ZTtcclxuICAgICAgICBjbnQgKz0gMjU2LyhzZWdtZW50cy0xKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YWJsZS5qb2luKCcgJyk7XHJcbn07XHJcblxyXG5TVkdQcm9MZXZlbHNGaWx0ZXIucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24oZm9yY2VSZW5kZXIpe1xyXG4gICAgaWYoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYpe1xyXG4gICAgICAgIHZhciB2YWwsIGNudCwgcGVyYywgYmV6aWVyO1xyXG4gICAgICAgIHZhciBlZmZlY3RFbGVtZW50cyA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50cztcclxuICAgICAgICBpZih0aGlzLmZlRnVuY1JDb21wb3NlZCAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbM10ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1s1XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbNl0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzddLnAuX21kZikpe1xyXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmdldFRhYmxlVmFsdWUoZWZmZWN0RWxlbWVudHNbM10ucC52LGVmZmVjdEVsZW1lbnRzWzRdLnAudixlZmZlY3RFbGVtZW50c1s1XS5wLnYsZWZmZWN0RWxlbWVudHNbNl0ucC52LGVmZmVjdEVsZW1lbnRzWzddLnAudik7XHJcbiAgICAgICAgICAgIHRoaXMuZmVGdW5jUkNvbXBvc2VkLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLHZhbCk7XHJcbiAgICAgICAgICAgIHRoaXMuZmVGdW5jR0NvbXBvc2VkLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLHZhbCk7XHJcbiAgICAgICAgICAgIHRoaXMuZmVGdW5jQkNvbXBvc2VkLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLHZhbCk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgaWYodGhpcy5mZUZ1bmNSICYmIChmb3JjZVJlbmRlciB8fCBlZmZlY3RFbGVtZW50c1sxMF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzExXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMTJdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1sxM10ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzE0XS5wLl9tZGYpKXtcclxuICAgICAgICAgICAgdmFsID0gdGhpcy5nZXRUYWJsZVZhbHVlKGVmZmVjdEVsZW1lbnRzWzEwXS5wLnYsZWZmZWN0RWxlbWVudHNbMTFdLnAudixlZmZlY3RFbGVtZW50c1sxMl0ucC52LGVmZmVjdEVsZW1lbnRzWzEzXS5wLnYsZWZmZWN0RWxlbWVudHNbMTRdLnAudik7XHJcbiAgICAgICAgICAgIHRoaXMuZmVGdW5jUi5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJyx2YWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5mZUZ1bmNHICYmIChmb3JjZVJlbmRlciB8fCBlZmZlY3RFbGVtZW50c1sxN10ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzE4XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMTldLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syMF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzIxXS5wLl9tZGYpKXtcclxuICAgICAgICAgICAgdmFsID0gdGhpcy5nZXRUYWJsZVZhbHVlKGVmZmVjdEVsZW1lbnRzWzE3XS5wLnYsZWZmZWN0RWxlbWVudHNbMThdLnAudixlZmZlY3RFbGVtZW50c1sxOV0ucC52LGVmZmVjdEVsZW1lbnRzWzIwXS5wLnYsZWZmZWN0RWxlbWVudHNbMjFdLnAudik7XHJcbiAgICAgICAgICAgIHRoaXMuZmVGdW5jRy5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJyx2YWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5mZUZ1bmNCICYmIChmb3JjZVJlbmRlciB8fCBlZmZlY3RFbGVtZW50c1syNF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzI1XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMjZdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syN10ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzI4XS5wLl9tZGYpKXtcclxuICAgICAgICAgICAgdmFsID0gdGhpcy5nZXRUYWJsZVZhbHVlKGVmZmVjdEVsZW1lbnRzWzI0XS5wLnYsZWZmZWN0RWxlbWVudHNbMjVdLnAudixlZmZlY3RFbGVtZW50c1syNl0ucC52LGVmZmVjdEVsZW1lbnRzWzI3XS5wLnYsZWZmZWN0RWxlbWVudHNbMjhdLnAudik7XHJcbiAgICAgICAgICAgIHRoaXMuZmVGdW5jQi5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJyx2YWwpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5mZUZ1bmNBICYmIChmb3JjZVJlbmRlciB8fCBlZmZlY3RFbGVtZW50c1szMV0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzMyXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMzNdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1szNF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzM1XS5wLl9tZGYpKXtcclxuICAgICAgICAgICAgdmFsID0gdGhpcy5nZXRUYWJsZVZhbHVlKGVmZmVjdEVsZW1lbnRzWzMxXS5wLnYsZWZmZWN0RWxlbWVudHNbMzJdLnAudixlZmZlY3RFbGVtZW50c1szM10ucC52LGVmZmVjdEVsZW1lbnRzWzM0XS5wLnYsZWZmZWN0RWxlbWVudHNbMzVdLnAudik7XHJcbiAgICAgICAgICAgIHRoaXMuZmVGdW5jQS5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJyx2YWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxufTtcbmZ1bmN0aW9uIFNWR0Ryb3BTaGFkb3dFZmZlY3QoZmlsdGVyLCBmaWx0ZXJNYW5hZ2VyKXtcclxuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ3gnLCctMTAwJScpO1xyXG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZSgneScsJy0xMDAlJyk7XHJcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsJzQwMCUnKTtcclxuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsJzQwMCUnKTtcclxuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XHJcblxyXG4gICAgdmFyIGZlR2F1c3NpYW5CbHVyID0gY3JlYXRlTlMoJ2ZlR2F1c3NpYW5CbHVyJyk7XHJcbiAgICBmZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ2luJywnU291cmNlQWxwaGEnKTtcclxuICAgIGZlR2F1c3NpYW5CbHVyLnNldEF0dHJpYnV0ZSgncmVzdWx0JywnZHJvcF9zaGFkb3dfMScpO1xyXG4gICAgZmVHYXVzc2lhbkJsdXIuc2V0QXR0cmlidXRlKCdzdGREZXZpYXRpb24nLCcwJyk7XHJcbiAgICB0aGlzLmZlR2F1c3NpYW5CbHVyID0gZmVHYXVzc2lhbkJsdXI7XHJcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVHYXVzc2lhbkJsdXIpO1xyXG5cclxuICAgIHZhciBmZU9mZnNldCA9IGNyZWF0ZU5TKCdmZU9mZnNldCcpO1xyXG4gICAgZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdkeCcsJzI1Jyk7XHJcbiAgICBmZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2R5JywnMCcpO1xyXG4gICAgZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdpbicsJ2Ryb3Bfc2hhZG93XzEnKTtcclxuICAgIGZlT2Zmc2V0LnNldEF0dHJpYnV0ZSgncmVzdWx0JywnZHJvcF9zaGFkb3dfMicpO1xyXG4gICAgdGhpcy5mZU9mZnNldCA9IGZlT2Zmc2V0O1xyXG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlT2Zmc2V0KTtcclxuICAgIHZhciBmZUZsb29kID0gY3JlYXRlTlMoJ2ZlRmxvb2QnKTtcclxuICAgIGZlRmxvb2Quc2V0QXR0cmlidXRlKCdmbG9vZC1jb2xvcicsJyMwMGZmMDAnKTtcclxuICAgIGZlRmxvb2Quc2V0QXR0cmlidXRlKCdmbG9vZC1vcGFjaXR5JywnMScpO1xyXG4gICAgZmVGbG9vZC5zZXRBdHRyaWJ1dGUoJ3Jlc3VsdCcsJ2Ryb3Bfc2hhZG93XzMnKTtcclxuICAgIHRoaXMuZmVGbG9vZCA9IGZlRmxvb2Q7XHJcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVGbG9vZCk7XHJcblxyXG4gICAgdmFyIGZlQ29tcG9zaXRlID0gY3JlYXRlTlMoJ2ZlQ29tcG9zaXRlJyk7XHJcbiAgICBmZUNvbXBvc2l0ZS5zZXRBdHRyaWJ1dGUoJ2luJywnZHJvcF9zaGFkb3dfMycpO1xyXG4gICAgZmVDb21wb3NpdGUuc2V0QXR0cmlidXRlKCdpbjInLCdkcm9wX3NoYWRvd18yJyk7XHJcbiAgICBmZUNvbXBvc2l0ZS5zZXRBdHRyaWJ1dGUoJ29wZXJhdG9yJywnaW4nKTtcclxuICAgIGZlQ29tcG9zaXRlLnNldEF0dHJpYnV0ZSgncmVzdWx0JywnZHJvcF9zaGFkb3dfNCcpO1xyXG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29tcG9zaXRlKTtcclxuXHJcblxyXG4gICAgdmFyIGZlTWVyZ2UgPSBjcmVhdGVOUygnZmVNZXJnZScpO1xyXG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlTWVyZ2UpO1xyXG4gICAgdmFyIGZlTWVyZ2VOb2RlO1xyXG4gICAgZmVNZXJnZU5vZGUgPSBjcmVhdGVOUygnZmVNZXJnZU5vZGUnKTtcclxuICAgIGZlTWVyZ2UuYXBwZW5kQ2hpbGQoZmVNZXJnZU5vZGUpO1xyXG4gICAgZmVNZXJnZU5vZGUgPSBjcmVhdGVOUygnZmVNZXJnZU5vZGUnKTtcclxuICAgIGZlTWVyZ2VOb2RlLnNldEF0dHJpYnV0ZSgnaW4nLCdTb3VyY2VHcmFwaGljJyk7XHJcbiAgICB0aGlzLmZlTWVyZ2VOb2RlID0gZmVNZXJnZU5vZGU7XHJcbiAgICB0aGlzLmZlTWVyZ2UgPSBmZU1lcmdlO1xyXG4gICAgdGhpcy5vcmlnaW5hbE5vZGVBZGRlZCA9IGZhbHNlO1xyXG4gICAgZmVNZXJnZS5hcHBlbmRDaGlsZChmZU1lcmdlTm9kZSk7XHJcbn1cclxuXHJcblNWR0Ryb3BTaGFkb3dFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24oZm9yY2VSZW5kZXIpe1xyXG4gICAgaWYoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYpe1xyXG4gICAgICAgIGlmKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLl9tZGYpe1xyXG4gICAgICAgICAgICB0aGlzLmZlR2F1c3NpYW5CbHVyLnNldEF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJywgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAudiAvIDQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC5fbWRmKXtcclxuICAgICAgICAgICAgdmFyIGNvbCA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnY7XHJcbiAgICAgICAgICAgIHRoaXMuZmVGbG9vZC5zZXRBdHRyaWJ1dGUoJ2Zsb29kLWNvbG9yJyxyZ2JUb0hleChNYXRoLnJvdW5kKGNvbFswXSoyNTUpLE1hdGgucm91bmQoY29sWzFdKjI1NSksTWF0aC5yb3VuZChjb2xbMl0qMjU1KSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC5fbWRmKXtcclxuICAgICAgICAgICAgdGhpcy5mZUZsb29kLnNldEF0dHJpYnV0ZSgnZmxvb2Qtb3BhY2l0eScsdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzFdLnAudi8yNTUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMl0ucC5fbWRmIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1szXS5wLl9tZGYpe1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbM10ucC52O1xyXG4gICAgICAgICAgICB2YXIgYW5nbGUgPSAodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudiAtIDkwKSAqIGRlZ1RvUmFkcztcclxuICAgICAgICAgICAgdmFyIHggPSBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICAgICAgdmFyIHkgPSBkaXN0YW5jZSAqIE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICAgICAgdGhpcy5mZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2R4JywgeCk7XHJcbiAgICAgICAgICAgIHRoaXMuZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdkeScsIHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKmlmKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s1XS5wLl9tZGYpe1xyXG4gICAgICAgICAgICBpZih0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNV0ucC52ID09PSAxICYmIHRoaXMub3JpZ2luYWxOb2RlQWRkZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmVNZXJnZS5yZW1vdmVDaGlsZCh0aGlzLmZlTWVyZ2VOb2RlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxOb2RlQWRkZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s1XS5wLnYgPT09IDAgJiYgIXRoaXMub3JpZ2luYWxOb2RlQWRkZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmVNZXJnZS5hcHBlbmRDaGlsZCh0aGlzLmZlTWVyZ2VOb2RlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luYWxOb2RlQWRkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSovXHJcbiAgICB9XHJcbn07XG52YXIgX3N2Z01hdHRlU3ltYm9scyA9IFtdO1xyXG52YXIgX3N2Z01hdHRlTWFza0NvdW50ZXIgPSAwO1xyXG5cclxuZnVuY3Rpb24gU1ZHTWF0dGUzRWZmZWN0KGZpbHRlckVsZW0sIGZpbHRlck1hbmFnZXIsIGVsZW0pe1xyXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcclxuICAgIHRoaXMuZmlsdGVyRWxlbSA9IGZpbHRlckVsZW07XHJcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xyXG4gICAgZWxlbS5tYXR0ZUVsZW1lbnQgPSBjcmVhdGVOUygnZycpO1xyXG4gICAgZWxlbS5tYXR0ZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbS5sYXllckVsZW1lbnQpO1xyXG4gICAgZWxlbS5tYXR0ZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbS50cmFuc2Zvcm1lZEVsZW1lbnQpO1xyXG4gICAgZWxlbS5iYXNlRWxlbWVudCA9IGVsZW0ubWF0dGVFbGVtZW50O1xyXG59XHJcblxyXG5TVkdNYXR0ZTNFZmZlY3QucHJvdG90eXBlLmZpbmRTeW1ib2wgPSBmdW5jdGlvbihtYXNrKSB7XHJcbiAgICB2YXIgaSA9IDAsIGxlbiA9IF9zdmdNYXR0ZVN5bWJvbHMubGVuZ3RoO1xyXG4gICAgd2hpbGUoaSA8IGxlbikge1xyXG4gICAgICAgIGlmKF9zdmdNYXR0ZVN5bWJvbHNbaV0gPT09IG1hc2spIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9zdmdNYXR0ZVN5bWJvbHNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgKz0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5cclxuU1ZHTWF0dGUzRWZmZWN0LnByb3RvdHlwZS5yZXBsYWNlSW5QYXJlbnQgPSBmdW5jdGlvbihtYXNrLCBzeW1ib2xJZCkge1xyXG4gICAgdmFyIHBhcmVudE5vZGUgPSBtYXNrLmxheWVyRWxlbWVudC5wYXJlbnROb2RlO1xyXG4gICAgaWYoIXBhcmVudE5vZGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnROb2RlLmNoaWxkcmVuO1xyXG4gICAgdmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICAgIGlmIChjaGlsZHJlbltpXSA9PT0gbWFzay5sYXllckVsZW1lbnQpIHtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGkgKz0gMTtcclxuICAgIH1cclxuICAgIHZhciBuZXh0Q2hpbGQ7XHJcbiAgICBpZiAoaSA8PSBsZW4gLSAyKSB7XHJcbiAgICAgICAgbmV4dENoaWxkID0gY2hpbGRyZW5baSArIDFdO1xyXG4gICAgfVxyXG4gICAgdmFyIHVzZUVsZW0gPSBjcmVhdGVOUygndXNlJyk7XHJcbiAgICB1c2VFbGVtLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyArIHN5bWJvbElkKTtcclxuICAgIGlmKG5leHRDaGlsZCkge1xyXG4gICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHVzZUVsZW0sIG5leHRDaGlsZCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodXNlRWxlbSk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5TVkdNYXR0ZTNFZmZlY3QucHJvdG90eXBlLnNldEVsZW1lbnRBc01hc2sgPSBmdW5jdGlvbihlbGVtLCBtYXNrKSB7XHJcbiAgICBpZighdGhpcy5maW5kU3ltYm9sKG1hc2spKSB7XHJcbiAgICAgICAgdmFyIHN5bWJvbElkID0gJ21hdHRlXycgKyByYW5kb21TdHJpbmcoNSkgKyAnXycgKyBfc3ZnTWF0dGVNYXNrQ291bnRlcisrO1xyXG4gICAgICAgIHZhciBtYXNrZXIgPSBjcmVhdGVOUygnbWFzaycpO1xyXG4gICAgICAgIG1hc2tlci5zZXRBdHRyaWJ1dGUoJ2lkJywgbWFzay5sYXllcklkKTtcclxuICAgICAgICBtYXNrZXIuc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnYWxwaGEnKTtcclxuICAgICAgICBfc3ZnTWF0dGVTeW1ib2xzLnB1c2gobWFzayk7XHJcbiAgICAgICAgdmFyIGRlZnMgPSBlbGVtLmdsb2JhbERhdGEuZGVmcztcclxuICAgICAgICBkZWZzLmFwcGVuZENoaWxkKG1hc2tlcik7XHJcbiAgICAgICAgdmFyIHN5bWJvbCA9IGNyZWF0ZU5TKCdzeW1ib2wnKTtcclxuICAgICAgICBzeW1ib2wuc2V0QXR0cmlidXRlKCdpZCcsIHN5bWJvbElkKTtcclxuICAgICAgICB0aGlzLnJlcGxhY2VJblBhcmVudChtYXNrLCBzeW1ib2xJZCk7XHJcbiAgICAgICAgc3ltYm9sLmFwcGVuZENoaWxkKG1hc2subGF5ZXJFbGVtZW50KTtcclxuICAgICAgICBkZWZzLmFwcGVuZENoaWxkKHN5bWJvbCk7XHJcbiAgICAgICAgdmFyIHVzZUVsZW0gPSBjcmVhdGVOUygndXNlJyk7XHJcbiAgICAgICAgdXNlRWxlbS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycgKyBzeW1ib2xJZCk7XHJcbiAgICAgICAgbWFza2VyLmFwcGVuZENoaWxkKHVzZUVsZW0pO1xyXG4gICAgICAgIG1hc2suZGF0YS5oZCA9IGZhbHNlO1xyXG4gICAgICAgIG1hc2suc2hvdygpO1xyXG4gICAgfVxyXG4gICAgZWxlbS5zZXRNYXR0ZShtYXNrLmxheWVySWQpO1xyXG59O1xyXG5cclxuU1ZHTWF0dGUzRWZmZWN0LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgaW5kID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzBdLnAudjtcclxuICAgIHZhciBpID0gMCwgbGVuID0gdGhpcy5lbGVtLmNvbXAuZWxlbWVudHMubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcclxuICAgIFx0aWYgKHRoaXMuZWxlbS5jb21wLmVsZW1lbnRzW2ldLmRhdGEuaW5kID09PSBpbmQpIHtcclxuICAgIFx0XHR0aGlzLnNldEVsZW1lbnRBc01hc2sodGhpcy5lbGVtLCB0aGlzLmVsZW0uY29tcC5lbGVtZW50c1tpXSk7XHJcbiAgICBcdH1cclxuICAgIFx0aSArPSAxO1xyXG4gICAgfVxyXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XHJcbn07XHJcblxyXG5TVkdNYXR0ZTNFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24oKSB7XHJcblx0aWYoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcclxuXHRcdHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG5cdH1cclxufTtcbmZ1bmN0aW9uIFNWR0VmZmVjdHMoZWxlbSl7XHJcbiAgICB2YXIgaSwgbGVuID0gZWxlbS5kYXRhLmVmID8gZWxlbS5kYXRhLmVmLmxlbmd0aCA6IDA7XHJcbiAgICB2YXIgZmlsSWQgPSByYW5kb21TdHJpbmcoMTApO1xyXG4gICAgdmFyIGZpbCA9IGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUZpbHRlcihmaWxJZCk7XHJcbiAgICB2YXIgY291bnQgPSAwO1xyXG4gICAgdGhpcy5maWx0ZXJzID0gW107XHJcbiAgICB2YXIgZmlsdGVyTWFuYWdlcjtcclxuICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgZmlsdGVyTWFuYWdlciA9IG51bGw7XHJcbiAgICAgICAgaWYoZWxlbS5kYXRhLmVmW2ldLnR5ID09PSAyMCl7XHJcbiAgICAgICAgICAgIGNvdW50ICs9IDE7XHJcbiAgICAgICAgICAgIGZpbHRlck1hbmFnZXIgPSBuZXcgU1ZHVGludEZpbHRlcihmaWwsIGVsZW0uZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHNbaV0pO1xyXG4gICAgICAgIH1lbHNlIGlmKGVsZW0uZGF0YS5lZltpXS50eSA9PT0gMjEpe1xyXG4gICAgICAgICAgICBjb3VudCArPSAxO1xyXG4gICAgICAgICAgICBmaWx0ZXJNYW5hZ2VyID0gbmV3IFNWR0ZpbGxGaWx0ZXIoZmlsLCBlbGVtLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzW2ldKTtcclxuICAgICAgICB9ZWxzZSBpZihlbGVtLmRhdGEuZWZbaV0udHkgPT09IDIyKXtcclxuICAgICAgICAgICAgZmlsdGVyTWFuYWdlciA9IG5ldyBTVkdTdHJva2VFZmZlY3QoZWxlbSwgZWxlbS5lZmZlY3RzTWFuYWdlci5lZmZlY3RFbGVtZW50c1tpXSk7XHJcbiAgICAgICAgfWVsc2UgaWYoZWxlbS5kYXRhLmVmW2ldLnR5ID09PSAyMyl7XHJcbiAgICAgICAgICAgIGNvdW50ICs9IDE7XHJcbiAgICAgICAgICAgIGZpbHRlck1hbmFnZXIgPSBuZXcgU1ZHVHJpdG9uZUZpbHRlcihmaWwsIGVsZW0uZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHNbaV0pO1xyXG4gICAgICAgIH1lbHNlIGlmKGVsZW0uZGF0YS5lZltpXS50eSA9PT0gMjQpe1xyXG4gICAgICAgICAgICBjb3VudCArPSAxO1xyXG4gICAgICAgICAgICBmaWx0ZXJNYW5hZ2VyID0gbmV3IFNWR1Byb0xldmVsc0ZpbHRlcihmaWwsIGVsZW0uZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHNbaV0pO1xyXG4gICAgICAgIH1lbHNlIGlmKGVsZW0uZGF0YS5lZltpXS50eSA9PT0gMjUpe1xyXG4gICAgICAgICAgICBjb3VudCArPSAxO1xyXG4gICAgICAgICAgICBmaWx0ZXJNYW5hZ2VyID0gbmV3IFNWR0Ryb3BTaGFkb3dFZmZlY3QoZmlsLCBlbGVtLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzW2ldKTtcclxuICAgICAgICB9ZWxzZSBpZihlbGVtLmRhdGEuZWZbaV0udHkgPT09IDI4KXtcclxuICAgICAgICAgICAgLy9jb3VudCArPSAxO1xyXG4gICAgICAgICAgICBmaWx0ZXJNYW5hZ2VyID0gbmV3IFNWR01hdHRlM0VmZmVjdChmaWwsIGVsZW0uZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHNbaV0sIGVsZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihmaWx0ZXJNYW5hZ2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVycy5wdXNoKGZpbHRlck1hbmFnZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmKGNvdW50KXtcclxuICAgICAgICBlbGVtLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChmaWwpO1xyXG4gICAgICAgIGVsZW0ubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsdGVyJywndXJsKCcgKyBsb2NhdGlvbkhyZWYgKyAnIycrZmlsSWQrJyknKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmZpbHRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgZWxlbS5hZGRSZW5kZXJhYmxlQ29tcG9uZW50KHRoaXMpO1xyXG4gICAgfVxyXG59XHJcblxyXG5TVkdFZmZlY3RzLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uKF9pc0ZpcnN0RnJhbWUpe1xyXG4gICAgdmFyIGksIGxlbiA9IHRoaXMuZmlsdGVycy5sZW5ndGg7XHJcbiAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgIHRoaXMuZmlsdGVyc1tpXS5yZW5kZXJGcmFtZShfaXNGaXJzdEZyYW1lKTtcclxuICAgIH1cclxufTtcbnZhciBhbmltYXRpb25NYW5hZ2VyID0gKGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgbW9kdWxlT2IgPSB7fTtcclxuICAgIHZhciByZWdpc3RlcmVkQW5pbWF0aW9ucyA9IFtdO1xyXG4gICAgdmFyIGluaXRUaW1lID0gMDtcclxuICAgIHZhciBsZW4gPSAwO1xyXG4gICAgdmFyIHBsYXlpbmdBbmltYXRpb25zTnVtID0gMDtcclxuICAgIHZhciBfc3RvcHBlZCA9IHRydWU7XHJcbiAgICB2YXIgX2lzRnJvemVuID0gZmFsc2U7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlRWxlbWVudChldil7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHZhciBhbmltSXRlbSA9IGV2LnRhcmdldDtcclxuICAgICAgICB3aGlsZShpPGxlbikge1xyXG4gICAgICAgICAgICBpZiAocmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uID09PSBhbmltSXRlbSkge1xyXG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgaSAtPSAxO1xyXG4gICAgICAgICAgICAgICAgbGVuIC09IDE7XHJcbiAgICAgICAgICAgICAgICBpZighYW5pbUl0ZW0uaXNQYXVzZWQpe1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YnRyYWN0UGxheWluZ0NvdW50KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByZWdpc3RlckFuaW1hdGlvbihlbGVtZW50LCBhbmltYXRpb25EYXRhKXtcclxuICAgICAgICBpZighZWxlbWVudCl7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaT0wO1xyXG4gICAgICAgIHdoaWxlKGk8bGVuKXtcclxuICAgICAgICAgICAgaWYocmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uZWxlbSA9PSBlbGVtZW50ICYmIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmVsZW0gIT09IG51bGwgKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSs9MTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFuaW1JdGVtID0gbmV3IEFuaW1hdGlvbkl0ZW0oKTtcclxuICAgICAgICBzZXR1cEFuaW1hdGlvbihhbmltSXRlbSwgZWxlbWVudCk7XHJcbiAgICAgICAgYW5pbUl0ZW0uc2V0RGF0YShlbGVtZW50LCBhbmltYXRpb25EYXRhKTtcclxuICAgICAgICByZXR1cm4gYW5pbUl0ZW07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnMoKSB7XHJcbiAgICAgICAgdmFyIGksIGxlbiA9IHJlZ2lzdGVyZWRBbmltYXRpb25zLmxlbmd0aDtcclxuICAgICAgICB2YXIgYW5pbWF0aW9ucyA9IFtdO1xyXG4gICAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaChyZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYW5pbWF0aW9ucztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBhZGRQbGF5aW5nQ291bnQoKXtcclxuICAgICAgICBwbGF5aW5nQW5pbWF0aW9uc051bSArPSAxO1xyXG4gICAgICAgIGFjdGl2YXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc3VidHJhY3RQbGF5aW5nQ291bnQoKXtcclxuICAgICAgICBwbGF5aW5nQW5pbWF0aW9uc051bSAtPSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldHVwQW5pbWF0aW9uKGFuaW1JdGVtLCBlbGVtZW50KXtcclxuICAgICAgICBhbmltSXRlbS5hZGRFdmVudExpc3RlbmVyKCdkZXN0cm95JyxyZW1vdmVFbGVtZW50KTtcclxuICAgICAgICBhbmltSXRlbS5hZGRFdmVudExpc3RlbmVyKCdfYWN0aXZlJyxhZGRQbGF5aW5nQ291bnQpO1xyXG4gICAgICAgIGFuaW1JdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ19pZGxlJyxzdWJ0cmFjdFBsYXlpbmdDb3VudCk7XHJcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnMucHVzaCh7ZWxlbTogZWxlbWVudCxhbmltYXRpb246YW5pbUl0ZW19KTtcclxuICAgICAgICBsZW4gKz0gMTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsb2FkQW5pbWF0aW9uKHBhcmFtcyl7XHJcbiAgICAgICAgdmFyIGFuaW1JdGVtID0gbmV3IEFuaW1hdGlvbkl0ZW0oKTtcclxuICAgICAgICBzZXR1cEFuaW1hdGlvbihhbmltSXRlbSwgbnVsbCk7XHJcbiAgICAgICAgYW5pbUl0ZW0uc2V0UGFyYW1zKHBhcmFtcyk7XHJcbiAgICAgICAgcmV0dXJuIGFuaW1JdGVtO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRTcGVlZCh2YWwsYW5pbWF0aW9uKXtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24uc2V0U3BlZWQodmFsLCBhbmltYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXREaXJlY3Rpb24odmFsLCBhbmltYXRpb24pe1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5zZXREaXJlY3Rpb24odmFsLCBhbmltYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwbGF5KGFuaW1hdGlvbil7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnBsYXkoYW5pbWF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobm93VGltZSkge1xyXG4gICAgICAgIHZhciBlbGFwc2VkVGltZSA9IG5vd1RpbWUgLSBpbml0VGltZTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24uYWR2YW5jZVRpbWUoZWxhcHNlZFRpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbml0VGltZSA9IG5vd1RpbWU7XHJcbiAgICAgICAgaWYocGxheWluZ0FuaW1hdGlvbnNOdW0gJiYgIV9pc0Zyb3plbikge1xyXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc3VtZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmaXJzdChub3dUaW1lKXtcclxuICAgICAgICBpbml0VGltZSA9IG5vd1RpbWU7XHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyZXN1bWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBhdXNlKGFuaW1hdGlvbikge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5wYXVzZShhbmltYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnb1RvQW5kU3RvcCh2YWx1ZSxpc0ZyYW1lLGFuaW1hdGlvbikge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5nb1RvQW5kU3RvcCh2YWx1ZSxpc0ZyYW1lLGFuaW1hdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN0b3AoYW5pbWF0aW9uKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnN0b3AoYW5pbWF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdG9nZ2xlUGF1c2UoYW5pbWF0aW9uKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnRvZ2dsZVBhdXNlKGFuaW1hdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koYW5pbWF0aW9uKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yKGk9KGxlbi0xKTtpPj0wO2ktPTEpe1xyXG4gICAgICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24uZGVzdHJveShhbmltYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZWFyY2hBbmltYXRpb25zKGFuaW1hdGlvbkRhdGEsIHN0YW5kYWxvbmUsIHJlbmRlcmVyKXtcclxuICAgICAgICB2YXIgYW5pbUVsZW1lbnRzID0gW10uY29uY2F0KFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbG90dGllJykpLFxyXG4gICAgICAgICAgICAgICAgICBbXS5zbGljZS5jYWxsKGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2JvZHltb3ZpbicpKSk7XHJcbiAgICAgICAgdmFyIGksIGxlbiA9IGFuaW1FbGVtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAgICAgaWYocmVuZGVyZXIpe1xyXG4gICAgICAgICAgICAgICAgYW5pbUVsZW1lbnRzW2ldLnNldEF0dHJpYnV0ZSgnZGF0YS1ibS10eXBlJyxyZW5kZXJlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVnaXN0ZXJBbmltYXRpb24oYW5pbUVsZW1lbnRzW2ldLCBhbmltYXRpb25EYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoc3RhbmRhbG9uZSAmJiBsZW4gPT09IDApe1xyXG4gICAgICAgICAgICBpZighcmVuZGVyZXIpe1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIgPSAnc3ZnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07XHJcbiAgICAgICAgICAgIGJvZHkuaW5uZXJIVE1MID0gJyc7XHJcbiAgICAgICAgICAgIHZhciBkaXYgPSBjcmVhdGVUYWcoJ2RpdicpO1xyXG4gICAgICAgICAgICBkaXYuc3R5bGUud2lkdGggPSAnMTAwJSc7XHJcbiAgICAgICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XHJcbiAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2RhdGEtYm0tdHlwZScscmVuZGVyZXIpO1xyXG4gICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKGRpdik7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyQW5pbWF0aW9uKGRpdiwgYW5pbWF0aW9uRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlc2l6ZSgpe1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5yZXNpemUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWN0aXZhdGUoKXtcclxuICAgICAgICBpZighX2lzRnJvemVuICYmIHBsYXlpbmdBbmltYXRpb25zTnVtKXtcclxuICAgICAgICAgICAgaWYoX3N0b3BwZWQpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZmlyc3QpO1xyXG4gICAgICAgICAgICAgICAgX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmcmVlemUoKSB7XHJcbiAgICAgICAgX2lzRnJvemVuID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB1bmZyZWV6ZSgpIHtcclxuICAgICAgICBfaXNGcm96ZW4gPSBmYWxzZTtcclxuICAgICAgICBhY3RpdmF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZU9iLnJlZ2lzdGVyQW5pbWF0aW9uID0gcmVnaXN0ZXJBbmltYXRpb247XHJcbiAgICBtb2R1bGVPYi5sb2FkQW5pbWF0aW9uID0gbG9hZEFuaW1hdGlvbjtcclxuICAgIG1vZHVsZU9iLnNldFNwZWVkID0gc2V0U3BlZWQ7XHJcbiAgICBtb2R1bGVPYi5zZXREaXJlY3Rpb24gPSBzZXREaXJlY3Rpb247XHJcbiAgICBtb2R1bGVPYi5wbGF5ID0gcGxheTtcclxuICAgIG1vZHVsZU9iLnBhdXNlID0gcGF1c2U7XHJcbiAgICBtb2R1bGVPYi5zdG9wID0gc3RvcDtcclxuICAgIG1vZHVsZU9iLnRvZ2dsZVBhdXNlID0gdG9nZ2xlUGF1c2U7XHJcbiAgICBtb2R1bGVPYi5zZWFyY2hBbmltYXRpb25zID0gc2VhcmNoQW5pbWF0aW9ucztcclxuICAgIG1vZHVsZU9iLnJlc2l6ZSA9IHJlc2l6ZTtcclxuICAgIC8vbW9kdWxlT2Iuc3RhcnQgPSBzdGFydDtcclxuICAgIG1vZHVsZU9iLmdvVG9BbmRTdG9wID0gZ29Ub0FuZFN0b3A7XHJcbiAgICBtb2R1bGVPYi5kZXN0cm95ID0gZGVzdHJveTtcclxuICAgIG1vZHVsZU9iLmZyZWV6ZSA9IGZyZWV6ZTtcclxuICAgIG1vZHVsZU9iLnVuZnJlZXplID0gdW5mcmVlemU7XHJcbiAgICBtb2R1bGVPYi5nZXRSZWdpc3RlcmVkQW5pbWF0aW9ucyA9IGdldFJlZ2lzdGVyZWRBbmltYXRpb25zO1xyXG4gICAgcmV0dXJuIG1vZHVsZU9iO1xyXG59KCkpO1xyXG5cbnZhciBBbmltYXRpb25JdGVtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5fY2JzID0gW107XHJcbiAgICB0aGlzLm5hbWUgPSAnJztcclxuICAgIHRoaXMucGF0aCA9ICcnO1xyXG4gICAgdGhpcy5pc0xvYWRlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xyXG4gICAgdGhpcy5jdXJyZW50UmF3RnJhbWUgPSAwO1xyXG4gICAgdGhpcy50b3RhbEZyYW1lcyA9IDA7XHJcbiAgICB0aGlzLmZyYW1lUmF0ZSA9IDA7XHJcbiAgICB0aGlzLmZyYW1lTXVsdCA9IDA7XHJcbiAgICB0aGlzLnBsYXlTcGVlZCA9IDE7XHJcbiAgICB0aGlzLnBsYXlEaXJlY3Rpb24gPSAxO1xyXG4gICAgdGhpcy5wbGF5Q291bnQgPSAwO1xyXG4gICAgdGhpcy5hbmltYXRpb25EYXRhID0ge307XHJcbiAgICB0aGlzLmFzc2V0cyA9IFtdO1xyXG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XHJcbiAgICB0aGlzLmF1dG9wbGF5ID0gZmFsc2U7XHJcbiAgICB0aGlzLmxvb3AgPSB0cnVlO1xyXG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XHJcbiAgICB0aGlzLmFuaW1hdGlvbklEID0gcmFuZG9tU3RyaW5nKDEwKTtcclxuICAgIHRoaXMuYXNzZXRzUGF0aCA9ICcnO1xyXG4gICAgdGhpcy50aW1lQ29tcGxldGVkID0gMDtcclxuICAgIHRoaXMuc2VnbWVudFBvcyA9IDA7XHJcbiAgICB0aGlzLnN1YmZyYW1lRW5hYmxlZCA9IHN1YmZyYW1lRW5hYmxlZDtcclxuICAgIHRoaXMuc2VnbWVudHMgPSBbXTtcclxuICAgIHRoaXMuX2lkbGUgPSB0cnVlO1xyXG4gICAgdGhpcy5fY29tcGxldGVkTG9vcCA9IGZhbHNlO1xyXG4gICAgdGhpcy5wcm9qZWN0SW50ZXJmYWNlID0gUHJvamVjdEludGVyZmFjZSgpO1xyXG4gICAgdGhpcy5pbWFnZVByZWxvYWRlciA9IG5ldyBJbWFnZVByZWxvYWRlcigpO1xyXG59O1xyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlRXZlbnRdLCBBbmltYXRpb25JdGVtKTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldFBhcmFtcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xyXG4gICAgaWYocGFyYW1zLmNvbnRleHQpe1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IHBhcmFtcy5jb250ZXh0O1xyXG4gICAgfVxyXG4gICAgaWYocGFyYW1zLndyYXBwZXIgfHwgcGFyYW1zLmNvbnRhaW5lcil7XHJcbiAgICAgICAgdGhpcy53cmFwcGVyID0gcGFyYW1zLndyYXBwZXIgfHwgcGFyYW1zLmNvbnRhaW5lcjtcclxuICAgIH1cclxuICAgIHZhciBhbmltVHlwZSA9IHBhcmFtcy5hbmltVHlwZSA/IHBhcmFtcy5hbmltVHlwZSA6IHBhcmFtcy5yZW5kZXJlciA/IHBhcmFtcy5yZW5kZXJlciA6ICdzdmcnO1xyXG4gICAgc3dpdGNoKGFuaW1UeXBlKXtcclxuICAgICAgICBjYXNlICdjYW52YXMnOlxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IENhbnZhc1JlbmRlcmVyKHRoaXMsIHBhcmFtcy5yZW5kZXJlclNldHRpbmdzKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnc3ZnJzpcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBTVkdSZW5kZXJlcih0aGlzLCBwYXJhbXMucmVuZGVyZXJTZXR0aW5ncyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgSHlicmlkUmVuZGVyZXIodGhpcywgcGFyYW1zLnJlbmRlcmVyU2V0dGluZ3MpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvamVjdEludGVyZmFjZSh0aGlzLnByb2plY3RJbnRlcmZhY2UpO1xyXG4gICAgdGhpcy5hbmltVHlwZSA9IGFuaW1UeXBlO1xyXG5cclxuICAgIGlmKHBhcmFtcy5sb29wID09PSAnJyB8fCBwYXJhbXMubG9vcCA9PT0gbnVsbCl7XHJcbiAgICB9ZWxzZSBpZihwYXJhbXMubG9vcCA9PT0gZmFsc2Upe1xyXG4gICAgICAgIHRoaXMubG9vcCA9IGZhbHNlO1xyXG4gICAgfWVsc2UgaWYocGFyYW1zLmxvb3AgPT09IHRydWUpe1xyXG4gICAgICAgIHRoaXMubG9vcCA9IHRydWU7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB0aGlzLmxvb3AgPSBwYXJzZUludChwYXJhbXMubG9vcCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmF1dG9wbGF5ID0gJ2F1dG9wbGF5JyBpbiBwYXJhbXMgPyBwYXJhbXMuYXV0b3BsYXkgOiB0cnVlO1xyXG4gICAgdGhpcy5uYW1lID0gcGFyYW1zLm5hbWUgPyBwYXJhbXMubmFtZSA6ICAnJztcclxuICAgIHRoaXMuYXV0b2xvYWRTZWdtZW50cyA9IHBhcmFtcy5oYXNPd25Qcm9wZXJ0eSgnYXV0b2xvYWRTZWdtZW50cycpID8gcGFyYW1zLmF1dG9sb2FkU2VnbWVudHMgOiAgdHJ1ZTtcclxuICAgIHRoaXMuYXNzZXRzUGF0aCA9IHBhcmFtcy5hc3NldHNQYXRoO1xyXG4gICAgaWYocGFyYW1zLmFuaW1hdGlvbkRhdGEpe1xyXG4gICAgICAgIHRoaXMuY29uZmlnQW5pbWF0aW9uKHBhcmFtcy5hbmltYXRpb25EYXRhKTtcclxuICAgIH1lbHNlIGlmKHBhcmFtcy5wYXRoKXtcclxuICAgICAgICBpZihwYXJhbXMucGF0aC5zdWJzdHIoLTQpICE9ICdqc29uJyl7XHJcbiAgICAgICAgICAgIGlmIChwYXJhbXMucGF0aC5zdWJzdHIoLTEsIDEpICE9ICcvJykge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zLnBhdGggKz0gJy8nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmFtcy5wYXRoICs9ICdkYXRhLmpzb24nO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYocGFyYW1zLnBhdGgubGFzdEluZGV4T2YoJ1xcXFwnKSAhPSAtMSl7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHBhcmFtcy5wYXRoLnN1YnN0cigwLHBhcmFtcy5wYXRoLmxhc3RJbmRleE9mKCdcXFxcJykrMSk7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHBhcmFtcy5wYXRoLnN1YnN0cigwLHBhcmFtcy5wYXRoLmxhc3RJbmRleE9mKCcvJykrMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBwYXJhbXMucGF0aC5zdWJzdHIocGFyYW1zLnBhdGgubGFzdEluZGV4T2YoJy8nKSsxKTtcclxuICAgICAgICB0aGlzLmZpbGVOYW1lID0gdGhpcy5maWxlTmFtZS5zdWJzdHIoMCx0aGlzLmZpbGVOYW1lLmxhc3RJbmRleE9mKCcuanNvbicpKTtcclxuXHJcbiAgICAgICAgYXNzZXRMb2FkZXIubG9hZChwYXJhbXMucGF0aCwgdGhpcy5jb25maWdBbmltYXRpb24uYmluZCh0aGlzKSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZGF0YV9mYWlsZWQnKTtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uICh3cmFwcGVyLCBhbmltYXRpb25EYXRhKSB7XHJcbiAgICB2YXIgcGFyYW1zID0ge1xyXG4gICAgICAgIHdyYXBwZXI6IHdyYXBwZXIsXHJcbiAgICAgICAgYW5pbWF0aW9uRGF0YTogYW5pbWF0aW9uRGF0YSA/ICh0eXBlb2YgYW5pbWF0aW9uRGF0YSAgPT09IFwib2JqZWN0XCIpID8gYW5pbWF0aW9uRGF0YSA6IEpTT04ucGFyc2UoYW5pbWF0aW9uRGF0YSkgOiBudWxsXHJcbiAgICB9O1xyXG4gICAgdmFyIHdyYXBwZXJBdHRyaWJ1dGVzID0gd3JhcHBlci5hdHRyaWJ1dGVzO1xyXG5cclxuICAgIHBhcmFtcy5wYXRoID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW1hdGlvbi1wYXRoJykgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbWF0aW9uLXBhdGgnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1wYXRoJykgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcGF0aCcpLnZhbHVlIDogIHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcGF0aCcpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1wYXRoJykudmFsdWUgOiAnJztcclxuICAgIHBhcmFtcy5hbmltVHlwZSA9IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLXR5cGUnKSA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLXR5cGUnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS10eXBlJykgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tdHlwZScpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS10eXBlJykgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXR5cGUnKS52YWx1ZSA6ICB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcmVuZGVyZXInKSA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1yZW5kZXJlcicpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1yZW5kZXJlcicpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1yZW5kZXJlcicpLnZhbHVlIDogJ2NhbnZhcyc7XHJcblxyXG4gICAgdmFyIGxvb3AgPSB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS1sb29wJykgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS1sb29wJykudmFsdWUgOiAgd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLWxvb3AnKSA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1sb29wJykudmFsdWUgOiAgd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1sb29wJykgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLWxvb3AnKS52YWx1ZSA6ICcnO1xyXG4gICAgaWYobG9vcCA9PT0gJycpe1xyXG4gICAgfWVsc2UgaWYobG9vcCA9PT0gJ2ZhbHNlJyl7XHJcbiAgICAgICAgcGFyYW1zLmxvb3AgPSBmYWxzZTtcclxuICAgIH1lbHNlIGlmKGxvb3AgPT09ICd0cnVlJyl7XHJcbiAgICAgICAgcGFyYW1zLmxvb3AgPSB0cnVlO1xyXG4gICAgfWVsc2V7XHJcbiAgICAgICAgcGFyYW1zLmxvb3AgPSBwYXJzZUludChsb29wKTtcclxuICAgIH1cclxuICAgIHZhciBhdXRvcGxheSA9IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLWF1dG9wbGF5JykgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS1hdXRvcGxheScpLnZhbHVlIDogIHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1hdXRvcGxheScpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLWF1dG9wbGF5JykudmFsdWUgOiAgd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1hdXRvcGxheScpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1hdXRvcGxheScpLnZhbHVlIDogdHJ1ZTtcclxuICAgIHBhcmFtcy5hdXRvcGxheSA9IGF1dG9wbGF5ICE9PSBcImZhbHNlXCI7XHJcblxyXG4gICAgcGFyYW1zLm5hbWUgPSB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtbmFtZScpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLW5hbWUnKS52YWx1ZSA6ICB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tbmFtZScpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLW5hbWUnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tbmFtZScpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1uYW1lJykudmFsdWUgOiAgJyc7XHJcbiAgICB2YXIgcHJlcmVuZGVyID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tcHJlcmVuZGVyJykgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS1wcmVyZW5kZXInKS52YWx1ZSA6ICB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcHJlcmVuZGVyJykgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcHJlcmVuZGVyJykudmFsdWUgOiAgd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1wcmVyZW5kZXInKSA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcHJlcmVuZGVyJykudmFsdWUgOiAnJztcclxuXHJcbiAgICBpZihwcmVyZW5kZXIgPT09ICdmYWxzZScpe1xyXG4gICAgICAgIHBhcmFtcy5wcmVyZW5kZXIgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHRoaXMuc2V0UGFyYW1zKHBhcmFtcyk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5pbmNsdWRlTGF5ZXJzID0gZnVuY3Rpb24oZGF0YSkge1xyXG4gICAgaWYoZGF0YS5vcCA+IHRoaXMuYW5pbWF0aW9uRGF0YS5vcCl7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25EYXRhLm9wID0gZGF0YS5vcDtcclxuICAgICAgICB0aGlzLnRvdGFsRnJhbWVzID0gTWF0aC5mbG9vcihkYXRhLm9wIC0gdGhpcy5hbmltYXRpb25EYXRhLmlwKTtcclxuICAgIH1cclxuICAgIHZhciBsYXllcnMgPSB0aGlzLmFuaW1hdGlvbkRhdGEubGF5ZXJzO1xyXG4gICAgdmFyIGksIGxlbiA9IGxheWVycy5sZW5ndGg7XHJcbiAgICB2YXIgbmV3TGF5ZXJzID0gZGF0YS5sYXllcnM7XHJcbiAgICB2YXIgaiwgakxlbiA9IG5ld0xheWVycy5sZW5ndGg7XHJcbiAgICBmb3Ioaj0wO2o8akxlbjtqKz0xKXtcclxuICAgICAgICBpID0gMDtcclxuICAgICAgICB3aGlsZShpPGxlbil7XHJcbiAgICAgICAgICAgIGlmKGxheWVyc1tpXS5pZCA9PSBuZXdMYXllcnNbal0uaWQpe1xyXG4gICAgICAgICAgICAgICAgbGF5ZXJzW2ldID0gbmV3TGF5ZXJzW2pdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmKGRhdGEuY2hhcnMgfHwgZGF0YS5mb250cyl7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmFkZENoYXJzKGRhdGEuY2hhcnMpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5hZGRGb250cyhkYXRhLmZvbnRzLCB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZGVmcyk7XHJcbiAgICB9XHJcbiAgICBpZihkYXRhLmFzc2V0cyl7XHJcbiAgICAgICAgbGVuID0gZGF0YS5hc3NldHMubGVuZ3RoO1xyXG4gICAgICAgIGZvcihpID0gMDsgaSA8IGxlbjsgaSArPSAxKXtcclxuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25EYXRhLmFzc2V0cy5wdXNoKGRhdGEuYXNzZXRzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmFuaW1hdGlvbkRhdGEuX19jb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgZGF0YU1hbmFnZXIuY29tcGxldGVEYXRhKHRoaXMuYW5pbWF0aW9uRGF0YSx0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIpO1xyXG4gICAgdGhpcy5yZW5kZXJlci5pbmNsdWRlTGF5ZXJzKGRhdGEubGF5ZXJzKTtcclxuICAgIGlmKGV4cHJlc3Npb25zUGx1Z2luKXtcclxuICAgICAgICBleHByZXNzaW9uc1BsdWdpbi5pbml0RXhwcmVzc2lvbnModGhpcyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmxvYWROZXh0U2VnbWVudCgpO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUubG9hZE5leHRTZWdtZW50ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc2VnbWVudHMgPSB0aGlzLmFuaW1hdGlvbkRhdGEuc2VnbWVudHM7XHJcbiAgICBpZighc2VnbWVudHMgfHwgc2VnbWVudHMubGVuZ3RoID09PSAwIHx8ICF0aGlzLmF1dG9sb2FkU2VnbWVudHMpe1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignZGF0YV9yZWFkeScpO1xyXG4gICAgICAgIHRoaXMudGltZUNvbXBsZXRlZCA9IHRoaXMudG90YWxGcmFtZXM7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50cy5zaGlmdCgpO1xyXG4gICAgdGhpcy50aW1lQ29tcGxldGVkID0gc2VnbWVudC50aW1lICogdGhpcy5mcmFtZVJhdGU7XHJcbiAgICB2YXIgc2VnbWVudFBhdGggPSB0aGlzLnBhdGgrdGhpcy5maWxlTmFtZSsnXycgKyB0aGlzLnNlZ21lbnRQb3MgKyAnLmpzb24nO1xyXG4gICAgdGhpcy5zZWdtZW50UG9zICs9IDE7XHJcbiAgICBhc3NldExvYWRlci5sb2FkKHNlZ21lbnRQYXRoLCB0aGlzLmluY2x1ZGVMYXllcnMuYmluZCh0aGlzKSwgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhX2ZhaWxlZCcpO1xyXG4gICAgfS5iaW5kKHRoaXMpKTtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmxvYWRTZWdtZW50cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHNlZ21lbnRzID0gdGhpcy5hbmltYXRpb25EYXRhLnNlZ21lbnRzO1xyXG4gICAgaWYoIXNlZ21lbnRzKSB7XHJcbiAgICAgICAgdGhpcy50aW1lQ29tcGxldGVkID0gdGhpcy50b3RhbEZyYW1lcztcclxuICAgIH1cclxuICAgIHRoaXMubG9hZE5leHRTZWdtZW50KCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5pbWFnZXNMb2FkZWQgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMudHJpZ2dlcignbG9hZGVkX2ltYWdlcycpO1xyXG4gICAgdGhpcy5jaGVja0xvYWRlZCgpXHJcbn1cclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnByZWxvYWRJbWFnZXMgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuaW1hZ2VQcmVsb2FkZXIuc2V0QXNzZXRzUGF0aCh0aGlzLmFzc2V0c1BhdGgpO1xyXG4gICAgdGhpcy5pbWFnZVByZWxvYWRlci5zZXRQYXRoKHRoaXMucGF0aCk7XHJcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyLmxvYWRBc3NldHModGhpcy5hbmltYXRpb25EYXRhLmFzc2V0cywgdGhpcy5pbWFnZXNMb2FkZWQuYmluZCh0aGlzKSk7XHJcbn1cclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmNvbmZpZ0FuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltRGF0YSkge1xyXG4gICAgaWYoIXRoaXMucmVuZGVyZXIpe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuYW5pbWF0aW9uRGF0YSA9IGFuaW1EYXRhO1xyXG4gICAgdGhpcy50b3RhbEZyYW1lcyA9IE1hdGguZmxvb3IodGhpcy5hbmltYXRpb25EYXRhLm9wIC0gdGhpcy5hbmltYXRpb25EYXRhLmlwKTtcclxuICAgIHRoaXMucmVuZGVyZXIuY29uZmlnQW5pbWF0aW9uKGFuaW1EYXRhKTtcclxuICAgIGlmKCFhbmltRGF0YS5hc3NldHMpe1xyXG4gICAgICAgIGFuaW1EYXRhLmFzc2V0cyA9IFtdO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZW5kZXJlci5zZWFyY2hFeHRyYUNvbXBvc2l0aW9ucyhhbmltRGF0YS5hc3NldHMpO1xyXG5cclxuICAgIHRoaXMuYXNzZXRzID0gdGhpcy5hbmltYXRpb25EYXRhLmFzc2V0cztcclxuICAgIHRoaXMuZnJhbWVSYXRlID0gdGhpcy5hbmltYXRpb25EYXRhLmZyO1xyXG4gICAgdGhpcy5maXJzdEZyYW1lID0gTWF0aC5yb3VuZCh0aGlzLmFuaW1hdGlvbkRhdGEuaXApO1xyXG4gICAgdGhpcy5mcmFtZU11bHQgPSB0aGlzLmFuaW1hdGlvbkRhdGEuZnIgLyAxMDAwO1xyXG4gICAgdGhpcy50cmlnZ2VyKCdjb25maWdfcmVhZHknKTtcclxuICAgIHRoaXMucHJlbG9hZEltYWdlcygpO1xyXG4gICAgdGhpcy5sb2FkU2VnbWVudHMoKTtcclxuICAgIHRoaXMudXBkYUZyYW1lTW9kaWZpZXIoKTtcclxuICAgIHRoaXMud2FpdEZvckZvbnRzTG9hZGVkKCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS53YWl0Rm9yRm9udHNMb2FkZWQgPSBmdW5jdGlvbigpe1xyXG4gICAgaWYoIXRoaXMucmVuZGVyZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZih0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIubG9hZGVkKCkpe1xyXG4gICAgICAgIHRoaXMuY2hlY2tMb2FkZWQoKTtcclxuICAgIH1lbHNle1xyXG4gICAgICAgIHNldFRpbWVvdXQodGhpcy53YWl0Rm9yRm9udHNMb2FkZWQuYmluZCh0aGlzKSwyMCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmNoZWNrTG9hZGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCF0aGlzLmlzTG9hZGVkICYmIHRoaXMucmVuZGVyZXIuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5sb2FkZWQoKSAmJiAodGhpcy5pbWFnZVByZWxvYWRlci5sb2FkZWQoKSB8fCB0aGlzLnJlbmRlcmVyLnJlbmRlcmVyVHlwZSAhPT0gJ2NhbnZhcycpKSB7XHJcbiAgICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgZGF0YU1hbmFnZXIuY29tcGxldGVEYXRhKHRoaXMuYW5pbWF0aW9uRGF0YSwgdGhpcy5yZW5kZXJlci5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyKTtcclxuICAgICAgICBpZihleHByZXNzaW9uc1BsdWdpbil7XHJcbiAgICAgICAgICAgIGV4cHJlc3Npb25zUGx1Z2luLmluaXRFeHByZXNzaW9ucyh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5pbml0SXRlbXMoKTtcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ0RPTUxvYWRlZCcpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSwgMCk7XHJcbiAgICAgICAgdGhpcy5nb3RvRnJhbWUoKTtcclxuICAgICAgICBpZih0aGlzLmF1dG9wbGF5KXtcclxuICAgICAgICAgICAgdGhpcy5wbGF5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5yZW5kZXJlci51cGRhdGVDb250YWluZXJTaXplKCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRTdWJmcmFtZSA9IGZ1bmN0aW9uKGZsYWcpe1xyXG4gICAgdGhpcy5zdWJmcmFtZUVuYWJsZWQgPSBmbGFnID8gdHJ1ZSA6IGZhbHNlO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ290b0ZyYW1lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSB0aGlzLnN1YmZyYW1lRW5hYmxlZCA/IHRoaXMuY3VycmVudFJhd0ZyYW1lIDogfn50aGlzLmN1cnJlbnRSYXdGcmFtZTtcclxuXHJcbiAgICBpZih0aGlzLnRpbWVDb21wbGV0ZWQgIT09IHRoaXMudG90YWxGcmFtZXMgJiYgdGhpcy5jdXJyZW50RnJhbWUgPiB0aGlzLnRpbWVDb21wbGV0ZWQpe1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gdGhpcy50aW1lQ29tcGxldGVkO1xyXG4gICAgfVxyXG4gICAgdGhpcy50cmlnZ2VyKCdlbnRlckZyYW1lJyk7XHJcbiAgICB0aGlzLnJlbmRlckZyYW1lKCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmKHRoaXMuaXNMb2FkZWQgPT09IGZhbHNlKXtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLnJlbmRlcmVyLnJlbmRlckZyYW1lKHRoaXMuY3VycmVudEZyYW1lICsgdGhpcy5maXJzdEZyYW1lKTtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgaWYobmFtZSAmJiB0aGlzLm5hbWUgIT0gbmFtZSl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYodGhpcy5pc1BhdXNlZCA9PT0gdHJ1ZSl7XHJcbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmKHRoaXMuX2lkbGUpe1xyXG4gICAgICAgICAgICB0aGlzLl9pZGxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignX2FjdGl2ZScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgIGlmKG5hbWUgJiYgdGhpcy5uYW1lICE9IG5hbWUpe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmKHRoaXMuaXNQYXVzZWQgPT09IGZhbHNlKXtcclxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9pZGxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ19pZGxlJyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS50b2dnbGVQYXVzZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICBpZihuYW1lICYmIHRoaXMubmFtZSAhPSBuYW1lKXtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZih0aGlzLmlzUGF1c2VkID09PSB0cnVlKXtcclxuICAgICAgICB0aGlzLnBsYXkoKTtcclxuICAgIH1lbHNle1xyXG4gICAgICAgIHRoaXMucGF1c2UoKTtcclxuICAgIH1cclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgaWYobmFtZSAmJiB0aGlzLm5hbWUgIT0gbmFtZSl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5wYXVzZSgpO1xyXG4gICAgdGhpcy5wbGF5Q291bnQgPSAwO1xyXG4gICAgdGhpcy5fY29tcGxldGVkTG9vcCA9IGZhbHNlO1xyXG4gICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZSgwKTtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdvVG9BbmRTdG9wID0gZnVuY3Rpb24gKHZhbHVlLCBpc0ZyYW1lLCBuYW1lKSB7XHJcbiAgICBpZihuYW1lICYmIHRoaXMubmFtZSAhPSBuYW1lKXtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZihpc0ZyYW1lKXtcclxuICAgICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKHZhbHVlKTtcclxuICAgIH1lbHNle1xyXG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUodmFsdWUgKiB0aGlzLmZyYW1lTW9kaWZpZXIpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5wYXVzZSgpO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ29Ub0FuZFBsYXkgPSBmdW5jdGlvbiAodmFsdWUsIGlzRnJhbWUsIG5hbWUpIHtcclxuICAgIHRoaXMuZ29Ub0FuZFN0b3AodmFsdWUsIGlzRnJhbWUsIG5hbWUpO1xyXG4gICAgdGhpcy5wbGF5KCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5hZHZhbmNlVGltZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgaWYgKHRoaXMuaXNQYXVzZWQgPT09IHRydWUgfHwgdGhpcy5pc0xvYWRlZCA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgbmV4dFZhbHVlID0gdGhpcy5jdXJyZW50UmF3RnJhbWUgKyB2YWx1ZSAqIHRoaXMuZnJhbWVNb2RpZmllcjtcclxuICAgIHZhciBfaXNDb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgLy8gQ2hlY2tpbmcgaWYgbmV4dFZhbHVlID4gdG90YWxGcmFtZXMgLSAxIGZvciBhZGRyZXNzaW5nIG5vbiBsb29waW5nIGFuZCBsb29waW5nIGFuaW1hdGlvbnMuXHJcbiAgICAvLyBJZiBhbmltYXRpb24gd29uJ3QgbG9vcCwgaXQgc2hvdWxkIHN0b3AgYXQgdG90YWxGcmFtZXMgLSAxLiBJZiBpdCB3aWxsIGxvb3AgaXQgc2hvdWxkIGNvbXBsZXRlIHRoZSBsYXN0IGZyYW1lIGFuZCB0aGVuIGxvb3AuXHJcbiAgICBpZiAobmV4dFZhbHVlID49IHRoaXMudG90YWxGcmFtZXMgLSAxICYmIHRoaXMuZnJhbWVNb2RpZmllciA+IDApIHtcclxuICAgICAgICBpZiAoIXRoaXMubG9vcCB8fCB0aGlzLnBsYXlDb3VudCA9PT0gdGhpcy5sb29wKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1NlZ21lbnRzKG5leHRWYWx1ZSA+ICB0aGlzLnRvdGFsRnJhbWVzID8gbmV4dFZhbHVlICUgdGhpcy50b3RhbEZyYW1lcyA6IDApKSB7XHJcbiAgICAgICAgICAgICAgICBfaXNDb21wbGV0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBuZXh0VmFsdWUgPSB0aGlzLnRvdGFsRnJhbWVzIC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAobmV4dFZhbHVlID49IHRoaXMudG90YWxGcmFtZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5wbGF5Q291bnQgKz0gMTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU2VnbWVudHMobmV4dFZhbHVlICUgdGhpcy50b3RhbEZyYW1lcykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUobmV4dFZhbHVlICUgdGhpcy50b3RhbEZyYW1lcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRMb29wID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbG9vcENvbXBsZXRlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKG5leHRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIGlmKG5leHRWYWx1ZSA8IDApIHtcclxuICAgICAgICBpZiAoIXRoaXMuY2hlY2tTZWdtZW50cyhuZXh0VmFsdWUgJSB0aGlzLnRvdGFsRnJhbWVzKSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sb29wICYmICEodGhpcy5wbGF5Q291bnQtLSA8PSAwICYmIHRoaXMubG9vcCAhPT0gdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUodGhpcy50b3RhbEZyYW1lcyArIChuZXh0VmFsdWUgJSB0aGlzLnRvdGFsRnJhbWVzKSk7XHJcbiAgICAgICAgICAgICAgICBpZighdGhpcy5fY29tcGxldGVkTG9vcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlZExvb3AgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2xvb3BDb21wbGV0ZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgX2lzQ29tcGxldGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgbmV4dFZhbHVlID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZShuZXh0VmFsdWUpO1xyXG4gICAgfVxyXG4gICAgaWYgKF9pc0NvbXBsZXRlKSB7XHJcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZShuZXh0VmFsdWUpO1xyXG4gICAgICAgIHRoaXMucGF1c2UoKTtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NvbXBsZXRlJyk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5hZGp1c3RTZWdtZW50ID0gZnVuY3Rpb24oYXJyLCBvZmZzZXQpe1xyXG4gICAgdGhpcy5wbGF5Q291bnQgPSAwO1xyXG4gICAgaWYoYXJyWzFdIDwgYXJyWzBdKXtcclxuICAgICAgICBpZih0aGlzLmZyYW1lTW9kaWZpZXIgPiAwKXtcclxuICAgICAgICAgICAgaWYodGhpcy5wbGF5U3BlZWQgPCAwKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3BlZWQoLXRoaXMucGxheVNwZWVkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RGlyZWN0aW9uKC0xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRpbWVDb21wbGV0ZWQgPSB0aGlzLnRvdGFsRnJhbWVzID0gYXJyWzBdIC0gYXJyWzFdO1xyXG4gICAgICAgIHRoaXMuZmlyc3RGcmFtZSA9IGFyclsxXTtcclxuICAgICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKHRoaXMudG90YWxGcmFtZXMgLSAwLjAwMSAtIG9mZnNldCk7XHJcbiAgICB9IGVsc2UgaWYoYXJyWzFdID4gYXJyWzBdKXtcclxuICAgICAgICBpZih0aGlzLmZyYW1lTW9kaWZpZXIgPCAwKXtcclxuICAgICAgICAgICAgaWYodGhpcy5wbGF5U3BlZWQgPCAwKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3BlZWQoLXRoaXMucGxheVNwZWVkKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RGlyZWN0aW9uKDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGltZUNvbXBsZXRlZCA9IHRoaXMudG90YWxGcmFtZXMgPSBhcnJbMV0gLSBhcnJbMF07XHJcbiAgICAgICAgdGhpcy5maXJzdEZyYW1lID0gYXJyWzBdO1xyXG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUoMC4wMDEgKyBvZmZzZXQpO1xyXG4gICAgfVxyXG4gICAgdGhpcy50cmlnZ2VyKCdzZWdtZW50U3RhcnQnKTtcclxufTtcclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0U2VnbWVudCA9IGZ1bmN0aW9uIChpbml0LGVuZCkge1xyXG4gICAgdmFyIHBlbmRpbmdGcmFtZSA9IC0xO1xyXG4gICAgaWYodGhpcy5pc1BhdXNlZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRSYXdGcmFtZSArIHRoaXMuZmlyc3RGcmFtZSA8IGluaXQpIHtcclxuICAgICAgICAgICAgcGVuZGluZ0ZyYW1lID0gaW5pdDtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFJhd0ZyYW1lICsgdGhpcy5maXJzdEZyYW1lID4gZW5kKSB7XHJcbiAgICAgICAgICAgIHBlbmRpbmdGcmFtZSA9IGVuZCAtIGluaXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZmlyc3RGcmFtZSA9IGluaXQ7XHJcbiAgICB0aGlzLnRpbWVDb21wbGV0ZWQgPSB0aGlzLnRvdGFsRnJhbWVzID0gZW5kIC0gaW5pdDtcclxuICAgIGlmKHBlbmRpbmdGcmFtZSAhPT0gLTEpIHtcclxuICAgICAgICB0aGlzLmdvVG9BbmRTdG9wKHBlbmRpbmdGcmFtZSx0cnVlKTtcclxuICAgIH1cclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnBsYXlTZWdtZW50cyA9IGZ1bmN0aW9uIChhcnIsIGZvcmNlRmxhZykge1xyXG4gICAgaWYgKGZvcmNlRmxhZykge1xyXG4gICAgICAgIHRoaXMuc2VnbWVudHMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgYXJyWzBdID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHZhciBpLCBsZW4gPSBhcnIubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlZ21lbnRzLnB1c2goYXJyW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuc2VnbWVudHMucHVzaChhcnIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuc2VnbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5hZGp1c3RTZWdtZW50KHRoaXMuc2VnbWVudHMuc2hpZnQoKSwgMCk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5pc1BhdXNlZCkge1xyXG4gICAgICAgIHRoaXMucGxheSgpO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucmVzZXRTZWdtZW50cyA9IGZ1bmN0aW9uIChmb3JjZUZsYWcpIHtcclxuICAgIHRoaXMuc2VnbWVudHMubGVuZ3RoID0gMDtcclxuICAgIHRoaXMuc2VnbWVudHMucHVzaChbdGhpcy5hbmltYXRpb25EYXRhLmlwLHRoaXMuYW5pbWF0aW9uRGF0YS5vcF0pO1xyXG4gICAgLy90aGlzLnNlZ21lbnRzLnB1c2goW3RoaXMuYW5pbWF0aW9uRGF0YS5pcCp0aGlzLmZyYW1lUmF0ZSxNYXRoLmZsb29yKHRoaXMuYW5pbWF0aW9uRGF0YS5vcCAtIHRoaXMuYW5pbWF0aW9uRGF0YS5pcCt0aGlzLmFuaW1hdGlvbkRhdGEuaXAqdGhpcy5mcmFtZVJhdGUpXSk7XHJcbiAgICBpZiAoZm9yY2VGbGFnKSB7XHJcbiAgICAgICAgdGhpcy5jaGVja1NlZ21lbnRzKDApO1xyXG4gICAgfVxyXG59O1xyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5jaGVja1NlZ21lbnRzID0gZnVuY3Rpb24ob2Zmc2V0KSB7XHJcbiAgICBpZiAodGhpcy5zZWdtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICB0aGlzLmFkanVzdFNlZ21lbnQodGhpcy5zZWdtZW50cy5zaGlmdCgpLCBvZmZzZXQpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICBpZiAoKG5hbWUgJiYgdGhpcy5uYW1lICE9IG5hbWUpIHx8ICF0aGlzLnJlbmRlcmVyKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZW5kZXJlci5kZXN0cm95KCk7XHJcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyLmRlc3Ryb3koKTtcclxuICAgIHRoaXMudHJpZ2dlcignZGVzdHJveScpO1xyXG4gICAgdGhpcy5fY2JzID0gbnVsbDtcclxuICAgIHRoaXMub25FbnRlckZyYW1lID0gdGhpcy5vbkxvb3BDb21wbGV0ZSA9IHRoaXMub25Db21wbGV0ZSA9IHRoaXMub25TZWdtZW50U3RhcnQgPSB0aGlzLm9uRGVzdHJveSA9IG51bGw7XHJcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlID0gZnVuY3Rpb24odmFsdWUpe1xyXG4gICAgdGhpcy5jdXJyZW50UmF3RnJhbWUgPSB2YWx1ZTtcclxuICAgIHRoaXMuZ290b0ZyYW1lKCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRTcGVlZCA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgIHRoaXMucGxheVNwZWVkID0gdmFsO1xyXG4gICAgdGhpcy51cGRhRnJhbWVNb2RpZmllcigpO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgdGhpcy5wbGF5RGlyZWN0aW9uID0gdmFsIDwgMCA/IC0xIDogMTtcclxuICAgIHRoaXMudXBkYUZyYW1lTW9kaWZpZXIoKTtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnVwZGFGcmFtZU1vZGlmaWVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5mcmFtZU1vZGlmaWVyID0gdGhpcy5mcmFtZU11bHQgKiB0aGlzLnBsYXlTcGVlZCAqIHRoaXMucGxheURpcmVjdGlvbjtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wYXRoO1xyXG59O1xyXG5cclxuQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0QXNzZXRzUGF0aCA9IGZ1bmN0aW9uIChhc3NldERhdGEpIHtcclxuICAgIHZhciBwYXRoID0gJyc7XHJcbiAgICBpZihhc3NldERhdGEuZSkge1xyXG4gICAgICAgIHBhdGggPSBhc3NldERhdGEucDtcclxuICAgIH0gZWxzZSBpZih0aGlzLmFzc2V0c1BhdGgpe1xyXG4gICAgICAgIHZhciBpbWFnZVBhdGggPSBhc3NldERhdGEucDtcclxuICAgICAgICBpZihpbWFnZVBhdGguaW5kZXhPZignaW1hZ2VzLycpICE9PSAtMSl7XHJcbiAgICAgICAgICAgIGltYWdlUGF0aCA9IGltYWdlUGF0aC5zcGxpdCgnLycpWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXRoID0gdGhpcy5hc3NldHNQYXRoICsgaW1hZ2VQYXRoO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBwYXRoID0gdGhpcy5wYXRoO1xyXG4gICAgICAgIHBhdGggKz0gYXNzZXREYXRhLnUgPyBhc3NldERhdGEudSA6ICcnO1xyXG4gICAgICAgIHBhdGggKz0gYXNzZXREYXRhLnA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGF0aDtcclxufTtcclxuXHJcbkFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdldEFzc2V0RGF0YSA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgdmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFzc2V0cy5sZW5ndGg7XHJcbiAgICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgICAgIGlmKGlkID09IHRoaXMuYXNzZXRzW2ldLmlkKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXRzW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpICs9IDE7XHJcbiAgICB9XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5yZW5kZXJlci5oaWRlKCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5yZW5kZXJlci5zaG93KCk7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS5nZXREdXJhdGlvbiA9IGZ1bmN0aW9uIChpc0ZyYW1lKSB7XHJcbiAgICByZXR1cm4gaXNGcmFtZSA/IHRoaXMudG90YWxGcmFtZXMgOiB0aGlzLnRvdGFsRnJhbWVzIC8gdGhpcy5mcmFtZVJhdGU7XHJcbn07XHJcblxyXG5BbmltYXRpb25JdGVtLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICBpZih0aGlzLl9jYnMgJiYgdGhpcy5fY2JzW25hbWVdKXtcclxuICAgICAgICBzd2l0Y2gobmFtZSl7XHJcbiAgICAgICAgICAgIGNhc2UgJ2VudGVyRnJhbWUnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmFtZSxuZXcgQk1FbnRlckZyYW1lRXZlbnQobmFtZSx0aGlzLmN1cnJlbnRGcmFtZSx0aGlzLnRvdGFsRnJhbWVzLHRoaXMuZnJhbWVNdWx0KSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnbG9vcENvbXBsZXRlJzpcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsbmV3IEJNQ29tcGxldGVMb29wRXZlbnQobmFtZSx0aGlzLmxvb3AsdGhpcy5wbGF5Q291bnQsdGhpcy5mcmFtZU11bHQpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdjb21wbGV0ZSc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuYW1lLG5ldyBCTUNvbXBsZXRlRXZlbnQobmFtZSx0aGlzLmZyYW1lTXVsdCkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3NlZ21lbnRTdGFydCc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuYW1lLG5ldyBCTVNlZ21lbnRTdGFydEV2ZW50KG5hbWUsdGhpcy5maXJzdEZyYW1lLHRoaXMudG90YWxGcmFtZXMpKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdkZXN0cm95JzpcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsbmV3IEJNRGVzdHJveUV2ZW50KG5hbWUsdGhpcykpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZihuYW1lID09PSAnZW50ZXJGcmFtZScgJiYgdGhpcy5vbkVudGVyRnJhbWUpe1xyXG4gICAgICAgIHRoaXMub25FbnRlckZyYW1lLmNhbGwodGhpcyxuZXcgQk1FbnRlckZyYW1lRXZlbnQobmFtZSx0aGlzLmN1cnJlbnRGcmFtZSx0aGlzLnRvdGFsRnJhbWVzLHRoaXMuZnJhbWVNdWx0KSk7XHJcbiAgICB9XHJcbiAgICBpZihuYW1lID09PSAnbG9vcENvbXBsZXRlJyAmJiB0aGlzLm9uTG9vcENvbXBsZXRlKXtcclxuICAgICAgICB0aGlzLm9uTG9vcENvbXBsZXRlLmNhbGwodGhpcyxuZXcgQk1Db21wbGV0ZUxvb3BFdmVudChuYW1lLHRoaXMubG9vcCx0aGlzLnBsYXlDb3VudCx0aGlzLmZyYW1lTXVsdCkpO1xyXG4gICAgfVxyXG4gICAgaWYobmFtZSA9PT0gJ2NvbXBsZXRlJyAmJiB0aGlzLm9uQ29tcGxldGUpe1xyXG4gICAgICAgIHRoaXMub25Db21wbGV0ZS5jYWxsKHRoaXMsbmV3IEJNQ29tcGxldGVFdmVudChuYW1lLHRoaXMuZnJhbWVNdWx0KSk7XHJcbiAgICB9XHJcbiAgICBpZihuYW1lID09PSAnc2VnbWVudFN0YXJ0JyAmJiB0aGlzLm9uU2VnbWVudFN0YXJ0KXtcclxuICAgICAgICB0aGlzLm9uU2VnbWVudFN0YXJ0LmNhbGwodGhpcyxuZXcgQk1TZWdtZW50U3RhcnRFdmVudChuYW1lLHRoaXMuZmlyc3RGcmFtZSx0aGlzLnRvdGFsRnJhbWVzKSk7XHJcbiAgICB9XHJcbiAgICBpZihuYW1lID09PSAnZGVzdHJveScgJiYgdGhpcy5vbkRlc3Ryb3kpe1xyXG4gICAgICAgIHRoaXMub25EZXN0cm95LmNhbGwodGhpcyxuZXcgQk1EZXN0cm95RXZlbnQobmFtZSx0aGlzKSk7XHJcbiAgICB9XHJcbn07XHJcblxuZnVuY3Rpb24gRWZmZWN0c01hbmFnZXIoKXt9XG5mdW5jdGlvbiBDYW52YXNSZW5kZXJlcihhbmltYXRpb25JdGVtLCBjb25maWcpe1xyXG4gICAgdGhpcy5hbmltYXRpb25JdGVtID0gYW5pbWF0aW9uSXRlbTtcclxuICAgIHRoaXMucmVuZGVyQ29uZmlnID0ge1xyXG4gICAgICAgIGNsZWFyQ2FudmFzOiAoY29uZmlnICYmIGNvbmZpZy5jbGVhckNhbnZhcyAhPT0gdW5kZWZpbmVkKSA/IGNvbmZpZy5jbGVhckNhbnZhcyA6IHRydWUsXHJcbiAgICAgICAgY29udGV4dDogKGNvbmZpZyAmJiBjb25maWcuY29udGV4dCkgfHwgbnVsbCxcclxuICAgICAgICBwcm9ncmVzc2l2ZUxvYWQ6IChjb25maWcgJiYgY29uZmlnLnByb2dyZXNzaXZlTG9hZCkgfHwgZmFsc2UsXHJcbiAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogKGNvbmZpZyAmJiBjb25maWcucHJlc2VydmVBc3BlY3RSYXRpbykgfHwgJ3hNaWRZTWlkIG1lZXQnLFxyXG4gICAgICAgIGltYWdlUHJlc2VydmVBc3BlY3RSYXRpbzogKGNvbmZpZyAmJiBjb25maWcuaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvKSB8fCAneE1pZFlNaWQgc2xpY2UnLFxyXG4gICAgICAgIGNsYXNzTmFtZTogKGNvbmZpZyAmJiBjb25maWcuY2xhc3NOYW1lKSB8fCAnJ1xyXG4gICAgfTtcclxuICAgIHRoaXMucmVuZGVyQ29uZmlnLmRwciA9IChjb25maWcgJiYgY29uZmlnLmRwcikgfHwgMTtcclxuICAgIGlmICh0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlcikge1xyXG4gICAgICAgIHRoaXMucmVuZGVyQ29uZmlnLmRwciA9IChjb25maWcgJiYgY29uZmlnLmRwcikgfHwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcclxuICAgIH1cclxuICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IC0xO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhID0ge1xyXG4gICAgICAgIGZyYW1lTnVtOiAtMSxcclxuICAgICAgICBfbWRmOiBmYWxzZSxcclxuICAgICAgICByZW5kZXJDb25maWc6IHRoaXMucmVuZGVyQ29uZmlnLFxyXG4gICAgICAgIGN1cnJlbnRHbG9iYWxBbHBoYTogLTFcclxuICAgIH07XHJcbiAgICB0aGlzLmNvbnRleHREYXRhID0gbmV3IENWQ29udGV4dERhdGEoKTtcclxuICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcclxuICAgIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XHJcbiAgICB0aGlzLnRyYW5zZm9ybU1hdCA9IG5ldyBNYXRyaXgoKTtcclxuICAgIHRoaXMuY29tcGxldGVMYXllcnMgPSBmYWxzZTtcclxuICAgIHRoaXMucmVuZGVyZXJUeXBlID0gJ2NhbnZhcyc7XHJcbn1cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlUmVuZGVyZXJdLENhbnZhc1JlbmRlcmVyKTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVTaGFwZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICByZXR1cm4gbmV3IENWU2hhcGVFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICByZXR1cm4gbmV3IENWVGV4dEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVJbWFnZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICByZXR1cm4gbmV3IENWSW1hZ2VFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ29tcCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICByZXR1cm4gbmV3IENWQ29tcEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVTb2xpZCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICByZXR1cm4gbmV3IENWU29saWRFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlTnVsbCA9IFNWR1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVOdWxsO1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmN0eFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHByb3BzKXtcclxuICAgIGlmKHByb3BzWzBdID09PSAxICYmIHByb3BzWzFdID09PSAwICYmIHByb3BzWzRdID09PSAwICYmIHByb3BzWzVdID09PSAxICYmIHByb3BzWzEyXSA9PT0gMCAmJiBwcm9wc1sxM10gPT09IDApe1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmKCF0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcyl7XHJcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnRyYW5zZm9ybShwcm9wc1swXSxwcm9wc1sxXSxwcm9wc1s0XSxwcm9wc1s1XSxwcm9wc1sxMl0scHJvcHNbMTNdKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLnRyYW5zZm9ybU1hdC5jbG9uZUZyb21Qcm9wcyhwcm9wcyk7XHJcbiAgICB2YXIgY1Byb3BzID0gdGhpcy5jb250ZXh0RGF0YS5jVHIucHJvcHM7XHJcbiAgICB0aGlzLnRyYW5zZm9ybU1hdC50cmFuc2Zvcm0oY1Byb3BzWzBdLGNQcm9wc1sxXSxjUHJvcHNbMl0sY1Byb3BzWzNdLGNQcm9wc1s0XSxjUHJvcHNbNV0sY1Byb3BzWzZdLGNQcm9wc1s3XSxjUHJvcHNbOF0sY1Byb3BzWzldLGNQcm9wc1sxMF0sY1Byb3BzWzExXSxjUHJvcHNbMTJdLGNQcm9wc1sxM10sY1Byb3BzWzE0XSxjUHJvcHNbMTVdKTtcclxuICAgIC8vdGhpcy5jb250ZXh0RGF0YS5jVHIudHJhbnNmb3JtKHByb3BzWzBdLHByb3BzWzFdLHByb3BzWzJdLHByb3BzWzNdLHByb3BzWzRdLHByb3BzWzVdLHByb3BzWzZdLHByb3BzWzddLHByb3BzWzhdLHByb3BzWzldLHByb3BzWzEwXSxwcm9wc1sxMV0scHJvcHNbMTJdLHByb3BzWzEzXSxwcm9wc1sxNF0scHJvcHNbMTVdKTtcclxuICAgIHRoaXMuY29udGV4dERhdGEuY1RyLmNsb25lRnJvbVByb3BzKHRoaXMudHJhbnNmb3JtTWF0LnByb3BzKTtcclxuICAgIHZhciB0clByb3BzID0gdGhpcy5jb250ZXh0RGF0YS5jVHIucHJvcHM7XHJcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuc2V0VHJhbnNmb3JtKHRyUHJvcHNbMF0sdHJQcm9wc1sxXSx0clByb3BzWzRdLHRyUHJvcHNbNV0sdHJQcm9wc1sxMl0sdHJQcm9wc1sxM10pO1xyXG59O1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmN0eE9wYWNpdHkgPSBmdW5jdGlvbihvcCl7XHJcbiAgICAvKmlmKG9wID09PSAxKXtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9Ki9cclxuICAgIGlmKCF0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcyl7XHJcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0Lmdsb2JhbEFscGhhICo9IG9wIDwgMCA/IDAgOiBvcDtcclxuICAgICAgICB0aGlzLmdsb2JhbERhdGEuY3VycmVudEdsb2JhbEFscGhhID0gdGhpcy5jb250ZXh0RGF0YS5jTztcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmNvbnRleHREYXRhLmNPICo9IG9wIDwgMCA/IDAgOiBvcDtcclxuICAgIGlmKHRoaXMuZ2xvYmFsRGF0YS5jdXJyZW50R2xvYmFsQWxwaGEgIT09IHRoaXMuY29udGV4dERhdGEuY08pIHtcclxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZ2xvYmFsQWxwaGEgPSB0aGlzLmNvbnRleHREYXRhLmNPO1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jdXJyZW50R2xvYmFsQWxwaGEgPSB0aGlzLmNvbnRleHREYXRhLmNPO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcclxuICAgIGlmKCF0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcyl7XHJcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB0aGlzLmNvbnRleHREYXRhLnJlc2V0KCk7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKGFjdGlvbkZsYWcpe1xyXG4gICAgaWYoIXRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzKXtcclxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmKGFjdGlvbkZsYWcpe1xyXG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5zYXZlKCk7XHJcbiAgICB9XHJcbiAgICB2YXIgcHJvcHMgPSB0aGlzLmNvbnRleHREYXRhLmNUci5wcm9wcztcclxuICAgIGlmKHRoaXMuY29udGV4dERhdGEuX2xlbmd0aCA8PSB0aGlzLmNvbnRleHREYXRhLmNBcnJQb3MpIHtcclxuICAgICAgICB0aGlzLmNvbnRleHREYXRhLmR1cGxpY2F0ZSgpO1xyXG4gICAgfVxyXG4gICAgdmFyIGksIGFyciA9IHRoaXMuY29udGV4dERhdGEuc2F2ZWRbdGhpcy5jb250ZXh0RGF0YS5jQXJyUG9zXTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XHJcbiAgICAgICAgYXJyW2ldID0gcHJvcHNbaV07XHJcbiAgICB9XHJcbiAgICB0aGlzLmNvbnRleHREYXRhLnNhdmVkT3BbdGhpcy5jb250ZXh0RGF0YS5jQXJyUG9zXSA9IHRoaXMuY29udGV4dERhdGEuY087XHJcbiAgICB0aGlzLmNvbnRleHREYXRhLmNBcnJQb3MgKz0gMTtcclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24oYWN0aW9uRmxhZyl7XHJcbiAgICBpZighdGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXMpe1xyXG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYoYWN0aW9uRmxhZyl7XHJcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICB0aGlzLmdsb2JhbERhdGEuYmxlbmRNb2RlID0gJ3NvdXJjZS1vdmVyJztcclxuICAgIH1cclxuICAgIHRoaXMuY29udGV4dERhdGEuY0FyclBvcyAtPSAxO1xyXG4gICAgdmFyIHBvcHBlZCA9IHRoaXMuY29udGV4dERhdGEuc2F2ZWRbdGhpcy5jb250ZXh0RGF0YS5jQXJyUG9zXTtcclxuICAgIHZhciBpLGFyciA9IHRoaXMuY29udGV4dERhdGEuY1RyLnByb3BzO1xyXG4gICAgZm9yKGk9MDtpPDE2O2krPTEpe1xyXG4gICAgICAgIGFycltpXSA9IHBvcHBlZFtpXTtcclxuICAgIH1cclxuICAgIHRoaXMuY2FudmFzQ29udGV4dC5zZXRUcmFuc2Zvcm0ocG9wcGVkWzBdLHBvcHBlZFsxXSxwb3BwZWRbNF0scG9wcGVkWzVdLHBvcHBlZFsxMl0scG9wcGVkWzEzXSk7XHJcbiAgICBwb3BwZWQgPSB0aGlzLmNvbnRleHREYXRhLnNhdmVkT3BbdGhpcy5jb250ZXh0RGF0YS5jQXJyUG9zXTtcclxuICAgIHRoaXMuY29udGV4dERhdGEuY08gPSBwb3BwZWQ7XHJcbiAgICBpZih0aGlzLmdsb2JhbERhdGEuY3VycmVudEdsb2JhbEFscGhhICE9PSBwb3BwZWQpIHtcclxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZ2xvYmFsQWxwaGEgPSBwb3BwZWQ7XHJcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmN1cnJlbnRHbG9iYWxBbHBoYSA9IHBvcHBlZDtcclxuICAgIH1cclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jb25maWdBbmltYXRpb24gPSBmdW5jdGlvbihhbmltRGF0YSl7XHJcbiAgICBpZih0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlcil7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lciA9IGNyZWF0ZVRhZygnY2FudmFzJyk7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5zdHlsZS53aWR0aCA9ICcxMDAlJztcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcclxuICAgICAgICAvL3RoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKDAsMCwwKSc7XHJcbiAgICAgICAgLy90aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgwLDAsMCknO1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5zdHlsZS5tb3pUcmFuc2Zvcm1PcmlnaW4gPSB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLnN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9IHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc3R5bGVbJy13ZWJraXQtdHJhbnNmb3JtJ10gPSBcIjBweCAwcHggMHB4XCI7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lcik7XHJcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0ID0gdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIGlmKHRoaXMucmVuZGVyQ29uZmlnLmNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0aGlzLnJlbmRlckNvbmZpZy5jbGFzc05hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1lbHNle1xyXG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dCA9IHRoaXMucmVuZGVyQ29uZmlnLmNvbnRleHQ7XHJcbiAgICB9XHJcbiAgICB0aGlzLmRhdGEgPSBhbmltRGF0YTtcclxuICAgIHRoaXMubGF5ZXJzID0gYW5pbURhdGEubGF5ZXJzO1xyXG4gICAgdGhpcy50cmFuc2Zvcm1DYW52YXMgPSB7XHJcbiAgICAgICAgdzogYW5pbURhdGEudyxcclxuICAgICAgICBoOmFuaW1EYXRhLmgsXHJcbiAgICAgICAgc3g6MCxcclxuICAgICAgICBzeTowLFxyXG4gICAgICAgIHR4OjAsXHJcbiAgICAgICAgdHk6MFxyXG4gICAgfTtcclxuICAgIHRoaXMuc2V0dXBHbG9iYWxEYXRhKGFuaW1EYXRhLCBkb2N1bWVudC5ib2R5KTtcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0ID0gdGhpcy5jYW52YXNDb250ZXh0O1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyID0gdGhpcztcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS5pc0Rhc2hlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLnByb2dyZXNzaXZlTG9hZCA9IHRoaXMucmVuZGVyQ29uZmlnLnByb2dyZXNzaXZlTG9hZDtcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS50cmFuc2Zvcm1DYW52YXMgPSB0aGlzLnRyYW5zZm9ybUNhbnZhcztcclxuICAgIHRoaXMuZWxlbWVudHMgPSBjcmVhdGVTaXplZEFycmF5KGFuaW1EYXRhLmxheWVycy5sZW5ndGgpO1xyXG5cclxuICAgIHRoaXMudXBkYXRlQ29udGFpbmVyU2l6ZSgpO1xyXG59O1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZUNvbnRhaW5lclNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICB2YXIgZWxlbWVudFdpZHRoLGVsZW1lbnRIZWlnaHQ7XHJcbiAgICBpZih0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlciAmJiB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyKXtcclxuICAgICAgICBlbGVtZW50V2lkdGggPSB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5vZmZzZXRXaWR0aDtcclxuICAgICAgICBlbGVtZW50SGVpZ2h0ID0gdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuc2V0QXR0cmlidXRlKCd3aWR0aCcsZWxlbWVudFdpZHRoICogdGhpcy5yZW5kZXJDb25maWcuZHByICk7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsZWxlbWVudEhlaWdodCAqIHRoaXMucmVuZGVyQ29uZmlnLmRwcik7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgICBlbGVtZW50V2lkdGggPSB0aGlzLmNhbnZhc0NvbnRleHQuY2FudmFzLndpZHRoICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xyXG4gICAgICAgIGVsZW1lbnRIZWlnaHQgPSB0aGlzLmNhbnZhc0NvbnRleHQuY2FudmFzLmhlaWdodCAqIHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcclxuICAgIH1cclxuICAgIHZhciBlbGVtZW50UmVsLGFuaW1hdGlvblJlbDtcclxuICAgIGlmKHRoaXMucmVuZGVyQ29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8uaW5kZXhPZignbWVldCcpICE9PSAtMSB8fCB0aGlzLnJlbmRlckNvbmZpZy5wcmVzZXJ2ZUFzcGVjdFJhdGlvLmluZGV4T2YoJ3NsaWNlJykgIT09IC0xKXtcclxuICAgICAgICB2YXIgcGFyID0gdGhpcy5yZW5kZXJDb25maWcucHJlc2VydmVBc3BlY3RSYXRpby5zcGxpdCgnICcpO1xyXG4gICAgICAgIHZhciBmaWxsVHlwZSA9IHBhclsxXSB8fCAnbWVldCc7XHJcbiAgICAgICAgdmFyIHBvcyA9IHBhclswXSB8fCAneE1pZFlNaWQnO1xyXG4gICAgICAgIHZhciB4UG9zID0gcG9zLnN1YnN0cigwLDQpO1xyXG4gICAgICAgIHZhciB5UG9zID0gcG9zLnN1YnN0cig0KTtcclxuICAgICAgICBlbGVtZW50UmVsID0gZWxlbWVudFdpZHRoL2VsZW1lbnRIZWlnaHQ7XHJcbiAgICAgICAgYW5pbWF0aW9uUmVsID0gdGhpcy50cmFuc2Zvcm1DYW52YXMudy90aGlzLnRyYW5zZm9ybUNhbnZhcy5oO1xyXG4gICAgICAgIGlmKGFuaW1hdGlvblJlbD5lbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcgfHwgYW5pbWF0aW9uUmVsPGVsZW1lbnRSZWwgJiYgZmlsbFR5cGUgPT09ICdzbGljZScpe1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCA9IGVsZW1lbnRXaWR0aC8odGhpcy50cmFuc2Zvcm1DYW52YXMudy90aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSA9IGVsZW1lbnRXaWR0aC8odGhpcy50cmFuc2Zvcm1DYW52YXMudy90aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCA9IGVsZW1lbnRIZWlnaHQvKHRoaXMudHJhbnNmb3JtQ2FudmFzLmggLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSA9IGVsZW1lbnRIZWlnaHQvKHRoaXMudHJhbnNmb3JtQ2FudmFzLmggLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYoeFBvcyA9PT0gJ3hNaWQnICYmICgoYW5pbWF0aW9uUmVsPGVsZW1lbnRSZWwgJiYgZmlsbFR5cGU9PT0nbWVldCcpIHx8IChhbmltYXRpb25SZWw+ZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpKXtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHggPSAoZWxlbWVudFdpZHRoLXRoaXMudHJhbnNmb3JtQ2FudmFzLncqKGVsZW1lbnRIZWlnaHQvdGhpcy50cmFuc2Zvcm1DYW52YXMuaCkpLzIqdGhpcy5yZW5kZXJDb25maWcuZHByO1xyXG4gICAgICAgIH0gZWxzZSBpZih4UG9zID09PSAneE1heCcgJiYgKChhbmltYXRpb25SZWw8ZWxlbWVudFJlbCAmJiBmaWxsVHlwZT09PSdtZWV0JykgfHwgKGFuaW1hdGlvblJlbD5lbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnc2xpY2UnKSkpe1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eCA9IChlbGVtZW50V2lkdGgtdGhpcy50cmFuc2Zvcm1DYW52YXMudyooZWxlbWVudEhlaWdodC90aGlzLnRyYW5zZm9ybUNhbnZhcy5oKSkqdGhpcy5yZW5kZXJDb25maWcuZHByO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoeVBvcyA9PT0gJ1lNaWQnICYmICgoYW5pbWF0aW9uUmVsPmVsZW1lbnRSZWwgJiYgZmlsbFR5cGU9PT0nbWVldCcpIHx8IChhbmltYXRpb25SZWw8ZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpKXtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAoKGVsZW1lbnRIZWlnaHQtdGhpcy50cmFuc2Zvcm1DYW52YXMuaCooZWxlbWVudFdpZHRoL3RoaXMudHJhbnNmb3JtQ2FudmFzLncpKS8yKSp0aGlzLnJlbmRlckNvbmZpZy5kcHI7XHJcbiAgICAgICAgfSBlbHNlIGlmKHlQb3MgPT09ICdZTWF4JyAmJiAoKGFuaW1hdGlvblJlbD5lbGVtZW50UmVsICYmIGZpbGxUeXBlPT09J21lZXQnKSB8fCAoYW5pbWF0aW9uUmVsPGVsZW1lbnRSZWwgJiYgZmlsbFR5cGUgPT09ICdzbGljZScpKSl7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5ID0gKChlbGVtZW50SGVpZ2h0LXRoaXMudHJhbnNmb3JtQ2FudmFzLmgqKGVsZW1lbnRXaWR0aC90aGlzLnRyYW5zZm9ybUNhbnZhcy53KSkpKnRoaXMucmVuZGVyQ29uZmlnLmRwcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eSA9IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1lbHNlIGlmKHRoaXMucmVuZGVyQ29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8gPT0gJ25vbmUnKXtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCA9IGVsZW1lbnRXaWR0aC8odGhpcy50cmFuc2Zvcm1DYW52YXMudy90aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN5ID0gZWxlbWVudEhlaWdodC8odGhpcy50cmFuc2Zvcm1DYW52YXMuaC90aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR4ID0gMDtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eSA9IDA7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCA9IHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSA9IHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eCA9IDA7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHkgPSAwO1xyXG4gICAgfVxyXG4gICAgdGhpcy50cmFuc2Zvcm1DYW52YXMucHJvcHMgPSBbdGhpcy50cmFuc2Zvcm1DYW52YXMuc3gsMCwwLDAsMCx0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSwwLDAsMCwwLDEsMCx0aGlzLnRyYW5zZm9ybUNhbnZhcy50eCx0aGlzLnRyYW5zZm9ybUNhbnZhcy50eSwwLDFdO1xyXG4gICAgLyp2YXIgaSwgbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XHJcbiAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgIGlmKHRoaXMuZWxlbWVudHNbaV0gJiYgdGhpcy5lbGVtZW50c1tpXS5kYXRhLnR5ID09PSAwKXtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5yZXNpemUodGhpcy5nbG9iYWxEYXRhLnRyYW5zZm9ybUNhbnZhcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSovXHJcbiAgICB0aGlzLmN0eFRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybUNhbnZhcy5wcm9wcyk7XHJcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQucmVjdCgwLDAsdGhpcy50cmFuc2Zvcm1DYW52YXMudyx0aGlzLnRyYW5zZm9ybUNhbnZhcy5oKTtcclxuICAgIHRoaXMuY2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgIHRoaXMuY2FudmFzQ29udGV4dC5jbGlwKCk7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmKHRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzKSB7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIuaW5uZXJIVE1MID0gJyc7XHJcbiAgICB9XHJcbiAgICB2YXIgaSwgbGVuID0gdGhpcy5sYXllcnMgPyB0aGlzLmxheWVycy5sZW5ndGggOiAwO1xyXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLT0xKSB7XHJcbiAgICAgICAgaWYodGhpcy5lbGVtZW50c1tpXSkge1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IDA7XHJcbiAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dCA9IG51bGw7XHJcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyID0gbnVsbDtcclxuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcclxufTtcclxuXHJcbkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uKG51bSl7XHJcbiAgICBpZigodGhpcy5yZW5kZXJlZEZyYW1lID09IG51bSAmJiB0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcyA9PT0gdHJ1ZSkgfHwgdGhpcy5kZXN0cm95ZWQgfHwgbnVtID09PSAtMSl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gbnVtO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lTnVtID0gbnVtIC0gdGhpcy5hbmltYXRpb25JdGVtLl9pc0ZpcnN0RnJhbWU7XHJcbiAgICB0aGlzLmdsb2JhbERhdGEuZnJhbWVJZCArPSAxO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhLl9tZGYgPSAhdGhpcy5yZW5kZXJDb25maWcuY2xlYXJDYW52YXM7XHJcbiAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5jdXJyZW50RnJhbWUgPSBudW07XHJcblxyXG4gICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLScpO1xyXG4gICAgIC8vIGNvbnNvbGUubG9nKCdORVc6ICcsbnVtKTtcclxuICAgIHZhciBpLCBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XHJcbiAgICBpZighdGhpcy5jb21wbGV0ZUxheWVycyl7XHJcbiAgICAgICAgdGhpcy5jaGVja0xheWVycyhudW0pO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSl7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucHJlcGFyZUZyYW1lKG51bSAtIHRoaXMubGF5ZXJzW2ldLnN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZih0aGlzLmdsb2JhbERhdGEuX21kZikge1xyXG4gICAgICAgIGlmKHRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzID09PSB0cnVlKXtcclxuICAgICAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLnRyYW5zZm9ybUNhbnZhcy53LCB0aGlzLnRyYW5zZm9ybUNhbnZhcy5oKTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdGhpcy5zYXZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS09MSkge1xyXG4gICAgICAgICAgICBpZih0aGlzLmNvbXBsZXRlTGF5ZXJzIHx8IHRoaXMuZWxlbWVudHNbaV0pe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5yZW5kZXJGcmFtZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzICE9PSB0cnVlKXtcclxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkSXRlbSA9IGZ1bmN0aW9uKHBvcyl7XHJcbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xyXG4gICAgaWYoZWxlbWVudHNbcG9zXSB8fCB0aGlzLmxheWVyc1twb3NdLnR5ID09IDk5KXtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuY3JlYXRlSXRlbSh0aGlzLmxheWVyc1twb3NdLCB0aGlzLHRoaXMuZ2xvYmFsRGF0YSk7XHJcbiAgICBlbGVtZW50c1twb3NdID0gZWxlbWVudDtcclxuICAgIGVsZW1lbnQuaW5pdEV4cHJlc3Npb25zKCk7XHJcbiAgICAvKmlmKHRoaXMubGF5ZXJzW3Bvc10udHkgPT09IDApe1xyXG4gICAgICAgIGVsZW1lbnQucmVzaXplKHRoaXMuZ2xvYmFsRGF0YS50cmFuc2Zvcm1DYW52YXMpO1xyXG4gICAgfSovXHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuY2hlY2tQZW5kaW5nRWxlbWVudHMgID0gZnVuY3Rpb24oKXtcclxuICAgIHdoaWxlKHRoaXMucGVuZGluZ0VsZW1lbnRzLmxlbmd0aCl7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnBlbmRpbmdFbGVtZW50cy5wb3AoKTtcclxuICAgICAgICBlbGVtZW50LmNoZWNrUGFyZW50aW5nKCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbn07XHJcblxyXG5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG59O1xyXG5cbmZ1bmN0aW9uIEh5YnJpZFJlbmRlcmVyKGFuaW1hdGlvbkl0ZW0sIGNvbmZpZyl7XHJcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0gPSBhbmltYXRpb25JdGVtO1xyXG4gICAgdGhpcy5sYXllcnMgPSBudWxsO1xyXG4gICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gLTE7XHJcbiAgICB0aGlzLnJlbmRlckNvbmZpZyA9IHtcclxuICAgICAgICBjbGFzc05hbWU6IChjb25maWcgJiYgY29uZmlnLmNsYXNzTmFtZSkgfHwgJycsXHJcbiAgICAgICAgaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvOiAoY29uZmlnICYmIGNvbmZpZy5pbWFnZVByZXNlcnZlQXNwZWN0UmF0aW8pIHx8ICd4TWlkWU1pZCBzbGljZScsXHJcbiAgICAgICAgaGlkZU9uVHJhbnNwYXJlbnQ6IChjb25maWcgJiYgY29uZmlnLmhpZGVPblRyYW5zcGFyZW50ID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWVcclxuICAgIH07XHJcbiAgICB0aGlzLmdsb2JhbERhdGEgPSB7XHJcbiAgICAgICAgX21kZjogZmFsc2UsXHJcbiAgICAgICAgZnJhbWVOdW06IC0xLFxyXG4gICAgICAgIHJlbmRlckNvbmZpZzogdGhpcy5yZW5kZXJDb25maWdcclxuICAgIH07XHJcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xyXG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xyXG4gICAgdGhpcy50aHJlZURFbGVtZW50cyA9IFtdO1xyXG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuY2FtZXJhID0gbnVsbDtcclxuICAgIHRoaXMuc3VwcG9ydHMzZCA9IHRydWU7XHJcbiAgICB0aGlzLnJlbmRlcmVyVHlwZSA9ICdodG1sJztcclxuXHJcbn1cclxuXHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZVJlbmRlcmVyXSxIeWJyaWRSZW5kZXJlcik7XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRJdGVtID0gU1ZHUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkSXRlbTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5jaGVja1BlbmRpbmdFbGVtZW50cyAgPSBmdW5jdGlvbigpe1xyXG4gICAgd2hpbGUodGhpcy5wZW5kaW5nRWxlbWVudHMubGVuZ3RoKXtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGVuZGluZ0VsZW1lbnRzLnBvcCgpO1xyXG4gICAgICAgIGVsZW1lbnQuY2hlY2tQYXJlbnRpbmcoKTtcclxuICAgIH1cclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5hcHBlbmRFbGVtZW50SW5Qb3MgPSBmdW5jdGlvbihlbGVtZW50LCBwb3Mpe1xyXG4gICAgdmFyIG5ld0RPTUVsZW1lbnQgPSBlbGVtZW50LmdldEJhc2VFbGVtZW50KCk7XHJcbiAgICBpZighbmV3RE9NRWxlbWVudCl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIGxheWVyID0gdGhpcy5sYXllcnNbcG9zXTtcclxuICAgIGlmKCFsYXllci5kZGQgfHwgIXRoaXMuc3VwcG9ydHMzZCl7XHJcbiAgICAgICAgaWYodGhpcy50aHJlZURFbGVtZW50cykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZFRvM2RDb250YWluZXIobmV3RE9NRWxlbWVudCxwb3MpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgdmFyIG5leHRET01FbGVtZW50LCBuZXh0TGF5ZXIsIHRtcERPTUVsZW1lbnQ7XHJcbiAgICAgICAgICAgIHdoaWxlKGk8cG9zKXtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMuZWxlbWVudHNbaV0gJiYgdGhpcy5lbGVtZW50c1tpXSE9PSB0cnVlICYmIHRoaXMuZWxlbWVudHNbaV0uZ2V0QmFzZUVsZW1lbnQpe1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRMYXllciA9IHRoaXMuZWxlbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgdG1wRE9NRWxlbWVudCA9IHRoaXMubGF5ZXJzW2ldLmRkZCA/IHRoaXMuZ2V0VGhyZWVEQ29udGFpbmVyQnlQb3MoaSkgOiBuZXh0TGF5ZXIuZ2V0QmFzZUVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0RE9NRWxlbWVudCA9IHRtcERPTUVsZW1lbnQgfHwgbmV4dERPTUVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYobmV4dERPTUVsZW1lbnQpe1xyXG4gICAgICAgICAgICAgICAgaWYoIWxheWVyLmRkZCB8fCAhdGhpcy5zdXBwb3J0czNkKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5pbnNlcnRCZWZvcmUobmV3RE9NRWxlbWVudCwgbmV4dERPTUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYoIWxheWVyLmRkZCB8fCAhdGhpcy5zdXBwb3J0czNkKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChuZXdET01FbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5hZGRUbzNkQ29udGFpbmVyKG5ld0RPTUVsZW1lbnQscG9zKTtcclxuICAgIH1cclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVTaGFwZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICBpZighdGhpcy5zdXBwb3J0czNkKXtcclxuICAgICAgICByZXR1cm4gbmV3IFNWR1NoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBIU2hhcGVFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbn07XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGV4dCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICBpZighdGhpcy5zdXBwb3J0czNkKXtcclxuICAgICAgICByZXR1cm4gbmV3IFNWR1RleHRFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEhUZXh0RWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNhbWVyYSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBIQ2FtZXJhRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG4gICAgcmV0dXJuIHRoaXMuY2FtZXJhO1xyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUltYWdlID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgIGlmKCF0aGlzLnN1cHBvcnRzM2Qpe1xyXG4gICAgICAgIHJldHVybiBuZXcgSUltYWdlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBISW1hZ2VFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbn07XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlQ29tcCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICBpZighdGhpcy5zdXBwb3J0czNkKXtcclxuICAgICAgICByZXR1cm4gbmV3IFNWR0NvbXBFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEhDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG5cclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVTb2xpZCA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICBpZighdGhpcy5zdXBwb3J0czNkKXtcclxuICAgICAgICByZXR1cm4gbmV3IElTb2xpZEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgSFNvbGlkRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZU51bGwgPSBTVkdSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlTnVsbDtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5nZXRUaHJlZURDb250YWluZXJCeVBvcyA9IGZ1bmN0aW9uKHBvcyl7XHJcbiAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMudGhyZWVERWxlbWVudHMubGVuZ3RoO1xyXG4gICAgd2hpbGUoaTxsZW4pIHtcclxuICAgICAgICBpZih0aGlzLnRocmVlREVsZW1lbnRzW2ldLnN0YXJ0UG9zIDw9IHBvcyAmJiB0aGlzLnRocmVlREVsZW1lbnRzW2ldLmVuZFBvcyA+PSBwb3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhyZWVERWxlbWVudHNbaV0ucGVyc3BlY3RpdmVFbGVtO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpICs9IDE7XHJcbiAgICB9XHJcbn07XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuY3JlYXRlVGhyZWVEQ29udGFpbmVyID0gZnVuY3Rpb24ocG9zLCB0eXBlKXtcclxuICAgIHZhciBwZXJzcGVjdGl2ZUVsZW0gPSBjcmVhdGVUYWcoJ2RpdicpO1xyXG4gICAgc3R5bGVEaXYocGVyc3BlY3RpdmVFbGVtKTtcclxuICAgIHZhciBjb250YWluZXIgPSBjcmVhdGVUYWcoJ2RpdicpO1xyXG4gICAgc3R5bGVEaXYoY29udGFpbmVyKTtcclxuICAgIGlmKHR5cGUgPT09ICczZCcpIHtcclxuICAgICAgICBwZXJzcGVjdGl2ZUVsZW0uc3R5bGUud2lkdGggPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudysncHgnO1xyXG4gICAgICAgIHBlcnNwZWN0aXZlRWxlbS5zdHlsZS5oZWlnaHQgPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaCsncHgnO1xyXG4gICAgICAgIHBlcnNwZWN0aXZlRWxlbS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBwZXJzcGVjdGl2ZUVsZW0uc3R5bGUubW96VHJhbnNmb3JtT3JpZ2luID0gcGVyc3BlY3RpdmVFbGVtLnN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9IFwiNTAlIDUwJVwiO1xyXG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm0gPSBjb250YWluZXIuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ21hdHJpeDNkKDEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDEpJztcclxuICAgIH1cclxuICAgIFxyXG4gICAgcGVyc3BlY3RpdmVFbGVtLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XHJcbiAgICAvL3RoaXMucmVzaXplckVsZW0uYXBwZW5kQ2hpbGQocGVyc3BlY3RpdmVFbGVtKTtcclxuICAgIHZhciB0aHJlZURDb250YWluZXJEYXRhID0ge1xyXG4gICAgICAgIGNvbnRhaW5lcjpjb250YWluZXIsXHJcbiAgICAgICAgcGVyc3BlY3RpdmVFbGVtOnBlcnNwZWN0aXZlRWxlbSxcclxuICAgICAgICBzdGFydFBvczogcG9zLFxyXG4gICAgICAgIGVuZFBvczogcG9zLFxyXG4gICAgICAgIHR5cGU6IHR5cGVcclxuICAgIH07XHJcbiAgICB0aGlzLnRocmVlREVsZW1lbnRzLnB1c2godGhyZWVEQ29udGFpbmVyRGF0YSk7XHJcbiAgICByZXR1cm4gdGhyZWVEQ29udGFpbmVyRGF0YTtcclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5idWlsZDNkQ29udGFpbmVycyA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgaSwgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xyXG4gICAgdmFyIGxhc3RUaHJlZURDb250YWluZXJEYXRhO1xyXG4gICAgdmFyIGN1cnJlbnRDb250YWluZXIgPSAnJztcclxuICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgaWYodGhpcy5sYXllcnNbaV0uZGRkICYmIHRoaXMubGF5ZXJzW2ldLnR5ICE9PSAzKXtcclxuICAgICAgICAgICAgaWYoY3VycmVudENvbnRhaW5lciAhPT0gJzNkJyl7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gJzNkJztcclxuICAgICAgICAgICAgICAgIGxhc3RUaHJlZURDb250YWluZXJEYXRhID0gdGhpcy5jcmVhdGVUaHJlZURDb250YWluZXIoaSwnM2QnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0VGhyZWVEQ29udGFpbmVyRGF0YS5lbmRQb3MgPSBNYXRoLm1heChsYXN0VGhyZWVEQ29udGFpbmVyRGF0YS5lbmRQb3MsaSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYoY3VycmVudENvbnRhaW5lciAhPT0gJzJkJyl7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gJzJkJztcclxuICAgICAgICAgICAgICAgIGxhc3RUaHJlZURDb250YWluZXJEYXRhID0gdGhpcy5jcmVhdGVUaHJlZURDb250YWluZXIoaSwnMmQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsYXN0VGhyZWVEQ29udGFpbmVyRGF0YS5lbmRQb3MgPSBNYXRoLm1heChsYXN0VGhyZWVEQ29udGFpbmVyRGF0YS5lbmRQb3MsaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbGVuID0gdGhpcy50aHJlZURFbGVtZW50cy5sZW5ndGg7XHJcbiAgICBmb3IoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtLSkge1xyXG4gICAgICAgIHRoaXMucmVzaXplckVsZW0uYXBwZW5kQ2hpbGQodGhpcy50aHJlZURFbGVtZW50c1tpXS5wZXJzcGVjdGl2ZUVsZW0pO1xyXG4gICAgfVxyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmFkZFRvM2RDb250YWluZXIgPSBmdW5jdGlvbihlbGVtLHBvcyl7XHJcbiAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMudGhyZWVERWxlbWVudHMubGVuZ3RoO1xyXG4gICAgd2hpbGUoaTxsZW4pe1xyXG4gICAgICAgIGlmKHBvcyA8PSB0aGlzLnRocmVlREVsZW1lbnRzW2ldLmVuZFBvcyl7XHJcbiAgICAgICAgICAgIHZhciBqID0gdGhpcy50aHJlZURFbGVtZW50c1tpXS5zdGFydFBvcztcclxuICAgICAgICAgICAgdmFyIG5leHRFbGVtZW50O1xyXG4gICAgICAgICAgICB3aGlsZShqPHBvcyl7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmVsZW1lbnRzW2pdICYmIHRoaXMuZWxlbWVudHNbal0uZ2V0QmFzZUVsZW1lbnQpe1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRFbGVtZW50ID0gdGhpcy5lbGVtZW50c1tqXS5nZXRCYXNlRWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaiArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKG5leHRFbGVtZW50KXtcclxuICAgICAgICAgICAgICAgIHRoaXMudGhyZWVERWxlbWVudHNbaV0uY29udGFpbmVyLmluc2VydEJlZm9yZShlbGVtLCBuZXh0RWxlbWVudCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRocmVlREVsZW1lbnRzW2ldLmNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaSArPSAxO1xyXG4gICAgfVxyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmNvbmZpZ0FuaW1hdGlvbiA9IGZ1bmN0aW9uKGFuaW1EYXRhKXtcclxuICAgIHZhciByZXNpemVyRWxlbSA9IGNyZWF0ZVRhZygnZGl2Jyk7XHJcbiAgICB2YXIgd3JhcHBlciA9IHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyO1xyXG4gICAgcmVzaXplckVsZW0uc3R5bGUud2lkdGggPSBhbmltRGF0YS53KydweCc7XHJcbiAgICByZXNpemVyRWxlbS5zdHlsZS5oZWlnaHQgPSBhbmltRGF0YS5oKydweCc7XHJcbiAgICB0aGlzLnJlc2l6ZXJFbGVtID0gcmVzaXplckVsZW07XHJcbiAgICBzdHlsZURpdihyZXNpemVyRWxlbSk7XHJcbiAgICByZXNpemVyRWxlbS5zdHlsZS50cmFuc2Zvcm1TdHlsZSA9IHJlc2l6ZXJFbGVtLnN0eWxlLndlYmtpdFRyYW5zZm9ybVN0eWxlID0gcmVzaXplckVsZW0uc3R5bGUubW96VHJhbnNmb3JtU3R5bGUgPSBcImZsYXRcIjtcclxuICAgIGlmKHRoaXMucmVuZGVyQ29uZmlnLmNsYXNzTmFtZSkge1xyXG4gICAgICByZXNpemVyRWxlbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKTtcclxuICAgIH1cclxuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQocmVzaXplckVsZW0pO1xyXG5cclxuICAgIHJlc2l6ZXJFbGVtLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICB2YXIgc3ZnID0gY3JlYXRlTlMoJ3N2ZycpO1xyXG4gICAgc3ZnLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCcxJyk7XHJcbiAgICBzdmcuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCcxJyk7XHJcbiAgICBzdHlsZURpdihzdmcpO1xyXG4gICAgdGhpcy5yZXNpemVyRWxlbS5hcHBlbmRDaGlsZChzdmcpO1xyXG4gICAgdmFyIGRlZnMgPSBjcmVhdGVOUygnZGVmcycpO1xyXG4gICAgc3ZnLmFwcGVuZENoaWxkKGRlZnMpO1xyXG4gICAgdGhpcy5kYXRhID0gYW5pbURhdGE7XHJcbiAgICAvL01hc2sgYW5pbWF0aW9uXHJcbiAgICB0aGlzLnNldHVwR2xvYmFsRGF0YShhbmltRGF0YSwgc3ZnKTtcclxuICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzID0gZGVmcztcclxuICAgIHRoaXMubGF5ZXJzID0gYW5pbURhdGEubGF5ZXJzO1xyXG4gICAgdGhpcy5sYXllckVsZW1lbnQgPSB0aGlzLnJlc2l6ZXJFbGVtO1xyXG4gICAgdGhpcy5idWlsZDNkQ29udGFpbmVycygpO1xyXG4gICAgdGhpcy51cGRhdGVDb250YWluZXJTaXplKCk7XHJcbn07XHJcblxyXG5IeWJyaWRSZW5kZXJlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLmlubmVySFRNTCA9ICcnO1xyXG4gICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lciA9IG51bGw7XHJcbiAgICB0aGlzLmdsb2JhbERhdGEuZGVmcyA9IG51bGw7XHJcbiAgICB2YXIgaSwgbGVuID0gdGhpcy5sYXllcnMgPyB0aGlzLmxheWVycy5sZW5ndGggOiAwO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IDA7XHJcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XHJcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0gPSBudWxsO1xyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZUNvbnRhaW5lclNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZWxlbWVudFdpZHRoID0gdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIub2Zmc2V0V2lkdGg7XHJcbiAgICB2YXIgZWxlbWVudEhlaWdodCA9IHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLm9mZnNldEhlaWdodDtcclxuICAgIHZhciBlbGVtZW50UmVsID0gZWxlbWVudFdpZHRoL2VsZW1lbnRIZWlnaHQ7XHJcbiAgICB2YXIgYW5pbWF0aW9uUmVsID0gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLncvdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmg7XHJcbiAgICB2YXIgc3gsc3ksdHgsdHk7XHJcbiAgICBpZihhbmltYXRpb25SZWw+ZWxlbWVudFJlbCl7XHJcbiAgICAgICAgc3ggPSBlbGVtZW50V2lkdGgvKHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53KTtcclxuICAgICAgICBzeSA9IGVsZW1lbnRXaWR0aC8odGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLncpO1xyXG4gICAgICAgIHR4ID0gMDtcclxuICAgICAgICB0eSA9ICgoZWxlbWVudEhlaWdodC10aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaCooZWxlbWVudFdpZHRoL3RoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53KSkvMik7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgICBzeCA9IGVsZW1lbnRIZWlnaHQvKHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oKTtcclxuICAgICAgICBzeSA9IGVsZW1lbnRIZWlnaHQvKHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oKTtcclxuICAgICAgICB0eCA9IChlbGVtZW50V2lkdGgtdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLncqKGVsZW1lbnRIZWlnaHQvdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmgpKS8yO1xyXG4gICAgICAgIHR5ID0gMDtcclxuICAgIH1cclxuICAgIHRoaXMucmVzaXplckVsZW0uc3R5bGUudHJhbnNmb3JtID0gdGhpcy5yZXNpemVyRWxlbS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnbWF0cml4M2QoJyArIHN4ICsgJywwLDAsMCwwLCcrc3krJywwLDAsMCwwLDEsMCwnK3R4KycsJyt0eSsnLDAsMSknO1xyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZyYW1lID0gU1ZHUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZyYW1lO1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5yZXNpemVyRWxlbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG59O1xyXG5cclxuSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5yZXNpemVyRWxlbS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5pbml0SXRlbXMgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5idWlsZEFsbEl0ZW1zKCk7XHJcbiAgICBpZih0aGlzLmNhbWVyYSl7XHJcbiAgICAgICAgdGhpcy5jYW1lcmEuc2V0dXAoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdmFyIGNXaWR0aCA9IHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53O1xyXG4gICAgICAgIHZhciBjSGVpZ2h0ID0gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmg7XHJcbiAgICAgICAgdmFyIGksIGxlbiA9IHRoaXMudGhyZWVERWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgICAgIHRoaXMudGhyZWVERWxlbWVudHNbaV0ucGVyc3BlY3RpdmVFbGVtLnN0eWxlLnBlcnNwZWN0aXZlID0gdGhpcy50aHJlZURFbGVtZW50c1tpXS5wZXJzcGVjdGl2ZUVsZW0uc3R5bGUud2Via2l0UGVyc3BlY3RpdmUgPSBNYXRoLnNxcnQoTWF0aC5wb3coY1dpZHRoLDIpICsgTWF0aC5wb3coY0hlaWdodCwyKSkgKyAncHgnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5zZWFyY2hFeHRyYUNvbXBvc2l0aW9ucyA9IGZ1bmN0aW9uKGFzc2V0cyl7XHJcbiAgICB2YXIgaSwgbGVuID0gYXNzZXRzLmxlbmd0aDtcclxuICAgIHZhciBmbG9hdGluZ0NvbnRhaW5lciA9IGNyZWF0ZVRhZygnZGl2Jyk7XHJcbiAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgIGlmKGFzc2V0c1tpXS54dCl7XHJcbiAgICAgICAgICAgIHZhciBjb21wID0gdGhpcy5jcmVhdGVDb21wKGFzc2V0c1tpXSxmbG9hdGluZ0NvbnRhaW5lcix0aGlzLmdsb2JhbERhdGEuY29tcCxudWxsKTtcclxuICAgICAgICAgICAgY29tcC5pbml0RXhwcmVzc2lvbnMoKTtcclxuICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UucmVnaXN0ZXJDb21wb3NpdGlvbihjb21wKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxuZnVuY3Rpb24gQ1ZTaGFwZURhdGEoZWxlbWVudCwgZGF0YSwgc3R5bGVzLCB0cmFuc2Zvcm1zTWFuYWdlcikge1xyXG4gICAgdGhpcy5zdHlsZWRTaGFwZXMgPSBbXTtcclxuICAgIHRoaXMudHIgPSBbMCwwLDAsMCwwLDBdO1xyXG4gICAgdmFyIHR5ID0gNDtcclxuICAgIGlmKGRhdGEudHkgPT0gJ3JjJyl7XHJcbiAgICAgICAgdHkgPSA1O1xyXG4gICAgfWVsc2UgaWYoZGF0YS50eSA9PSAnZWwnKXtcclxuICAgICAgICB0eSA9IDY7XHJcbiAgICB9ZWxzZSBpZihkYXRhLnR5ID09ICdzcicpe1xyXG4gICAgICAgIHR5ID0gNztcclxuICAgIH1cclxuICAgIHRoaXMuc2ggPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AoZWxlbWVudCxkYXRhLHR5LGVsZW1lbnQpO1xyXG4gICAgdmFyIGkgLCBsZW4gPSBzdHlsZXMubGVuZ3RoLHN0eWxlZFNoYXBlO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgaWYgKCFzdHlsZXNbaV0uY2xvc2VkKSB7XHJcbiAgICAgICAgICAgIHN0eWxlZFNoYXBlID0ge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtczogdHJhbnNmb3Jtc01hbmFnZXIuYWRkVHJhbnNmb3JtU2VxdWVuY2Uoc3R5bGVzW2ldLnRyYW5zZm9ybXMpLFxyXG4gICAgICAgICAgICAgICAgdHJOb2RlczogW11cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0eWxlZFNoYXBlcy5wdXNoKHN0eWxlZFNoYXBlKTtcclxuICAgICAgICAgICAgc3R5bGVzW2ldLmVsZW1lbnRzLnB1c2goc3R5bGVkU2hhcGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuQ1ZTaGFwZURhdGEucHJvdG90eXBlLnNldEFzQW5pbWF0ZWQgPSBTVkdTaGFwZURhdGEucHJvdG90eXBlLnNldEFzQW5pbWF0ZWQ7XG5mdW5jdGlvbiBDVkNvbnRleHREYXRhKCkge1xyXG5cdHRoaXMuc2F2ZWQgPSBbXTtcclxuICAgIHRoaXMuY0FyclBvcyA9IDA7XHJcbiAgICB0aGlzLmNUciA9IG5ldyBNYXRyaXgoKTtcclxuICAgIHRoaXMuY08gPSAxO1xyXG4gICAgdmFyIGksIGxlbiA9IDE1O1xyXG4gICAgdGhpcy5zYXZlZE9wID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XHJcbiAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgIHRoaXMuc2F2ZWRbaV0gPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgMTYpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fbGVuZ3RoID0gbGVuO1xyXG59XHJcblxyXG5DVkNvbnRleHREYXRhLnByb3RvdHlwZS5kdXBsaWNhdGUgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgbmV3TGVuZ3RoID0gdGhpcy5fbGVuZ3RoICogMjtcclxuXHR2YXIgY3VycmVudFNhdmVkT3AgPSB0aGlzLnNhdmVkT3A7XHJcbiAgICB0aGlzLnNhdmVkT3AgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbmV3TGVuZ3RoKTtcclxuICAgIHRoaXMuc2F2ZWRPcC5zZXQoY3VycmVudFNhdmVkT3ApO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgZm9yKGkgPSB0aGlzLl9sZW5ndGg7IGkgPCBuZXdMZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAgIHRoaXMuc2F2ZWRbaV0gPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgMTYpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fbGVuZ3RoID0gbmV3TGVuZ3RoO1xyXG59O1xyXG5cclxuQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcclxuXHR0aGlzLmNBcnJQb3MgPSAwO1xyXG5cdHRoaXMuY1RyLnJlc2V0KCk7XHJcbiAgICB0aGlzLmNPID0gMTtcclxufTtcbmZ1bmN0aW9uIENWQmFzZUVsZW1lbnQoKXtcclxufVxyXG5cclxuQ1ZCYXNlRWxlbWVudC5wcm90b3R5cGUgPSB7XHJcbiAgICBjcmVhdGVFbGVtZW50czogZnVuY3Rpb24oKXt9LFxyXG4gICAgaW5pdFJlbmRlcmVyRWxlbWVudDogZnVuY3Rpb24oKXt9LFxyXG4gICAgY3JlYXRlQ29udGFpbmVyRWxlbWVudHM6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0ID0gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIgPSBuZXcgQ1ZFZmZlY3RzKHRoaXMpO1xyXG4gICAgfSxcclxuICAgIGNyZWF0ZUNvbnRlbnQ6IGZ1bmN0aW9uKCl7fSxcclxuICAgIHNldEJsZW5kTW9kZTogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgZ2xvYmFsRGF0YSA9IHRoaXMuZ2xvYmFsRGF0YTtcclxuICAgICAgICBpZihnbG9iYWxEYXRhLmJsZW5kTW9kZSAhPT0gdGhpcy5kYXRhLmJtKSB7XHJcbiAgICAgICAgICAgIGdsb2JhbERhdGEuYmxlbmRNb2RlID0gdGhpcy5kYXRhLmJtO1xyXG4gICAgICAgICAgICB2YXIgYmxlbmRNb2RlVmFsdWUgPSB0aGlzLmdldEJsZW5kTW9kZSgpO1xyXG4gICAgICAgICAgICBnbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gYmxlbmRNb2RlVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzOiBmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMubWFza01hbmFnZXIgPSBuZXcgQ1ZNYXNrRWxlbWVudCh0aGlzLmRhdGEsIHRoaXMpO1xyXG4gICAgfSxcclxuICAgIGhpZGVFbGVtZW50OiBmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmICghdGhpcy5oaWRkZW4gJiYgKCF0aGlzLmlzSW5SYW5nZSB8fCB0aGlzLmlzVHJhbnNwYXJlbnQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2hvd0VsZW1lbnQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNJblJhbmdlICYmICF0aGlzLmlzVHJhbnNwYXJlbnQpe1xyXG4gICAgICAgICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLm1hc2tNYW5hZ2VyLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZW5kZXJGcmFtZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGlkZGVuIHx8IHRoaXMuZGF0YS5oZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVuZGVyVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJSZW5kZXJhYmxlKCk7XHJcbiAgICAgICAgdGhpcy5zZXRCbGVuZE1vZGUoKTtcclxuICAgICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuc2F2ZSgpO1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5jdHhUcmFuc2Zvcm0odGhpcy5maW5hbFRyYW5zZm9ybS5tYXQucHJvcHMpO1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5jdHhPcGFjaXR5KHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3Auby52KTtcclxuICAgICAgICB0aGlzLnJlbmRlcklubmVyQ29udGVudCgpO1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5yZXN0b3JlKCk7XHJcbiAgICAgICAgaWYodGhpcy5tYXNrTWFuYWdlci5oYXNNYXNrcykge1xyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIucmVzdG9yZSh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzRmlyc3RGcmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1hc2tNYW5hZ2VyLmRlc3Ryb3koKTtcclxuICAgIH0sXHJcbiAgICBtSGVscGVyOiBuZXcgTWF0cml4KClcclxufTtcclxuQ1ZCYXNlRWxlbWVudC5wcm90b3R5cGUuaGlkZSA9IENWQmFzZUVsZW1lbnQucHJvdG90eXBlLmhpZGVFbGVtZW50O1xyXG5DVkJhc2VFbGVtZW50LnByb3RvdHlwZS5zaG93ID0gQ1ZCYXNlRWxlbWVudC5wcm90b3R5cGUuc2hvd0VsZW1lbnQ7XHJcblxuZnVuY3Rpb24gQ1ZJbWFnZUVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCl7XHJcbiAgICB0aGlzLmZhaWxlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5hc3NldERhdGEgPSBnbG9iYWxEYXRhLmdldEFzc2V0RGF0YShkYXRhLnJlZklkKTtcclxuICAgIHRoaXMuaW1nID0gZ2xvYmFsRGF0YS5pbWFnZUxvYWRlci5nZXRJbWFnZSh0aGlzLmFzc2V0RGF0YSk7XHJcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsZ2xvYmFsRGF0YSxjb21wKTtcclxufVxyXG5leHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBDVkJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50XSwgQ1ZJbWFnZUVsZW1lbnQpO1xyXG5cclxuQ1ZJbWFnZUVsZW1lbnQucHJvdG90eXBlLmluaXRFbGVtZW50ID0gU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudDtcclxuQ1ZJbWFnZUVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IElJbWFnZUVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZTtcclxuXHJcbkNWSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24oKXtcclxuXHJcbiAgICBpZiAodGhpcy5pbWcud2lkdGggJiYgKHRoaXMuYXNzZXREYXRhLncgIT09IHRoaXMuaW1nLndpZHRoIHx8IHRoaXMuYXNzZXREYXRhLmggIT09IHRoaXMuaW1nLmhlaWdodCkpIHtcclxuICAgICAgICB2YXIgY2FudmFzID0gY3JlYXRlVGFnKCdjYW52YXMnKTtcclxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLmFzc2V0RGF0YS53O1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmFzc2V0RGF0YS5oO1xyXG4gICAgICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgICAgICAgdmFyIGltZ1cgPSB0aGlzLmltZy53aWR0aDtcclxuICAgICAgICB2YXIgaW1nSCA9IHRoaXMuaW1nLmhlaWdodDtcclxuICAgICAgICB2YXIgaW1nUmVsID0gaW1nVyAvIGltZ0g7XHJcbiAgICAgICAgdmFyIGNhbnZhc1JlbCA9IHRoaXMuYXNzZXREYXRhLncvdGhpcy5hc3NldERhdGEuaDtcclxuICAgICAgICB2YXIgd2lkdGhDcm9wLCBoZWlnaHRDcm9wO1xyXG4gICAgICAgIHZhciBwYXIgPSB0aGlzLmFzc2V0RGF0YS5wciB8fCB0aGlzLmdsb2JhbERhdGEucmVuZGVyQ29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbztcclxuICAgICAgICBpZigoaW1nUmVsID4gY2FudmFzUmVsICYmIHBhciA9PT0gJ3hNaWRZTWlkIHNsaWNlJykgfHwgKGltZ1JlbCA8IGNhbnZhc1JlbCAmJiBwYXIgIT09ICd4TWlkWU1pZCBzbGljZScpKSB7XHJcbiAgICAgICAgICAgIGhlaWdodENyb3AgPSBpbWdIO1xyXG4gICAgICAgICAgICB3aWR0aENyb3AgPSBoZWlnaHRDcm9wKmNhbnZhc1JlbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB3aWR0aENyb3AgPSBpbWdXO1xyXG4gICAgICAgICAgICBoZWlnaHRDcm9wID0gd2lkdGhDcm9wL2NhbnZhc1JlbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmltZywoaW1nVy13aWR0aENyb3ApLzIsKGltZ0gtaGVpZ2h0Q3JvcCkvMix3aWR0aENyb3AsaGVpZ2h0Q3JvcCwwLDAsdGhpcy5hc3NldERhdGEudyx0aGlzLmFzc2V0RGF0YS5oKTtcclxuICAgICAgICB0aGlzLmltZyA9IGNhbnZhcztcclxuICAgIH1cclxuXHJcbn07XHJcblxyXG5DVkltYWdlRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24ocGFyZW50TWF0cml4KXtcclxuICAgIGlmICh0aGlzLmZhaWxlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHRoaXMuY2FudmFzQ29udGV4dC5kcmF3SW1hZ2UodGhpcy5pbWcsIDAsIDApO1xyXG59O1xyXG5cclxuQ1ZJbWFnZUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5pbWcgPSBudWxsO1xyXG59O1xuZnVuY3Rpb24gQ1ZDb21wRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XHJcbiAgICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gZmFsc2U7XHJcbiAgICB0aGlzLmxheWVycyA9IGRhdGEubGF5ZXJzO1xyXG4gICAgdGhpcy5wZW5kaW5nRWxlbWVudHMgPSBbXTtcclxuICAgIHRoaXMuZWxlbWVudHMgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMubGF5ZXJzLmxlbmd0aCk7XHJcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xyXG4gICAgdGhpcy50bSA9IGRhdGEudG0gPyBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLGRhdGEudG0sMCxnbG9iYWxEYXRhLmZyYW1lUmF0ZSwgdGhpcykgOiB7X3BsYWNlaG9sZGVyOnRydWV9O1xyXG59XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0NhbnZhc1JlbmRlcmVyLCBJQ29tcEVsZW1lbnQsIENWQmFzZUVsZW1lbnRdLCBDVkNvbXBFbGVtZW50KTtcclxuXHJcbkNWQ29tcEVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGksbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xyXG4gICAgZm9yKCBpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEgKXtcclxuICAgICAgICBpZih0aGlzLmNvbXBsZXRlTGF5ZXJzIHx8IHRoaXMuZWxlbWVudHNbaV0pe1xyXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnJlbmRlckZyYW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cclxuQ1ZDb21wRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgaSxsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XHJcbiAgICBmb3IoIGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSApe1xyXG4gICAgICAgIGlmKHRoaXMuZWxlbWVudHNbaV0pIHtcclxuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdGhpcy5sYXllcnMgPSBudWxsO1xyXG4gICAgdGhpcy5lbGVtZW50cyA9IG51bGw7XHJcbn07XG5cclxuZnVuY3Rpb24gQ1ZNYXNrRWxlbWVudChkYXRhLGVsZW1lbnQpe1xyXG4gICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICB0aGlzLm1hc2tzUHJvcGVydGllcyA9IHRoaXMuZGF0YS5tYXNrc1Byb3BlcnRpZXMgfHwgW107XHJcbiAgICB0aGlzLnZpZXdEYXRhID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLm1hc2tzUHJvcGVydGllcy5sZW5ndGgpO1xyXG4gICAgdmFyIGksIGxlbiA9IHRoaXMubWFza3NQcm9wZXJ0aWVzLmxlbmd0aCwgaGFzTWFza3MgPSBmYWxzZTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmKHRoaXMubWFza3NQcm9wZXJ0aWVzW2ldLm1vZGUgIT09ICduJyl7XHJcbiAgICAgICAgICAgIGhhc01hc2tzID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52aWV3RGF0YVtpXSA9IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcCh0aGlzLmVsZW1lbnQsdGhpcy5tYXNrc1Byb3BlcnRpZXNbaV0sMyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLmhhc01hc2tzID0gaGFzTWFza3M7XHJcbiAgICBpZihoYXNNYXNrcykge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRSZW5kZXJhYmxlQ29tcG9uZW50KHRoaXMpO1xyXG4gICAgfVxyXG59XHJcblxyXG5DVk1hc2tFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmKCF0aGlzLmhhc01hc2tzKXtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5lbGVtZW50LmZpbmFsVHJhbnNmb3JtLm1hdDtcclxuICAgIHZhciBjdHggPSB0aGlzLmVsZW1lbnQuY2FudmFzQ29udGV4dDtcclxuICAgIHZhciBpLCBsZW4gPSB0aGlzLm1hc2tzUHJvcGVydGllcy5sZW5ndGg7XHJcbiAgICB2YXIgcHQscHRzLGRhdGE7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZih0aGlzLm1hc2tzUHJvcGVydGllc1tpXS5tb2RlICE9PSAnbicpe1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXNrc1Byb3BlcnRpZXNbaV0uaW52KSB7XHJcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLmVsZW1lbnQuZ2xvYmFsRGF0YS5jb21wU2l6ZS53LCAwKTtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy5lbGVtZW50Lmdsb2JhbERhdGEuY29tcFNpemUudywgdGhpcy5lbGVtZW50Lmdsb2JhbERhdGEuY29tcFNpemUuaCk7XHJcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKDAsIHRoaXMuZWxlbWVudC5nbG9iYWxEYXRhLmNvbXBTaXplLmgpO1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbygwLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkYXRhID0gdGhpcy52aWV3RGF0YVtpXS52O1xyXG4gICAgICAgICAgICBwdCA9IHRyYW5zZm9ybS5hcHBseVRvUG9pbnRBcnJheShkYXRhLnZbMF1bMF0sZGF0YS52WzBdWzFdLDApO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKHB0WzBdLCBwdFsxXSk7XHJcbiAgICAgICAgICAgIHZhciBqLCBqTGVuID0gZGF0YS5fbGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGogPSAxOyBqIDwgakxlbjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBwdHMgPSB0cmFuc2Zvcm0uYXBwbHlUb1RyaXBsZVBvaW50cyhkYXRhLm9baiAtIDFdLCBkYXRhLmlbal0sIGRhdGEudltqXSk7XHJcbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhwdHNbMF0sIHB0c1sxXSwgcHRzWzJdLCBwdHNbM10sIHB0c1s0XSwgcHRzWzVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwdHMgPSB0cmFuc2Zvcm0uYXBwbHlUb1RyaXBsZVBvaW50cyhkYXRhLm9baiAtIDFdLCBkYXRhLmlbMF0sIGRhdGEudlswXSk7XHJcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHB0c1swXSwgcHRzWzFdLCBwdHNbMl0sIHB0c1szXSwgcHRzWzRdLCBwdHNbNV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMuZWxlbWVudC5nbG9iYWxEYXRhLnJlbmRlcmVyLnNhdmUodHJ1ZSk7XHJcbiAgICBjdHguY2xpcCgpO1xyXG59O1xyXG5cclxuQ1ZNYXNrRWxlbWVudC5wcm90b3R5cGUuZ2V0TWFza1Byb3BlcnR5ID0gTWFza0VsZW1lbnQucHJvdG90eXBlLmdldE1hc2tQcm9wZXJ0eTtcclxuXHJcbkNWTWFza0VsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcclxufTtcbmZ1bmN0aW9uIENWU2hhcGVFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcclxuICAgIHRoaXMuc2hhcGVzID0gW107XHJcbiAgICB0aGlzLnNoYXBlc0RhdGEgPSBkYXRhLnNoYXBlcztcclxuICAgIHRoaXMuc3R5bGVzTGlzdCA9IFtdO1xyXG4gICAgdGhpcy5pdGVtc0RhdGEgPSBbXTtcclxuICAgIHRoaXMucHJldlZpZXdEYXRhID0gW107XHJcbiAgICB0aGlzLnNoYXBlTW9kaWZpZXJzID0gW107XHJcbiAgICB0aGlzLnByb2Nlc3NlZEVsZW1lbnRzID0gW107XHJcbiAgICB0aGlzLnRyYW5zZm9ybXNNYW5hZ2VyID0gbmV3IFNoYXBlVHJhbnNmb3JtTWFuYWdlcigpO1xyXG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcclxufVxyXG5cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCxUcmFuc2Zvcm1FbGVtZW50LENWQmFzZUVsZW1lbnQsSVNoYXBlRWxlbWVudCxIaWVyYXJjaHlFbGVtZW50LEZyYW1lRWxlbWVudCxSZW5kZXJhYmxlRWxlbWVudF0sIENWU2hhcGVFbGVtZW50KTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IFJlbmRlcmFibGVET01FbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudDtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS50cmFuc2Zvcm1IZWxwZXIgPSB7b3BhY2l0eToxLF9vcE1kZjpmYWxzZX07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuZGFzaFJlc2V0dGVyID0gW107XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLnNlYXJjaFNoYXBlcyh0aGlzLnNoYXBlc0RhdGEsdGhpcy5pdGVtc0RhdGEsdGhpcy5wcmV2Vmlld0RhdGEsIHRydWUsIFtdKTtcclxufTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTdHlsZUVsZW1lbnQgPSBmdW5jdGlvbihkYXRhLCB0cmFuc2Zvcm1zKSB7XHJcbiAgICB2YXIgdHJhbnNmb3Jtc1NlcXVlbmNlID0gdGhpcy50cmFuc2Zvcm1zTWFuYWdlci5hZGRUcmFuc2Zvcm1TZXF1ZW5jZSh0cmFuc2Zvcm1zKTtcclxuICAgIHZhciBzdHlsZUVsZW0gPSB7XHJcbiAgICAgICAgZGF0YTogZGF0YSxcclxuICAgICAgICB0eXBlOiBkYXRhLnR5LFxyXG4gICAgICAgIHByZVRyYW5zZm9ybXM6IHRyYW5zZm9ybXNTZXF1ZW5jZSxcclxuICAgICAgICB0cmFuc2Zvcm1zOiBbXSxcclxuICAgICAgICBlbGVtZW50czogW10sXHJcbiAgICAgICAgY2xvc2VkOiBkYXRhLmhkID09PSB0cnVlXHJcbiAgICB9O1xyXG4gICAgdmFyIGVsZW1lbnREYXRhID0ge307XHJcbiAgICBpZihkYXRhLnR5ID09ICdmbCcgfHwgZGF0YS50eSA9PSAnc3QnKXtcclxuICAgICAgICBlbGVtZW50RGF0YS5jID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcyxkYXRhLmMsMSwyNTUsdGhpcyk7XHJcbiAgICAgICAgaWYoIWVsZW1lbnREYXRhLmMuayl7XHJcbiAgICAgICAgICAgIHN0eWxlRWxlbS5jbyA9ICdyZ2IoJytibV9mbG9vcihlbGVtZW50RGF0YS5jLnZbMF0pKycsJytibV9mbG9vcihlbGVtZW50RGF0YS5jLnZbMV0pKycsJytibV9mbG9vcihlbGVtZW50RGF0YS5jLnZbMl0pKycpJztcclxuICAgICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdnZicgfHwgZGF0YS50eSA9PT0gJ2dzJykge1xyXG4gICAgICAgIGVsZW1lbnREYXRhLnMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLGRhdGEucywxLG51bGwsdGhpcyk7XHJcbiAgICAgICAgZWxlbWVudERhdGEuZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsZGF0YS5lLDEsbnVsbCx0aGlzKTtcclxuICAgICAgICBlbGVtZW50RGF0YS5oID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcyxkYXRhLmh8fHtrOjB9LDAsMC4wMSx0aGlzKTtcclxuICAgICAgICBlbGVtZW50RGF0YS5hID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcyxkYXRhLmF8fHtrOjB9LDAsZGVnVG9SYWRzLHRoaXMpO1xyXG4gICAgICAgIGVsZW1lbnREYXRhLmcgPSBuZXcgR3JhZGllbnRQcm9wZXJ0eSh0aGlzLGRhdGEuZyx0aGlzKTtcclxuICAgIH1cclxuICAgIGVsZW1lbnREYXRhLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLGRhdGEubywwLDAuMDEsdGhpcyk7XHJcbiAgICBpZihkYXRhLnR5ID09ICdzdCcgfHwgZGF0YS50eSA9PSAnZ3MnKSB7XHJcbiAgICAgICAgc3R5bGVFbGVtLmxjID0gdGhpcy5sY0VudW1bZGF0YS5sY10gfHwgJ3JvdW5kJztcclxuICAgICAgICBzdHlsZUVsZW0ubGogPSB0aGlzLmxqRW51bVtkYXRhLmxqXSB8fCAncm91bmQnO1xyXG4gICAgICAgIGlmKGRhdGEubGogPT0gMSkge1xyXG4gICAgICAgICAgICBzdHlsZUVsZW0ubWwgPSBkYXRhLm1sO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbGVtZW50RGF0YS53ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcyxkYXRhLncsMCxudWxsLHRoaXMpO1xyXG4gICAgICAgIGlmKCFlbGVtZW50RGF0YS53Lmspe1xyXG4gICAgICAgICAgICBzdHlsZUVsZW0ud2kgPSBlbGVtZW50RGF0YS53LnY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGRhdGEuZCl7XHJcbiAgICAgICAgICAgIHZhciBkID0gbmV3IERhc2hQcm9wZXJ0eSh0aGlzLGRhdGEuZCwnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIGVsZW1lbnREYXRhLmQgPSBkO1xyXG4gICAgICAgICAgICBpZighZWxlbWVudERhdGEuZC5rKXtcclxuICAgICAgICAgICAgICAgIHN0eWxlRWxlbS5kYSA9IGVsZW1lbnREYXRhLmQuZGFzaEFycmF5O1xyXG4gICAgICAgICAgICAgICAgc3R5bGVFbGVtLmRvID0gZWxlbWVudERhdGEuZC5kYXNob2Zmc2V0WzBdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBzdHlsZUVsZW0uciA9IGRhdGEuciA9PT0gMiA/ICdldmVub2RkJyA6ICdub256ZXJvJztcclxuICAgIH1cclxuICAgIHRoaXMuc3R5bGVzTGlzdC5wdXNoKHN0eWxlRWxlbSk7XHJcbiAgICBlbGVtZW50RGF0YS5zdHlsZSA9IHN0eWxlRWxlbTtcclxuICAgIHJldHVybiBlbGVtZW50RGF0YTtcclxufTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVHcm91cEVsZW1lbnQgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICB2YXIgZWxlbWVudERhdGEgPSB7XHJcbiAgICAgICAgaXQ6IFtdLFxyXG4gICAgICAgIHByZXZWaWV3RGF0YTogW11cclxuICAgIH07XHJcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlVHJhbnNmb3JtRWxlbWVudCA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgIHZhciBlbGVtZW50RGF0YSA9IHtcclxuICAgICAgICB0cmFuc2Zvcm0gOiB7XHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXHJcbiAgICAgICAgICAgIF9vcE1kZjpmYWxzZSxcclxuICAgICAgICAgICAga2V5OiB0aGlzLnRyYW5zZm9ybXNNYW5hZ2VyLmdldE5ld0tleSgpLFxyXG4gICAgICAgICAgICBvcDogUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcyxkYXRhLm8sMCwwLjAxLHRoaXMpLFxyXG4gICAgICAgICAgICBtUHJvcHM6IFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eSh0aGlzLGRhdGEsdGhpcylcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGVsZW1lbnREYXRhO1xyXG59O1xyXG5cclxuQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNoYXBlRWxlbWVudCA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgIHZhciBlbGVtZW50RGF0YSA9IG5ldyBDVlNoYXBlRGF0YSh0aGlzLCBkYXRhLCB0aGlzLnN0eWxlc0xpc3QsIHRoaXMudHJhbnNmb3Jtc01hbmFnZXIpO1xyXG4gICAgXHJcbiAgICB0aGlzLnNoYXBlcy5wdXNoKGVsZW1lbnREYXRhKTtcclxuICAgIHRoaXMuYWRkU2hhcGVUb01vZGlmaWVycyhlbGVtZW50RGF0YSk7XHJcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVsb2FkU2hhcGVzID0gZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xyXG4gICAgdmFyIGksIGxlbiA9IHRoaXMuaXRlbXNEYXRhLmxlbmd0aDtcclxuICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgdGhpcy5wcmV2Vmlld0RhdGFbaV0gPSB0aGlzLml0ZW1zRGF0YVtpXTtcclxuICAgIH1cclxuICAgIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSx0aGlzLml0ZW1zRGF0YSx0aGlzLnByZXZWaWV3RGF0YSwgdHJ1ZSwgW10pO1xyXG4gICAgbGVuID0gdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7XHJcbiAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0uZ2V0VmFsdWUoKTtcclxuICAgIH1cclxuICAgIHRoaXMucmVuZGVyTW9kaWZpZXJzKCk7XHJcbiAgICB0aGlzLnRyYW5zZm9ybXNNYW5hZ2VyLnByb2Nlc3NTZXF1ZW5jZXModGhpcy5faXNGaXJzdEZyYW1lKTtcclxufTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5hZGRUcmFuc2Zvcm1Ub1N0eWxlTGlzdCA9IGZ1bmN0aW9uKHRyYW5zZm9ybSkge1xyXG4gICAgdmFyIGksIGxlbiA9IHRoaXMuc3R5bGVzTGlzdC5sZW5ndGg7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBpZighdGhpcy5zdHlsZXNMaXN0W2ldLmNsb3NlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlc0xpc3RbaV0udHJhbnNmb3Jtcy5wdXNoKHRyYW5zZm9ybSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuY2xvc2VTdHlsZXMgPSBmdW5jdGlvbihzdHlsZXMpIHtcclxuICAgIHZhciBpLCBsZW4gPSBzdHlsZXMubGVuZ3RoLCBqLCBqTGVuO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcbiAgICAgICAgc3R5bGVzW2ldLmNsb3NlZCA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5zZWFyY2hTaGFwZXMgPSBmdW5jdGlvbihhcnIsaXRlbXNEYXRhLCBwcmV2Vmlld0RhdGEsIHNob3VsZFJlbmRlciwgdHJhbnNmb3Jtcyl7XHJcbiAgICB2YXIgaSwgbGVuID0gYXJyLmxlbmd0aCAtIDE7XHJcbiAgICB2YXIgaiwgakxlbjtcclxuICAgIHZhciBvd25TdHlsZXMgPSBbXSwgb3duTW9kaWZpZXJzID0gW10sIHByb2Nlc3NlZFBvcywgbW9kaWZpZXIsIGN1cnJlbnRUcmFuc2Zvcm07XHJcbiAgICB2YXIgb3duVHJhbnNmb3JtcyA9IFtdLmNvbmNhdCh0cmFuc2Zvcm1zKTtcclxuICAgIGZvcihpPWxlbjtpPj0wO2ktPTEpe1xyXG4gICAgICAgIHByb2Nlc3NlZFBvcyA9IHRoaXMuc2VhcmNoUHJvY2Vzc2VkRWxlbWVudChhcnJbaV0pO1xyXG4gICAgICAgIGlmKCFwcm9jZXNzZWRQb3Mpe1xyXG4gICAgICAgICAgICBhcnJbaV0uX3Nob3VsZFJlbmRlciA9IHNob3VsZFJlbmRlcjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpdGVtc0RhdGFbaV0gPSBwcmV2Vmlld0RhdGFbcHJvY2Vzc2VkUG9zIC0gMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGFycltpXS50eSA9PSAnZmwnIHx8IGFycltpXS50eSA9PSAnc3QnfHwgYXJyW2ldLnR5ID09ICdnZid8fCBhcnJbaV0udHkgPT0gJ2dzJyl7XHJcbiAgICAgICAgICAgIGlmKCFwcm9jZXNzZWRQb3Mpe1xyXG4gICAgICAgICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVTdHlsZUVsZW1lbnQoYXJyW2ldLCBvd25UcmFuc2Zvcm1zKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGl0ZW1zRGF0YVtpXS5zdHlsZS5jbG9zZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgb3duU3R5bGVzLnB1c2goaXRlbXNEYXRhW2ldLnN0eWxlKTtcclxuICAgICAgICB9ZWxzZSBpZihhcnJbaV0udHkgPT0gJ2dyJyl7XHJcbiAgICAgICAgICAgIGlmKCFwcm9jZXNzZWRQb3Mpe1xyXG4gICAgICAgICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVHcm91cEVsZW1lbnQoYXJyW2ldKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGpMZW4gPSBpdGVtc0RhdGFbaV0uaXQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yKGo9MDtqPGpMZW47ais9MSl7XHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNEYXRhW2ldLnByZXZWaWV3RGF0YVtqXSA9IGl0ZW1zRGF0YVtpXS5pdFtqXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNlYXJjaFNoYXBlcyhhcnJbaV0uaXQsaXRlbXNEYXRhW2ldLml0LGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGEsIHNob3VsZFJlbmRlciwgb3duVHJhbnNmb3Jtcyk7XHJcbiAgICAgICAgfWVsc2UgaWYoYXJyW2ldLnR5ID09ICd0cicpe1xyXG4gICAgICAgICAgICBpZighcHJvY2Vzc2VkUG9zKXtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFuc2Zvcm0gPSB0aGlzLmNyZWF0ZVRyYW5zZm9ybUVsZW1lbnQoYXJyW2ldKTtcclxuICAgICAgICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IGN1cnJlbnRUcmFuc2Zvcm07XHJcbiAgICAgICAgICAgICAgICBvd25UcmFuc2Zvcm1zLnB1c2goY3VycmVudFRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFRyYW5zZm9ybVRvU3R5bGVMaXN0KGN1cnJlbnRUcmFuc2Zvcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWVsc2UgaWYoYXJyW2ldLnR5ID09ICdzaCcgfHwgYXJyW2ldLnR5ID09ICdyYycgfHwgYXJyW2ldLnR5ID09ICdlbCcgfHwgYXJyW2ldLnR5ID09ICdzcicpe1xyXG4gICAgICAgICAgICBpZighcHJvY2Vzc2VkUG9zKXtcclxuICAgICAgICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IHRoaXMuY3JlYXRlU2hhcGVFbGVtZW50KGFycltpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgfWVsc2UgaWYoYXJyW2ldLnR5ID09ICd0bScgfHwgYXJyW2ldLnR5ID09ICdyZCcpe1xyXG4gICAgICAgICAgICBpZighcHJvY2Vzc2VkUG9zKXtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVyID0gU2hhcGVNb2RpZmllcnMuZ2V0TW9kaWZpZXIoYXJyW2ldLnR5KTtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVyLmluaXQodGhpcyxhcnJbaV0pO1xyXG4gICAgICAgICAgICAgICAgaXRlbXNEYXRhW2ldID0gbW9kaWZpZXI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXBlTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZXIgPSBpdGVtc0RhdGFbaV07XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllci5jbG9zZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvd25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgfSBlbHNlIGlmKGFycltpXS50eSA9PSAncnAnKXtcclxuICAgICAgICAgICAgaWYoIXByb2Nlc3NlZFBvcyl7XHJcbiAgICAgICAgICAgICAgICBtb2RpZmllciA9IFNoYXBlTW9kaWZpZXJzLmdldE1vZGlmaWVyKGFycltpXS50eSk7XHJcbiAgICAgICAgICAgICAgICBpdGVtc0RhdGFbaV0gPSBtb2RpZmllcjtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVyLmluaXQodGhpcyxhcnIsaSxpdGVtc0RhdGEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGFwZU1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcclxuICAgICAgICAgICAgICAgIHNob3VsZFJlbmRlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIG1vZGlmaWVyID0gaXRlbXNEYXRhW2ldO1xyXG4gICAgICAgICAgICAgICAgbW9kaWZpZXIuY2xvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvd25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkUHJvY2Vzc2VkRWxlbWVudChhcnJbaV0sIGkgKyAxKTtcclxuICAgIH1cclxuICAgIHRoaXMuY2xvc2VTdHlsZXMob3duU3R5bGVzKTtcclxuICAgIGxlbiA9IG93bk1vZGlmaWVycy5sZW5ndGg7XHJcbiAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgIG93bk1vZGlmaWVyc1tpXS5jbG9zZWQgPSB0cnVlO1xyXG4gICAgfVxyXG59O1xyXG5cclxuQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy50cmFuc2Zvcm1IZWxwZXIub3BhY2l0eSA9IDE7XHJcbiAgICB0aGlzLnRyYW5zZm9ybUhlbHBlci5fb3BNZGYgPSBmYWxzZTtcclxuICAgIHRoaXMucmVuZGVyTW9kaWZpZXJzKCk7XHJcbiAgICB0aGlzLnRyYW5zZm9ybXNNYW5hZ2VyLnByb2Nlc3NTZXF1ZW5jZXModGhpcy5faXNGaXJzdEZyYW1lKTtcclxuICAgIHRoaXMucmVuZGVyU2hhcGUodGhpcy50cmFuc2Zvcm1IZWxwZXIsdGhpcy5zaGFwZXNEYXRhLHRoaXMuaXRlbXNEYXRhLHRydWUpO1xyXG59O1xyXG5cclxuQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlclNoYXBlVHJhbnNmb3JtID0gZnVuY3Rpb24ocGFyZW50VHJhbnNmb3JtLCBncm91cFRyYW5zZm9ybSkge1xyXG4gICAgdmFyIHByb3BzLCBncm91cE1hdHJpeDtcclxuICAgIGlmKHBhcmVudFRyYW5zZm9ybS5fb3BNZGYgfHwgZ3JvdXBUcmFuc2Zvcm0ub3AuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcclxuICAgICAgICBncm91cFRyYW5zZm9ybS5vcGFjaXR5ID0gcGFyZW50VHJhbnNmb3JtLm9wYWNpdHk7XHJcbiAgICAgICAgZ3JvdXBUcmFuc2Zvcm0ub3BhY2l0eSAqPSBncm91cFRyYW5zZm9ybS5vcC52O1xyXG4gICAgICAgIGdyb3VwVHJhbnNmb3JtLl9vcE1kZiA9IHRydWU7XHJcbiAgICB9XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuZHJhd0xheWVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgaSwgbGVuID0gdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aDtcclxuICAgIHZhciBqLCBqTGVuLCBrLCBrTGVuLGVsZW1zLG5vZGVzLCByZW5kZXJlciA9IHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlciwgY3R4ID0gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQsIHR5cGUsIGN1cnJlbnRTdHlsZTtcclxuICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgY3VycmVudFN0eWxlID0gdGhpcy5zdHlsZXNMaXN0W2ldO1xyXG4gICAgICAgIHR5cGUgPSBjdXJyZW50U3R5bGUudHlwZTtcclxuXHJcbiAgICAgICAgLy9Ta2lwcGluZyBzdHlsZSB3aGVuXHJcbiAgICAgICAgLy9TdHJva2Ugd2lkdGggZXF1YWxzIDBcclxuICAgICAgICAvL3N0eWxlIHNob3VsZCBub3QgYmUgcmVuZGVyZWQgKGV4dHJhIHVudXNlZCByZXBlYXRlcnMpXHJcbiAgICAgICAgLy9jdXJyZW50IG9wYWNpdHkgZXF1YWxzIDBcclxuICAgICAgICAvL2dsb2JhbCBvcGFjaXR5IGVxdWFscyAwXHJcbiAgICAgICAgaWYoKCh0eXBlID09PSAnc3QnIHx8IHR5cGUgPT09ICdncycpICYmIGN1cnJlbnRTdHlsZS53aSA9PT0gMCkgfHwgIWN1cnJlbnRTdHlsZS5kYXRhLl9zaG91bGRSZW5kZXIgfHwgY3VycmVudFN0eWxlLmNvT3AgPT09IDAgfHwgdGhpcy5nbG9iYWxEYXRhLmN1cnJlbnRHbG9iYWxBbHBoYSA9PT0gMCl7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXJlci5zYXZlKCk7XHJcbiAgICAgICAgZWxlbXMgPSBjdXJyZW50U3R5bGUuZWxlbWVudHM7XHJcbiAgICAgICAgaWYodHlwZSA9PT0gJ3N0JyB8fCB0eXBlID09PSAnZ3MnKXtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdHlwZSA9PT0gJ3N0JyA/IGN1cnJlbnRTdHlsZS5jbyA6IGN1cnJlbnRTdHlsZS5ncmQ7XHJcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBjdXJyZW50U3R5bGUud2k7XHJcbiAgICAgICAgICAgIGN0eC5saW5lQ2FwID0gY3VycmVudFN0eWxlLmxjO1xyXG4gICAgICAgICAgICBjdHgubGluZUpvaW4gPSBjdXJyZW50U3R5bGUubGo7XHJcbiAgICAgICAgICAgIGN0eC5taXRlckxpbWl0ID0gY3VycmVudFN0eWxlLm1sIHx8IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHR5cGUgPT09ICdmbCcgPyBjdXJyZW50U3R5bGUuY28gOiBjdXJyZW50U3R5bGUuZ3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXJlci5jdHhPcGFjaXR5KGN1cnJlbnRTdHlsZS5jb09wKTtcclxuICAgICAgICBpZih0eXBlICE9PSAnc3QnICYmIHR5cGUgIT09ICdncycpe1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcmVyLmN0eFRyYW5zZm9ybShjdXJyZW50U3R5bGUucHJlVHJhbnNmb3Jtcy5maW5hbFRyYW5zZm9ybS5wcm9wcyk7XHJcbiAgICAgICAgakxlbiA9IGVsZW1zLmxlbmd0aDtcclxuICAgICAgICBmb3Ioaj0wO2o8akxlbjtqKz0xKXtcclxuICAgICAgICAgICAgaWYodHlwZSA9PT0gJ3N0JyB8fCB0eXBlID09PSAnZ3MnKXtcclxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRTdHlsZS5kYSl7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKGN1cnJlbnRTdHlsZS5kYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gY3VycmVudFN0eWxlLmRvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5vZGVzID0gZWxlbXNbal0udHJOb2RlcztcclxuICAgICAgICAgICAga0xlbiA9IG5vZGVzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIGZvcihrPTA7azxrTGVuO2srPTEpe1xyXG4gICAgICAgICAgICAgICAgaWYobm9kZXNba10udCA9PSAnbScpe1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5tb3ZlVG8obm9kZXNba10ucFswXSxub2Rlc1trXS5wWzFdKTtcclxuICAgICAgICAgICAgICAgIH1lbHNlIGlmKG5vZGVzW2tdLnQgPT0gJ2MnKXtcclxuICAgICAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhub2Rlc1trXS5wdHNbMF0sbm9kZXNba10ucHRzWzFdLG5vZGVzW2tdLnB0c1syXSxub2Rlc1trXS5wdHNbM10sbm9kZXNba10ucHRzWzRdLG5vZGVzW2tdLnB0c1s1XSk7XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYodHlwZSA9PT0gJ3N0JyB8fCB0eXBlID09PSAnZ3MnKXtcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgICAgIGlmKGN1cnJlbnRTdHlsZS5kYSl7XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKHRoaXMuZGFzaFJlc2V0dGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0eXBlICE9PSAnc3QnICYmIHR5cGUgIT09ICdncycpe1xyXG4gICAgICAgICAgICBjdHguZmlsbChjdXJyZW50U3R5bGUucik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcmVyLnJlc3RvcmUoKTtcclxuICAgIH1cclxufTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJTaGFwZSA9IGZ1bmN0aW9uKHBhcmVudFRyYW5zZm9ybSxpdGVtcyxkYXRhLGlzTWFpbil7XHJcbiAgICB2YXIgaSwgbGVuID0gaXRlbXMubGVuZ3RoIC0gMTtcclxuICAgIHZhciBncm91cFRyYW5zZm9ybTtcclxuICAgIGdyb3VwVHJhbnNmb3JtID0gcGFyZW50VHJhbnNmb3JtO1xyXG4gICAgZm9yKGk9bGVuO2k+PTA7aS09MSl7XHJcbiAgICAgICAgaWYoaXRlbXNbaV0udHkgPT0gJ3RyJyl7XHJcbiAgICAgICAgICAgIGdyb3VwVHJhbnNmb3JtID0gZGF0YVtpXS50cmFuc2Zvcm07XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2hhcGVUcmFuc2Zvcm0ocGFyZW50VHJhbnNmb3JtLCBncm91cFRyYW5zZm9ybSk7XHJcbiAgICAgICAgfWVsc2UgaWYoaXRlbXNbaV0udHkgPT0gJ3NoJyB8fCBpdGVtc1tpXS50eSA9PSAnZWwnIHx8IGl0ZW1zW2ldLnR5ID09ICdyYycgfHwgaXRlbXNbaV0udHkgPT0gJ3NyJyl7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUGF0aChpdGVtc1tpXSxkYXRhW2ldLGdyb3VwVHJhbnNmb3JtKTtcclxuICAgICAgICB9ZWxzZSBpZihpdGVtc1tpXS50eSA9PSAnZmwnKXtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJGaWxsKGl0ZW1zW2ldLGRhdGFbaV0sZ3JvdXBUcmFuc2Zvcm0pO1xyXG4gICAgICAgIH1lbHNlIGlmKGl0ZW1zW2ldLnR5ID09ICdzdCcpe1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclN0cm9rZShpdGVtc1tpXSxkYXRhW2ldLGdyb3VwVHJhbnNmb3JtKTtcclxuICAgICAgICB9ZWxzZSBpZihpdGVtc1tpXS50eSA9PSAnZ2YnIHx8IGl0ZW1zW2ldLnR5ID09ICdncycpe1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckdyYWRpZW50RmlsbChpdGVtc1tpXSxkYXRhW2ldLGdyb3VwVHJhbnNmb3JtKTtcclxuICAgICAgICB9ZWxzZSBpZihpdGVtc1tpXS50eSA9PSAnZ3InKXtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTaGFwZShncm91cFRyYW5zZm9ybSxpdGVtc1tpXS5pdCxkYXRhW2ldLml0KTtcclxuICAgICAgICB9ZWxzZSBpZihpdGVtc1tpXS50eSA9PSAndG0nKXtcclxuICAgICAgICAgICAgLy9cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZihpc01haW4pe1xyXG4gICAgICAgIHRoaXMuZHJhd0xheWVyKCk7XHJcbiAgICB9XHJcbiAgICBcclxufTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJTdHlsZWRTaGFwZSA9IGZ1bmN0aW9uKHN0eWxlZFNoYXBlLCBzaGFwZSl7XHJcbiAgICBpZih0aGlzLl9pc0ZpcnN0RnJhbWUgfHwgc2hhcGUuX21kZiB8fCBzdHlsZWRTaGFwZS50cmFuc2Zvcm1zLl9tZGYpIHtcclxuICAgICAgICB2YXIgc2hhcGVOb2RlcyA9IHN0eWxlZFNoYXBlLnRyTm9kZXM7XHJcbiAgICAgICAgdmFyIHBhdGhzID0gc2hhcGUucGF0aHM7XHJcbiAgICAgICAgdmFyIGksIGxlbiwgaiwgakxlbiA9IHBhdGhzLl9sZW5ndGg7XHJcbiAgICAgICAgc2hhcGVOb2Rlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHZhciBncm91cFRyYW5zZm9ybU1hdCA9IHN0eWxlZFNoYXBlLnRyYW5zZm9ybXMuZmluYWxUcmFuc2Zvcm07XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xyXG4gICAgICAgICAgICB2YXIgcGF0aE5vZGVzID0gcGF0aHMuc2hhcGVzW2pdO1xyXG4gICAgICAgICAgICBpZihwYXRoTm9kZXMgJiYgcGF0aE5vZGVzLnYpe1xyXG4gICAgICAgICAgICAgICAgbGVuID0gcGF0aE5vZGVzLl9sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZU5vZGVzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdDogJ20nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcDogZ3JvdXBUcmFuc2Zvcm1NYXQuYXBwbHlUb1BvaW50QXJyYXkocGF0aE5vZGVzLnZbMF1bMF0sIHBhdGhOb2Rlcy52WzBdWzFdLCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdDogJ2MnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHM6IGdyb3VwVHJhbnNmb3JtTWF0LmFwcGx5VG9UcmlwbGVQb2ludHMocGF0aE5vZGVzLm9baSAtIDFdLCBwYXRoTm9kZXMuaVtpXSwgcGF0aE5vZGVzLnZbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobGVuID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdDogJ20nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwOiBncm91cFRyYW5zZm9ybU1hdC5hcHBseVRvUG9pbnRBcnJheShwYXRoTm9kZXMudlswXVswXSwgcGF0aE5vZGVzLnZbMF1bMV0sIDApXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocGF0aE5vZGVzLmMgJiYgbGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdDogJ2MnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwdHM6IGdyb3VwVHJhbnNmb3JtTWF0LmFwcGx5VG9UcmlwbGVQb2ludHMocGF0aE5vZGVzLm9baSAtIDFdLCBwYXRoTm9kZXMuaVswXSwgcGF0aE5vZGVzLnZbMF0pXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdDogJ3onXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3R5bGVkU2hhcGUudHJOb2RlcyA9IHNoYXBlTm9kZXM7XHJcbiAgICB9XHJcbn1cclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJQYXRoID0gZnVuY3Rpb24ocGF0aERhdGEsaXRlbURhdGEsZ3JvdXBUcmFuc2Zvcm0pe1xyXG4gICAgaWYocGF0aERhdGEuaGQgIT09IHRydWUgJiYgcGF0aERhdGEuX3Nob3VsZFJlbmRlcikge1xyXG4gICAgICAgIHZhciBpLCBsZW4gPSBpdGVtRGF0YS5zdHlsZWRTaGFwZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclN0eWxlZFNoYXBlKGl0ZW1EYXRhLnN0eWxlZFNoYXBlc1tpXSwgaXRlbURhdGEuc2gpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkNWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGaWxsID0gZnVuY3Rpb24oc3R5bGVEYXRhLGl0ZW1EYXRhLCBncm91cFRyYW5zZm9ybSl7XHJcbiAgICB2YXIgc3R5bGVFbGVtID0gaXRlbURhdGEuc3R5bGU7XHJcblxyXG4gICAgaWYgKGl0ZW1EYXRhLmMuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcclxuICAgICAgICBzdHlsZUVsZW0uY28gPSAncmdiKCcgXHJcbiAgICAgICAgKyBibV9mbG9vcihpdGVtRGF0YS5jLnZbMF0pICsgJywnIFxyXG4gICAgICAgICsgYm1fZmxvb3IoaXRlbURhdGEuYy52WzFdKSArICcsJyBcclxuICAgICAgICArIGJtX2Zsb29yKGl0ZW1EYXRhLmMudlsyXSkgKyAnKSc7XHJcbiAgICB9XHJcbiAgICBpZiAoaXRlbURhdGEuby5fbWRmIHx8IGdyb3VwVHJhbnNmb3JtLl9vcE1kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcclxuICAgICAgICBzdHlsZUVsZW0uY29PcCA9IGl0ZW1EYXRhLm8udiAqIGdyb3VwVHJhbnNmb3JtLm9wYWNpdHk7XHJcbiAgICB9XHJcbn07XHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyR3JhZGllbnRGaWxsID0gZnVuY3Rpb24oc3R5bGVEYXRhLGl0ZW1EYXRhLCBncm91cFRyYW5zZm9ybSl7XHJcbiAgICB2YXIgc3R5bGVFbGVtID0gaXRlbURhdGEuc3R5bGU7XHJcbiAgICBpZighc3R5bGVFbGVtLmdyZCB8fCBpdGVtRGF0YS5nLl9tZGYgfHwgaXRlbURhdGEucy5fbWRmIHx8IGl0ZW1EYXRhLmUuX21kZiB8fCAoc3R5bGVEYXRhLnQgIT09IDEgJiYgKGl0ZW1EYXRhLmguX21kZiB8fCBpdGVtRGF0YS5hLl9tZGYpKSkge1xyXG4gICAgICAgIHZhciBjdHggPSB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dDtcclxuICAgICAgICB2YXIgZ3JkO1xyXG4gICAgICAgIHZhciBwdDEgPSBpdGVtRGF0YS5zLnYsIHB0MiA9IGl0ZW1EYXRhLmUudjtcclxuICAgICAgICBpZiAoc3R5bGVEYXRhLnQgPT09IDEpIHtcclxuICAgICAgICAgICAgZ3JkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHB0MVswXSwgcHQxWzFdLCBwdDJbMF0sIHB0MlsxXSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHJhZCA9IE1hdGguc3FydChNYXRoLnBvdyhwdDFbMF0gLSBwdDJbMF0sIDIpICsgTWF0aC5wb3cocHQxWzFdIC0gcHQyWzFdLCAyKSk7XHJcbiAgICAgICAgICAgIHZhciBhbmcgPSBNYXRoLmF0YW4yKHB0MlsxXSAtIHB0MVsxXSwgcHQyWzBdIC0gcHQxWzBdKTtcclxuXHJcbiAgICAgICAgICAgIHZhciBwZXJjZW50ID0gaXRlbURhdGEuaC52ID49IDEgPyAwLjk5IDogaXRlbURhdGEuaC52IDw9IC0xID8gLTAuOTk6IGl0ZW1EYXRhLmgudjtcclxuICAgICAgICAgICAgdmFyIGRpc3QgPSByYWQgKiBwZXJjZW50O1xyXG4gICAgICAgICAgICB2YXIgeCA9IE1hdGguY29zKGFuZyArIGl0ZW1EYXRhLmEudikgKiBkaXN0ICsgcHQxWzBdO1xyXG4gICAgICAgICAgICB2YXIgeSA9IE1hdGguc2luKGFuZyArIGl0ZW1EYXRhLmEudikgKiBkaXN0ICsgcHQxWzFdO1xyXG4gICAgICAgICAgICB2YXIgZ3JkID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgsIHksIDAsIHB0MVswXSwgcHQxWzFdLCByYWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGksIGxlbiA9IHN0eWxlRGF0YS5nLnA7XHJcbiAgICAgICAgdmFyIGNWYWx1ZXMgPSBpdGVtRGF0YS5nLmM7XHJcbiAgICAgICAgdmFyIG9wYWNpdHkgPSAxO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpe1xyXG4gICAgICAgICAgICBpZihpdGVtRGF0YS5nLl9oYXNPcGFjaXR5ICYmIGl0ZW1EYXRhLmcuX2NvbGxhcHNhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5ID0gaXRlbURhdGEuZy5vW2kqMiArIDFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdyZC5hZGRDb2xvclN0b3AoY1ZhbHVlc1tpICogNF0gLyAxMDAsJ3JnYmEoJysgY1ZhbHVlc1tpICogNCArIDFdICsgJywnICsgY1ZhbHVlc1tpICogNCArIDJdICsgJywnK2NWYWx1ZXNbaSAqIDQgKyAzXSArICcsJyArIG9wYWNpdHkgKyAnKScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdHlsZUVsZW0uZ3JkID0gZ3JkO1xyXG4gICAgfVxyXG4gICAgc3R5bGVFbGVtLmNvT3AgPSBpdGVtRGF0YS5vLnYqZ3JvdXBUcmFuc2Zvcm0ub3BhY2l0eTtcclxuICAgIFxyXG59O1xyXG5cclxuQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlclN0cm9rZSA9IGZ1bmN0aW9uKHN0eWxlRGF0YSxpdGVtRGF0YSwgZ3JvdXBUcmFuc2Zvcm0pe1xyXG4gICAgdmFyIHN0eWxlRWxlbSA9IGl0ZW1EYXRhLnN0eWxlO1xyXG4gICAgdmFyIGQgPSBpdGVtRGF0YS5kO1xyXG4gICAgaWYoZCAmJiAoZC5fbWRmICB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpKXtcclxuICAgICAgICBzdHlsZUVsZW0uZGEgPSBkLmRhc2hBcnJheTtcclxuICAgICAgICBzdHlsZUVsZW0uZG8gPSBkLmRhc2hvZmZzZXRbMF07XHJcbiAgICB9XHJcbiAgICBpZihpdGVtRGF0YS5jLl9tZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKXtcclxuICAgICAgICBzdHlsZUVsZW0uY28gPSAncmdiKCcrYm1fZmxvb3IoaXRlbURhdGEuYy52WzBdKSsnLCcrYm1fZmxvb3IoaXRlbURhdGEuYy52WzFdKSsnLCcrYm1fZmxvb3IoaXRlbURhdGEuYy52WzJdKSsnKSc7XHJcbiAgICB9XHJcbiAgICBpZihpdGVtRGF0YS5vLl9tZGYgfHwgZ3JvdXBUcmFuc2Zvcm0uX29wTWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSl7XHJcbiAgICAgICAgc3R5bGVFbGVtLmNvT3AgPSBpdGVtRGF0YS5vLnYqZ3JvdXBUcmFuc2Zvcm0ub3BhY2l0eTtcclxuICAgIH1cclxuICAgIGlmKGl0ZW1EYXRhLncuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpe1xyXG4gICAgICAgIHN0eWxlRWxlbS53aSA9IGl0ZW1EYXRhLncudjtcclxuICAgIH1cclxufTtcclxuXHJcblxyXG5DVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLnNoYXBlc0RhdGEgPSBudWxsO1xyXG4gICAgdGhpcy5nbG9iYWxEYXRhID0gbnVsbDtcclxuICAgIHRoaXMuY2FudmFzQ29udGV4dCA9IG51bGw7XHJcbiAgICB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoID0gMDtcclxuICAgIHRoaXMuaXRlbXNEYXRhLmxlbmd0aCA9IDA7XHJcbn07XHJcblxyXG5cbmZ1bmN0aW9uIENWU29saWRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcclxuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSxnbG9iYWxEYXRhLGNvbXApO1xyXG59XHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIENWQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZUVsZW1lbnRdLCBDVlNvbGlkRWxlbWVudCk7XHJcblxyXG5DVlNvbGlkRWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQgPSBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmluaXRFbGVtZW50O1xyXG5DVlNvbGlkRWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gSUltYWdlRWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lO1xyXG5cclxuQ1ZTb2xpZEVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzQ29udGV4dDtcclxuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmRhdGEuc2M7XHJcbiAgICBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy5kYXRhLnN3LCB0aGlzLmRhdGEuc2gpO1xyXG4gICAgLy9cclxufTtcbmZ1bmN0aW9uIENWVGV4dEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCl7XHJcbiAgICB0aGlzLnRleHRTcGFucyA9IFtdO1xyXG4gICAgdGhpcy55T2Zmc2V0ID0gMDtcclxuICAgIHRoaXMuZmlsbENvbG9yQW5pbSA9IGZhbHNlO1xyXG4gICAgdGhpcy5zdHJva2VDb2xvckFuaW0gPSBmYWxzZTtcclxuICAgIHRoaXMuc3Ryb2tlV2lkdGhBbmltID0gZmFsc2U7XHJcbiAgICB0aGlzLnN0cm9rZSA9IGZhbHNlO1xyXG4gICAgdGhpcy5maWxsID0gZmFsc2U7XHJcbiAgICB0aGlzLmp1c3RpZnlPZmZzZXQgPSAwO1xyXG4gICAgdGhpcy5jdXJyZW50UmVuZGVyID0gbnVsbDtcclxuICAgIHRoaXMucmVuZGVyVHlwZSA9ICdjYW52YXMnO1xyXG4gICAgdGhpcy52YWx1ZXMgPSB7XHJcbiAgICAgICAgZmlsbDogJ3JnYmEoMCwwLDAsMCknLFxyXG4gICAgICAgIHN0cm9rZTogJ3JnYmEoMCwwLDAsMCknLFxyXG4gICAgICAgIHNXaWR0aDogMCxcclxuICAgICAgICBmVmFsdWU6ICcnXHJcbiAgICB9O1xyXG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLGdsb2JhbERhdGEsY29tcCk7XHJcbn1cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCxUcmFuc2Zvcm1FbGVtZW50LENWQmFzZUVsZW1lbnQsSGllcmFyY2h5RWxlbWVudCxGcmFtZUVsZW1lbnQsUmVuZGVyYWJsZUVsZW1lbnQsSVRleHRFbGVtZW50XSwgQ1ZUZXh0RWxlbWVudCk7XHJcblxyXG5DVlRleHRFbGVtZW50LnByb3RvdHlwZS50SGVscGVyID0gY3JlYXRlVGFnKCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpO1xyXG5cclxuQ1ZUZXh0RWxlbWVudC5wcm90b3R5cGUuYnVpbGROZXdUZXh0ID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBkb2N1bWVudERhdGEgPSB0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YTtcclxuICAgIHRoaXMucmVuZGVyZWRMZXR0ZXJzID0gY3JlYXRlU2l6ZWRBcnJheShkb2N1bWVudERhdGEubCA/IGRvY3VtZW50RGF0YS5sLmxlbmd0aCA6IDApO1xyXG5cclxuICAgIHZhciBoYXNGaWxsID0gZmFsc2U7XHJcbiAgICBpZihkb2N1bWVudERhdGEuZmMpIHtcclxuICAgICAgICBoYXNGaWxsID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnZhbHVlcy5maWxsID0gdGhpcy5idWlsZENvbG9yKGRvY3VtZW50RGF0YS5mYyk7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB0aGlzLnZhbHVlcy5maWxsID0gJ3JnYmEoMCwwLDAsMCknO1xyXG4gICAgfVxyXG4gICAgdGhpcy5maWxsID0gaGFzRmlsbDtcclxuICAgIHZhciBoYXNTdHJva2UgPSBmYWxzZTtcclxuICAgIGlmKGRvY3VtZW50RGF0YS5zYyl7XHJcbiAgICAgICAgaGFzU3Ryb2tlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnZhbHVlcy5zdHJva2UgPSB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLnNjKTtcclxuICAgICAgICB0aGlzLnZhbHVlcy5zV2lkdGggPSBkb2N1bWVudERhdGEuc3c7XHJcbiAgICB9XHJcbiAgICB2YXIgZm9udERhdGEgPSB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZik7XHJcbiAgICB2YXIgaSwgbGVuO1xyXG4gICAgdmFyIGxldHRlcnMgPSBkb2N1bWVudERhdGEubDtcclxuICAgIHZhciBtYXRyaXhIZWxwZXIgPSB0aGlzLm1IZWxwZXI7XHJcbiAgICB0aGlzLnN0cm9rZSA9IGhhc1N0cm9rZTtcclxuICAgIHRoaXMudmFsdWVzLmZWYWx1ZSA9IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKyAncHggJysgdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpLmZGYW1pbHk7XHJcbiAgICBsZW4gPSBkb2N1bWVudERhdGEuZmluYWxUZXh0Lmxlbmd0aDtcclxuICAgIC8vdGhpcy50SGVscGVyLmZvbnQgPSB0aGlzLnZhbHVlcy5mVmFsdWU7XHJcbiAgICB2YXIgY2hhckRhdGEsIHNoYXBlRGF0YSwgaywga0xlbiwgc2hhcGVzLCBqLCBqTGVuLCBwYXRoTm9kZXMsIGNvbW1hbmRzLCBwYXRoQXJyLCBzaW5nbGVTaGFwZSA9IHRoaXMuZGF0YS5zaW5nbGVTaGFwZTtcclxuICAgIHZhciB0cmFja2luZ09mZnNldCA9IGRvY3VtZW50RGF0YS50ci8xMDAwKmRvY3VtZW50RGF0YS5maW5hbFNpemU7XHJcbiAgICB2YXIgeFBvcyA9IDAsIHlQb3MgPSAwLCBmaXJzdExpbmUgPSB0cnVlO1xyXG4gICAgdmFyIGNudCA9IDA7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBjaGFyRGF0YSA9IHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRDaGFyRGF0YShkb2N1bWVudERhdGEuZmluYWxUZXh0W2ldLCBmb250RGF0YS5mU3R5bGUsIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5KTtcclxuICAgICAgICBzaGFwZURhdGEgPSBjaGFyRGF0YSAmJiBjaGFyRGF0YS5kYXRhIHx8IHt9O1xyXG4gICAgICAgIG1hdHJpeEhlbHBlci5yZXNldCgpO1xyXG4gICAgICAgIGlmKHNpbmdsZVNoYXBlICYmIGxldHRlcnNbaV0ubikge1xyXG4gICAgICAgICAgICB4UG9zID0gLXRyYWNraW5nT2Zmc2V0O1xyXG4gICAgICAgICAgICB5UG9zICs9IGRvY3VtZW50RGF0YS55T2Zmc2V0O1xyXG4gICAgICAgICAgICB5UG9zICs9IGZpcnN0TGluZSA/IDEgOiAwO1xyXG4gICAgICAgICAgICBmaXJzdExpbmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNoYXBlcyA9IHNoYXBlRGF0YS5zaGFwZXMgPyBzaGFwZURhdGEuc2hhcGVzWzBdLml0IDogW107XHJcbiAgICAgICAgakxlbiA9IHNoYXBlcy5sZW5ndGg7XHJcbiAgICAgICAgbWF0cml4SGVscGVyLnNjYWxlKGRvY3VtZW50RGF0YS5maW5hbFNpemUvMTAwLGRvY3VtZW50RGF0YS5maW5hbFNpemUvMTAwKTtcclxuICAgICAgICBpZihzaW5nbGVTaGFwZSl7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlUZXh0UHJvcGVydGllc1RvTWF0cml4KGRvY3VtZW50RGF0YSwgbWF0cml4SGVscGVyLCBsZXR0ZXJzW2ldLmxpbmUsIHhQb3MsIHlQb3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb21tYW5kcyA9IGNyZWF0ZVNpemVkQXJyYXkoakxlbik7XHJcbiAgICAgICAgZm9yKGo9MDtqPGpMZW47ais9MSl7XHJcbiAgICAgICAgICAgIGtMZW4gPSBzaGFwZXNbal0ua3Muay5pLmxlbmd0aDtcclxuICAgICAgICAgICAgcGF0aE5vZGVzID0gc2hhcGVzW2pdLmtzLms7XHJcbiAgICAgICAgICAgIHBhdGhBcnIgPSBbXTtcclxuICAgICAgICAgICAgZm9yKGs9MTtrPGtMZW47ays9MSl7XHJcbiAgICAgICAgICAgICAgICBpZihrPT0xKXtcclxuICAgICAgICAgICAgICAgICAgICBwYXRoQXJyLnB1c2gobWF0cml4SGVscGVyLmFwcGx5VG9YKHBhdGhOb2Rlcy52WzBdWzBdLHBhdGhOb2Rlcy52WzBdWzFdLDApLG1hdHJpeEhlbHBlci5hcHBseVRvWShwYXRoTm9kZXMudlswXVswXSxwYXRoTm9kZXMudlswXVsxXSwwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXRoQXJyLnB1c2gobWF0cml4SGVscGVyLmFwcGx5VG9YKHBhdGhOb2Rlcy5vW2stMV1bMF0scGF0aE5vZGVzLm9bay0xXVsxXSwwKSxtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLm9bay0xXVswXSxwYXRoTm9kZXMub1trLTFdWzFdLDApLG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMuaVtrXVswXSxwYXRoTm9kZXMuaVtrXVsxXSwwKSxtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLmlba11bMF0scGF0aE5vZGVzLmlba11bMV0sMCksbWF0cml4SGVscGVyLmFwcGx5VG9YKHBhdGhOb2Rlcy52W2tdWzBdLHBhdGhOb2Rlcy52W2tdWzFdLDApLG1hdHJpeEhlbHBlci5hcHBseVRvWShwYXRoTm9kZXMudltrXVswXSxwYXRoTm9kZXMudltrXVsxXSwwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGF0aEFyci5wdXNoKG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMub1trLTFdWzBdLHBhdGhOb2Rlcy5vW2stMV1bMV0sMCksbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy5vW2stMV1bMF0scGF0aE5vZGVzLm9bay0xXVsxXSwwKSxtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLmlbMF1bMF0scGF0aE5vZGVzLmlbMF1bMV0sMCksbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy5pWzBdWzBdLHBhdGhOb2Rlcy5pWzBdWzFdLDApLG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMudlswXVswXSxwYXRoTm9kZXMudlswXVsxXSwwKSxtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLnZbMF1bMF0scGF0aE5vZGVzLnZbMF1bMV0sMCkpO1xyXG4gICAgICAgICAgICBjb21tYW5kc1tqXSA9IHBhdGhBcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHNpbmdsZVNoYXBlKXtcclxuICAgICAgICAgICAgeFBvcyArPSBsZXR0ZXJzW2ldLmw7XHJcbiAgICAgICAgICAgIHhQb3MgKz0gdHJhY2tpbmdPZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMudGV4dFNwYW5zW2NudF0pe1xyXG4gICAgICAgICAgICB0aGlzLnRleHRTcGFuc1tjbnRdLmVsZW0gPSBjb21tYW5kcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRleHRTcGFuc1tjbnRdID0ge2VsZW06IGNvbW1hbmRzfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY250ICs9MTtcclxuICAgIH1cclxufTtcclxuXHJcbkNWVGV4dEVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXNDb250ZXh0O1xyXG4gICAgdmFyIGZpbmFsTWF0ID0gdGhpcy5maW5hbFRyYW5zZm9ybS5tYXQucHJvcHM7XHJcbiAgICBjdHguZm9udCA9IHRoaXMudmFsdWVzLmZWYWx1ZTtcclxuICAgIGN0eC5saW5lQ2FwID0gJ2J1dHQnO1xyXG4gICAgY3R4LmxpbmVKb2luID0gJ21pdGVyJztcclxuICAgIGN0eC5taXRlckxpbWl0ID0gNDtcclxuXHJcbiAgICBpZighdGhpcy5kYXRhLnNpbmdsZVNoYXBlKXtcclxuICAgICAgICB0aGlzLnRleHRBbmltYXRvci5nZXRNZWFzdXJlcyh0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YSwgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciAgaSxsZW4sIGosIGpMZW4sIGssIGtMZW47XHJcbiAgICB2YXIgcmVuZGVyZWRMZXR0ZXJzID0gdGhpcy50ZXh0QW5pbWF0b3IucmVuZGVyZWRMZXR0ZXJzO1xyXG5cclxuICAgIHZhciBsZXR0ZXJzID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEubDtcclxuXHJcbiAgICBsZW4gPSBsZXR0ZXJzLmxlbmd0aDtcclxuICAgIHZhciByZW5kZXJlZExldHRlcjtcclxuICAgIHZhciBsYXN0RmlsbCA9IG51bGwsIGxhc3RTdHJva2UgPSBudWxsLCBsYXN0U3Ryb2tlVyA9IG51bGwsIGNvbW1hbmRzLCBwYXRoQXJyO1xyXG4gICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICBpZihsZXR0ZXJzW2ldLm4pe1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyZWRMZXR0ZXIgPSByZW5kZXJlZExldHRlcnNbaV07XHJcbiAgICAgICAgaWYocmVuZGVyZWRMZXR0ZXIpe1xyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuc2F2ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4VHJhbnNmb3JtKHJlbmRlcmVkTGV0dGVyLnApO1xyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4T3BhY2l0eShyZW5kZXJlZExldHRlci5vKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYodGhpcy5maWxsKXtcclxuICAgICAgICAgICAgaWYocmVuZGVyZWRMZXR0ZXIgJiYgcmVuZGVyZWRMZXR0ZXIuZmMpe1xyXG4gICAgICAgICAgICAgICAgaWYobGFzdEZpbGwgIT09IHJlbmRlcmVkTGV0dGVyLmZjKXtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0RmlsbCA9IHJlbmRlcmVkTGV0dGVyLmZjO1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSByZW5kZXJlZExldHRlci5mYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2UgaWYobGFzdEZpbGwgIT09IHRoaXMudmFsdWVzLmZpbGwpe1xyXG4gICAgICAgICAgICAgICAgbGFzdEZpbGwgPSB0aGlzLnZhbHVlcy5maWxsO1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMudmFsdWVzLmZpbGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29tbWFuZHMgPSB0aGlzLnRleHRTcGFuc1tpXS5lbGVtO1xyXG4gICAgICAgICAgICBqTGVuID0gY29tbWFuZHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgZm9yKGo9MDtqPGpMZW47ais9MSkge1xyXG4gICAgICAgICAgICAgICAgcGF0aEFyciA9IGNvbW1hbmRzW2pdO1xyXG4gICAgICAgICAgICAgICAga0xlbiA9IHBhdGhBcnIubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQubW92ZVRvKHBhdGhBcnJbMF0sIHBhdGhBcnJbMV0pO1xyXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMjsgayA8IGtMZW47IGsgKz0gNikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlemllckN1cnZlVG8ocGF0aEFycltrXSwgcGF0aEFycltrICsgMV0sIHBhdGhBcnJbayArIDJdLCBwYXRoQXJyW2sgKyAzXSwgcGF0aEFycltrICsgNF0sIHBhdGhBcnJbayArIDVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuZmlsbCgpO1xyXG4gICAgICAgICAgICAvLy9jdHguZmlsbFRleHQodGhpcy50ZXh0U3BhbnNbaV0udmFsLDAsMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMuc3Ryb2tlKXtcclxuICAgICAgICAgICAgaWYocmVuZGVyZWRMZXR0ZXIgJiYgcmVuZGVyZWRMZXR0ZXIuc3cpe1xyXG4gICAgICAgICAgICAgICAgaWYobGFzdFN0cm9rZVcgIT09IHJlbmRlcmVkTGV0dGVyLnN3KXtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0U3Ryb2tlVyA9IHJlbmRlcmVkTGV0dGVyLnN3O1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSByZW5kZXJlZExldHRlci5zdztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2UgaWYobGFzdFN0cm9rZVcgIT09IHRoaXMudmFsdWVzLnNXaWR0aCl7XHJcbiAgICAgICAgICAgICAgICBsYXN0U3Ryb2tlVyA9IHRoaXMudmFsdWVzLnNXaWR0aDtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnZhbHVlcy5zV2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYocmVuZGVyZWRMZXR0ZXIgJiYgcmVuZGVyZWRMZXR0ZXIuc2Mpe1xyXG4gICAgICAgICAgICAgICAgaWYobGFzdFN0cm9rZSAhPT0gcmVuZGVyZWRMZXR0ZXIuc2Mpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RTdHJva2UgPSByZW5kZXJlZExldHRlci5zYztcclxuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSByZW5kZXJlZExldHRlci5zYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfWVsc2UgaWYobGFzdFN0cm9rZSAhPT0gdGhpcy52YWx1ZXMuc3Ryb2tlKXtcclxuICAgICAgICAgICAgICAgIGxhc3RTdHJva2UgPSB0aGlzLnZhbHVlcy5zdHJva2U7XHJcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnZhbHVlcy5zdHJva2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29tbWFuZHMgPSB0aGlzLnRleHRTcGFuc1tpXS5lbGVtO1xyXG4gICAgICAgICAgICBqTGVuID0gY29tbWFuZHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgZm9yKGo9MDtqPGpMZW47ais9MSkge1xyXG4gICAgICAgICAgICAgICAgcGF0aEFyciA9IGNvbW1hbmRzW2pdO1xyXG4gICAgICAgICAgICAgICAga0xlbiA9IHBhdGhBcnIubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQubW92ZVRvKHBhdGhBcnJbMF0sIHBhdGhBcnJbMV0pO1xyXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMjsgayA8IGtMZW47IGsgKz0gNikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlemllckN1cnZlVG8ocGF0aEFycltrXSwgcGF0aEFycltrICsgMV0sIHBhdGhBcnJbayArIDJdLCBwYXRoQXJyW2sgKyAzXSwgcGF0aEFycltrICsgNF0sIHBhdGhBcnJbayArIDVdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuc3Ryb2tlKCk7XHJcbiAgICAgICAgICAgIC8vL2N0eC5zdHJva2VUZXh0KGxldHRlcnNbaV0udmFsLDAsMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHJlbmRlcmVkTGV0dGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xuZnVuY3Rpb24gQ1ZFZmZlY3RzKCkge1xyXG5cclxufVxyXG5DVkVmZmVjdHMucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24oKXt9O1xuZnVuY3Rpb24gSEJhc2VFbGVtZW50KGRhdGEsZ2xvYmFsRGF0YSxjb21wKXt9XHJcbkhCYXNlRWxlbWVudC5wcm90b3R5cGUgPSB7XHJcbiAgICBjaGVja0JsZW5kTW9kZTogZnVuY3Rpb24oKXt9LFxyXG4gICAgaW5pdFJlbmRlcmVyRWxlbWVudDogZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLmJhc2VFbGVtZW50ID0gY3JlYXRlVGFnKHRoaXMuZGF0YS50ZyB8fCAnZGl2Jyk7XHJcbiAgICAgICAgaWYodGhpcy5kYXRhLmhhc01hc2spIHtcclxuICAgICAgICAgICAgdGhpcy5zdmdFbGVtZW50ID0gY3JlYXRlTlMoJ3N2ZycpO1xyXG4gICAgICAgICAgICB0aGlzLmxheWVyRWxlbWVudCA9IGNyZWF0ZU5TKCdnJyk7XHJcbiAgICAgICAgICAgIHRoaXMubWFza2VkRWxlbWVudCA9IHRoaXMubGF5ZXJFbGVtZW50O1xyXG4gICAgICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xyXG4gICAgICAgICAgICB0aGlzLmJhc2VFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc3ZnRWxlbWVudCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sYXllckVsZW1lbnQgPSB0aGlzLmJhc2VFbGVtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdHlsZURpdih0aGlzLmJhc2VFbGVtZW50KTtcclxuICAgIH0sXHJcbiAgICBjcmVhdGVDb250YWluZXJFbGVtZW50czogZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlciA9IG5ldyBDVkVmZmVjdHModGhpcyk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSB0aGlzLmJhc2VFbGVtZW50O1xyXG4gICAgICAgIHRoaXMubWFza2VkRWxlbWVudCA9IHRoaXMubGF5ZXJFbGVtZW50O1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGEubG4pIHtcclxuICAgICAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsdGhpcy5kYXRhLmxuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5jbCkge1xyXG4gICAgICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5kYXRhLmNsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5ibSAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldEJsZW5kTW9kZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICByZW5kZXJFbGVtZW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgICBpZih0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYpe1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1hdC50b0NTUygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0aGlzLmZpbmFsVHJhbnNmb3JtLl9vcE1kZil7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLm8udjtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyRnJhbWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vSWYgaXQgaXMgZXhwb3J0ZWQgYXMgaGlkZGVuIChkYXRhLmhkID09PSB0cnVlKSBubyBuZWVkIHRvIHJlbmRlclxyXG4gICAgICAgIC8vSWYgaXQgaXMgbm90IHZpc2libGUgbm8gbmVlZCB0byByZW5kZXJcclxuICAgICAgICBpZiAodGhpcy5kYXRhLmhkIHx8IHRoaXMuaGlkZGVuKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZW5kZXJUcmFuc2Zvcm0oKTtcclxuICAgICAgICB0aGlzLnJlbmRlclJlbmRlcmFibGUoKTtcclxuICAgICAgICB0aGlzLnJlbmRlckVsZW1lbnQoKTtcclxuICAgICAgICB0aGlzLnJlbmRlcklubmVyQ29udGVudCgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5faXNGaXJzdEZyYW1lID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy5sYXllckVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50ID0gbnVsbDtcclxuICAgICAgICBpZih0aGlzLm1hdHRlRWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLm1hdHRlRWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMubWFza01hbmFnZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXNrTWFuYWdlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMubWFza01hbmFnZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjcmVhdGVSZW5kZXJhYmxlQ29tcG9uZW50czogZnVuY3Rpb24oKXtcclxuICAgICAgICB0aGlzLm1hc2tNYW5hZ2VyID0gbmV3IE1hc2tFbGVtZW50KHRoaXMuZGF0YSwgdGhpcywgdGhpcy5nbG9iYWxEYXRhKTtcclxuICAgIH0sXHJcbiAgICBhZGRFZmZlY3RzOiBmdW5jdGlvbigpe1xyXG4gICAgfSxcclxuICAgIHNldE1hdHRlOiBmdW5jdGlvbigpe31cclxufTtcclxuSEJhc2VFbGVtZW50LnByb3RvdHlwZS5nZXRCYXNlRWxlbWVudCA9IFNWR0Jhc2VFbGVtZW50LnByb3RvdHlwZS5nZXRCYXNlRWxlbWVudDtcclxuSEJhc2VFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95QmFzZUVsZW1lbnQgPSBIQmFzZUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3k7XHJcbkhCYXNlRWxlbWVudC5wcm90b3R5cGUuYnVpbGRFbGVtZW50UGFyZW50aW5nID0gSHlicmlkUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkRWxlbWVudFBhcmVudGluZztcbmZ1bmN0aW9uIEhTb2xpZEVsZW1lbnQoZGF0YSxnbG9iYWxEYXRhLGNvbXApe1xyXG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLGdsb2JhbERhdGEsY29tcCk7XHJcbn1cclxuZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCxUcmFuc2Zvcm1FbGVtZW50LEhCYXNlRWxlbWVudCxIaWVyYXJjaHlFbGVtZW50LEZyYW1lRWxlbWVudCxSZW5kZXJhYmxlRE9NRWxlbWVudF0sIEhTb2xpZEVsZW1lbnQpO1xyXG5cclxuSFNvbGlkRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgcmVjdDtcclxuICAgIGlmKHRoaXMuZGF0YS5oYXNNYXNrKXtcclxuICAgICAgICByZWN0ID0gY3JlYXRlTlMoJ3JlY3QnKTtcclxuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLHRoaXMuZGF0YS5zdyk7XHJcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsdGhpcy5kYXRhLnNoKTtcclxuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsdGhpcy5kYXRhLnNjKTtcclxuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsdGhpcy5kYXRhLnN3KTtcclxuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLHRoaXMuZGF0YS5zaCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlY3QgPSBjcmVhdGVUYWcoJ2RpdicpO1xyXG4gICAgICAgIHJlY3Quc3R5bGUud2lkdGggPSB0aGlzLmRhdGEuc3cgKyAncHgnO1xyXG4gICAgICAgIHJlY3Quc3R5bGUuaGVpZ2h0ID0gdGhpcy5kYXRhLnNoICsgJ3B4JztcclxuICAgICAgICByZWN0LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZGF0YS5zYztcclxuICAgIH1cclxuICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHJlY3QpO1xyXG59O1xyXG5cbmZ1bmN0aW9uIEhDb21wRWxlbWVudChkYXRhLGdsb2JhbERhdGEsY29tcCl7XHJcbiAgICB0aGlzLmxheWVycyA9IGRhdGEubGF5ZXJzO1xyXG4gICAgdGhpcy5zdXBwb3J0czNkID0gIWRhdGEuaGFzTWFzaztcclxuICAgIHRoaXMuY29tcGxldGVMYXllcnMgPSBmYWxzZTtcclxuICAgIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XHJcbiAgICB0aGlzLmVsZW1lbnRzID0gdGhpcy5sYXllcnMgPyBjcmVhdGVTaXplZEFycmF5KHRoaXMubGF5ZXJzLmxlbmd0aCkgOiBbXTtcclxuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSxnbG9iYWxEYXRhLGNvbXApO1xyXG4gICAgdGhpcy50bSA9IGRhdGEudG0gPyBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLGRhdGEudG0sMCxnbG9iYWxEYXRhLmZyYW1lUmF0ZSx0aGlzKSA6IHtfcGxhY2Vob2xkZXI6dHJ1ZX07XHJcbn1cclxuXHJcbmV4dGVuZFByb3RvdHlwZShbSHlicmlkUmVuZGVyZXIsIElDb21wRWxlbWVudCwgSEJhc2VFbGVtZW50XSwgSENvbXBFbGVtZW50KTtcclxuSENvbXBFbGVtZW50LnByb3RvdHlwZS5fY3JlYXRlQmFzZUNvbnRhaW5lckVsZW1lbnRzID0gSENvbXBFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250YWluZXJFbGVtZW50cztcclxuXHJcbkhDb21wRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGFpbmVyRWxlbWVudHMgPSBmdW5jdGlvbigpe1xyXG4gICAgdGhpcy5fY3JlYXRlQmFzZUNvbnRhaW5lckVsZW1lbnRzKCk7XHJcbiAgICAvL2RpdkVsZW1lbnQuc3R5bGUuY2xpcCA9ICdyZWN0KDBweCwgJyt0aGlzLmRhdGEudysncHgsICcrdGhpcy5kYXRhLmgrJ3B4LCAwcHgpJztcclxuICAgIGlmKHRoaXMuZGF0YS5oYXNNYXNrKXtcclxuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsdGhpcy5kYXRhLncpO1xyXG4gICAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsdGhpcy5kYXRhLmgpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50ID0gdGhpcy5iYXNlRWxlbWVudDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSB0aGlzLmxheWVyRWxlbWVudDtcclxuICAgIH1cclxufTtcclxuXHJcbkhDb21wRWxlbWVudC5wcm90b3R5cGUuYWRkVG8zZENvbnRhaW5lciA9IGZ1bmN0aW9uKGVsZW0scG9zKSB7XHJcbiAgICB2YXIgaiA9IDA7XHJcbiAgICB2YXIgbmV4dEVsZW1lbnQ7XHJcbiAgICB3aGlsZShqPHBvcyl7XHJcbiAgICAgICAgaWYodGhpcy5lbGVtZW50c1tqXSAmJiB0aGlzLmVsZW1lbnRzW2pdLmdldEJhc2VFbGVtZW50KXtcclxuICAgICAgICAgICAgbmV4dEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2pdLmdldEJhc2VFbGVtZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGogKz0gMTtcclxuICAgIH1cclxuICAgIGlmKG5leHRFbGVtZW50KXtcclxuICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5pbnNlcnRCZWZvcmUoZWxlbSwgbmV4dEVsZW1lbnQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChlbGVtKTtcclxuICAgIH1cclxufVxyXG5cbmZ1bmN0aW9uIEhTaGFwZUVsZW1lbnQoZGF0YSxnbG9iYWxEYXRhLGNvbXApe1xyXG4gICAgLy9MaXN0IG9mIGRyYXdhYmxlIGVsZW1lbnRzXHJcbiAgICB0aGlzLnNoYXBlcyA9IFtdO1xyXG4gICAgLy8gRnVsbCBzaGFwZSBkYXRhXHJcbiAgICB0aGlzLnNoYXBlc0RhdGEgPSBkYXRhLnNoYXBlcztcclxuICAgIC8vTGlzdCBvZiBzdHlsZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gc2hhcGVzXHJcbiAgICB0aGlzLnN0eWxlc0xpc3QgPSBbXTtcclxuICAgIC8vTGlzdCBvZiBtb2RpZmllcnMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gc2hhcGVzXHJcbiAgICB0aGlzLnNoYXBlTW9kaWZpZXJzID0gW107XHJcbiAgICAvL0xpc3Qgb2YgaXRlbXMgaW4gc2hhcGUgdHJlZVxyXG4gICAgdGhpcy5pdGVtc0RhdGEgPSBbXTtcclxuICAgIC8vTGlzdCBvZiBpdGVtcyBpbiBwcmV2aW91cyBzaGFwZSB0cmVlXHJcbiAgICB0aGlzLnByb2Nlc3NlZEVsZW1lbnRzID0gW107XHJcbiAgICAvLyBMaXN0IG9mIGFuaW1hdGVkIGNvbXBvbmVudHNcclxuICAgIHRoaXMuYW5pbWF0ZWRDb250ZW50cyA9IFtdO1xyXG4gICAgdGhpcy5zaGFwZXNDb250YWluZXIgPSBjcmVhdGVOUygnZycpO1xyXG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLGdsb2JhbERhdGEsY29tcCk7XHJcbiAgICAvL01vdmluZyBhbnkgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGdldCB0b28gbXVjaCBhY2Nlc3MgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gYmVjYXVzZSBvZiB2OCB3YXkgb2YgaGFuZGxpbmcgbW9yZSB0aGFuIDEwIHByb3BlcnRpZXMuXHJcbiAgICAvLyBMaXN0IG9mIGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIGNyZWF0ZWRcclxuICAgIHRoaXMucHJldlZpZXdEYXRhID0gW107XHJcbiAgICB0aGlzLmN1cnJlbnRCQm94ID0ge1xyXG4gICAgICAgIHg6OTk5OTk5LFxyXG4gICAgICAgIHk6IC05OTk5OTksXHJcbiAgICAgICAgaDogMCxcclxuICAgICAgICB3OiAwXHJcbiAgICB9O1xyXG59XHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsVHJhbnNmb3JtRWxlbWVudCxIU29saWRFbGVtZW50LFNWR1NoYXBlRWxlbWVudCxIQmFzZUVsZW1lbnQsSGllcmFyY2h5RWxlbWVudCxGcmFtZUVsZW1lbnQsUmVuZGVyYWJsZUVsZW1lbnRdLCBIU2hhcGVFbGVtZW50KTtcclxuSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuX3JlbmRlclNoYXBlRnJhbWUgPSBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQ7XHJcblxyXG5IU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBjb250O1xyXG4gICAgdGhpcy5iYXNlRWxlbWVudC5zdHlsZS5mb250U2l6ZSA9IDA7XHJcbiAgICBpZiAodGhpcy5kYXRhLmhhc01hc2spIHtcclxuICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLnNoYXBlc0NvbnRhaW5lcik7XHJcbiAgICAgICAgY29udCA9IHRoaXMuc3ZnRWxlbWVudDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29udCA9IGNyZWF0ZU5TKCdzdmcnKTtcclxuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuY29tcC5kYXRhID8gdGhpcy5jb21wLmRhdGEgOiB0aGlzLmdsb2JhbERhdGEuY29tcFNpemU7XHJcbiAgICAgICAgY29udC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyxzaXplLncpO1xyXG4gICAgICAgIGNvbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLHNpemUuaCk7XHJcbiAgICAgICAgY29udC5hcHBlbmRDaGlsZCh0aGlzLnNoYXBlc0NvbnRhaW5lcik7XHJcbiAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zZWFyY2hTaGFwZXModGhpcy5zaGFwZXNEYXRhLHRoaXMuaXRlbXNEYXRhLHRoaXMucHJldlZpZXdEYXRhLHRoaXMuc2hhcGVzQ29udGFpbmVyLDAsIFtdLCB0cnVlKTtcclxuICAgIHRoaXMuZmlsdGVyVW5pcXVlU2hhcGVzKCk7XHJcbiAgICB0aGlzLnNoYXBlQ29udCA9IGNvbnQ7XHJcbn07XHJcblxyXG5IU2hhcGVFbGVtZW50LnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1lZFBvaW50ID0gZnVuY3Rpb24odHJhbnNmb3JtZXJzLCBwb2ludCkge1xyXG4gICAgdmFyIGksIGxlbiA9IHRyYW5zZm9ybWVycy5sZW5ndGg7XHJcbiAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgIHBvaW50ID0gdHJhbnNmb3JtZXJzW2ldLm1Qcm9wcy52LmFwcGx5VG9Qb2ludEFycmF5KHBvaW50WzBdLCBwb2ludFsxXSwgMCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9pbnQ7XHJcbn1cclxuXHJcbkhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNhbGN1bGF0ZVNoYXBlQm91bmRpbmdCb3ggPSBmdW5jdGlvbihpdGVtLCBib3VuZGluZ0JveCkge1xyXG4gICAgdmFyIHNoYXBlID0gaXRlbS5zaC52O1xyXG4gICAgdmFyIHRyYW5zZm9ybWVycyA9IGl0ZW0udHJhbnNmb3JtZXJzO1xyXG4gICAgdmFyIGksIGxlbiA9IHNoYXBlLl9sZW5ndGgsIHZQb2ludCwgb1BvaW50LCBuZXh0SVBvaW50LCBuZXh0VlBvaW50LCBib3VuZHM7XHJcbiAgICBpZiAobGVuIDw9IDEpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgaSArPSAxKSB7XHJcbiAgICAgICAgdlBvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUudltpXSk7XHJcbiAgICAgICAgb1BvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUub1tpXSk7XHJcbiAgICAgICAgbmV4dElQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLmlbaSArIDFdKTtcclxuICAgICAgICBuZXh0VlBvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUudltpICsgMV0pO1xyXG4gICAgICAgIHRoaXMuY2hlY2tCb3VuZHModlBvaW50LCBvUG9pbnQsIG5leHRJUG9pbnQsIG5leHRWUG9pbnQsIGJvdW5kaW5nQm94KTtcclxuICAgIH1cclxuICAgIGlmKHNoYXBlLmMpIHtcclxuICAgICAgICB2UG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS52W2ldKTtcclxuICAgICAgICBvUG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS5vW2ldKTtcclxuICAgICAgICBuZXh0SVBvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50KHRyYW5zZm9ybWVycywgc2hhcGUuaVswXSk7XHJcbiAgICAgICAgbmV4dFZQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLnZbMF0pO1xyXG4gICAgICAgIHRoaXMuY2hlY2tCb3VuZHModlBvaW50LCBvUG9pbnQsIG5leHRJUG9pbnQsIG5leHRWUG9pbnQsIGJvdW5kaW5nQm94KTtcclxuICAgIH1cclxufVxyXG5cclxuSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuY2hlY2tCb3VuZHMgPSBmdW5jdGlvbih2UG9pbnQsIG9Qb2ludCwgbmV4dElQb2ludCwgbmV4dFZQb2ludCwgYm91bmRpbmdCb3gpIHtcclxuICAgIHRoaXMuZ2V0Qm91bmRzT2ZDdXJ2ZSh2UG9pbnQsIG9Qb2ludCwgbmV4dElQb2ludCwgbmV4dFZQb2ludCk7XHJcbiAgICB2YXIgYm91bmRzID0gdGhpcy5zaGFwZUJvdW5kaW5nQm94O1xyXG4gICAgYm91bmRpbmdCb3gueCA9IGJtX21pbihib3VuZHMubGVmdCwgYm91bmRpbmdCb3gueCk7XHJcbiAgICBib3VuZGluZ0JveC54TWF4ID0gYm1fbWF4KGJvdW5kcy5yaWdodCwgYm91bmRpbmdCb3gueE1heCk7XHJcbiAgICBib3VuZGluZ0JveC55ID0gYm1fbWluKGJvdW5kcy50b3AsIGJvdW5kaW5nQm94LnkpO1xyXG4gICAgYm91bmRpbmdCb3gueU1heCA9IGJtX21heChib3VuZHMuYm90dG9tLCBib3VuZGluZ0JveC55TWF4KTtcclxufVxyXG5cclxuSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuc2hhcGVCb3VuZGluZ0JveCA9IHtcclxuICAgIGxlZnQ6MCxcclxuICAgIHJpZ2h0OjAsXHJcbiAgICB0b3A6MCxcclxuICAgIGJvdHRvbTowLFxyXG59XHJcblxyXG5IU2hhcGVFbGVtZW50LnByb3RvdHlwZS50ZW1wQm91bmRpbmdCb3ggPSB7XHJcbiAgICB4OjAsXHJcbiAgICB4TWF4OjAsXHJcbiAgICB5OjAsXHJcbiAgICB5TWF4OjAsXHJcbiAgICB3aWR0aDowLFxyXG4gICAgaGVpZ2h0OjBcclxufVxyXG5cclxuSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuZ2V0Qm91bmRzT2ZDdXJ2ZSA9IGZ1bmN0aW9uKHAwLCBwMSwgcDIsIHAzKSB7XHJcblxyXG4gICAgdmFyIGJvdW5kcyA9IFtbcDBbMF0scDNbMF1dLCBbcDBbMV0scDNbMV1dXTtcclxuXHJcbiAgICBmb3IgKHZhciBhLCBiLCBjLCB0LCBiMmFjLCB0MSwgdDIsIGkgPSAwOyBpIDwgMjsgKytpKSB7XHJcblxyXG4gICAgICBiID0gNiAqIHAwW2ldIC0gMTIgKiBwMVtpXSArIDYgKiBwMltpXTtcclxuICAgICAgYSA9IC0zICogcDBbaV0gKyA5ICogcDFbaV0gLSA5ICogcDJbaV0gKyAzICogcDNbaV07XHJcbiAgICAgIGMgPSAzICogcDFbaV0gLSAzICogcDBbaV07XHJcblxyXG4gICAgICBiID0gYiB8IDA7XHJcbiAgICAgIGEgPSBhIHwgMDtcclxuICAgICAgYyA9IGMgfCAwO1xyXG5cclxuICAgICAgaWYgKGEgPT09IDApIHtcclxuXHJcbiAgICAgICAgaWYgKGIgPT09IDApIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdCA9IC1jIC8gYjtcclxuXHJcbiAgICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XHJcbiAgICAgICAgICBib3VuZHNbaV0ucHVzaCh0aGlzLmNhbGN1bGF0ZUYodCxwMCxwMSxwMixwMyxpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBiMmFjID0gYiAqIGIgLSA0ICogYyAqIGE7XHJcblxyXG4gICAgICBpZiAoYjJhYyA8IDApIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdDEgPSAoLWIgKyBibV9zcXJ0KGIyYWMpKS8oMiAqIGEpO1xyXG4gICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkgYm91bmRzW2ldLnB1c2godGhpcy5jYWxjdWxhdGVGKHQxLHAwLHAxLHAyLHAzLGkpKTtcclxuXHJcbiAgICAgIHQyID0gKC1iIC0gYm1fc3FydChiMmFjKSkvKDIgKiBhKTtcclxuICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIGJvdW5kc1tpXS5wdXNoKHRoaXMuY2FsY3VsYXRlRih0MixwMCxwMSxwMixwMyxpKSk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc2hhcGVCb3VuZGluZ0JveC5sZWZ0ID0gYm1fbWluLmFwcGx5KG51bGwsIGJvdW5kc1swXSk7XHJcbiAgICB0aGlzLnNoYXBlQm91bmRpbmdCb3gudG9wID0gYm1fbWluLmFwcGx5KG51bGwsIGJvdW5kc1sxXSk7XHJcbiAgICB0aGlzLnNoYXBlQm91bmRpbmdCb3gucmlnaHQgPSBibV9tYXguYXBwbHkobnVsbCwgYm91bmRzWzBdKTtcclxuICAgIHRoaXMuc2hhcGVCb3VuZGluZ0JveC5ib3R0b20gPSBibV9tYXguYXBwbHkobnVsbCwgYm91bmRzWzFdKTtcclxuICB9O1xyXG5cclxuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jYWxjdWxhdGVGID0gZnVuY3Rpb24odCwgcDAsIHAxLCBwMiwgcDMsIGkpIHtcclxuICAgIHJldHVybiBibV9wb3coMS10LCAzKSAqIHAwW2ldXHJcbiAgICAgICAgKyAzICogYm1fcG93KDEtdCwgMikgKiB0ICogcDFbaV1cclxuICAgICAgICArIDMgKiAoMS10KSAqIGJtX3Bvdyh0LCAyKSAqIHAyW2ldXHJcbiAgICAgICAgKyBibV9wb3codCwgMykgKiBwM1tpXTtcclxuICB9XHJcblxyXG5IU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jYWxjdWxhdGVCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKGl0ZW1zRGF0YSwgYm91bmRpbmdCb3gpIHtcclxuICAgIHZhciBpLCBsZW4gPSBpdGVtc0RhdGEubGVuZ3RoLCBwYXRoO1xyXG4gICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICBpZihpdGVtc0RhdGFbaV0gJiYgaXRlbXNEYXRhW2ldLnNoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlU2hhcGVCb3VuZGluZ0JveChpdGVtc0RhdGFbaV0sIGJvdW5kaW5nQm94KVxyXG4gICAgICAgIH0gZWxzZSBpZihpdGVtc0RhdGFbaV0gJiYgaXRlbXNEYXRhW2ldLml0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRpbmdCb3goaXRlbXNEYXRhW2ldLml0LCBib3VuZGluZ0JveClcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbkhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmN1cnJlbnRCb3hDb250YWlucyA9IGZ1bmN0aW9uKGJveCkge1xyXG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEJCb3gueCA8PSBib3gueCBcclxuICAgICYmIHRoaXMuY3VycmVudEJCb3gueSA8PSBib3gueSBcclxuICAgICYmIHRoaXMuY3VycmVudEJCb3gud2lkdGggKyB0aGlzLmN1cnJlbnRCQm94LnggPj0gYm94LnggKyBib3gud2lkdGhcclxuICAgICYmIHRoaXMuY3VycmVudEJCb3guaGVpZ2h0ICsgdGhpcy5jdXJyZW50QkJveC55ID49IGJveC55ICsgYm94LmhlaWdodFxyXG59XHJcblxyXG5IU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuX3JlbmRlclNoYXBlRnJhbWUoKTtcclxuXHJcbiAgICBpZighdGhpcy5oaWRkZW4gJiYgKHRoaXMuX2lzRmlyc3RGcmFtZSB8fCB0aGlzLl9tZGYpKSB7XHJcbiAgICAgICAgdmFyIHRlbXBCb3VuZGluZ0JveCA9IHRoaXMudGVtcEJvdW5kaW5nQm94O1xyXG4gICAgICAgIHZhciBtYXggPSA5OTk5OTk7XHJcbiAgICAgICAgdGVtcEJvdW5kaW5nQm94LnggPSBtYXg7XHJcbiAgICAgICAgdGVtcEJvdW5kaW5nQm94LnhNYXggPSAtbWF4O1xyXG4gICAgICAgIHRlbXBCb3VuZGluZ0JveC55ID0gbWF4O1xyXG4gICAgICAgIHRlbXBCb3VuZGluZ0JveC55TWF4ID0gLW1heDtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kaW5nQm94KHRoaXMuaXRlbXNEYXRhLCB0ZW1wQm91bmRpbmdCb3gpO1xyXG4gICAgICAgIHRlbXBCb3VuZGluZ0JveC53aWR0aCA9IHRlbXBCb3VuZGluZ0JveC54TWF4IDwgdGVtcEJvdW5kaW5nQm94LnggPyAwIDogdGVtcEJvdW5kaW5nQm94LnhNYXggLSB0ZW1wQm91bmRpbmdCb3gueDtcclxuICAgICAgICB0ZW1wQm91bmRpbmdCb3guaGVpZ2h0ID0gdGVtcEJvdW5kaW5nQm94LnlNYXggPCB0ZW1wQm91bmRpbmdCb3gueSA/IDAgOiB0ZW1wQm91bmRpbmdCb3gueU1heCAtIHRlbXBCb3VuZGluZ0JveC55O1xyXG4gICAgICAgIC8vdmFyIHRlbXBCb3VuZGluZ0JveCA9IHRoaXMuc2hhcGVDb250LmdldEJCb3goKTtcclxuICAgICAgICBpZih0aGlzLmN1cnJlbnRCb3hDb250YWlucyh0ZW1wQm91bmRpbmdCb3gpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICBpZih0aGlzLmN1cnJlbnRCQm94LncgIT09IHRlbXBCb3VuZGluZ0JveC53aWR0aCl7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJCb3gudyA9IHRlbXBCb3VuZGluZ0JveC53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5zaGFwZUNvbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsdGVtcEJvdW5kaW5nQm94LndpZHRoKTtcclxuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMuY3VycmVudEJCb3guaCAhPT0gdGVtcEJvdW5kaW5nQm94LmhlaWdodCl7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJCb3guaCA9IHRlbXBCb3VuZGluZ0JveC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhcGVDb250LnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jyx0ZW1wQm91bmRpbmdCb3guaGVpZ2h0KTtcclxuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGNoYW5nZWQgIHx8IHRoaXMuY3VycmVudEJCb3gueCAhPT0gdGVtcEJvdW5kaW5nQm94LnggIHx8IHRoaXMuY3VycmVudEJCb3gueSAhPT0gdGVtcEJvdW5kaW5nQm94Lnkpe1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRCQm94LncgPSB0ZW1wQm91bmRpbmdCb3gud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJCb3guaCA9IHRlbXBCb3VuZGluZ0JveC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJCb3gueCA9IHRlbXBCb3VuZGluZ0JveC54O1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRCQm94LnkgPSB0ZW1wQm91bmRpbmdCb3gueTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuc2hhcGVDb250LnNldEF0dHJpYnV0ZSgndmlld0JveCcsdGhpcy5jdXJyZW50QkJveC54KycgJyt0aGlzLmN1cnJlbnRCQm94LnkrJyAnK3RoaXMuY3VycmVudEJCb3gudysnICcrdGhpcy5jdXJyZW50QkJveC5oKTtcclxuICAgICAgICAgICAgdGhpcy5zaGFwZUNvbnQuc3R5bGUudHJhbnNmb3JtID0gdGhpcy5zaGFwZUNvbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgdGhpcy5jdXJyZW50QkJveC54ICsgJ3B4LCcgKyB0aGlzLmN1cnJlbnRCQm94LnkgKyAncHgpJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59O1xuZnVuY3Rpb24gSFRleHRFbGVtZW50KGRhdGEsZ2xvYmFsRGF0YSxjb21wKXtcclxuICAgIHRoaXMudGV4dFNwYW5zID0gW107XHJcbiAgICB0aGlzLnRleHRQYXRocyA9IFtdO1xyXG4gICAgdGhpcy5jdXJyZW50QkJveCA9IHtcclxuICAgICAgICB4Ojk5OTk5OSxcclxuICAgICAgICB5OiAtOTk5OTk5LFxyXG4gICAgICAgIGg6IDAsXHJcbiAgICAgICAgdzogMFxyXG4gICAgfTtcclxuICAgIHRoaXMucmVuZGVyVHlwZSA9ICdzdmcnO1xyXG4gICAgdGhpcy5pc01hc2tlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLGdsb2JhbERhdGEsY29tcCk7XHJcblxyXG59XHJcbmV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsVHJhbnNmb3JtRWxlbWVudCxIQmFzZUVsZW1lbnQsSGllcmFyY2h5RWxlbWVudCxGcmFtZUVsZW1lbnQsUmVuZGVyYWJsZURPTUVsZW1lbnQsSVRleHRFbGVtZW50XSwgSFRleHRFbGVtZW50KTtcclxuXHJcbkhUZXh0RWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uKCl7XHJcbiAgICB0aGlzLmlzTWFza2VkID0gdGhpcy5jaGVja01hc2tzKCk7XHJcbiAgICBpZih0aGlzLmlzTWFza2VkKXtcclxuICAgICAgICB0aGlzLnJlbmRlclR5cGUgPSAnc3ZnJztcclxuICAgICAgICB0aGlzLmNvbXBXID0gdGhpcy5jb21wLmRhdGEudztcclxuICAgICAgICB0aGlzLmNvbXBIID0gdGhpcy5jb21wLmRhdGEuaDtcclxuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsdGhpcy5jb21wVyk7XHJcbiAgICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jyx0aGlzLmNvbXBIKTtcclxuICAgICAgICB2YXIgZyA9IGNyZWF0ZU5TKCdnJyk7XHJcbiAgICAgICAgdGhpcy5tYXNrZWRFbGVtZW50LmFwcGVuZENoaWxkKGcpO1xyXG4gICAgICAgIHRoaXMuaW5uZXJFbGVtID0gZztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJUeXBlID0gJ2h0bWwnO1xyXG4gICAgICAgIHRoaXMuaW5uZXJFbGVtID0gdGhpcy5sYXllckVsZW1lbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jaGVja1BhcmVudGluZygpO1xyXG5cclxufTtcclxuXHJcbkhUZXh0RWxlbWVudC5wcm90b3R5cGUuYnVpbGROZXdUZXh0ID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBkb2N1bWVudERhdGEgPSB0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YTtcclxuICAgIHRoaXMucmVuZGVyZWRMZXR0ZXJzID0gY3JlYXRlU2l6ZWRBcnJheShkb2N1bWVudERhdGEubCA/IGRvY3VtZW50RGF0YS5sLmxlbmd0aCA6IDApO1xyXG4gICAgdmFyIGlubmVyRWxlbVN0eWxlID0gdGhpcy5pbm5lckVsZW0uc3R5bGU7XHJcbiAgICBpbm5lckVsZW1TdHlsZS5jb2xvciA9IGlubmVyRWxlbVN0eWxlLmZpbGwgPSBkb2N1bWVudERhdGEuZmMgPyB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLmZjKSA6ICdyZ2JhKDAsMCwwLDApJztcclxuICAgIGlmKGRvY3VtZW50RGF0YS5zYyl7XHJcbiAgICAgICAgaW5uZXJFbGVtU3R5bGUuc3Ryb2tlID0gdGhpcy5idWlsZENvbG9yKGRvY3VtZW50RGF0YS5zYyk7XHJcbiAgICAgICAgaW5uZXJFbGVtU3R5bGUuc3Ryb2tlV2lkdGggPSBkb2N1bWVudERhdGEuc3crJ3B4JztcclxuICAgIH1cclxuICAgIHZhciBmb250RGF0YSA9IHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKTtcclxuICAgIGlmKCF0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuY2hhcnMpe1xyXG4gICAgICAgIGlubmVyRWxlbVN0eWxlLmZvbnRTaXplID0gZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSsncHgnO1xyXG4gICAgICAgIGlubmVyRWxlbVN0eWxlLmxpbmVIZWlnaHQgPSBkb2N1bWVudERhdGEuZmluYWxTaXplKydweCc7XHJcbiAgICAgICAgaWYoZm9udERhdGEuZkNsYXNzKXtcclxuICAgICAgICAgICAgdGhpcy5pbm5lckVsZW0uY2xhc3NOYW1lID0gZm9udERhdGEuZkNsYXNzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlubmVyRWxlbVN0eWxlLmZvbnRGYW1pbHkgPSBmb250RGF0YS5mRmFtaWx5O1xyXG4gICAgICAgICAgICB2YXIgZldlaWdodCA9IGRvY3VtZW50RGF0YS5mV2VpZ2h0LCBmU3R5bGUgPSBkb2N1bWVudERhdGEuZlN0eWxlO1xyXG4gICAgICAgICAgICBpbm5lckVsZW1TdHlsZS5mb250U3R5bGUgPSBmU3R5bGU7XHJcbiAgICAgICAgICAgIGlubmVyRWxlbVN0eWxlLmZvbnRXZWlnaHQgPSBmV2VpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBpLCBsZW47XHJcblxyXG4gICAgdmFyIGxldHRlcnMgPSBkb2N1bWVudERhdGEubDtcclxuICAgIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xyXG4gICAgdmFyIHRTcGFuLHRQYXJlbnQsdENvbnQ7XHJcbiAgICB2YXIgbWF0cml4SGVscGVyID0gdGhpcy5tSGVscGVyO1xyXG4gICAgdmFyIHNoYXBlcywgc2hhcGVTdHIgPSAnJztcclxuICAgIHZhciBjbnQgPSAwO1xyXG4gICAgZm9yIChpID0gMDtpIDwgbGVuIDtpICs9IDEpIHtcclxuICAgICAgICBpZih0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuY2hhcnMpe1xyXG4gICAgICAgICAgICBpZighdGhpcy50ZXh0UGF0aHNbY250XSl7XHJcbiAgICAgICAgICAgICAgICB0U3BhbiA9IGNyZWF0ZU5TKCdwYXRoJyk7XHJcbiAgICAgICAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgJ2J1dHQnKTtcclxuICAgICAgICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywncm91bmQnKTtcclxuICAgICAgICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW1pdGVybGltaXQnLCc0Jyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0U3BhbiA9IHRoaXMudGV4dFBhdGhzW2NudF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIXRoaXMuaXNNYXNrZWQpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy50ZXh0U3BhbnNbY250XSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdFBhcmVudCA9IHRoaXMudGV4dFNwYW5zW2NudF07XHJcbiAgICAgICAgICAgICAgICAgICAgdENvbnQgPSB0UGFyZW50LmNoaWxkcmVuWzBdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdFBhcmVudCA9IGNyZWF0ZVRhZygnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdENvbnQgPSBjcmVhdGVOUygnc3ZnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdENvbnQuYXBwZW5kQ2hpbGQodFNwYW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlRGl2KHRQYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIGlmKCF0aGlzLmlzTWFza2VkKXtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMudGV4dFNwYW5zW2NudF0pe1xyXG4gICAgICAgICAgICAgICAgICAgIHRQYXJlbnQgPSB0aGlzLnRleHRTcGFuc1tjbnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRTcGFuID0gdGhpcy50ZXh0UGF0aHNbY250XTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdFBhcmVudCA9IGNyZWF0ZVRhZygnc3BhbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlRGl2KHRQYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRTcGFuID0gY3JlYXRlVGFnKCdzcGFuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVEaXYodFNwYW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRQYXJlbnQuYXBwZW5kQ2hpbGQodFNwYW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdFNwYW4gPSB0aGlzLnRleHRQYXRoc1tjbnRdID8gdGhpcy50ZXh0UGF0aHNbY250XSA6IGNyZWF0ZU5TKCd0ZXh0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy90U3Bhbi5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XHJcbiAgICAgICAgaWYodGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzKXtcclxuICAgICAgICAgICAgdmFyIGNoYXJEYXRhID0gdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldENoYXJEYXRhKGRvY3VtZW50RGF0YS5maW5hbFRleHRbaV0sIGZvbnREYXRhLmZTdHlsZSwgdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpLmZGYW1pbHkpO1xyXG4gICAgICAgICAgICB2YXIgc2hhcGVEYXRhO1xyXG4gICAgICAgICAgICBpZihjaGFyRGF0YSl7XHJcbiAgICAgICAgICAgICAgICBzaGFwZURhdGEgPSBjaGFyRGF0YS5kYXRhO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2hhcGVEYXRhID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIucmVzZXQoKTtcclxuICAgICAgICAgICAgaWYoc2hhcGVEYXRhICYmIHNoYXBlRGF0YS5zaGFwZXMpe1xyXG4gICAgICAgICAgICAgICAgc2hhcGVzID0gc2hhcGVEYXRhLnNoYXBlc1swXS5pdDtcclxuICAgICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5zY2FsZShkb2N1bWVudERhdGEuZmluYWxTaXplLzEwMCxkb2N1bWVudERhdGEuZmluYWxTaXplLzEwMCk7XHJcbiAgICAgICAgICAgICAgICBzaGFwZVN0ciA9IHRoaXMuY3JlYXRlUGF0aFNoYXBlKG1hdHJpeEhlbHBlcixzaGFwZXMpO1xyXG4gICAgICAgICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdkJyxzaGFwZVN0cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIXRoaXMuaXNNYXNrZWQpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lckVsZW0uYXBwZW5kQ2hpbGQodFBhcmVudCk7XHJcbiAgICAgICAgICAgICAgICBpZihzaGFwZURhdGEgJiYgc2hhcGVEYXRhLnNoYXBlcyl7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCBpcyBuZWVkZWQgdG8gZ2V0IGV4YWN0IG1lYXN1cmUgb2Ygc2hhcGVcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRDb250KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSB0Q29udC5nZXRCQm94KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdENvbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsYm91bmRpbmdCb3gud2lkdGggKyAyKTtcclxuICAgICAgICAgICAgICAgICAgICB0Q29udC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsYm91bmRpbmdCb3guaGVpZ2h0ICsgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgdENvbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywoYm91bmRpbmdCb3gueC0xKSsnICcrIChib3VuZGluZ0JveC55LTEpKycgJysgKGJvdW5kaW5nQm94LndpZHRoKzIpKycgJysgKGJvdW5kaW5nQm94LmhlaWdodCsyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdENvbnQuc3R5bGUudHJhbnNmb3JtID0gdENvbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgKGJvdW5kaW5nQm94LngtMSkgKyAncHgsJyArIChib3VuZGluZ0JveC55LTEpICsgJ3B4KSc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldHRlcnNbaV0ueU9mZnNldCA9IGJvdW5kaW5nQm94LnktMTtcclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgdENvbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdENvbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHRQYXJlbnQuYXBwZW5kQ2hpbGQodENvbnQpO1xyXG4gICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJFbGVtLmFwcGVuZENoaWxkKHRTcGFuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0U3Bhbi50ZXh0Q29udGVudCA9IGxldHRlcnNbaV0udmFsO1xyXG4gICAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLCBcInhtbDpzcGFjZVwiLFwicHJlc2VydmVcIik7XHJcbiAgICAgICAgICAgIGlmKCF0aGlzLmlzTWFza2VkKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5uZXJFbGVtLmFwcGVuZENoaWxkKHRQYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIHRTcGFuLnN0eWxlLnRyYW5zZm9ybSA9IHRTcGFuLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgwLCcrIC1kb2N1bWVudERhdGEuZmluYWxTaXplLzEuMisncHgsMCknO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lckVsZW0uYXBwZW5kQ2hpbGQodFNwYW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgaWYoIXRoaXMuaXNNYXNrZWQpe1xyXG4gICAgICAgICAgICB0aGlzLnRleHRTcGFuc1tjbnRdID0gdFBhcmVudDtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgdGhpcy50ZXh0U3BhbnNbY250XSA9IHRTcGFuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRleHRTcGFuc1tjbnRdLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgIHRoaXMudGV4dFBhdGhzW2NudF0gPSB0U3BhbjtcclxuICAgICAgICBjbnQgKz0gMTtcclxuICAgIH1cclxuICAgIHdoaWxlKGNudCA8IHRoaXMudGV4dFNwYW5zLmxlbmd0aCl7XHJcbiAgICAgICAgdGhpcy50ZXh0U3BhbnNbY250XS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgIGNudCArPSAxO1xyXG4gICAgfVxyXG59O1xyXG5cclxuSFRleHRFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICBpZih0aGlzLmRhdGEuc2luZ2xlU2hhcGUpe1xyXG4gICAgICAgIGlmKCF0aGlzLl9pc0ZpcnN0RnJhbWUgJiYgIXRoaXMubGV0dGVyc0NoYW5nZWRGbGFnKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRvZG8gQmVuY2htYXJrIGlmIHVzaW5nIHRoaXMgaXMgYmV0dGVyIHRoYW4gZ2V0QkJveFxyXG4gICAgICAgICAgICAgaWYodGhpcy5pc01hc2tlZCAmJiB0aGlzLmZpbmFsVHJhbnNmb3JtLl9tYXRNZGYpe1xyXG4gICAgICAgICAgICAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLC10aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnAudlswXSsnICcrIC10aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnAudlsxXSsnICcrdGhpcy5jb21wVysnICcrdGhpcy5jb21wSCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gdGhpcy5zdmdFbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIC10aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLnAudlswXSArICdweCwnICsgLXRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3AucC52WzFdICsgJ3B4KSc7XHJcbiAgICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMudGV4dEFuaW1hdG9yLmdldE1lYXN1cmVzKHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLCB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyk7XHJcbiAgICBpZighdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgJiYgIXRoaXMudGV4dEFuaW1hdG9yLmxldHRlcnNDaGFuZ2VkRmxhZyl7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyICBpLGxlbiwgY291bnQgPSAwO1xyXG4gICAgdmFyIHJlbmRlcmVkTGV0dGVycyA9IHRoaXMudGV4dEFuaW1hdG9yLnJlbmRlcmVkTGV0dGVycztcclxuXHJcbiAgICB2YXIgbGV0dGVycyA9IHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmw7XHJcblxyXG4gICAgbGVuID0gbGV0dGVycy5sZW5ndGg7XHJcbiAgICB2YXIgcmVuZGVyZWRMZXR0ZXIsIHRleHRTcGFuLCB0ZXh0UGF0aDtcclxuICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgaWYobGV0dGVyc1tpXS5uKXtcclxuICAgICAgICAgICAgY291bnQgKz0gMTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRleHRTcGFuID0gdGhpcy50ZXh0U3BhbnNbaV07XHJcbiAgICAgICAgdGV4dFBhdGggPSB0aGlzLnRleHRQYXRoc1tpXTtcclxuICAgICAgICByZW5kZXJlZExldHRlciA9IHJlbmRlcmVkTGV0dGVyc1tjb3VudF07XHJcbiAgICAgICAgY291bnQgKz0gMTtcclxuICAgICAgICBpZihyZW5kZXJlZExldHRlci5fbWRmLm0pIHtcclxuICAgICAgICAgICAgaWYoIXRoaXMuaXNNYXNrZWQpe1xyXG4gICAgICAgICAgICAgICAgdGV4dFNwYW4uc3R5bGUudHJhbnNmb3JtID0gdGV4dFNwYW4uc3R5bGUud2Via2l0VHJhbnNmb3JtID0gcmVuZGVyZWRMZXR0ZXIubTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScscmVuZGVyZWRMZXR0ZXIubSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8vL3RleHRTcGFuLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScscmVuZGVyZWRMZXR0ZXIubyk7XHJcbiAgICAgICAgdGV4dFNwYW4uc3R5bGUub3BhY2l0eSA9IHJlbmRlcmVkTGV0dGVyLm87XHJcbiAgICAgICAgaWYocmVuZGVyZWRMZXR0ZXIuc3cgJiYgcmVuZGVyZWRMZXR0ZXIuX21kZi5zdyl7XHJcbiAgICAgICAgICAgIHRleHRQYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJyxyZW5kZXJlZExldHRlci5zdyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHJlbmRlcmVkTGV0dGVyLnNjICYmIHJlbmRlcmVkTGV0dGVyLl9tZGYuc2Mpe1xyXG4gICAgICAgICAgICB0ZXh0UGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScscmVuZGVyZWRMZXR0ZXIuc2MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihyZW5kZXJlZExldHRlci5mYyAmJiByZW5kZXJlZExldHRlci5fbWRmLmZjKXtcclxuICAgICAgICAgICAgdGV4dFBhdGguc2V0QXR0cmlidXRlKCdmaWxsJyxyZW5kZXJlZExldHRlci5mYyk7XHJcbiAgICAgICAgICAgIHRleHRQYXRoLnN0eWxlLmNvbG9yID0gcmVuZGVyZWRMZXR0ZXIuZmM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmKHRoaXMuaW5uZXJFbGVtLmdldEJCb3ggJiYgIXRoaXMuaGlkZGVuICYmICh0aGlzLl9pc0ZpcnN0RnJhbWUgfHwgdGhpcy5fbWRmKSl7XHJcbiAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gdGhpcy5pbm5lckVsZW0uZ2V0QkJveCgpO1xyXG5cclxuICAgICAgICBpZih0aGlzLmN1cnJlbnRCQm94LncgIT09IGJvdW5kaW5nQm94LndpZHRoKXtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QkJveC53ID0gYm91bmRpbmdCb3gud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyxib3VuZGluZ0JveC53aWR0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMuY3VycmVudEJCb3guaCAhPT0gYm91bmRpbmdCb3guaGVpZ2h0KXtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QkJveC5oID0gYm91bmRpbmdCb3guaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLGJvdW5kaW5nQm94LmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgbWFyZ2luID0gMTtcclxuICAgICAgICBpZih0aGlzLmN1cnJlbnRCQm94LncgIT09IChib3VuZGluZ0JveC53aWR0aCArIG1hcmdpbioyKSB8fCB0aGlzLmN1cnJlbnRCQm94LmggIT09IChib3VuZGluZ0JveC5oZWlnaHQgKyBtYXJnaW4qMikgIHx8IHRoaXMuY3VycmVudEJCb3gueCAhPT0gKGJvdW5kaW5nQm94LnggLSBtYXJnaW4pICB8fCB0aGlzLmN1cnJlbnRCQm94LnkgIT09IChib3VuZGluZ0JveC55IC0gbWFyZ2luKSl7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJCb3gudyA9IGJvdW5kaW5nQm94LndpZHRoICsgbWFyZ2luKjI7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJCb3guaCA9IGJvdW5kaW5nQm94LmhlaWdodCArIG1hcmdpbioyO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRCQm94LnggPSBib3VuZGluZ0JveC54IC0gbWFyZ2luO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRCQm94LnkgPSBib3VuZGluZ0JveC55IC0gbWFyZ2luO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsdGhpcy5jdXJyZW50QkJveC54KycgJyt0aGlzLmN1cnJlbnRCQm94LnkrJyAnK3RoaXMuY3VycmVudEJCb3gudysnICcrdGhpcy5jdXJyZW50QkJveC5oKTtcclxuICAgICAgICAgICAgdGhpcy5zdmdFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRoaXMuc3ZnRWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcgKyB0aGlzLmN1cnJlbnRCQm94LnggKyAncHgsJyArIHRoaXMuY3VycmVudEJCb3gueSArICdweCknO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcbmZ1bmN0aW9uIEhJbWFnZUVsZW1lbnQoZGF0YSxnbG9iYWxEYXRhLGNvbXApe1xyXG4gICAgdGhpcy5hc3NldERhdGEgPSBnbG9iYWxEYXRhLmdldEFzc2V0RGF0YShkYXRhLnJlZklkKTtcclxuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSxnbG9iYWxEYXRhLGNvbXApO1xyXG59XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LFRyYW5zZm9ybUVsZW1lbnQsSEJhc2VFbGVtZW50LEhTb2xpZEVsZW1lbnQsSGllcmFyY2h5RWxlbWVudCxGcmFtZUVsZW1lbnQsUmVuZGVyYWJsZUVsZW1lbnRdLCBISW1hZ2VFbGVtZW50KTtcclxuXHJcblxyXG5ISW1hZ2VFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24oKXtcclxuICAgIHZhciBhc3NldFBhdGggPSB0aGlzLmdsb2JhbERhdGEuZ2V0QXNzZXRzUGF0aCh0aGlzLmFzc2V0RGF0YSk7XHJcbiAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XHJcblxyXG4gICAgaWYodGhpcy5kYXRhLmhhc01hc2spe1xyXG4gICAgICAgIHRoaXMuaW1hZ2VFbGVtID0gY3JlYXRlTlMoJ2ltYWdlJyk7XHJcbiAgICAgICAgdGhpcy5pbWFnZUVsZW0uc2V0QXR0cmlidXRlKCd3aWR0aCcsdGhpcy5hc3NldERhdGEudytcInB4XCIpO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VFbGVtLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jyx0aGlzLmFzc2V0RGF0YS5oK1wicHhcIik7XHJcbiAgICAgICAgdGhpcy5pbWFnZUVsZW0uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCdocmVmJyxhc3NldFBhdGgpO1xyXG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuaW1hZ2VFbGVtKTtcclxuICAgICAgICB0aGlzLmJhc2VFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLHRoaXMuYXNzZXREYXRhLncpO1xyXG4gICAgICAgIHRoaXMuYmFzZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLHRoaXMuYXNzZXREYXRhLmgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChpbWcpO1xyXG4gICAgfVxyXG4gICAgaW1nLnNyYyA9IGFzc2V0UGF0aDtcclxuICAgIGlmKHRoaXMuZGF0YS5sbil7XHJcbiAgICAgICAgdGhpcy5iYXNlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJyx0aGlzLmRhdGEubG4pO1xyXG4gICAgfVxyXG59O1xuZnVuY3Rpb24gSENhbWVyYUVsZW1lbnQoZGF0YSxnbG9iYWxEYXRhLGNvbXApe1xyXG4gICAgdGhpcy5pbml0RnJhbWUoKTtcclxuICAgIHRoaXMuaW5pdEJhc2VEYXRhKGRhdGEsZ2xvYmFsRGF0YSxjb21wKTtcclxuICAgIHRoaXMuaW5pdEhpZXJhcmNoeSgpO1xyXG4gICAgdmFyIGdldFByb3AgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcDtcclxuICAgIHRoaXMucGUgPSBnZXRQcm9wKHRoaXMsZGF0YS5wZSwwLDAsdGhpcyk7XHJcbiAgICBpZihkYXRhLmtzLnAucyl7XHJcbiAgICAgICAgdGhpcy5weCA9IGdldFByb3AodGhpcyxkYXRhLmtzLnAueCwxLDAsdGhpcyk7XHJcbiAgICAgICAgdGhpcy5weSA9IGdldFByb3AodGhpcyxkYXRhLmtzLnAueSwxLDAsdGhpcyk7XHJcbiAgICAgICAgdGhpcy5weiA9IGdldFByb3AodGhpcyxkYXRhLmtzLnAueiwxLDAsdGhpcyk7XHJcbiAgICB9ZWxzZXtcclxuICAgICAgICB0aGlzLnAgPSBnZXRQcm9wKHRoaXMsZGF0YS5rcy5wLDEsMCx0aGlzKTtcclxuICAgIH1cclxuICAgIGlmKGRhdGEua3MuYSl7XHJcbiAgICAgICAgdGhpcy5hID0gZ2V0UHJvcCh0aGlzLGRhdGEua3MuYSwxLDAsdGhpcyk7XHJcbiAgICB9XHJcbiAgICBpZihkYXRhLmtzLm9yLmsubGVuZ3RoICYmIGRhdGEua3Mub3Iua1swXS50byl7XHJcbiAgICAgICAgdmFyIGksbGVuID0gZGF0YS5rcy5vci5rLmxlbmd0aDtcclxuICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICBkYXRhLmtzLm9yLmtbaV0udG8gPSBudWxsO1xyXG4gICAgICAgICAgICBkYXRhLmtzLm9yLmtbaV0udGkgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRoaXMub3IgPSBnZXRQcm9wKHRoaXMsZGF0YS5rcy5vciwxLGRlZ1RvUmFkcyx0aGlzKTtcclxuICAgIHRoaXMub3Iuc2ggPSB0cnVlO1xyXG4gICAgdGhpcy5yeCA9IGdldFByb3AodGhpcyxkYXRhLmtzLnJ4LDAsZGVnVG9SYWRzLHRoaXMpO1xyXG4gICAgdGhpcy5yeSA9IGdldFByb3AodGhpcyxkYXRhLmtzLnJ5LDAsZGVnVG9SYWRzLHRoaXMpO1xyXG4gICAgdGhpcy5yeiA9IGdldFByb3AodGhpcyxkYXRhLmtzLnJ6LDAsZGVnVG9SYWRzLHRoaXMpO1xyXG4gICAgdGhpcy5tYXQgPSBuZXcgTWF0cml4KCk7XHJcbiAgICB0aGlzLl9wcmV2TWF0ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcclxufVxyXG5leHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBGcmFtZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnRdLCBIQ2FtZXJhRWxlbWVudCk7XHJcblxyXG5IQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbigpIHtcclxuICAgIHZhciBpLCBsZW4gPSB0aGlzLmNvbXAudGhyZWVERWxlbWVudHMubGVuZ3RoLCBjb21wO1xyXG4gICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAvL1twZXJzcGVjdGl2ZUVsZW0sY29udGFpbmVyXVxyXG4gICAgICAgIGNvbXAgPSB0aGlzLmNvbXAudGhyZWVERWxlbWVudHNbaV07XHJcbiAgICAgICAgaWYoY29tcC50eXBlID09PSAnM2QnKSB7XHJcbiAgICAgICAgICAgIGNvbXAucGVyc3BlY3RpdmVFbGVtLnN0eWxlLnBlcnNwZWN0aXZlID0gY29tcC5wZXJzcGVjdGl2ZUVsZW0uc3R5bGUud2Via2l0UGVyc3BlY3RpdmUgPSB0aGlzLnBlLnYrJ3B4JztcclxuICAgICAgICAgICAgY29tcC5jb250YWluZXIuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gY29tcC5jb250YWluZXIuc3R5bGUubW96VHJhbnNmb3JtT3JpZ2luID0gY29tcC5jb250YWluZXIuc3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gXCIwcHggMHB4IDBweFwiO1xyXG4gICAgICAgICAgICBjb21wLnBlcnNwZWN0aXZlRWxlbS5zdHlsZS50cmFuc2Zvcm0gPSBjb21wLnBlcnNwZWN0aXZlRWxlbS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnbWF0cml4M2QoMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMSknO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXHJcbkhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50cyA9IGZ1bmN0aW9uKCl7XHJcbn07XHJcblxyXG5IQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKCl7XHJcbn07XHJcblxyXG5IQ2FtZXJhRWxlbWVudC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIF9tZGYgPSB0aGlzLl9pc0ZpcnN0RnJhbWU7XHJcbiAgICB2YXIgaSwgbGVuO1xyXG4gICAgaWYodGhpcy5oaWVyYXJjaHkpe1xyXG4gICAgICAgIGxlbiA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDtcclxuICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICBfbWRmID0gdGhpcy5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3AuX21kZiB8fCBfbWRmO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmKF9tZGYgfHwgdGhpcy5wZS5fbWRmIHx8ICh0aGlzLnAgJiYgdGhpcy5wLl9tZGYpIHx8ICh0aGlzLnB4ICYmICh0aGlzLnB4Ll9tZGYgfHwgdGhpcy5weS5fbWRmIHx8IHRoaXMucHouX21kZikpIHx8IHRoaXMucnguX21kZiB8fCB0aGlzLnJ5Ll9tZGYgfHwgdGhpcy5yei5fbWRmIHx8IHRoaXMub3IuX21kZiB8fCAodGhpcy5hICYmIHRoaXMuYS5fbWRmKSkge1xyXG4gICAgICAgIHRoaXMubWF0LnJlc2V0KCk7XHJcblxyXG4gICAgICAgIGlmKHRoaXMuaGllcmFyY2h5KXtcclxuICAgICAgICAgICAgdmFyIG1hdDtcclxuICAgICAgICAgICAgbGVuID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgZm9yIChpID0gbGVuOyBpID49IDA7IGkgLT0gMSkge1xyXG4gICAgICAgICAgICAgICAgLyptYXQgPSB0aGlzLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcC52LnByb3BzO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobWF0KVxyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXQudHJhbnNmb3JtKC1tYXRbMF0sLW1hdFsxXSwtbWF0WzJdLC1tYXRbM10sLW1hdFs0XSwtbWF0WzVdLC1tYXRbNl0sLW1hdFs3XSwtbWF0WzhdLC1tYXRbOV0sLW1hdFsxMF0sLW1hdFsxMV0sLW1hdFsxMl0sLW1hdFsxM10sLW1hdFsxNF0sbWF0WzE1XSk7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLm1hdC5wcm9wcykqL1xyXG4gICAgICAgICAgICAgICAgdmFyIG1UcmFuc2YgPSB0aGlzLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcDtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZSgtbVRyYW5zZi5wLnZbMF0sLW1UcmFuc2YucC52WzFdLG1UcmFuc2YucC52WzJdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF0LnJvdGF0ZVgoLW1UcmFuc2Yub3IudlswXSkucm90YXRlWSgtbVRyYW5zZi5vci52WzFdKS5yb3RhdGVaKG1UcmFuc2Yub3IudlsyXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdC5yb3RhdGVYKC1tVHJhbnNmLnJ4LnYpLnJvdGF0ZVkoLW1UcmFuc2Yucnkudikucm90YXRlWihtVHJhbnNmLnJ6LnYpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXQuc2NhbGUoMS9tVHJhbnNmLnMudlswXSwxL21UcmFuc2Yucy52WzFdLDEvbVRyYW5zZi5zLnZbMl0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXQudHJhbnNsYXRlKG1UcmFuc2YuYS52WzBdLG1UcmFuc2YuYS52WzFdLG1UcmFuc2YuYS52WzJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5wKXtcclxuICAgICAgICAgICAgdGhpcy5tYXQudHJhbnNsYXRlKC10aGlzLnAudlswXSwtdGhpcy5wLnZbMV0sdGhpcy5wLnZbMl0pO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB0aGlzLm1hdC50cmFuc2xhdGUoLXRoaXMucHgudiwtdGhpcy5weS52LHRoaXMucHoudik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKHRoaXMuYSl7XHJcbiAgICAgICAgICAgIHZhciBkaWZmVmVjdG9yID0gW3RoaXMucC52WzBdLXRoaXMuYS52WzBdLHRoaXMucC52WzFdLXRoaXMuYS52WzFdLHRoaXMucC52WzJdLXRoaXMuYS52WzJdXTtcclxuICAgICAgICAgICAgdmFyIG1hZyA9IE1hdGguc3FydChNYXRoLnBvdyhkaWZmVmVjdG9yWzBdLDIpK01hdGgucG93KGRpZmZWZWN0b3JbMV0sMikrTWF0aC5wb3coZGlmZlZlY3RvclsyXSwyKSk7XHJcbiAgICAgICAgICAgIC8vdmFyIGxvb2tEaXIgPSBnZXROb3JtYWxpemVkUG9pbnQoZ2V0RGlmZlZlY3Rvcih0aGlzLmEudix0aGlzLnAudikpO1xyXG4gICAgICAgICAgICB2YXIgbG9va0RpciA9IFtkaWZmVmVjdG9yWzBdL21hZyxkaWZmVmVjdG9yWzFdL21hZyxkaWZmVmVjdG9yWzJdL21hZ107XHJcbiAgICAgICAgICAgIHZhciBsb29rTGVuZ3RoT25YWiA9IE1hdGguc3FydCggbG9va0RpclsyXSpsb29rRGlyWzJdICsgbG9va0RpclswXSpsb29rRGlyWzBdICk7XHJcbiAgICAgICAgICAgIHZhciBtX3JvdGF0aW9uWCA9IChNYXRoLmF0YW4yKCBsb29rRGlyWzFdLCBsb29rTGVuZ3RoT25YWiApKTtcclxuICAgICAgICAgICAgdmFyIG1fcm90YXRpb25ZID0gKE1hdGguYXRhbjIoIGxvb2tEaXJbMF0sIC1sb29rRGlyWzJdKSk7XHJcbiAgICAgICAgICAgIHRoaXMubWF0LnJvdGF0ZVkobV9yb3RhdGlvblkpLnJvdGF0ZVgoLW1fcm90YXRpb25YKTtcclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWF0LnJvdGF0ZVgoLXRoaXMucngudikucm90YXRlWSgtdGhpcy5yeS52KS5yb3RhdGVaKHRoaXMucnoudik7XHJcbiAgICAgICAgdGhpcy5tYXQucm90YXRlWCgtdGhpcy5vci52WzBdKS5yb3RhdGVZKC10aGlzLm9yLnZbMV0pLnJvdGF0ZVoodGhpcy5vci52WzJdKTtcclxuICAgICAgICB0aGlzLm1hdC50cmFuc2xhdGUodGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLncvMix0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaC8yLDApO1xyXG4gICAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZSgwLDAsdGhpcy5wZS52KTtcclxuXHJcblxyXG4gICAgICAgIFxyXG5cclxuICAgICAgICB2YXIgaGFzTWF0cml4Q2hhbmdlZCA9ICF0aGlzLl9wcmV2TWF0LmVxdWFscyh0aGlzLm1hdCk7XHJcbiAgICAgICAgaWYoKGhhc01hdHJpeENoYW5nZWQgfHwgdGhpcy5wZS5fbWRmKSAmJiB0aGlzLmNvbXAudGhyZWVERWxlbWVudHMpIHtcclxuICAgICAgICAgICAgbGVuID0gdGhpcy5jb21wLnRocmVlREVsZW1lbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGNvbXA7XHJcbiAgICAgICAgICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5jb21wLnRocmVlREVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYoY29tcC50eXBlID09PSAnM2QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaGFzTWF0cml4Q2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wLmNvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm0gPSBjb21wLmNvbnRhaW5lci5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0aGlzLm1hdC50b0NTUygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLnBlLl9tZGYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcC5wZXJzcGVjdGl2ZUVsZW0uc3R5bGUucGVyc3BlY3RpdmUgPSBjb21wLnBlcnNwZWN0aXZlRWxlbS5zdHlsZS53ZWJraXRQZXJzcGVjdGl2ZSA9IHRoaXMucGUudisncHgnO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm1hdC5jbG9uZSh0aGlzLl9wcmV2TWF0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcclxufTtcclxuXHJcbkhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBmdW5jdGlvbihudW0pIHtcclxuICAgIHRoaXMucHJlcGFyZVByb3BlcnRpZXMobnVtLCB0cnVlKTtcclxufTtcclxuXHJcbkhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcclxufTtcclxuSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLmluaXRFeHByZXNzaW9ucyA9IGZ1bmN0aW9uKCl7fTtcclxuSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLmdldEJhc2VFbGVtZW50ID0gZnVuY3Rpb24oKXtyZXR1cm4gbnVsbDt9O1xuZnVuY3Rpb24gSEVmZmVjdHMoKSB7XHJcbn1cclxuSEVmZmVjdHMucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24oKXt9O1xudmFyIEV4cHJlc3Npb25zID0gKGZ1bmN0aW9uKCl7XHJcbiAgICB2YXIgb2IgPSB7fTtcclxuICAgIG9iLmluaXRFeHByZXNzaW9ucyA9IGluaXRFeHByZXNzaW9ucztcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gaW5pdEV4cHJlc3Npb25zKGFuaW1hdGlvbil7XHJcbiAgICAgICAgYW5pbWF0aW9uLnJlbmRlcmVyLmNvbXBJbnRlcmZhY2UgPSBDb21wRXhwcmVzc2lvbkludGVyZmFjZShhbmltYXRpb24ucmVuZGVyZXIpO1xyXG4gICAgICAgIGFuaW1hdGlvbi5yZW5kZXJlci5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UucmVnaXN0ZXJDb21wb3NpdGlvbihhbmltYXRpb24ucmVuZGVyZXIpO1xyXG4gICAgfVxyXG4gICByZXR1cm4gb2I7XHJcbn0oKSk7XHJcblxyXG5leHByZXNzaW9uc1BsdWdpbiA9IEV4cHJlc3Npb25zO1xyXG5cbnZhciBFeHByZXNzaW9uTWFuYWdlciA9IChmdW5jdGlvbigpe1xyXG4gICAgJ3VzZSBzdHJpY3QnO1xyXG4gICAgdmFyIG9iID0ge307XHJcbiAgICB2YXIgTWF0aCA9IEJNTWF0aDtcclxuICAgIHZhciB3aW5kb3cgPSBudWxsO1xyXG4gICAgdmFyIGRvY3VtZW50ID0gbnVsbDtcclxuXHJcbiAgICBmdW5jdGlvbiAkYm1faXNJbnN0YW5jZU9mQXJyYXkoYXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIGFyci5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgfHwgYXJyLmNvbnN0cnVjdG9yID09PSBGbG9hdDMyQXJyYXk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNOdW1lcmFibGUodE9mViwgdikge1xyXG4gICAgICAgIHJldHVybiB0T2ZWID09PSAnbnVtYmVyJyB8fCB0T2ZWID09PSAnYm9vbGVhbicgfHwgdE9mViA9PT0gJ3N0cmluZycgfHwgdiBpbnN0YW5jZW9mIE51bWJlcjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiAkYm1fbmVnKGEpe1xyXG4gICAgICAgIHZhciB0T2ZBID0gdHlwZW9mIGE7XHJcbiAgICAgICAgaWYodE9mQSA9PT0gJ251bWJlcicgfHwgdE9mQSA9PT0gJ2Jvb2xlYW4nICB8fCBhIGluc3RhbmNlb2YgTnVtYmVyICl7XHJcbiAgICAgICAgICAgIHJldHVybiAtYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpKXtcclxuICAgICAgICAgICAgdmFyIGksIGxlbkEgPSBhLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIHJldEFyciA9IFtdO1xyXG4gICAgICAgICAgICBmb3IoaT0wO2k8bGVuQTtpKz0xKXtcclxuICAgICAgICAgICAgICAgIHJldEFycltpXSA9IC1hW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN1bShhLGIpIHtcclxuICAgICAgICB2YXIgdE9mQSA9IHR5cGVvZiBhO1xyXG4gICAgICAgIHZhciB0T2ZCID0gdHlwZW9mIGI7XHJcbiAgICAgICAgaWYodE9mQSA9PT0gJ3N0cmluZycgfHwgdE9mQiA9PT0gJ3N0cmluZycpe1xyXG4gICAgICAgICAgICByZXR1cm4gYSArIGI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhICsgYjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKXtcclxuICAgICAgICAgICAgYSA9IGEuc2xpY2UoMCk7XHJcbiAgICAgICAgICAgIGFbMF0gPSBhWzBdICsgYjtcclxuICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSl7XHJcbiAgICAgICAgICAgIGIgPSBiLnNsaWNlKDApO1xyXG4gICAgICAgICAgICBiWzBdID0gYSArIGJbMF07XHJcbiAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZigkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgJGJtX2lzSW5zdGFuY2VPZkFycmF5KGIpKXtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBpID0gMCwgbGVuQSA9IGEubGVuZ3RoLCBsZW5CID0gYi5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciByZXRBcnIgPSBbXTtcclxuICAgICAgICAgICAgd2hpbGUoaTxsZW5BIHx8IGkgPCBsZW5CKXtcclxuICAgICAgICAgICAgICAgIGlmKCh0eXBlb2YgYVtpXSA9PT0gJ251bWJlcicgfHwgYVtpXSBpbnN0YW5jZW9mIE51bWJlcikgJiYgKHR5cGVvZiBiW2ldID09PSAnbnVtYmVyJyB8fCBiW2ldIGluc3RhbmNlb2YgTnVtYmVyKSl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0QXJyW2ldID0gYVtpXSArIGJbaV07XHJcbiAgICAgICAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICByZXRBcnJbaV0gPSBiW2ldID09PSB1bmRlZmluZWQgPyBhW2ldIDogYVtpXSB8fCBiW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXRBcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgdmFyIGFkZCA9IHN1bTtcclxuXHJcbiAgICBmdW5jdGlvbiBzdWIoYSxiKSB7XHJcbiAgICAgICAgdmFyIHRPZkEgPSB0eXBlb2YgYTtcclxuICAgICAgICB2YXIgdE9mQiA9IHR5cGVvZiBiO1xyXG4gICAgICAgIGlmKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XHJcbiAgICAgICAgICAgIGlmKHRPZkEgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBhID0gcGFyc2VJbnQoYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYodE9mQiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBwYXJzZUludChiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYSAtIGI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKCAkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpe1xyXG4gICAgICAgICAgICBhID0gYS5zbGljZSgwKTtcclxuICAgICAgICAgICAgYVswXSA9IGFbMF0gLSBiO1xyXG4gICAgICAgICAgICByZXR1cm4gYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSl7XHJcbiAgICAgICAgICAgIGIgPSBiLnNsaWNlKDApO1xyXG4gICAgICAgICAgICBiWzBdID0gYSAtIGJbMF07XHJcbiAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZigkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgJGJtX2lzSW5zdGFuY2VPZkFycmF5KGIpKXtcclxuICAgICAgICAgICAgdmFyIGkgPSAwLCBsZW5BID0gYS5sZW5ndGgsIGxlbkIgPSBiLmxlbmd0aDtcclxuICAgICAgICAgICAgdmFyIHJldEFyciA9IFtdO1xyXG4gICAgICAgICAgICB3aGlsZShpPGxlbkEgfHwgaSA8IGxlbkIpe1xyXG4gICAgICAgICAgICAgICAgaWYoKHR5cGVvZiBhW2ldID09PSAnbnVtYmVyJyB8fCBhW2ldIGluc3RhbmNlb2YgTnVtYmVyKSAmJiAodHlwZW9mIGJbaV0gPT09ICdudW1iZXInIHx8IGJbaV0gaW5zdGFuY2VvZiBOdW1iZXIpKXtcclxuICAgICAgICAgICAgICAgICAgICByZXRBcnJbaV0gPSBhW2ldIC0gYltpXTtcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIHJldEFycltpXSA9IGJbaV0gPT09IHVuZGVmaW5lZCA/IGFbaV0gOiBhW2ldIHx8IGJbaV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldEFycjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbXVsKGEsYikge1xyXG4gICAgICAgIHZhciB0T2ZBID0gdHlwZW9mIGE7XHJcbiAgICAgICAgdmFyIHRPZkIgPSB0eXBlb2YgYjtcclxuICAgICAgICB2YXIgYXJyO1xyXG4gICAgICAgIGlmKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhICogYjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHZhciBpLCBsZW47XHJcbiAgICAgICAgaWYoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKXtcclxuICAgICAgICAgICAgbGVuID0gYS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xyXG4gICAgICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICAgICAgYXJyW2ldID0gYVtpXSAqIGI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFycjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoaXNOdW1lcmFibGUodE9mQSwgYSkgJiYgJGJtX2lzSW5zdGFuY2VPZkFycmF5KGIpKXtcclxuICAgICAgICAgICAgbGVuID0gYi5sZW5ndGg7XHJcbiAgICAgICAgICAgIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xyXG4gICAgICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICAgICAgYXJyW2ldID0gYSAqIGJbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFycjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGl2KGEsYikge1xyXG4gICAgICAgIHZhciB0T2ZBID0gdHlwZW9mIGE7XHJcbiAgICAgICAgdmFyIHRPZkIgPSB0eXBlb2YgYjtcclxuICAgICAgICB2YXIgYXJyO1xyXG4gICAgICAgIGlmKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhIC8gYjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGksIGxlbjtcclxuICAgICAgICBpZigkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgaXNOdW1lcmFibGUodE9mQiwgYikpe1xyXG4gICAgICAgICAgICBsZW4gPSBhLmxlbmd0aDtcclxuICAgICAgICAgICAgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XHJcbiAgICAgICAgICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSBhW2ldIC8gYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZihpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiAkYm1faXNJbnN0YW5jZU9mQXJyYXkoYikpe1xyXG4gICAgICAgICAgICBsZW4gPSBiLmxlbmd0aDtcclxuICAgICAgICAgICAgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XHJcbiAgICAgICAgICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSBhIC8gYltpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1vZChhLGIpIHtcclxuICAgICAgICBpZih0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgYSA9IHBhcnNlSW50KGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0eXBlb2YgYiA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgYiA9IHBhcnNlSW50KGIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYSAlIGI7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2xhbXAobnVtLCBtaW4sIG1heCkge1xyXG4gICAgICAgIGlmKG1pbiA+IG1heCl7XHJcbiAgICAgICAgICAgIHZhciBtbSA9IG1heDtcclxuICAgICAgICAgICAgbWF4ID0gbWluO1xyXG4gICAgICAgICAgICBtaW4gPSBtbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG51bSwgbWluKSwgbWF4KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByYWRpYW5zVG9EZWdyZWVzKHZhbCkge1xyXG4gICAgICAgIHJldHVybiB2YWwvZGVnVG9SYWRzO1xyXG4gICAgfVxyXG4gICAgdmFyIHJhZGlhbnNfdG9fZGVncmVlcyA9IHJhZGlhbnNUb0RlZ3JlZXM7XHJcblxyXG4gICAgZnVuY3Rpb24gZGVncmVlc1RvUmFkaWFucyh2YWwpIHtcclxuICAgICAgICByZXR1cm4gdmFsKmRlZ1RvUmFkcztcclxuICAgIH1cclxuICAgIHZhciBkZWdyZWVzX3RvX3JhZGlhbnMgPSByYWRpYW5zVG9EZWdyZWVzO1xyXG5cclxuICAgIHZhciBoZWxwZXJMZW5ndGhBcnJheSA9IFswLDAsMCwwLDAsMF07XHJcblxyXG4gICAgZnVuY3Rpb24gbGVuZ3RoKGFycjEsIGFycjIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGFycjEgPT09ICdudW1iZXInIHx8IGFycjEgaW5zdGFuY2VvZiBOdW1iZXIpIHtcclxuICAgICAgICAgICAgYXJyMiA9IGFycjIgfHwgMDtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGFycjEgLSBhcnIyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoIWFycjIpIHtcclxuICAgICAgICAgICAgYXJyMiA9IGhlbHBlckxlbmd0aEFycmF5O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaSwgbGVuID0gTWF0aC5taW4oYXJyMS5sZW5ndGgsIGFycjIubGVuZ3RoKTtcclxuICAgICAgICB2YXIgYWRkZWRMZW5ndGggPSAwO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBhZGRlZExlbmd0aCArPSBNYXRoLnBvdyhhcnIyW2ldIC0gYXJyMVtpXSwgMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoYWRkZWRMZW5ndGgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZSh2ZWMpIHtcclxuICAgICAgICByZXR1cm4gZGl2KHZlYywgbGVuZ3RoKHZlYykpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJnYlRvSHNsKHZhbCkge1xyXG4gICAgICAgIHZhciByID0gdmFsWzBdOyB2YXIgZyA9IHZhbFsxXTsgdmFyIGIgPSB2YWxbMl07XHJcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcclxuICAgICAgICB2YXIgaCwgcywgbCA9IChtYXggKyBtaW4pIC8gMjtcclxuXHJcbiAgICAgICAgaWYobWF4ID09IG1pbil7XHJcbiAgICAgICAgICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICB2YXIgZCA9IG1heCAtIG1pbjtcclxuICAgICAgICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xyXG4gICAgICAgICAgICBzd2l0Y2gobWF4KXtcclxuICAgICAgICAgICAgICAgIGNhc2UgcjogaCA9IChnIC0gYikgLyBkICsgKGcgPCBiID8gNiA6IDApOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgZzogaCA9IChiIC0gcikgLyBkICsgMjsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGI6IGggPSAociAtIGcpIC8gZCArIDQ7IGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGggLz0gNjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBbaCwgcywgbCx2YWxbM11dO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCl7XHJcbiAgICAgICAgaWYodCA8IDApIHQgKz0gMTtcclxuICAgICAgICBpZih0ID4gMSkgdCAtPSAxO1xyXG4gICAgICAgIGlmKHQgPCAxLzYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xyXG4gICAgICAgIGlmKHQgPCAxLzIpIHJldHVybiBxO1xyXG4gICAgICAgIGlmKHQgPCAyLzMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyLzMgLSB0KSAqIDY7XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaHNsVG9SZ2IodmFsKXtcclxuICAgICAgICB2YXIgaCA9IHZhbFswXTtcclxuICAgICAgICB2YXIgcyA9IHZhbFsxXTtcclxuICAgICAgICB2YXIgbCA9IHZhbFsyXTtcclxuXHJcbiAgICAgICAgdmFyIHIsIGcsIGI7XHJcblxyXG4gICAgICAgIGlmKHMgPT09IDApe1xyXG4gICAgICAgICAgICByID0gZyA9IGIgPSBsOyAvLyBhY2hyb21hdGljXHJcbiAgICAgICAgfWVsc2V7XHJcblxyXG4gICAgICAgICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XHJcbiAgICAgICAgICAgIHZhciBwID0gMiAqIGwgLSBxO1xyXG4gICAgICAgICAgICByID0gaHVlMnJnYihwLCBxLCBoICsgMS8zKTtcclxuICAgICAgICAgICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XHJcbiAgICAgICAgICAgIGIgPSBodWUycmdiKHAsIHEsIGggLSAxLzMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIFtyLCBnICwgYiwgdmFsWzNdXTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBsaW5lYXIodCwgdE1pbiwgdE1heCwgdmFsdWUxLCB2YWx1ZTIpe1xyXG4gICAgICAgIGlmKHZhbHVlMSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlMiA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdmFsdWUxID0gdE1pbjtcclxuICAgICAgICAgICAgdmFsdWUyID0gdE1heDtcclxuICAgICAgICAgICAgdE1pbiA9IDA7XHJcbiAgICAgICAgICAgIHRNYXggPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0TWF4IDwgdE1pbikge1xyXG4gICAgICAgICAgICB2YXIgX3RNaW4gPSB0TWF4O1xyXG4gICAgICAgICAgICB0TWF4ID0gdE1pbjtcclxuICAgICAgICAgICAgdE1pbiA9IF90TWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZih0IDw9IHRNaW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlMTtcclxuICAgICAgICB9ZWxzZSBpZih0ID49IHRNYXgpe1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUyO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGVyYyA9IHRNYXggPT09IHRNaW4gPyAwIDogKHQtdE1pbikvKHRNYXgtdE1pbik7XHJcbiAgICAgICAgaWYoIXZhbHVlMS5sZW5ndGgpe1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUxICsgKHZhbHVlMi12YWx1ZTEpKnBlcmM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpLCBsZW4gPSB2YWx1ZTEubGVuZ3RoO1xyXG4gICAgICAgIHZhciBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcclxuICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICBhcnJbaV0gPSB2YWx1ZTFbaV0gKyAodmFsdWUyW2ldLXZhbHVlMVtpXSkqcGVyYztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJhbmRvbShtaW4sbWF4KXtcclxuICAgICAgICBpZihtYXggPT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIGlmKG1pbiA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIG1pbiA9IDA7XHJcbiAgICAgICAgICAgICAgICBtYXggPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gbWluO1xyXG4gICAgICAgICAgICAgICAgbWluID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKG1heC5sZW5ndGgpe1xyXG4gICAgICAgICAgICB2YXIgaSwgbGVuID0gbWF4Lmxlbmd0aDtcclxuICAgICAgICAgICAgaWYoIW1pbil7XHJcbiAgICAgICAgICAgICAgICBtaW4gPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XHJcbiAgICAgICAgICAgIHZhciBybmQgPSBCTU1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSBtaW5baV0gKyBybmQqKG1heFtpXS1taW5baV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmKG1pbiA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgbWluID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJuZG0gPSBCTU1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgcmV0dXJuIG1pbiArIHJuZG0qKG1heC1taW4pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGgocG9pbnRzLCBpblRhbmdlbnRzLCBvdXRUYW5nZW50cywgY2xvc2VkKSB7XHJcbiAgICAgICAgdmFyIGksIGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIHBhdGggPSBzaGFwZV9wb29sLm5ld0VsZW1lbnQoKTtcclxuICAgICAgICBwYXRoLnNldFBhdGhEYXRhKCEhY2xvc2VkLCBsZW4pO1xyXG4gICAgICAgIHZhciBhcnJQbGFjZWhvbGRlciA9IFswLDBdLCBpblZlcnRleFBvaW50LCBvdXRWZXJ0ZXhQb2ludDtcclxuICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBpblZlcnRleFBvaW50ID0gKGluVGFuZ2VudHMgJiYgaW5UYW5nZW50c1tpXSkgPyBpblRhbmdlbnRzW2ldIDogYXJyUGxhY2Vob2xkZXI7XHJcbiAgICAgICAgICAgIG91dFZlcnRleFBvaW50ID0gKG91dFRhbmdlbnRzICYmIG91dFRhbmdlbnRzW2ldKSA/IG91dFRhbmdlbnRzW2ldIDogYXJyUGxhY2Vob2xkZXI7XHJcbiAgICAgICAgICAgIHBhdGguc2V0VHJpcGxlQXQocG9pbnRzW2ldWzBdLHBvaW50c1tpXVsxXSxvdXRWZXJ0ZXhQb2ludFswXSArIHBvaW50c1tpXVswXSxvdXRWZXJ0ZXhQb2ludFsxXSArIHBvaW50c1tpXVsxXSxpblZlcnRleFBvaW50WzBdICsgcG9pbnRzW2ldWzBdLGluVmVydGV4UG9pbnRbMV0gKyBwb2ludHNbaV1bMV0saSx0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhdGg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5pdGlhdGVFeHByZXNzaW9uKGVsZW0sZGF0YSxwcm9wZXJ0eSl7XHJcbiAgICAgICAgdmFyIHZhbCA9IGRhdGEueDtcclxuICAgICAgICB2YXIgbmVlZHNWZWxvY2l0eSA9IC92ZWxvY2l0eSg/IVtcXHdcXGRdKS8udGVzdCh2YWwpO1xyXG4gICAgICAgIHZhciBfbmVlZHNSYW5kb20gPSB2YWwuaW5kZXhPZigncmFuZG9tJykgIT09IC0xO1xyXG4gICAgICAgIHZhciBlbGVtVHlwZSA9IGVsZW0uZGF0YS50eTtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtLCRibV90cmFuc2Zvcm0sY29udGVudCxlZmZlY3Q7XHJcbiAgICAgICAgdmFyIHRoaXNQcm9wZXJ0eSA9IHByb3BlcnR5O1xyXG4gICAgICAgIGVsZW0uY29tcC5mcmFtZUR1cmF0aW9uID0gMS9lbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICAgICAgdmFyIGluUG9pbnQgPSBlbGVtLmRhdGEuaXAvZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xyXG4gICAgICAgIHZhciBvdXRQb2ludCA9IGVsZW0uZGF0YS5vcC9lbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gZWxlbS5kYXRhLnN3ID8gZWxlbS5kYXRhLnN3IDogMDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gZWxlbS5kYXRhLnNoID8gZWxlbS5kYXRhLnNoIDogMDtcclxuICAgICAgICB2YXIgbmFtZSA9IGVsZW0uZGF0YS5ubTtcclxuICAgICAgICB2YXIgbG9vcEluLCBsb29wX2luLCBsb29wT3V0LCBsb29wX291dDtcclxuICAgICAgICB2YXIgdG9Xb3JsZCxmcm9tV29ybGQsZnJvbUNvbXAsdG9Db21wLGZyb21Db21wVG9TdXJmYWNlLCBwb3NpdGlvbiwgcm90YXRpb24sIGFuY2hvclBvaW50LCBzY2FsZSwgdGhpc0xheWVyLHRoaXNDb21wLG1hc2ssdmFsdWVBdFRpbWUsdmVsb2NpdHlBdFRpbWU7XHJcbiAgICAgICAgdmFyIF9fZXhwcmVzc2lvbl9mdW5jdGlvbnMgPSBbXTtcclxuICAgICAgICBpZihkYXRhLnhmKSB7XHJcbiAgICAgICAgICAgIHZhciBpLCBsZW4gPSBkYXRhLnhmLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgICAgIF9fZXhwcmVzc2lvbl9mdW5jdGlvbnNbaV0gPSBldmFsKCcoZnVuY3Rpb24oKXsgcmV0dXJuICcgKyBkYXRhLnhmW2ldICsgJ30oKSknKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHNjb3BlZF9ibV9ydDtcclxuICAgICAgICB2YXIgZXhwcmVzc2lvbl9mdW5jdGlvbiA9IGV2YWwoJ1tmdW5jdGlvbiBfZXhwcmVzc2lvbl9mdW5jdGlvbigpeycgKyB2YWwrJztzY29wZWRfYm1fcnQ9JGJtX3J0fScgKyAnXScpWzBdO1xyXG4gICAgICAgIHZhciBudW1LZXlzID0gcHJvcGVydHkua2YgPyBkYXRhLmsubGVuZ3RoIDogMDtcclxuXHJcbiAgICAgICAgdmFyIGFjdGl2ZSA9ICF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhLmhkICE9PSB0cnVlO1xyXG5cclxuICAgICAgICB2YXIgd2lnZ2xlID0gZnVuY3Rpb24gd2lnZ2xlKGZyZXEsYW1wKXtcclxuICAgICAgICAgICAgdmFyIGksaiwgbGVuID0gdGhpcy5wdi5sZW5ndGggPyB0aGlzLnB2Lmxlbmd0aCA6IDE7XHJcbiAgICAgICAgICAgIHZhciBhZGRlZEFtcHMgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcclxuICAgICAgICAgICAgZnJlcSA9IDU7XHJcbiAgICAgICAgICAgIHZhciBpdGVyYXRpb25zID0gTWF0aC5mbG9vcih0aW1lKmZyZXEpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgaiA9IDA7XHJcbiAgICAgICAgICAgIHdoaWxlKGk8aXRlcmF0aW9ucyl7XHJcbiAgICAgICAgICAgICAgICAvL3ZhciBybmQgPSBCTU1hdGgucmFuZG9tKCk7XHJcbiAgICAgICAgICAgICAgICBmb3Ioaj0wO2o8bGVuO2orPTEpe1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZGVkQW1wc1tqXSArPSAtYW1wICsgYW1wKjIqQk1NYXRoLnJhbmRvbSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vYWRkZWRBbXBzW2pdICs9IC1hbXAgKyBhbXAqMipybmQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy92YXIgcm5kMiA9IEJNTWF0aC5yYW5kb20oKTtcclxuICAgICAgICAgICAgdmFyIHBlcmlvZHMgPSB0aW1lKmZyZXE7XHJcbiAgICAgICAgICAgIHZhciBwZXJjID0gcGVyaW9kcyAtIE1hdGguZmxvb3IocGVyaW9kcyk7XHJcbiAgICAgICAgICAgIHZhciBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcclxuICAgICAgICAgICAgaWYobGVuPjEpe1xyXG4gICAgICAgICAgICAgICAgZm9yKGo9MDtqPGxlbjtqKz0xKXtcclxuICAgICAgICAgICAgICAgICAgICBhcnJbal0gPSB0aGlzLnB2W2pdICsgYWRkZWRBbXBzW2pdICsgKC1hbXAgKyBhbXAqMipCTU1hdGgucmFuZG9tKCkpKnBlcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9hcnJbal0gPSB0aGlzLnB2W2pdICsgYWRkZWRBbXBzW2pdICsgKC1hbXAgKyBhbXAqMipybmQpKnBlcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9hcnJbaV0gPSB0aGlzLnB2W2ldICsgYWRkZWRBbXAgKyBhbXAxKnBlcmMgKyBhbXAyKigxLXBlcmMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnB2ICsgYWRkZWRBbXBzWzBdICsgKC1hbXAgKyBhbXAqMipCTU1hdGgucmFuZG9tKCkpKnBlcmM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgICAgIGlmKHRoaXNQcm9wZXJ0eS5sb29wSW4pIHtcclxuICAgICAgICAgICAgbG9vcEluID0gdGhpc1Byb3BlcnR5Lmxvb3BJbi5iaW5kKHRoaXNQcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgIGxvb3BfaW4gPSBsb29wSW47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih0aGlzUHJvcGVydHkubG9vcE91dCkge1xyXG4gICAgICAgICAgICBsb29wT3V0ID0gdGhpc1Byb3BlcnR5Lmxvb3BPdXQuYmluZCh0aGlzUHJvcGVydHkpO1xyXG4gICAgICAgICAgICBsb29wX291dCA9IGxvb3BPdXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBsb29wSW5EdXJhdGlvbih0eXBlLGR1cmF0aW9uKXtcclxuICAgICAgICAgICAgcmV0dXJuIGxvb3BJbih0eXBlLGR1cmF0aW9uLHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbG9vcE91dER1cmF0aW9uKHR5cGUsZHVyYXRpb24pe1xyXG4gICAgICAgICAgICByZXR1cm4gbG9vcE91dCh0eXBlLGR1cmF0aW9uLHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYodGhpcy5nZXRWYWx1ZUF0VGltZSkge1xyXG4gICAgICAgICAgICB2YWx1ZUF0VGltZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUuYmluZCh0aGlzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmKHRoaXMuZ2V0VmVsb2NpdHlBdFRpbWUpIHtcclxuICAgICAgICAgICAgdmVsb2NpdHlBdFRpbWUgPSB0aGlzLmdldFZlbG9jaXR5QXRUaW1lLmJpbmQodGhpcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgY29tcCA9IGVsZW0uY29tcC5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UuYmluZChlbGVtLmNvbXAuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbG9va0F0KGVsZW0xLGVsZW0yKXtcclxuICAgICAgICAgICAgdmFyIGZWZWMgPSBbZWxlbTJbMF0tZWxlbTFbMF0sZWxlbTJbMV0tZWxlbTFbMV0sZWxlbTJbMl0tZWxlbTFbMl1dO1xyXG4gICAgICAgICAgICB2YXIgcGl0Y2ggPSBNYXRoLmF0YW4yKGZWZWNbMF0sTWF0aC5zcXJ0KGZWZWNbMV0qZlZlY1sxXStmVmVjWzJdKmZWZWNbMl0pKS9kZWdUb1JhZHM7XHJcbiAgICAgICAgICAgIHZhciB5YXcgPSAtTWF0aC5hdGFuMihmVmVjWzFdLGZWZWNbMl0pL2RlZ1RvUmFkcztcclxuICAgICAgICAgICAgcmV0dXJuIFt5YXcscGl0Y2gsMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBlYXNlT3V0KHQsIHRNaW4sIHRNYXgsIHZhbDEsIHZhbDIpe1xyXG4gICAgICAgICAgICBpZih2YWwxID09PSB1bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgdmFsMSA9IHRNaW47XHJcbiAgICAgICAgICAgICAgICB2YWwyID0gdE1heDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHQgPSAodCAtIHRNaW4pIC8gKHRNYXggLSB0TWluKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gLSh2YWwyLXZhbDEpICogdCoodC0yKSArIHZhbDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBlYXNlSW4odCwgdE1pbiwgdE1heCwgdmFsMSwgdmFsMil7XHJcbiAgICAgICAgICAgIGlmKHZhbDEgPT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICB2YWwxID0gdE1pbjtcclxuICAgICAgICAgICAgICAgIHZhbDIgPSB0TWF4O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdCA9ICh0IC0gdE1pbikgLyAodE1heCAtIHRNaW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAodmFsMi12YWwxKSp0KnQgKyB2YWwxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbmVhcmVzdEtleSh0aW1lKXtcclxuICAgICAgICAgICAgdmFyIGksIGxlbiA9IGRhdGEuay5sZW5ndGgsaW5kZXgsa2V5VGltZTtcclxuICAgICAgICAgICAgaWYoIWRhdGEuay5sZW5ndGggfHwgdHlwZW9mKGRhdGEua1swXSkgPT09ICdudW1iZXInKXtcclxuICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIGtleVRpbWUgPSAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIHRpbWUgKj0gZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRpbWUgPCBkYXRhLmtbMF0udCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBrZXlUaW1lID0gZGF0YS5rWzBdLnQ7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihpPTA7aTxsZW4tMTtpKz0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGltZSA9PT0gZGF0YS5rW2ldLnQpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVRpbWUgPSBkYXRhLmtbaV0udDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSBpZih0aW1lPmRhdGEua1tpXS50ICYmIHRpbWU8ZGF0YS5rW2krMV0udCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0aW1lLWRhdGEua1tpXS50ID4gZGF0YS5rW2krMV0udCAtIHRpbWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaSArIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1tpKzFdLnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1tpXS50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaW5kZXggPT09IC0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpICsgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5VGltZSA9IGRhdGEua1tpXS50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBvYiA9IHt9O1xyXG4gICAgICAgICAgICBvYi5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgICAgICBvYi50aW1lID0ga2V5VGltZS9lbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICAgICAgICAgIHJldHVybiBvYjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGtleShpbmQpe1xyXG4gICAgICAgICAgICB2YXIgb2IsIGksIGxlbjtcclxuICAgICAgICAgICAgaWYoIWRhdGEuay5sZW5ndGggfHwgdHlwZW9mKGRhdGEua1swXSkgPT09ICdudW1iZXInKXtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3BlcnR5IGhhcyBubyBrZXlmcmFtZSBhdCBpbmRleCAnICsgaW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbmQgLT0gMTtcclxuICAgICAgICAgICAgb2IgPSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lOiBkYXRhLmtbaW5kXS50L2VsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgYXJyO1xyXG4gICAgICAgICAgICBpZihpbmQgPT09IGRhdGEuay5sZW5ndGggLSAxICYmICFkYXRhLmtbaW5kXS5oKXtcclxuICAgICAgICAgICAgICAgIGFyciA9IGRhdGEua1tpbmQtMV0uZTtcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICBhcnIgPSBkYXRhLmtbaW5kXS5zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxlbiA9IGFyci5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgICAgICAgICBvYltpXSA9IGFycltpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb2I7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBmcmFtZXNUb1RpbWUoZnJhbWVzLCBmcHMpIHsgXHJcbiAgICAgICAgICAgIGlmICghZnBzKSB7XHJcbiAgICAgICAgICAgICAgICBmcHMgPSBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZyYW1lcyAvIGZwcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIHRpbWVUb0ZyYW1lcyh0LCBmcHMpIHtcclxuICAgICAgICAgICAgaWYgKCF0ICYmIHQgIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHQgPSB0aW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZnBzKSB7XHJcbiAgICAgICAgICAgICAgICBmcHMgPSBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHQgKiBmcHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBzZWVkUmFuZG9tKHNlZWQpe1xyXG4gICAgICAgICAgICBCTU1hdGguc2VlZHJhbmRvbShyYW5kU2VlZCArIHNlZWQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc291cmNlUmVjdEF0VGltZSgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW0uc291cmNlUmVjdEF0VGltZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc3Vic3RyaW5nKGluaXQsIGVuZCkge1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBpZihlbmQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZyhpbml0KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZyhpbml0LCBlbmQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc3Vic3RyKGluaXQsIGVuZCkge1xyXG4gICAgICAgICAgICBpZih0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBpZihlbmQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cihpbml0KVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cihpbml0LCBlbmQpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHRpbWUsIHZlbG9jaXR5LCB2YWx1ZSwgdGV4dCwgdGV4dEluZGV4LCB0ZXh0VG90YWwsIHNlbGVjdG9yVmFsdWU7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gZWxlbS5kYXRhLmluZDtcclxuICAgICAgICB2YXIgaGFzUGFyZW50ID0gISEoZWxlbS5oaWVyYXJjaHkgJiYgZWxlbS5oaWVyYXJjaHkubGVuZ3RoKTtcclxuICAgICAgICB2YXIgcGFyZW50O1xyXG4gICAgICAgIHZhciByYW5kU2VlZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoxMDAwMDAwKTtcclxuICAgICAgICBmdW5jdGlvbiBleGVjdXRlRXhwcmVzc2lvbihfdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBfdmFsdWU7XHJcbiAgICAgICAgICAgIGlmIChfbmVlZHNSYW5kb20pIHtcclxuICAgICAgICAgICAgICAgIHNlZWRSYW5kb20ocmFuZFNlZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZyYW1lRXhwcmVzc2lvbklkID09PSBlbGVtLmdsb2JhbERhdGEuZnJhbWVJZCAmJiB0aGlzLnByb3BUeXBlICE9PSAndGV4dFNlbGVjdG9yJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHRoaXMucHJvcFR5cGUgPT09ICd0ZXh0U2VsZWN0b3InKXtcclxuICAgICAgICAgICAgICAgIHRleHRJbmRleCA9IHRoaXMudGV4dEluZGV4O1xyXG4gICAgICAgICAgICAgICAgdGV4dFRvdGFsID0gdGhpcy50ZXh0VG90YWw7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvclZhbHVlID0gdGhpcy5zZWxlY3RvclZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpc0xheWVyKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZWxlbS5sYXllckludGVyZmFjZS50ZXh0O1xyXG4gICAgICAgICAgICAgICAgdGhpc0xheWVyID0gZWxlbS5sYXllckludGVyZmFjZTtcclxuICAgICAgICAgICAgICAgIHRoaXNDb21wID0gZWxlbS5jb21wLmNvbXBJbnRlcmZhY2U7XHJcbiAgICAgICAgICAgICAgICB0b1dvcmxkID0gdGhpc0xheWVyLnRvV29ybGQuYmluZCh0aGlzTGF5ZXIpO1xyXG4gICAgICAgICAgICAgICAgZnJvbVdvcmxkID0gdGhpc0xheWVyLmZyb21Xb3JsZC5iaW5kKHRoaXNMYXllcik7XHJcbiAgICAgICAgICAgICAgICBmcm9tQ29tcCA9IHRoaXNMYXllci5mcm9tQ29tcC5iaW5kKHRoaXNMYXllcik7XHJcbiAgICAgICAgICAgICAgICB0b0NvbXAgPSB0aGlzTGF5ZXIudG9Db21wLmJpbmQodGhpc0xheWVyKTtcclxuICAgICAgICAgICAgICAgIG1hc2sgPSB0aGlzTGF5ZXIubWFzayA/IHRoaXNMYXllci5tYXNrLmJpbmQodGhpc0xheWVyKSA6IG51bGw7XHJcbiAgICAgICAgICAgICAgICBmcm9tQ29tcFRvU3VyZmFjZSA9IGZyb21Db21wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0gPSBlbGVtLmxheWVySW50ZXJmYWNlKFwiQURCRSBUcmFuc2Zvcm0gR3JvdXBcIik7XHJcbiAgICAgICAgICAgICAgICAkYm1fdHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgICAgICAgICAgICAgaWYodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yUG9pbnQgPSB0cmFuc2Zvcm0uYW5jaG9yUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLypwb3NpdGlvbiA9IHRyYW5zZm9ybS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbiA9IHRyYW5zZm9ybS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IHRyYW5zZm9ybS5zY2FsZTsqL1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoZWxlbVR5cGUgPT09IDQgJiYgIWNvbnRlbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzTGF5ZXIoXCJBREJFIFJvb3QgVmVjdG9ycyBHcm91cFwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWVmZmVjdCkge1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0ID0gdGhpc0xheWVyKDQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGhhc1BhcmVudCA9ICEhKGVsZW0uaGllcmFyY2h5ICYmIGVsZW0uaGllcmFyY2h5Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGlmIChoYXNQYXJlbnQgJiYgIXBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gZWxlbS5oaWVyYXJjaHlbMF0ubGF5ZXJJbnRlcmZhY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGltZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lL3RoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcclxuICAgICAgICAgICAgaWYgKG5lZWRzVmVsb2NpdHkpIHtcclxuICAgICAgICAgICAgICAgIHZlbG9jaXR5ID0gdmVsb2NpdHlBdFRpbWUodGltZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZXhwcmVzc2lvbl9mdW5jdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLmZyYW1lRXhwcmVzc2lvbklkID0gZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XHJcblxyXG5cclxuICAgICAgICAgICAgLy9UT0RPOiBDaGVjayBpZiBpdCdzIHBvc3NpYmxlIHRvIHJldHVybiBvbiBTaGFwZUludGVyZmFjZSB0aGUgLnYgdmFsdWVcclxuICAgICAgICAgICAgaWYgKHNjb3BlZF9ibV9ydC5wcm9wVHlwZSA9PT0gXCJzaGFwZVwiKSB7XHJcbiAgICAgICAgICAgICAgICBzY29wZWRfYm1fcnQgPSBzaGFwZV9wb29sLmNsb25lKHNjb3BlZF9ibV9ydC52KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gc2NvcGVkX2JtX3J0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXhlY3V0ZUV4cHJlc3Npb247XHJcbiAgICB9XHJcblxyXG4gICAgb2IuaW5pdGlhdGVFeHByZXNzaW9uID0gaW5pdGlhdGVFeHByZXNzaW9uO1xyXG4gICAgcmV0dXJuIG9iO1xyXG59KCkpO1xuKGZ1bmN0aW9uIGFkZFByb3BlcnR5RGVjb3JhdG9yKCkge1xyXG5cclxuICAgIGZ1bmN0aW9uIGdldFN0YXRpY1ZhbHVlQXRUaW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnB2O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxvb3BPdXQodHlwZSxkdXJhdGlvbixkdXJhdGlvbkZsYWcpe1xyXG4gICAgICAgIGlmKCF0aGlzLmsgfHwgIXRoaXMua2V5ZnJhbWVzKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHR5cGUgPSB0eXBlID8gdHlwZS50b0xvd2VyQ2FzZSgpIDogJyc7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRGcmFtZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lO1xyXG4gICAgICAgIHZhciBrZXlmcmFtZXMgPSB0aGlzLmtleWZyYW1lcztcclxuICAgICAgICB2YXIgbGFzdEtleUZyYW1lID0ga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxXS50O1xyXG4gICAgICAgIGlmKGN1cnJlbnRGcmFtZTw9bGFzdEtleUZyYW1lKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHY7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHZhciBjeWNsZUR1cmF0aW9uLCBmaXJzdEtleUZyYW1lO1xyXG4gICAgICAgICAgICBpZighZHVyYXRpb25GbGFnKXtcclxuICAgICAgICAgICAgICAgIGlmKCFkdXJhdGlvbiB8fCBkdXJhdGlvbiA+IGtleWZyYW1lcy5sZW5ndGggLSAxKXtcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IGtleWZyYW1lcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZmlyc3RLZXlGcmFtZSA9IGtleWZyYW1lc1trZXlmcmFtZXMubGVuZ3RoIC0gMSAtIGR1cmF0aW9uXS50O1xyXG4gICAgICAgICAgICAgICAgY3ljbGVEdXJhdGlvbiA9IGxhc3RLZXlGcmFtZSAtIGZpcnN0S2V5RnJhbWU7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZighZHVyYXRpb24pe1xyXG4gICAgICAgICAgICAgICAgICAgIGN5Y2xlRHVyYXRpb24gPSBNYXRoLm1heCgwLGxhc3RLZXlGcmFtZSAtIHRoaXMuZWxlbS5kYXRhLmlwKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3ljbGVEdXJhdGlvbiA9IE1hdGguYWJzKGxhc3RLZXlGcmFtZSAtIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSpkdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmaXJzdEtleUZyYW1lID0gbGFzdEtleUZyYW1lIC0gY3ljbGVEdXJhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaSwgbGVuLCByZXQ7XHJcbiAgICAgICAgICAgIGlmKHR5cGUgPT09ICdwaW5ncG9uZycpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVyYXRpb25zID0gTWF0aC5mbG9vcigoY3VycmVudEZyYW1lIC0gZmlyc3RLZXlGcmFtZSkvY3ljbGVEdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZihpdGVyYXRpb25zICUgMiAhPT0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVBdFRpbWUoKChjeWNsZUR1cmF0aW9uIC0gKGN1cnJlbnRGcmFtZSAtIGZpcnN0S2V5RnJhbWUpICUgY3ljbGVEdXJhdGlvbiArICBmaXJzdEtleUZyYW1lKSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYodHlwZSA9PT0gJ29mZnNldCcpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGluaXRWID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmaXJzdEtleUZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRWID0gdGhpcy5nZXRWYWx1ZUF0VGltZShsYXN0S2V5RnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFZhbHVlQXRUaW1lKCgoY3VycmVudEZyYW1lIC0gZmlyc3RLZXlGcmFtZSkgJSBjeWNsZUR1cmF0aW9uICsgIGZpcnN0S2V5RnJhbWUpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcclxuICAgICAgICAgICAgICAgIHZhciByZXBlYXRzID0gTWF0aC5mbG9vcigoY3VycmVudEZyYW1lIC0gZmlyc3RLZXlGcmFtZSkvY3ljbGVEdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLnB2Lmxlbmd0aCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gbmV3IEFycmF5KGluaXRWLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gcmV0Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXRbaV0gPSAoZW5kVltpXS1pbml0VltpXSkqcmVwZWF0cyArIGN1cnJlbnRbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKGVuZFYtaW5pdFYpKnJlcGVhdHMgKyBjdXJyZW50O1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYodHlwZSA9PT0gJ2NvbnRpbnVlJyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFZhbHVlID0gdGhpcy5nZXRWYWx1ZUF0VGltZShsYXN0S2V5RnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRMYXN0VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKChsYXN0S2V5RnJhbWUgLSAwLjAwMSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5wdi5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IG5ldyBBcnJheShsYXN0VmFsdWUubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBsZW4gPSByZXQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihpPTA7aTxsZW47aSs9MSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldFtpXSA9IGxhc3RWYWx1ZVtpXSArIChsYXN0VmFsdWVbaV0tbmV4dExhc3RWYWx1ZVtpXSkqKChjdXJyZW50RnJhbWUgLSBsYXN0S2V5RnJhbWUpLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUpLzAuMDAwNTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBsYXN0VmFsdWUgKyAobGFzdFZhbHVlLW5leHRMYXN0VmFsdWUpKigoKGN1cnJlbnRGcmFtZSAtIGxhc3RLZXlGcmFtZSkpLzAuMDAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUF0VGltZSgoKChjdXJyZW50RnJhbWUgLSBmaXJzdEtleUZyYW1lKSAlIGN5Y2xlRHVyYXRpb24gKyAgZmlyc3RLZXlGcmFtZSkpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbG9vcEluKHR5cGUsZHVyYXRpb24sIGR1cmF0aW9uRmxhZykge1xyXG4gICAgICAgIGlmKCF0aGlzLmspe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHlwZSA9IHR5cGUgPyB0eXBlLnRvTG93ZXJDYXNlKCkgOiAnJztcclxuICAgICAgICB2YXIgY3VycmVudEZyYW1lID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWU7XHJcbiAgICAgICAgdmFyIGtleWZyYW1lcyA9IHRoaXMua2V5ZnJhbWVzO1xyXG4gICAgICAgIHZhciBmaXJzdEtleUZyYW1lID0ga2V5ZnJhbWVzWzBdLnQ7XHJcbiAgICAgICAgaWYoY3VycmVudEZyYW1lPj1maXJzdEtleUZyYW1lKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHY7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgIHZhciBjeWNsZUR1cmF0aW9uLCBsYXN0S2V5RnJhbWU7XHJcbiAgICAgICAgICAgIGlmKCFkdXJhdGlvbkZsYWcpe1xyXG4gICAgICAgICAgICAgICAgaWYoIWR1cmF0aW9uIHx8IGR1cmF0aW9uID4ga2V5ZnJhbWVzLmxlbmd0aCAtIDEpe1xyXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0ga2V5ZnJhbWVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsYXN0S2V5RnJhbWUgPSBrZXlmcmFtZXNbZHVyYXRpb25dLnQ7XHJcbiAgICAgICAgICAgICAgICBjeWNsZUR1cmF0aW9uID0gbGFzdEtleUZyYW1lIC0gZmlyc3RLZXlGcmFtZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmKCFkdXJhdGlvbil7XHJcbiAgICAgICAgICAgICAgICAgICAgY3ljbGVEdXJhdGlvbiA9IE1hdGgubWF4KDAsdGhpcy5lbGVtLmRhdGEub3AgLSBmaXJzdEtleUZyYW1lKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3ljbGVEdXJhdGlvbiA9IE1hdGguYWJzKGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSpkdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsYXN0S2V5RnJhbWUgPSBmaXJzdEtleUZyYW1lICsgY3ljbGVEdXJhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaSwgbGVuLCByZXQ7XHJcbiAgICAgICAgICAgIGlmKHR5cGUgPT09ICdwaW5ncG9uZycpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpdGVyYXRpb25zID0gTWF0aC5mbG9vcigoZmlyc3RLZXlGcmFtZSAtIGN1cnJlbnRGcmFtZSkvY3ljbGVEdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZihpdGVyYXRpb25zICUgMiA9PT0gMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVBdFRpbWUoKCgoZmlyc3RLZXlGcmFtZSAtIGN1cnJlbnRGcmFtZSklY3ljbGVEdXJhdGlvbiArICBmaXJzdEtleUZyYW1lKSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYodHlwZSA9PT0gJ29mZnNldCcpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGluaXRWID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmaXJzdEtleUZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcclxuICAgICAgICAgICAgICAgIHZhciBlbmRWID0gdGhpcy5nZXRWYWx1ZUF0VGltZShsYXN0S2V5RnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFZhbHVlQXRUaW1lKChjeWNsZUR1cmF0aW9uIC0gKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpJWN5Y2xlRHVyYXRpb24gKyAgZmlyc3RLZXlGcmFtZSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlcGVhdHMgPSBNYXRoLmZsb29yKChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKS9jeWNsZUR1cmF0aW9uKSsxO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5wdi5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IG5ldyBBcnJheShpbml0Vi5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHJldC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0W2ldID0gY3VycmVudFtpXS0oZW5kVltpXS1pbml0VltpXSkqcmVwZWF0cztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50LShlbmRWLWluaXRWKSpyZXBlYXRzO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYodHlwZSA9PT0gJ2NvbnRpbnVlJyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoZmlyc3RLZXlGcmFtZSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEZpcnN0VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKChmaXJzdEtleUZyYW1lICsgMC4wMDEpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcclxuICAgICAgICAgICAgICAgIGlmKHRoaXMucHYubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgICAgICByZXQgPSBuZXcgQXJyYXkoZmlyc3RWYWx1ZS5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IHJldC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0W2ldID0gZmlyc3RWYWx1ZVtpXSArIChmaXJzdFZhbHVlW2ldLW5leHRGaXJzdFZhbHVlW2ldKSooZmlyc3RLZXlGcmFtZSAtIGN1cnJlbnRGcmFtZSkvMC4wMDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlyc3RWYWx1ZSArIChmaXJzdFZhbHVlLW5leHRGaXJzdFZhbHVlKSooZmlyc3RLZXlGcmFtZSAtIGN1cnJlbnRGcmFtZSkvMC4wMDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVBdFRpbWUoKChjeWNsZUR1cmF0aW9uIC0gKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpICUgY3ljbGVEdXJhdGlvbiArICBmaXJzdEtleUZyYW1lKSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRWYWx1ZUF0VGltZShmcmFtZU51bSkge1xyXG4gICAgICAgIGlmKGZyYW1lTnVtICE9PSB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RGcmFtZSkge1xyXG4gICAgICAgICAgICBmcmFtZU51bSAqPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XHJcbiAgICAgICAgICAgIGZyYW1lTnVtIC09IHRoaXMub2Zmc2V0VGltZTtcclxuICAgICAgICAgICAgdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0SW5kZXggPSB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RGcmFtZSA8IGZyYW1lTnVtID8gdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0SW5kZXggOiAwO1xyXG4gICAgICAgICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lLnZhbHVlID0gdGhpcy5pbnRlcnBvbGF0ZVZhbHVlKGZyYW1lTnVtLCB0aGlzLl9jYWNoaW5nQXRUaW1lKTtcclxuICAgICAgICAgICAgdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0RnJhbWUgPSBmcmFtZU51bTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hpbmdBdFRpbWUudmFsdWU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFNwZWVkQXRUaW1lKGZyYW1lTnVtKSB7XHJcbiAgICAgICAgdmFyIGRlbHRhID0gLTAuMDE7XHJcbiAgICAgICAgdmFyIHYxID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmcmFtZU51bSk7XHJcbiAgICAgICAgdmFyIHYyID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmcmFtZU51bSArIGRlbHRhKTtcclxuICAgICAgICB2YXIgc3BlZWQgPSAwO1xyXG4gICAgICAgIGlmKHYxLmxlbmd0aCl7XHJcbiAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICBmb3IoaT0wO2k8djEubGVuZ3RoO2krPTEpe1xyXG4gICAgICAgICAgICAgICAgc3BlZWQgKz0gTWF0aC5wb3codjJbaV0gLSB2MVtpXSwgMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3BlZWQgPSBNYXRoLnNxcnQoc3BlZWQpICogMTAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHNwZWVkID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNwZWVkO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFZlbG9jaXR5QXRUaW1lKGZyYW1lTnVtKSB7XHJcbiAgICAgICAgaWYodGhpcy52ZWwgIT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRlbHRhID0gLTAuMDAxO1xyXG4gICAgICAgIC8vZnJhbWVOdW0gKz0gdGhpcy5lbGVtLmRhdGEuc3Q7XHJcbiAgICAgICAgdmFyIHYxID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmcmFtZU51bSk7XHJcbiAgICAgICAgdmFyIHYyID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmcmFtZU51bSArIGRlbHRhKTtcclxuICAgICAgICB2YXIgdmVsb2NpdHk7XHJcbiAgICAgICAgaWYodjEubGVuZ3RoKXtcclxuICAgICAgICAgICAgdmVsb2NpdHkgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgdjEubGVuZ3RoKTtcclxuICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgIGZvcihpPTA7aTx2MS5sZW5ndGg7aSs9MSl7XHJcbiAgICAgICAgICAgICAgICAvL3JlbW92aW5nIGZyYW1lUmF0ZVxyXG4gICAgICAgICAgICAgICAgLy9pZiBuZWVkZWQsIGRvbid0IGFkZCBpdCBoZXJlXHJcbiAgICAgICAgICAgICAgICAvL3ZlbG9jaXR5W2ldID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVSYXRlKigodjJbaV0gLSB2MVtpXSkvZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgdmVsb2NpdHlbaV0gPSAodjJbaV0gLSB2MVtpXSkvZGVsdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2ZWxvY2l0eSA9ICh2MiAtIHYxKS9kZWx0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZlbG9jaXR5O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNldEdyb3VwUHJvcGVydHkocHJvcGVydHlHcm91cCl7XHJcbiAgICAgICAgdGhpcy5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZWFyY2hFeHByZXNzaW9ucyhlbGVtLGRhdGEscHJvcCl7XHJcbiAgICAgICAgaWYoZGF0YS54KXtcclxuICAgICAgICAgICAgcHJvcC5rID0gdHJ1ZTtcclxuICAgICAgICAgICAgcHJvcC54ID0gdHJ1ZTtcclxuICAgICAgICAgICAgcHJvcC5pbml0aWF0ZUV4cHJlc3Npb24gPSBFeHByZXNzaW9uTWFuYWdlci5pbml0aWF0ZUV4cHJlc3Npb247XHJcbiAgICAgICAgICAgIHByb3AuZWZmZWN0c1NlcXVlbmNlLnB1c2gocHJvcC5pbml0aWF0ZUV4cHJlc3Npb24oZWxlbSxkYXRhLHByb3ApLmJpbmQocHJvcCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBnZXRUcmFuc2Zvcm1WYWx1ZUF0VGltZSh0aW1lKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdUcmFuc2Zvcm0gYXQgdGltZSBub3Qgc3VwcG9ydGVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtU3RhdGljVmFsdWVBdFRpbWUodGltZSkge1xyXG5cclxuICAgIH1cclxuXHJcbiAgICB2YXIgVGV4dEV4cHJlc3Npb25TZWxlY3RvclByb3AgPSAoZnVuY3Rpb24oKXtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gZ2V0VmFsdWVQcm94eShpbmRleCx0b3RhbCl7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dEluZGV4ID0gaW5kZXgrMTtcclxuICAgICAgICAgICAgdGhpcy50ZXh0VG90YWwgPSB0b3RhbDtcclxuICAgICAgICAgICAgdGhpcy5nZXRWYWx1ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIFRleHRFeHByZXNzaW9uU2VsZWN0b3JQcm9wKGVsZW0sZGF0YSl7XHJcbiAgICAgICAgICAgIHRoaXMucHYgPSAxO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XHJcbiAgICAgICAgICAgIHRoaXMuZWxlbSA9IGVsZW07XHJcbiAgICAgICAgICAgIHRoaXMubXVsdCA9IDAuMDE7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcFR5cGUgPSAndGV4dFNlbGVjdG9yJztcclxuICAgICAgICAgICAgdGhpcy50ZXh0VG90YWwgPSBkYXRhLnRvdGFsQ2hhcnM7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JWYWx1ZSA9IDEwMDtcclxuICAgICAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSBbMSwxLDFdO1xyXG4gICAgICAgICAgICBzZWFyY2hFeHByZXNzaW9ucy5iaW5kKHRoaXMpKGVsZW0sZGF0YSx0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5nZXRNdWx0ID0gZ2V0VmFsdWVQcm94eTtcclxuICAgICAgICAgICAgdGhpcy5nZXRWZWxvY2l0eUF0VGltZSA9IGdldFZlbG9jaXR5QXRUaW1lO1xyXG4gICAgICAgICAgICBpZih0aGlzLmtmKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VmFsdWVBdFRpbWUgPSBnZXRWYWx1ZUF0VGltZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRWYWx1ZUF0VGltZSA9IGdldFN0YXRpY1ZhbHVlQXRUaW1lLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZXRHcm91cFByb3BlcnR5ID0gc2V0R3JvdXBQcm9wZXJ0eTtcclxuICAgICAgICB9O1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICB2YXIgZ2V0VHJhbnNmb3JtUHJvcGVydHkgPSBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHk7XHJcbiAgICBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHkgPSBmdW5jdGlvbihlbGVtLCBkYXRhLCBjb250YWluZXIpIHtcclxuICAgICAgICB2YXIgcHJvcCA9IGdldFRyYW5zZm9ybVByb3BlcnR5KGVsZW0sIGRhdGEsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgaWYocHJvcC5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcHJvcC5nZXRWYWx1ZUF0VGltZSA9IGdldFRyYW5zZm9ybVZhbHVlQXRUaW1lLmJpbmQocHJvcCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcHJvcC5nZXRWYWx1ZUF0VGltZSA9IGdldFRyYW5zZm9ybVN0YXRpY1ZhbHVlQXRUaW1lLmJpbmQocHJvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3Auc2V0R3JvdXBQcm9wZXJ0eSA9IHNldEdyb3VwUHJvcGVydHk7XHJcbiAgICAgICAgcmV0dXJuIHByb3A7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBwcm9wZXJ0eUdldFByb3AgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcDtcclxuICAgIFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wID0gZnVuY3Rpb24oZWxlbSxkYXRhLHR5cGUsIG11bHQsIGNvbnRhaW5lcil7XHJcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wZXJ0eUdldFByb3AoZWxlbSxkYXRhLHR5cGUsIG11bHQsIGNvbnRhaW5lcik7XHJcbiAgICAgICAgLy9wcm9wLmdldFZlbG9jaXR5QXRUaW1lID0gZ2V0VmVsb2NpdHlBdFRpbWU7XHJcbiAgICAgICAgLy9wcm9wLmxvb3BPdXQgPSBsb29wT3V0O1xyXG4gICAgICAgIC8vcHJvcC5sb29wSW4gPSBsb29wSW47XHJcbiAgICAgICAgaWYocHJvcC5rZil7XHJcbiAgICAgICAgICAgIHByb3AuZ2V0VmFsdWVBdFRpbWUgPSBnZXRWYWx1ZUF0VGltZS5iaW5kKHByb3ApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHByb3AuZ2V0VmFsdWVBdFRpbWUgPSBnZXRTdGF0aWNWYWx1ZUF0VGltZS5iaW5kKHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9wLnNldEdyb3VwUHJvcGVydHkgPSBzZXRHcm91cFByb3BlcnR5O1xyXG4gICAgICAgIHByb3AubG9vcE91dCA9IGxvb3BPdXQ7XHJcbiAgICAgICAgcHJvcC5sb29wSW4gPSBsb29wSW47XHJcbiAgICAgICAgcHJvcC5nZXRWZWxvY2l0eUF0VGltZSA9IGdldFZlbG9jaXR5QXRUaW1lLmJpbmQocHJvcCk7XHJcbiAgICAgICAgcHJvcC5nZXRTcGVlZEF0VGltZSA9IGdldFNwZWVkQXRUaW1lLmJpbmQocHJvcCk7XHJcbiAgICAgICAgcHJvcC5udW1LZXlzID0gZGF0YS5hID09PSAxID8gZGF0YS5rLmxlbmd0aCA6IDA7XHJcbiAgICAgICAgcHJvcC5wcm9wZXJ0eUluZGV4ID0gZGF0YS5peDtcclxuICAgICAgICB2YXIgdmFsdWUgPSAwO1xyXG4gICAgICAgIGlmKHR5cGUgIT09IDApIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgZGF0YS5hID09PSAxID8gIGRhdGEua1swXS5zLmxlbmd0aCA6IGRhdGEuay5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9wLl9jYWNoaW5nQXRUaW1lID0ge1xyXG4gICAgICAgICAgICBsYXN0RnJhbWU6IGluaXRpYWxEZWZhdWx0RnJhbWUsXHJcbiAgICAgICAgICAgIGxhc3RJbmRleDogMCxcclxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgICAgICBzZWFyY2hFeHByZXNzaW9ucyhlbGVtLGRhdGEscHJvcCk7XHJcbiAgICAgICAgaWYocHJvcC5rKXtcclxuICAgICAgICAgICAgY29udGFpbmVyLmFkZER5bmFtaWNQcm9wZXJ0eShwcm9wKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwcm9wO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRTaGFwZVZhbHVlQXRUaW1lKGZyYW1lTnVtKSB7XHJcbiAgICAgICAgLy9Gb3Igbm93IHRoaXMgY2FjaGluZyBvYmplY3QgaXMgY3JlYXRlZCBvbmx5IHdoZW4gbmVlZGVkIGluc3RlYWQgb2YgY3JlYXRpbmcgaXQgd2hlbiB0aGUgc2hhcGUgaXMgaW5pdGlhbGl6ZWQuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoaW5nQXRUaW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhY2hpbmdBdFRpbWUgPSB7XHJcbiAgICAgICAgICAgICAgICBzaGFwZVZhbHVlOiBzaGFwZV9wb29sLmNsb25lKHRoaXMucHYpLFxyXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4OiAwLFxyXG4gICAgICAgICAgICAgICAgbGFzdFRpbWU6IGluaXRpYWxEZWZhdWx0RnJhbWVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoZnJhbWVOdW0gIT09IHRoaXMuX2NhY2hpbmdBdFRpbWUubGFzdFRpbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0SW5kZXggPSB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RUaW1lIDwgZnJhbWVOdW0gPyB0aGlzLl9jYWNoaW5nLmxhc3RJbmRleCA6IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhY2hpbmdBdFRpbWUubGFzdFRpbWUgPSBmcmFtZU51bTtcclxuICAgICAgICAgICAgZnJhbWVOdW0gKj0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xyXG4gICAgICAgICAgICB0aGlzLmludGVycG9sYXRlU2hhcGUoZnJhbWVOdW0sIHRoaXMuX2NhY2hpbmdBdFRpbWUuc2hhcGVWYWx1ZSwgdGhpcy5fY2FjaGluZ0F0VGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoaW5nQXRUaW1lLnNoYXBlVmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uID0gU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0Q29uc3RydWN0b3JGdW5jdGlvbigpO1xyXG4gICAgdmFyIEtleWZyYW1lZFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uID0gU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0S2V5ZnJhbWVkQ29uc3RydWN0b3JGdW5jdGlvbigpO1xyXG5cclxuICAgIGZ1bmN0aW9uIFNoYXBlRXhwcmVzc2lvbnMoKXt9XHJcbiAgICBTaGFwZUV4cHJlc3Npb25zLnByb3RvdHlwZSA9IHtcclxuICAgICAgICB2ZXJ0aWNlczogZnVuY3Rpb24ocHJvcCwgdGltZSl7XHJcbiAgICAgICAgICAgIHZhciBzaGFwZVBhdGggPSB0aGlzLnY7XHJcbiAgICAgICAgICAgIGlmKHRpbWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgc2hhcGVQYXRoID0gdGhpcy5nZXRWYWx1ZUF0VGltZSh0aW1lLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgaSwgbGVuID0gc2hhcGVQYXRoLl9sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IHNoYXBlUGF0aFtwcm9wXTtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHNoYXBlUGF0aC52O1xyXG4gICAgICAgICAgICB2YXIgYXJyID0gY3JlYXRlU2l6ZWRBcnJheShsZW4pO1xyXG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYocHJvcCA9PT0gJ2knIHx8IHByb3AgPT09ICdvJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFycltpXSA9IFt2ZXJ0aWNlc1tpXVswXSAtIHBvaW50c1tpXVswXSwgdmVydGljZXNbaV1bMV0gLSBwb2ludHNbaV1bMV1dO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhcnJbaV0gPSBbdmVydGljZXNbaV1bMF0sIHZlcnRpY2VzW2ldWzFdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBwb2ludHM6IGZ1bmN0aW9uKHRpbWUpe1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZXJ0aWNlcygndicsIHRpbWUpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW5UYW5nZW50czogZnVuY3Rpb24odGltZSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcnRpY2VzKCdpJywgdGltZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvdXRUYW5nZW50czogZnVuY3Rpb24odGltZSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlcnRpY2VzKCdvJywgdGltZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBpc0Nsb3NlZDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudi5jO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcG9pbnRPblBhdGg6IGZ1bmN0aW9uKHBlcmMsIHRpbWUpe1xyXG4gICAgICAgICAgICB2YXIgc2hhcGVQYXRoID0gdGhpcy52O1xyXG4gICAgICAgICAgICBpZih0aW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHNoYXBlUGF0aCA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUodGltZSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIXRoaXMuX3NlZ21lbnRzTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWdtZW50c0xlbmd0aCA9IGJlei5nZXRTZWdtZW50c0xlbmd0aChzaGFwZVBhdGgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgc2VnbWVudHNMZW5ndGggPSB0aGlzLl9zZWdtZW50c0xlbmd0aDtcclxuICAgICAgICAgICAgdmFyIGxlbmd0aHMgPSBzZWdtZW50c0xlbmd0aC5sZW5ndGhzO1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoUG9zID0gc2VnbWVudHNMZW5ndGgudG90YWxMZW5ndGggKiBwZXJjO1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IGxlbmd0aHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgaiA9IDAsIGpMZW47XHJcbiAgICAgICAgICAgIHZhciBhY2N1bXVsYXRlZExlbmd0aCA9IDAsIHB0O1xyXG4gICAgICAgICAgICB3aGlsZShpIDwgbGVuKSB7XHJcbiAgICAgICAgICAgICAgICBpZihhY2N1bXVsYXRlZExlbmd0aCArIGxlbmd0aHNbaV0uYWRkZWRMZW5ndGggPiBsZW5ndGhQb3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5pdEluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZW5kSW5kZXggPSAoc2hhcGVQYXRoLmMgJiYgaSA9PT0gbGVuIC0gMSkgPyAwIDogaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlZ21lbnRQZXJjID0gKGxlbmd0aFBvcyAtIGFjY3VtdWxhdGVkTGVuZ3RoKS9sZW5ndGhzW2ldLmFkZGVkTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHB0ID0gYmV6LmdldFBvaW50SW5TZWdtZW50KHNoYXBlUGF0aC52W2luaXRJbmRleF0sIHNoYXBlUGF0aC52W2VuZEluZGV4XSwgc2hhcGVQYXRoLm9baW5pdEluZGV4XSwgc2hhcGVQYXRoLmlbZW5kSW5kZXhdLCBzZWdtZW50UGVyYywgbGVuZ3Roc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkTGVuZ3RoICs9IGxlbmd0aHNbaV0uYWRkZWRMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIXB0KXtcclxuICAgICAgICAgICAgICAgIHB0ID0gc2hhcGVQYXRoLmMgPyBbc2hhcGVQYXRoLnZbMF1bMF0sc2hhcGVQYXRoLnZbMF1bMV1dOltzaGFwZVBhdGgudltzaGFwZVBhdGguX2xlbmd0aC0xXVswXSxzaGFwZVBhdGgudltzaGFwZVBhdGguX2xlbmd0aC0xXVsxXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHB0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmVjdG9yT25QYXRoOiBmdW5jdGlvbihwZXJjLCB0aW1lLCB2ZWN0b3JUeXBlKXtcclxuICAgICAgICAgICAgLy9wZXJjIGRvZXNuJ3QgdXNlIHRyaXBsZSBlcXVhbGl0eSBiZWNhdXNlIGl0IGNhbiBiZSBhIE51bWJlciBvYmplY3QgYXMgd2VsbCBhcyBhIHByaW1pdGl2ZS5cclxuICAgICAgICAgICAgcGVyYyA9IHBlcmMgPT0gMSA/IHRoaXMudi5jID8gMCA6IDAuOTk5IDogcGVyYztcclxuICAgICAgICAgICAgdmFyIHB0MSA9IHRoaXMucG9pbnRPblBhdGgocGVyYywgdGltZSk7XHJcbiAgICAgICAgICAgIHZhciBwdDIgPSB0aGlzLnBvaW50T25QYXRoKHBlcmMgKyAwLjAwMSwgdGltZSk7XHJcbiAgICAgICAgICAgIHZhciB4TGVuZ3RoID0gcHQyWzBdIC0gcHQxWzBdO1xyXG4gICAgICAgICAgICB2YXIgeUxlbmd0aCA9IHB0MlsxXSAtIHB0MVsxXTtcclxuICAgICAgICAgICAgdmFyIG1hZ25pdHVkZSA9IE1hdGguc3FydChNYXRoLnBvdyh4TGVuZ3RoLDIpICsgTWF0aC5wb3coeUxlbmd0aCwyKSk7XHJcbiAgICAgICAgICAgIHZhciB1bml0VmVjdG9yID0gdmVjdG9yVHlwZSA9PT0gJ3RhbmdlbnQnID8gW3hMZW5ndGgvbWFnbml0dWRlLCB5TGVuZ3RoL21hZ25pdHVkZV0gOiBbLXlMZW5ndGgvbWFnbml0dWRlLCB4TGVuZ3RoL21hZ25pdHVkZV07XHJcbiAgICAgICAgICAgIHJldHVybiB1bml0VmVjdG9yO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGFuZ2VudE9uUGF0aDogZnVuY3Rpb24ocGVyYywgdGltZSl7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlY3Rvck9uUGF0aChwZXJjLCB0aW1lLCAndGFuZ2VudCcpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbm9ybWFsT25QYXRoOiBmdW5jdGlvbihwZXJjLCB0aW1lKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmVjdG9yT25QYXRoKHBlcmMsIHRpbWUsICdub3JtYWwnKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNldEdyb3VwUHJvcGVydHk6IHNldEdyb3VwUHJvcGVydHksXHJcbiAgICAgICAgZ2V0VmFsdWVBdFRpbWU6IGdldFN0YXRpY1ZhbHVlQXRUaW1lXHJcbiAgICB9O1xyXG4gICAgZXh0ZW5kUHJvdG90eXBlKFtTaGFwZUV4cHJlc3Npb25zXSwgU2hhcGVQcm9wZXJ0eUNvbnN0cnVjdG9yRnVuY3Rpb24pO1xyXG4gICAgZXh0ZW5kUHJvdG90eXBlKFtTaGFwZUV4cHJlc3Npb25zXSwgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eUNvbnN0cnVjdG9yRnVuY3Rpb24pO1xyXG4gICAgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eUNvbnN0cnVjdG9yRnVuY3Rpb24ucHJvdG90eXBlLmdldFZhbHVlQXRUaW1lID0gZ2V0U2hhcGVWYWx1ZUF0VGltZTtcclxuICAgIEtleWZyYW1lZFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uLnByb3RvdHlwZS5pbml0aWF0ZUV4cHJlc3Npb24gPSBFeHByZXNzaW9uTWFuYWdlci5pbml0aWF0ZUV4cHJlc3Npb247XHJcblxyXG4gICAgdmFyIHByb3BlcnR5R2V0U2hhcGVQcm9wID0gU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0U2hhcGVQcm9wO1xyXG4gICAgU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0U2hhcGVQcm9wID0gZnVuY3Rpb24oZWxlbSxkYXRhLHR5cGUsIGFyciwgdHJpbXMpe1xyXG4gICAgICAgIHZhciBwcm9wID0gcHJvcGVydHlHZXRTaGFwZVByb3AoZWxlbSxkYXRhLHR5cGUsIGFyciwgdHJpbXMpO1xyXG4gICAgICAgIHByb3AucHJvcGVydHlJbmRleCA9IGRhdGEuaXg7XHJcbiAgICAgICAgcHJvcC5sb2NrID0gZmFsc2U7XHJcbiAgICAgICAgaWYodHlwZSA9PT0gMyl7XHJcbiAgICAgICAgICAgIHNlYXJjaEV4cHJlc3Npb25zKGVsZW0sZGF0YS5wdCxwcm9wKTtcclxuICAgICAgICB9IGVsc2UgaWYodHlwZSA9PT0gNCl7XHJcbiAgICAgICAgICAgIHNlYXJjaEV4cHJlc3Npb25zKGVsZW0sZGF0YS5rcyxwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYocHJvcC5rKXtcclxuICAgICAgICAgICAgZWxlbS5hZGREeW5hbWljUHJvcGVydHkocHJvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9wO1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgcHJvcGVydHlHZXRUZXh0UHJvcCA9IFRleHRTZWxlY3RvclByb3AuZ2V0VGV4dFNlbGVjdG9yUHJvcDtcclxuICAgIFRleHRTZWxlY3RvclByb3AuZ2V0VGV4dFNlbGVjdG9yUHJvcCA9IGZ1bmN0aW9uKGVsZW0sIGRhdGEsYXJyKXtcclxuICAgICAgICBpZihkYXRhLnQgPT09IDEpe1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRFeHByZXNzaW9uU2VsZWN0b3JQcm9wKGVsZW0sIGRhdGEsYXJyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHlHZXRUZXh0UHJvcChlbGVtLGRhdGEsYXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59KCkpO1xuKGZ1bmN0aW9uIGFkZERlY29yYXRvcigpIHtcclxuXHJcbiAgICBmdW5jdGlvbiBzZWFyY2hFeHByZXNzaW9ucygpe1xyXG4gICAgICAgIGlmKHRoaXMuZGF0YS5kLngpe1xyXG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUV4cHJlc3Npb24gPSBFeHByZXNzaW9uTWFuYWdlci5pbml0aWF0ZUV4cHJlc3Npb24uYmluZCh0aGlzKSh0aGlzLmVsZW0sdGhpcy5kYXRhLmQsdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0KHRoaXMuZ2V0RXhwcmVzc2lvblZhbHVlLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5nZXRFeHByZXNzaW9uVmFsdWUgPSBmdW5jdGlvbihjdXJyZW50VmFsdWUsIHRleHQpIHtcclxuICAgICAgICB2YXIgbmV3VmFsdWUgPSB0aGlzLmNhbGN1bGF0ZUV4cHJlc3Npb24odGV4dCk7XHJcbiAgICAgICAgaWYoY3VycmVudFZhbHVlLnQgIT09IG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdEYXRhID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuY29weURhdGEobmV3RGF0YSwgY3VycmVudFZhbHVlKTtcclxuICAgICAgICAgICAgbmV3RGF0YS50ID0gbmV3VmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgbmV3RGF0YS5fX2NvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdEYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VycmVudFZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuc2VhcmNoUHJvcGVydHkgPSBmdW5jdGlvbigpe1xyXG5cclxuICAgICAgICB2YXIgaXNLZXlmcmFtZWQgPSB0aGlzLnNlYXJjaEtleWZyYW1lcygpO1xyXG4gICAgICAgIHZhciBoYXNFeHByZXNzaW9ucyA9IHRoaXMuc2VhcmNoRXhwcmVzc2lvbnMoKTtcclxuICAgICAgICB0aGlzLmtmID0gaXNLZXlmcmFtZWQgfHwgaGFzRXhwcmVzc2lvbnM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2Y7XHJcbiAgICB9O1xyXG5cclxuICAgIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuc2VhcmNoRXhwcmVzc2lvbnMgPSBzZWFyY2hFeHByZXNzaW9ucztcclxuICAgIFxyXG59KCkpO1xudmFyIFNoYXBlRXhwcmVzc2lvbkludGVyZmFjZSA9IChmdW5jdGlvbigpe1xyXG5cclxuICAgIGZ1bmN0aW9uIGl0ZXJhdGVFbGVtZW50cyhzaGFwZXMsdmlldywgcHJvcGVydHlHcm91cCl7XHJcbiAgICAgICAgdmFyIGFyciA9IFtdO1xyXG4gICAgICAgIHZhciBpLCBsZW4gPSBzaGFwZXMgPyBzaGFwZXMubGVuZ3RoIDogMDtcclxuICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICBpZihzaGFwZXNbaV0udHkgPT0gJ2dyJyl7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaChncm91cEludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLHZpZXdbaV0scHJvcGVydHlHcm91cCkpO1xyXG4gICAgICAgICAgICB9ZWxzZSBpZihzaGFwZXNbaV0udHkgPT0gJ2ZsJyl7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaChmaWxsSW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sdmlld1tpXSxwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICAgICAgICAgIH1lbHNlIGlmKHNoYXBlc1tpXS50eSA9PSAnc3QnKXtcclxuICAgICAgICAgICAgICAgIGFyci5wdXNoKHN0cm9rZUludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLHZpZXdbaV0scHJvcGVydHlHcm91cCkpO1xyXG4gICAgICAgICAgICB9ZWxzZSBpZihzaGFwZXNbaV0udHkgPT0gJ3RtJyl7XHJcbiAgICAgICAgICAgICAgICBhcnIucHVzaCh0cmltSW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sdmlld1tpXSxwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICAgICAgICAgIH1lbHNlIGlmKHNoYXBlc1tpXS50eSA9PSAndHInKXtcclxuICAgICAgICAgICAgICAgIC8vYXJyLnB1c2godHJhbnNmb3JtSW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sdmlld1tpXSxwcm9wZXJ0eUdyb3VwKSk7XHJcbiAgICAgICAgICAgIH1lbHNlIGlmKHNoYXBlc1tpXS50eSA9PSAnZWwnKXtcclxuICAgICAgICAgICAgICAgIGFyci5wdXNoKGVsbGlwc2VJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSx2aWV3W2ldLHByb3BlcnR5R3JvdXApKTtcclxuICAgICAgICAgICAgfWVsc2UgaWYoc2hhcGVzW2ldLnR5ID09ICdzcicpe1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2goc3RhckludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLHZpZXdbaV0scHJvcGVydHlHcm91cCkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYoc2hhcGVzW2ldLnR5ID09ICdzaCcpe1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2gocGF0aEludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLHZpZXdbaV0scHJvcGVydHlHcm91cCkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYoc2hhcGVzW2ldLnR5ID09ICdyYycpe1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2gocmVjdEludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLHZpZXdbaV0scHJvcGVydHlHcm91cCkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYoc2hhcGVzW2ldLnR5ID09ICdyZCcpe1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2gocm91bmRlZEludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLHZpZXdbaV0scHJvcGVydHlHcm91cCkpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYoc2hhcGVzW2ldLnR5ID09ICdycCcpe1xyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2gocmVwZWF0ZXJJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSx2aWV3W2ldLHByb3BlcnR5R3JvdXApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbnRlbnRzSW50ZXJmYWNlRmFjdG9yeShzaGFwZSx2aWV3LCBwcm9wZXJ0eUdyb3VwKXtcclxuICAgICAgIHZhciBpbnRlcmZhY2VzO1xyXG4gICAgICAgdmFyIGludGVyZmFjZUZ1bmN0aW9uID0gZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IGludGVyZmFjZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZShpPGxlbil7XHJcbiAgICAgICAgICAgICAgICBpZihpbnRlcmZhY2VzW2ldLl9uYW1lID09PSB2YWx1ZSB8fCBpbnRlcmZhY2VzW2ldLm1uID09PSB2YWx1ZSB8fCBpbnRlcmZhY2VzW2ldLnByb3BlcnR5SW5kZXggPT09IHZhbHVlIHx8IGludGVyZmFjZXNbaV0uaXggPT09IHZhbHVlIHx8IGludGVyZmFjZXNbaV0uaW5kID09PSB2YWx1ZSl7XHJcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlc1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGkrPTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyl7XHJcbiAgICAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VzW3ZhbHVlLTFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICB9O1xyXG4gICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCA9IGZ1bmN0aW9uKHZhbCl7XHJcbiAgICAgICAgICAgaWYodmFsID09PSAxKXtcclxuICAgICAgICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gICAgICAgICAgIH0gZWxzZXtcclxuICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5R3JvdXAodmFsLTEpO1xyXG4gICAgICAgICAgIH1cclxuICAgICAgIH07XHJcbiAgICAgICBpbnRlcmZhY2VzID0gaXRlcmF0ZUVsZW1lbnRzKHNoYXBlLml0LCB2aWV3Lml0LCBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwKTtcclxuICAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm51bVByb3BlcnRpZXMgPSBpbnRlcmZhY2VzLmxlbmd0aDtcclxuICAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5jaXg7XHJcbiAgICAgICBpbnRlcmZhY2VGdW5jdGlvbi5fbmFtZSA9IHNoYXBlLm5tO1xyXG5cclxuICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcclxuICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdyb3VwSW50ZXJmYWNlRmFjdG9yeShzaGFwZSx2aWV3LCBwcm9wZXJ0eUdyb3VwKXtcclxuICAgICAgICB2YXIgaW50ZXJmYWNlRnVuY3Rpb24gPSBmdW5jdGlvbiBfaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICAgICAgICBzd2l0Y2godmFsdWUpe1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnQURCRSBWZWN0b3JzIEdyb3VwJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgJ0NvbnRlbnRzJzpcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uY29udGVudDtcclxuICAgICAgICAgICAgICAgIC8vTm90IG5lY2Vzc2FyeSBmb3Igbm93LiBLZWVwaW5nIHRoZW0gaGVyZSBpbiBjYXNlIGEgbmV3IGNhc2UgYXBwZWFyc1xyXG4gICAgICAgICAgICAgICAgLy9jYXNlICdBREJFIFZlY3RvciBUcmFuc2Zvcm0gR3JvdXAnOlxyXG4gICAgICAgICAgICAgICAgLy9jYXNlIDM6XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi50cmFuc2Zvcm07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXAgPSBmdW5jdGlvbih2YWwpe1xyXG4gICAgICAgICAgICBpZih2YWwgPT09IDEpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gICAgICAgICAgICB9IGVsc2V7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHlHcm91cCh2YWwtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBjb250ZW50ID0gY29udGVudHNJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLHZpZXcsaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCk7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybUludGVyZmFjZSA9IHRyYW5zZm9ybUludGVyZmFjZUZhY3Rvcnkoc2hhcGUuaXRbc2hhcGUuaXQubGVuZ3RoIC0gMV0sdmlldy5pdFt2aWV3Lml0Lmxlbmd0aCAtIDFdLGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXApO1xyXG4gICAgICAgIGludGVyZmFjZUZ1bmN0aW9uLmNvbnRlbnQgPSBjb250ZW50O1xyXG4gICAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnRyYW5zZm9ybSA9IHRyYW5zZm9ybUludGVyZmFjZTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW50ZXJmYWNlRnVuY3Rpb24sICdfbmFtZScsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYXBlLm5tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy9pbnRlcmZhY2VGdW5jdGlvbi5jb250ZW50ID0gaW50ZXJmYWNlRnVuY3Rpb247XHJcbiAgICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ubnVtUHJvcGVydGllcyA9IHNoYXBlLm5wO1xyXG4gICAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcclxuICAgICAgICBpbnRlcmZhY2VGdW5jdGlvbi5ubSA9IHNoYXBlLm5tO1xyXG4gICAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGZpbGxJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLHZpZXcscHJvcGVydHlHcm91cCl7XHJcbiAgICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsKXtcclxuICAgICAgICAgICAgaWYodmFsID09PSAnQ29sb3InIHx8IHZhbCA9PT0gJ2NvbG9yJyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uY29sb3I7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZih2YWwgPT09ICdPcGFjaXR5JyB8fCB2YWwgPT09ICdvcGFjaXR5Jyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3BhY2l0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xyXG4gICAgICAgICAgICAnY29sb3InOiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHByZXNzaW9uVmFsdWUodmlldy5jLCAxIC8gdmlldy5jLm11bHQsICdjb2xvcicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnb3BhY2l0eSc6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEV4cHJlc3Npb25WYWx1ZSh2aWV3Lm8sIDEwMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdfbmFtZSc6IHsgdmFsdWU6IHNoYXBlLm5tIH0sXHJcbiAgICAgICAgICAgICdtbic6IHsgdmFsdWU6IHNoYXBlLm1uIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmlldy5jLnNldEdyb3VwUHJvcGVydHkocHJvcGVydHlHcm91cCk7XHJcbiAgICAgICAgdmlldy5vLnNldEdyb3VwUHJvcGVydHkocHJvcGVydHlHcm91cCk7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN0cm9rZUludGVyZmFjZUZhY3Rvcnkoc2hhcGUsdmlldyxwcm9wZXJ0eUdyb3VwKXtcclxuICAgICAgICBmdW5jdGlvbiBfcHJvcGVydHlHcm91cCh2YWwpe1xyXG4gICAgICAgICAgICBpZih2YWwgPT09IDEpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iO1xyXG4gICAgICAgICAgICB9IGVsc2V7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHlHcm91cCh2YWwtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gX2Rhc2hQcm9wZXJ0eUdyb3VwKHZhbCl7XHJcbiAgICAgICAgICAgIGlmKHZhbCA9PT0gMSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGFzaE9iO1xyXG4gICAgICAgICAgICB9IGVsc2V7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3Byb3BlcnR5R3JvdXAodmFsLTEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGFkZFByb3BlcnR5VG9EYXNoT2IoaSkge1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGFzaE9iLCBzaGFwZS5kW2ldLm5tLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEV4cHJlc3Npb25WYWx1ZSh2aWV3LmQuZGF0YVByb3BzW2ldLnApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGksIGxlbiA9IHNoYXBlLmQgPyBzaGFwZS5kLmxlbmd0aCA6IDA7XHJcbiAgICAgICAgdmFyIGRhc2hPYiA9IHt9O1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG4gICAgICAgICAgICBhZGRQcm9wZXJ0eVRvRGFzaE9iKGkpO1xyXG4gICAgICAgICAgICB2aWV3LmQuZGF0YVByb3BzW2ldLnAuc2V0R3JvdXBQcm9wZXJ0eShfZGFzaFByb3BlcnR5R3JvdXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsKXtcclxuICAgICAgICAgICAgaWYodmFsID09PSAnQ29sb3InIHx8IHZhbCA9PT0gJ2NvbG9yJyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uY29sb3I7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZih2YWwgPT09ICdPcGFjaXR5JyB8fCB2YWwgPT09ICdvcGFjaXR5Jyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3BhY2l0eTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmKHZhbCA9PT0gJ1N0cm9rZSBXaWR0aCcgfHwgdmFsID09PSAnc3Ryb2tlIHdpZHRoJyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc3Ryb2tlV2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcclxuICAgICAgICAgICAgJ2NvbG9yJzoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXhwcmVzc2lvblZhbHVlKHZpZXcuYywgMSAvIHZpZXcuYy5tdWx0LCAnY29sb3InKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ29wYWNpdHknOiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHByZXNzaW9uVmFsdWUodmlldy5vLCAxMDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnc3Ryb2tlV2lkdGgnOiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHByZXNzaW9uVmFsdWUodmlldy53KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ2Rhc2gnOiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXNoT2I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdfbmFtZSc6IHsgdmFsdWU6IHNoYXBlLm5tIH0sXHJcbiAgICAgICAgICAgICdtbic6IHsgdmFsdWU6IHNoYXBlLm1uIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmlldy5jLnNldEdyb3VwUHJvcGVydHkoX3Byb3BlcnR5R3JvdXApO1xyXG4gICAgICAgIHZpZXcuby5zZXRHcm91cFByb3BlcnR5KF9wcm9wZXJ0eUdyb3VwKTtcclxuICAgICAgICB2aWV3Lncuc2V0R3JvdXBQcm9wZXJ0eShfcHJvcGVydHlHcm91cCk7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRyaW1JbnRlcmZhY2VGYWN0b3J5KHNoYXBlLHZpZXcscHJvcGVydHlHcm91cCl7XHJcbiAgICAgICAgZnVuY3Rpb24gX3Byb3BlcnR5R3JvdXAodmFsKXtcclxuICAgICAgICAgICAgaWYodmFsID09IDEpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5R3JvdXAoLS12YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcclxuXHJcbiAgICAgICAgdmlldy5zLnNldEdyb3VwUHJvcGVydHkoX3Byb3BlcnR5R3JvdXApO1xyXG4gICAgICAgIHZpZXcuZS5zZXRHcm91cFByb3BlcnR5KF9wcm9wZXJ0eUdyb3VwKTtcclxuICAgICAgICB2aWV3Lm8uc2V0R3JvdXBQcm9wZXJ0eShfcHJvcGVydHlHcm91cCk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbCl7XHJcbiAgICAgICAgICAgIGlmKHZhbCA9PT0gc2hhcGUuZS5peCB8fCB2YWwgPT09ICdFbmQnIHx8IHZhbCA9PT0gJ2VuZCcpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmVuZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih2YWwgPT09IHNoYXBlLnMuaXgpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnN0YXJ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHZhbCA9PT0gc2hhcGUuby5peCl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcclxuXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcclxuICAgICAgICAgICAgJ3N0YXJ0Jzoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXhwcmVzc2lvblZhbHVlKHZpZXcucywgMSAvIHZpZXcucy5tdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ2VuZCc6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEV4cHJlc3Npb25WYWx1ZSh2aWV3LmUsIDEgLyB2aWV3LmUubXVsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdvZmZzZXQnOiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHByZXNzaW9uVmFsdWUodmlldy5vKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ19uYW1lJzogeyB2YWx1ZTogc2hhcGUubm0gfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybUludGVyZmFjZUZhY3Rvcnkoc2hhcGUsdmlldyxwcm9wZXJ0eUdyb3VwKXtcclxuICAgICAgICBmdW5jdGlvbiBfcHJvcGVydHlHcm91cCh2YWwpe1xyXG4gICAgICAgICAgICBpZih2YWwgPT0gMSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHlHcm91cCgtLXZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmlldy50cmFuc2Zvcm0ubVByb3BzLm8uc2V0R3JvdXBQcm9wZXJ0eShfcHJvcGVydHlHcm91cCk7XHJcbiAgICAgICAgdmlldy50cmFuc2Zvcm0ubVByb3BzLnAuc2V0R3JvdXBQcm9wZXJ0eShfcHJvcGVydHlHcm91cCk7XHJcbiAgICAgICAgdmlldy50cmFuc2Zvcm0ubVByb3BzLmEuc2V0R3JvdXBQcm9wZXJ0eShfcHJvcGVydHlHcm91cCk7XHJcbiAgICAgICAgdmlldy50cmFuc2Zvcm0ubVByb3BzLnMuc2V0R3JvdXBQcm9wZXJ0eShfcHJvcGVydHlHcm91cCk7XHJcbiAgICAgICAgdmlldy50cmFuc2Zvcm0ubVByb3BzLnIuc2V0R3JvdXBQcm9wZXJ0eShfcHJvcGVydHlHcm91cCk7XHJcbiAgICAgICAgaWYodmlldy50cmFuc2Zvcm0ubVByb3BzLnNrKXtcclxuICAgICAgICAgICAgdmlldy50cmFuc2Zvcm0ubVByb3BzLnNrLnNldEdyb3VwUHJvcGVydHkoX3Byb3BlcnR5R3JvdXApO1xyXG4gICAgICAgICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMuc2Euc2V0R3JvdXBQcm9wZXJ0eShfcHJvcGVydHlHcm91cCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZpZXcudHJhbnNmb3JtLm9wLnNldEdyb3VwUHJvcGVydHkoX3Byb3BlcnR5R3JvdXApO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgICAgICAgIGlmKHNoYXBlLmEuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnQW5jaG9yIFBvaW50Jyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uYW5jaG9yUG9pbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoc2hhcGUuby5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdPcGFjaXR5Jyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3BhY2l0eTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihzaGFwZS5wLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1Bvc2l0aW9uJyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucG9zaXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoc2hhcGUuci5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdSb3RhdGlvbicgfHwgdmFsdWUgPT09ICdBREJFIFZlY3RvciBSb3RhdGlvbicpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHNoYXBlLnMuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnU2NhbGUnKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zY2FsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihzaGFwZS5zayAmJiBzaGFwZS5zay5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdTa2V3Jyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc2tldztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihzaGFwZS5zYSAmJiBzaGFwZS5zYS5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdTa2V3IEF4aXMnKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5za2V3QXhpcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcclxuICAgICAgICAgICAgJ29wYWNpdHknOiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEV4cHJlc3Npb25WYWx1ZSh2aWV3LnRyYW5zZm9ybS5tUHJvcHMubywgMS92aWV3LnRyYW5zZm9ybS5tUHJvcHMuby5tdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ3Bvc2l0aW9uJzoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHByZXNzaW9uVmFsdWUodmlldy50cmFuc2Zvcm0ubVByb3BzLnApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnYW5jaG9yUG9pbnQnOiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEV4cHJlc3Npb25WYWx1ZSh2aWV3LnRyYW5zZm9ybS5tUHJvcHMuYSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdzY2FsZSc6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXhwcmVzc2lvblZhbHVlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5zLCAxIC8gdmlldy50cmFuc2Zvcm0ubVByb3BzLnMubXVsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdyb3RhdGlvbic6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXhwcmVzc2lvblZhbHVlKHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5yLCAxIC8gdmlldy50cmFuc2Zvcm0ubVByb3BzLnIubXVsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdza2V3Jzoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHByZXNzaW9uVmFsdWUodmlldy50cmFuc2Zvcm0ubVByb3BzLnNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ3NrZXdBeGlzJzoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHByZXNzaW9uVmFsdWUodmlldy50cmFuc2Zvcm0ubVByb3BzLnNhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ19uYW1lJzogeyB2YWx1ZTogc2hhcGUubm0gfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnR5ID0gJ3RyJztcclxuICAgICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBlbGxpcHNlSW50ZXJmYWNlRmFjdG9yeShzaGFwZSx2aWV3LHByb3BlcnR5R3JvdXApe1xyXG4gICAgICAgIGZ1bmN0aW9uIF9wcm9wZXJ0eUdyb3VwKHZhbCl7XHJcbiAgICAgICAgICAgIGlmKHZhbCA9PSAxKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eUdyb3VwKC0tdmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XHJcbiAgICAgICAgdmFyIHByb3AgPSB2aWV3LnNoLnR5ID09PSAndG0nID8gdmlldy5zaC5wcm9wIDogdmlldy5zaDtcclxuICAgICAgICBwcm9wLnMuc2V0R3JvdXBQcm9wZXJ0eShfcHJvcGVydHlHcm91cCk7XHJcbiAgICAgICAgcHJvcC5wLnNldEdyb3VwUHJvcGVydHkoX3Byb3BlcnR5R3JvdXApO1xyXG4gICAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgICAgICAgaWYoc2hhcGUucC5peCA9PT0gdmFsdWUpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHNoYXBlLnMuaXggPT09IHZhbHVlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XHJcbiAgICAgICAgICAgICdzaXplJzoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHByZXNzaW9uVmFsdWUocHJvcC5zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ3Bvc2l0aW9uJzoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHByZXNzaW9uVmFsdWUocHJvcC5wKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ19uYW1lJzogeyB2YWx1ZTogc2hhcGUubm0gfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN0YXJJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLHZpZXcscHJvcGVydHlHcm91cCl7XHJcbiAgICAgICAgZnVuY3Rpb24gX3Byb3BlcnR5R3JvdXAodmFsKXtcclxuICAgICAgICAgICAgaWYodmFsID09IDEpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5R3JvdXAoLS12YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcm9wID0gdmlldy5zaC50eSA9PT0gJ3RtJyA/IHZpZXcuc2gucHJvcCA6IHZpZXcuc2g7XHJcbiAgICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xyXG4gICAgICAgIHByb3Aub3Iuc2V0R3JvdXBQcm9wZXJ0eShfcHJvcGVydHlHcm91cCk7XHJcbiAgICAgICAgcHJvcC5vcy5zZXRHcm91cFByb3BlcnR5KF9wcm9wZXJ0eUdyb3VwKTtcclxuICAgICAgICBwcm9wLnB0LnNldEdyb3VwUHJvcGVydHkoX3Byb3BlcnR5R3JvdXApO1xyXG4gICAgICAgIHByb3AucC5zZXRHcm91cFByb3BlcnR5KF9wcm9wZXJ0eUdyb3VwKTtcclxuICAgICAgICBwcm9wLnIuc2V0R3JvdXBQcm9wZXJ0eShfcHJvcGVydHlHcm91cCk7XHJcbiAgICAgICAgaWYoc2hhcGUuaXIpe1xyXG4gICAgICAgICAgICBwcm9wLmlyLnNldEdyb3VwUHJvcGVydHkoX3Byb3BlcnR5R3JvdXApO1xyXG4gICAgICAgICAgICBwcm9wLmlzLnNldEdyb3VwUHJvcGVydHkoX3Byb3BlcnR5R3JvdXApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICAgICAgICBpZihzaGFwZS5wLml4ID09PSB2YWx1ZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucG9zaXRpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoc2hhcGUuci5peCA9PT0gdmFsdWUpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnJvdGF0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHNoYXBlLnB0Lml4ID09PSB2YWx1ZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucG9pbnRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHNoYXBlLm9yLml4ID09PSB2YWx1ZSB8fCAnQURCRSBWZWN0b3IgU3RhciBPdXRlciBSYWRpdXMnID09PSB2YWx1ZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3V0ZXJSYWRpdXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoc2hhcGUub3MuaXggPT09IHZhbHVlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vdXRlclJvdW5kbmVzcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihzaGFwZS5pciAmJiAoc2hhcGUuaXIuaXggPT09IHZhbHVlIHx8ICdBREJFIFZlY3RvciBTdGFyIElubmVyIFJhZGl1cycgPT09IHZhbHVlKSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uaW5uZXJSYWRpdXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoc2hhcGUuaXMgJiYgc2hhcGUuaXMuaXggPT09IHZhbHVlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5pbm5lclJvdW5kbmVzcztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcclxuICAgICAgICAgICAgJ3Bvc2l0aW9uJzoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXhwcmVzc2lvblZhbHVlKHByb3AucCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdyb3RhdGlvbic6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEV4cHJlc3Npb25WYWx1ZShwcm9wLnIsIDEgLyBwcm9wLnIubXVsdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdwb2ludHMnOiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHByZXNzaW9uVmFsdWUocHJvcC5wdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdvdXRlclJhZGl1cyc6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEV4cHJlc3Npb25WYWx1ZShwcm9wLm9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ291dGVyUm91bmRuZXNzJzoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHByZXNzaW9uVmFsdWUocHJvcC5vcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdpbm5lclJhZGl1cyc6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICBpZighcHJvcC5pcil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXhwcmVzc2lvblZhbHVlKHByb3AuaXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnaW5uZXJSb3VuZG5lc3MnOiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoIXByb3AuaXMpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEV4cHJlc3Npb25WYWx1ZShwcm9wLmlzLCAxIC8gcHJvcC5pcy5tdWx0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ19uYW1lJzogeyB2YWx1ZTogc2hhcGUubm0gfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlY3RJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLHZpZXcscHJvcGVydHlHcm91cCl7XHJcbiAgICAgICAgZnVuY3Rpb24gX3Byb3BlcnR5R3JvdXAodmFsKXtcclxuICAgICAgICAgICAgaWYodmFsID09IDEpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5R3JvdXAoLS12YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcm9wID0gdmlldy5zaC50eSA9PT0gJ3RtJyA/IHZpZXcuc2gucHJvcCA6IHZpZXcuc2g7XHJcbiAgICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xyXG4gICAgICAgIHByb3AucC5zZXRHcm91cFByb3BlcnR5KF9wcm9wZXJ0eUdyb3VwKTtcclxuICAgICAgICBwcm9wLnMuc2V0R3JvdXBQcm9wZXJ0eShfcHJvcGVydHlHcm91cCk7XHJcbiAgICAgICAgcHJvcC5yLnNldEdyb3VwUHJvcGVydHkoX3Byb3BlcnR5R3JvdXApO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgICAgICAgIGlmKHNoYXBlLnAuaXggPT09IHZhbHVlKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb3NpdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihzaGFwZS5yLml4ID09PSB2YWx1ZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucm91bmRuZXNzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHNoYXBlLnMuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnU2l6ZScgfHwgdmFsdWUgPT09ICdBREJFIFZlY3RvciBSZWN0IFNpemUnKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zaXplO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xyXG4gICAgICAgICAgICAncG9zaXRpb24nOiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEV4cHJlc3Npb25WYWx1ZShwcm9wLnApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAncm91bmRuZXNzJzoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHByZXNzaW9uVmFsdWUocHJvcC5yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ3NpemUnOiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEV4cHJlc3Npb25WYWx1ZShwcm9wLnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnX25hbWUnOiB7IHZhbHVlOiBzaGFwZS5ubSB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ubW4gPSBzaGFwZS5tbjtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcm91bmRlZEludGVyZmFjZUZhY3Rvcnkoc2hhcGUsdmlldyxwcm9wZXJ0eUdyb3VwKXtcclxuICAgICAgICBmdW5jdGlvbiBfcHJvcGVydHlHcm91cCh2YWwpe1xyXG4gICAgICAgICAgICBpZih2YWwgPT0gMSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHlHcm91cCgtLXZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHByb3AgPSB2aWV3O1xyXG4gICAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcclxuICAgICAgICBwcm9wLnJkLnNldEdyb3VwUHJvcGVydHkoX3Byb3BlcnR5R3JvdXApO1xyXG5cclxuICAgICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgICAgICAgIGlmKHNoYXBlLnIuaXggPT09IHZhbHVlIHx8ICdSb3VuZCBDb3JuZXJzIDEnID09PSB2YWx1ZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucmFkaXVzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xyXG4gICAgICAgICAgICAncmFkaXVzJzoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXhwcmVzc2lvblZhbHVlKHByb3AucmQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnX25hbWUnOiB7IHZhbHVlOiBzaGFwZS5ubSB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ubW4gPSBzaGFwZS5tbjtcclxuICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmVwZWF0ZXJJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLHZpZXcscHJvcGVydHlHcm91cCl7XHJcbiAgICAgICAgZnVuY3Rpb24gX3Byb3BlcnR5R3JvdXAodmFsKXtcclxuICAgICAgICAgICAgaWYodmFsID09IDEpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5R3JvdXAoLS12YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcm9wID0gdmlldztcclxuICAgICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XHJcbiAgICAgICAgcHJvcC5jLnNldEdyb3VwUHJvcGVydHkoX3Byb3BlcnR5R3JvdXApO1xyXG4gICAgICAgIHByb3Auby5zZXRHcm91cFByb3BlcnR5KF9wcm9wZXJ0eUdyb3VwKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpe1xyXG4gICAgICAgICAgICBpZihzaGFwZS5jLml4ID09PSB2YWx1ZSB8fCAnQ29waWVzJyA9PT0gdmFsdWUpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmNvcGllcztcclxuICAgICAgICAgICAgfSBlbHNlIGlmKHNoYXBlLm8uaXggPT09IHZhbHVlIHx8ICdPZmZzZXQnID09PSB2YWx1ZSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub2Zmc2V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xyXG4gICAgICAgICAgICAnY29waWVzJzoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBFeHByZXNzaW9uVmFsdWUocHJvcC5jKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgJ29mZnNldCc6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXhwcmVzc2lvblZhbHVlKHByb3Aubyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdfbmFtZSc6IHsgdmFsdWU6IHNoYXBlLm5tIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXRoSW50ZXJmYWNlRmFjdG9yeShzaGFwZSx2aWV3LHByb3BlcnR5R3JvdXApe1xyXG4gICAgICAgIHZhciBwcm9wID0gdmlldy5zaDtcclxuICAgICAgICBmdW5jdGlvbiBfcHJvcGVydHlHcm91cCh2YWwpe1xyXG4gICAgICAgICAgICBpZih2YWwgPT0gMSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHlHcm91cCgtLXZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvcC5zZXRHcm91cFByb3BlcnR5KF9wcm9wZXJ0eUdyb3VwKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsKXtcclxuICAgICAgICAgICAgaWYodmFsID09PSAnU2hhcGUnIHx8IHZhbCA9PT0gJ3NoYXBlJyB8fCB2YWwgPT09ICdQYXRoJyB8fCB2YWwgPT09ICdwYXRoJyB8fCB2YWwgPT09ICdBREJFIFZlY3RvciBTaGFwZScgfHwgdmFsID09PSAyKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wYXRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XHJcbiAgICAgICAgICAgICdwYXRoJzoge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHByb3Auayl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3AuZ2V0VmFsdWUoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICdzaGFwZSc6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICBpZihwcm9wLmspe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wLmdldFZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAnX25hbWUnOiB7IHZhbHVlOiBzaGFwZS5ubSB9LFxyXG4gICAgICAgICAgICAnaXgnOiB7IHZhbHVlOiBzaGFwZS5peCB9LFxyXG4gICAgICAgICAgICAnbW4nOiB7IHZhbHVlOiBzaGFwZS5tbiB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbihzaGFwZXMsdmlldyxwcm9wZXJ0eUdyb3VwKSB7XHJcbiAgICAgICAgdmFyIGludGVyZmFjZXM7XHJcbiAgICAgICAgZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgICAgICAgaWYodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlc1t2YWx1ZS0xXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMCwgbGVuID0gaW50ZXJmYWNlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZShpPGxlbil7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaW50ZXJmYWNlc1tpXS5fbmFtZSA9PT0gdmFsdWUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaSs9MTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXA7XHJcbiAgICAgICAgaW50ZXJmYWNlcyA9IGl0ZXJhdGVFbGVtZW50cyhzaGFwZXMsIHZpZXcsIF9pbnRlcmZhY2VGdW5jdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIF9pbnRlcmZhY2VGdW5jdGlvbjtcclxuICAgIH07XHJcbn0oKSk7XHJcblxudmFyIFRleHRFeHByZXNzaW9uSW50ZXJmYWNlID0gKGZ1bmN0aW9uKCl7XHJcblx0cmV0dXJuIGZ1bmN0aW9uKGVsZW0pe1xyXG4gICAgICAgIHZhciBfcHJldlZhbHVlLCBfc291cmNlVGV4dDtcclxuICAgICAgICBmdW5jdGlvbiBfdGhpc0xheWVyRnVuY3Rpb24oKXtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzTGF5ZXJGdW5jdGlvbiwgXCJzb3VyY2VUZXh0XCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gZWxlbS50ZXh0UHJvcGVydHkuY3VycmVudERhdGEudDtcclxuICAgICAgICAgICAgICAgIGlmKHN0cmluZ1ZhbHVlICE9PSBfcHJldlZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbS50ZXh0UHJvcGVydHkuY3VycmVudERhdGEudCA9IF9wcmV2VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3NvdXJjZVRleHQgPSBuZXcgU3RyaW5nKHN0cmluZ1ZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAvL0lmIHN0cmluZ1ZhbHVlIGlzIGFuIGVtcHR5IHN0cmluZywgZXZhbCByZXR1cm5zIHVuZGVmaW5lZCwgc28gaXQgaGFzIHRvIGJlIHJldHVybmVkIGFzIGEgU3RyaW5nIHByaW1pdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgIF9zb3VyY2VUZXh0LnZhbHVlID0gc3RyaW5nVmFsdWUgPyBzdHJpbmdWYWx1ZSA6IG5ldyBTdHJpbmcoc3RyaW5nVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zb3VyY2VUZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbjtcclxuICAgIH07XHJcbn0oKSk7XG52YXIgTGF5ZXJFeHByZXNzaW9uSW50ZXJmYWNlID0gKGZ1bmN0aW9uICgpe1xyXG4gICAgZnVuY3Rpb24gdG9Xb3JsZChhcnIsIHRpbWUpe1xyXG4gICAgICAgIHZhciB0b1dvcmxkTWF0ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgIHRvV29ybGRNYXQucmVzZXQoKTtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtTWF0O1xyXG4gICAgICAgIGlmKHRpbWUpIHtcclxuICAgICAgICAgICAgLy9Ub2RvIGltcGxlbWVudCB2YWx1ZSBhdCB0aW1lIG9uIHRyYW5zZm9ybSBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgIC8vdHJhbnNmb3JtTWF0ID0gdGhpcy5fZWxlbS5maW5hbFRyYW5zZm9ybS5tUHJvcC5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcclxuICAgICAgICAgICAgdHJhbnNmb3JtTWF0ID0gdGhpcy5fZWxlbS5maW5hbFRyYW5zZm9ybS5tUHJvcDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm1NYXQgPSB0aGlzLl9lbGVtLmZpbmFsVHJhbnNmb3JtLm1Qcm9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmFuc2Zvcm1NYXQuYXBwbHlUb01hdHJpeCh0b1dvcmxkTWF0KTtcclxuICAgICAgICBpZih0aGlzLl9lbGVtLmhpZXJhcmNoeSAmJiB0aGlzLl9lbGVtLmhpZXJhcmNoeS5sZW5ndGgpe1xyXG4gICAgICAgICAgICB2YXIgaSwgbGVuID0gdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbS5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3AuYXBwbHlUb01hdHJpeCh0b1dvcmxkTWF0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdG9Xb3JsZE1hdC5hcHBseVRvUG9pbnRBcnJheShhcnJbMF0sYXJyWzFdLGFyclsyXXx8MCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b1dvcmxkTWF0LmFwcGx5VG9Qb2ludEFycmF5KGFyclswXSxhcnJbMV0sYXJyWzJdfHwwKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGZyb21Xb3JsZChhcnIsIHRpbWUpe1xyXG4gICAgICAgIHZhciB0b1dvcmxkTWF0ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgIHRvV29ybGRNYXQucmVzZXQoKTtcclxuICAgICAgICB2YXIgdHJhbnNmb3JtTWF0O1xyXG4gICAgICAgIGlmKHRpbWUpIHtcclxuICAgICAgICAgICAgLy9Ub2RvIGltcGxlbWVudCB2YWx1ZSBhdCB0aW1lIG9uIHRyYW5zZm9ybSBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgIC8vdHJhbnNmb3JtTWF0ID0gdGhpcy5fZWxlbS5maW5hbFRyYW5zZm9ybS5tUHJvcC5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcclxuICAgICAgICAgICAgdHJhbnNmb3JtTWF0ID0gdGhpcy5fZWxlbS5maW5hbFRyYW5zZm9ybS5tUHJvcDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm1NYXQgPSB0aGlzLl9lbGVtLmZpbmFsVHJhbnNmb3JtLm1Qcm9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cmFuc2Zvcm1NYXQuYXBwbHlUb01hdHJpeCh0b1dvcmxkTWF0KTtcclxuICAgICAgICBpZih0aGlzLl9lbGVtLmhpZXJhcmNoeSAmJiB0aGlzLl9lbGVtLmhpZXJhcmNoeS5sZW5ndGgpe1xyXG4gICAgICAgICAgICB2YXIgaSwgbGVuID0gdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbS5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3AuYXBwbHlUb01hdHJpeCh0b1dvcmxkTWF0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdG9Xb3JsZE1hdC5pbnZlcnNlUG9pbnQoYXJyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvV29ybGRNYXQuaW52ZXJzZVBvaW50KGFycik7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBmcm9tQ29tcChhcnIpe1xyXG4gICAgICAgIHZhciB0b1dvcmxkTWF0ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgIHRvV29ybGRNYXQucmVzZXQoKTtcclxuICAgICAgICB0aGlzLl9lbGVtLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLmFwcGx5VG9NYXRyaXgodG9Xb3JsZE1hdCk7XHJcbiAgICAgICAgaWYodGhpcy5fZWxlbS5oaWVyYXJjaHkgJiYgdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoKXtcclxuICAgICAgICAgICAgdmFyIGksIGxlbiA9IHRoaXMuX2VsZW0uaGllcmFyY2h5Lmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VsZW0uaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLmFwcGx5VG9NYXRyaXgodG9Xb3JsZE1hdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRvV29ybGRNYXQuaW52ZXJzZVBvaW50KGFycik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0b1dvcmxkTWF0LmludmVyc2VQb2ludChhcnIpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNhbXBsZUltYWdlKCkge1xyXG4gICAgICAgIHJldHVybiBbMSwxLDEsMV07XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbihlbGVtKXtcclxuXHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybUludGVyZmFjZTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gX3JlZ2lzdGVyTWFza0ludGVyZmFjZShtYXNrTWFuYWdlcil7XHJcbiAgICAgICAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5tYXNrID0gbmV3IE1hc2tNYW5hZ2VySW50ZXJmYWNlKG1hc2tNYW5hZ2VyLCBlbGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gX3JlZ2lzdGVyRWZmZWN0c0ludGVyZmFjZShlZmZlY3RzKXtcclxuICAgICAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmVmZmVjdCA9IGVmZmVjdHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBfdGhpc0xheWVyRnVuY3Rpb24obmFtZSl7XHJcbiAgICAgICAgICAgIHN3aXRjaChuYW1lKXtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJBREJFIFJvb3QgVmVjdG9ycyBHcm91cFwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkNvbnRlbnRzXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbi5zaGFwZUludGVyZmFjZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJUcmFuc2Zvcm1cIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0cmFuc2Zvcm1cIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJBREJFIFRyYW5zZm9ybSBHcm91cFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1JbnRlcmZhY2U7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiQURCRSBFZmZlY3QgUGFyYWRlXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbi5lZmZlY3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnRvV29ybGQgPSB0b1dvcmxkO1xyXG4gICAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5mcm9tV29ybGQgPSBmcm9tV29ybGQ7XHJcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnRvQ29tcCA9IHRvV29ybGQ7XHJcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmZyb21Db21wID0gZnJvbUNvbXA7XHJcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnNhbXBsZUltYWdlID0gc2FtcGxlSW1hZ2U7XHJcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnNvdXJjZVJlY3RBdFRpbWUgPSBlbGVtLnNvdXJjZVJlY3RBdFRpbWUuYmluZChlbGVtKTtcclxuICAgICAgICBfdGhpc0xheWVyRnVuY3Rpb24uX2VsZW0gPSBlbGVtO1xyXG4gICAgICAgIHRyYW5zZm9ybUludGVyZmFjZSA9IFRyYW5zZm9ybUV4cHJlc3Npb25JbnRlcmZhY2UoZWxlbS5maW5hbFRyYW5zZm9ybS5tUHJvcCk7XHJcbiAgICAgICAgdmFyIGFuY2hvclBvaW50RGVzY3JpcHRvciA9IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAnYW5jaG9yUG9pbnQnKTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhfdGhpc0xheWVyRnVuY3Rpb24se1xyXG4gICAgICAgICAgICBoYXNQYXJlbnQ6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5oaWVyYXJjaHkubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwYXJlbnQ6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5oaWVyYXJjaHlbMF0ubGF5ZXJJbnRlcmZhY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiBnZXREZXNjcmlwdG9yKHRyYW5zZm9ybUludGVyZmFjZSwgJ3JvdGF0aW9uJyksXHJcbiAgICAgICAgICAgIHNjYWxlOiBnZXREZXNjcmlwdG9yKHRyYW5zZm9ybUludGVyZmFjZSwgJ3NjYWxlJyksXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBnZXREZXNjcmlwdG9yKHRyYW5zZm9ybUludGVyZmFjZSwgJ3Bvc2l0aW9uJyksXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAnb3BhY2l0eScpLFxyXG4gICAgICAgICAgICBhbmNob3JQb2ludDogYW5jaG9yUG9pbnREZXNjcmlwdG9yLFxyXG4gICAgICAgICAgICBhbmNob3JfcG9pbnQ6IGFuY2hvclBvaW50RGVzY3JpcHRvcixcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtSW50ZXJmYWNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhY3RpdmU6IHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5pc0luUmFuZ2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnN0YXJ0VGltZSA9IGVsZW0uZGF0YS5zdDtcclxuICAgICAgICBfdGhpc0xheWVyRnVuY3Rpb24uaW5kZXggPSBlbGVtLmRhdGEuaW5kO1xyXG4gICAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5zb3VyY2UgPSBlbGVtLmRhdGEucmVmSWQ7XHJcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmhlaWdodCA9IGVsZW0uZGF0YS50eSA9PT0gMCA/IGVsZW0uZGF0YS5oIDogMTAwO1xyXG4gICAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi53aWR0aCA9IGVsZW0uZGF0YS50eSA9PT0gMCA/IGVsZW0uZGF0YS53IDogMTAwO1xyXG4gICAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5pblBvaW50ID0gZWxlbS5kYXRhLmlwL2VsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcclxuICAgICAgICBfdGhpc0xheWVyRnVuY3Rpb24ub3V0UG9pbnQgPSBlbGVtLmRhdGEub3AvZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xyXG4gICAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5fbmFtZSA9IGVsZW0uZGF0YS5ubTtcclxuXHJcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnJlZ2lzdGVyTWFza0ludGVyZmFjZSA9IF9yZWdpc3Rlck1hc2tJbnRlcmZhY2U7XHJcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnJlZ2lzdGVyRWZmZWN0c0ludGVyZmFjZSA9IF9yZWdpc3RlckVmZmVjdHNJbnRlcmZhY2U7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbjtcclxuICAgIH07XHJcbn0oKSk7XHJcblxudmFyIENvbXBFeHByZXNzaW9uSW50ZXJmYWNlID0gKGZ1bmN0aW9uICgpe1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNvbXApe1xyXG4gICAgICAgIGZ1bmN0aW9uIF90aGlzTGF5ZXJGdW5jdGlvbihuYW1lKXtcclxuICAgICAgICAgICAgdmFyIGk9MCwgbGVuID0gY29tcC5sYXllcnMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZShpPGxlbil7XHJcbiAgICAgICAgICAgICAgICBpZihjb21wLmxheWVyc1tpXS5ubSA9PT0gbmFtZSB8fCBjb21wLmxheWVyc1tpXS5pbmQgPT09IG5hbWUpe1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21wLmVsZW1lbnRzW2ldLmxheWVySW50ZXJmYWNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAvL3JldHVybiB7YWN0aXZlOmZhbHNlfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzTGF5ZXJGdW5jdGlvbiwgXCJfbmFtZVwiLCB7IHZhbHVlOmNvbXAuZGF0YS5ubSB9KTtcclxuICAgICAgICBfdGhpc0xheWVyRnVuY3Rpb24ubGF5ZXIgPSBfdGhpc0xheWVyRnVuY3Rpb247XHJcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnBpeGVsQXNwZWN0ID0gMTtcclxuICAgICAgICBfdGhpc0xheWVyRnVuY3Rpb24uaGVpZ2h0ID0gY29tcC5kYXRhLmggfHwgY29tcC5nbG9iYWxEYXRhLmNvbXBTaXplLmg7XHJcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLndpZHRoID0gY29tcC5kYXRhLncgfHwgY29tcC5nbG9iYWxEYXRhLmNvbXBTaXplLnc7XHJcbiAgICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnBpeGVsQXNwZWN0ID0gMTtcclxuICAgICAgICBfdGhpc0xheWVyRnVuY3Rpb24uZnJhbWVEdXJhdGlvbiA9IDEvY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcclxuICAgICAgICBfdGhpc0xheWVyRnVuY3Rpb24ubnVtTGF5ZXJzID0gY29tcC5sYXllcnMubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb247XHJcbiAgICB9O1xyXG59KCkpO1xudmFyIFRyYW5zZm9ybUV4cHJlc3Npb25JbnRlcmZhY2UgPSAoZnVuY3Rpb24gKCl7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24odHJhbnNmb3JtKXtcclxuICAgICAgICBmdW5jdGlvbiBfdGhpc0Z1bmN0aW9uKG5hbWUpe1xyXG4gICAgICAgICAgICBzd2l0Y2gobmFtZSl7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwic2NhbGVcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJTY2FsZVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkFEQkUgU2NhbGVcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5zY2FsZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJyb3RhdGlvblwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIlJvdGF0aW9uXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiQURCRSBSb3RhdGlvblwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkFEQkUgUm90YXRlIFpcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgMTA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ucm90YXRpb247XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiQURCRSBSb3RhdGUgWFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnhSb3RhdGlvbjtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJBREJFIFJvdGF0ZSBZXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ueVJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInBvc2l0aW9uXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiUG9zaXRpb25cIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJBREJFIFBvc2l0aW9uXCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBjYXNlICdBREJFIFBvc2l0aW9uXzAnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnhQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ0FEQkUgUG9zaXRpb25fMSc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ueVBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnQURCRSBQb3NpdGlvbl8yJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi56UG9zaXRpb247XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiYW5jaG9yUG9pbnRcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJBbmNob3JQb2ludFwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkFuY2hvciBQb2ludFwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSBcIkFEQkUgQW5jaG9yUG9pbnRcIjpcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5hbmNob3JQb2ludDtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJvcGFjaXR5XCI6XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiT3BhY2l0eVwiOlxyXG4gICAgICAgICAgICAgICAgY2FzZSAxMTpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5vcGFjaXR5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgXCJyb3RhdGlvblwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIGlmKHRyYW5zZm9ybS5yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEV4cHJlc3Npb25WYWx1ZSh0cmFuc2Zvcm0uciwgMS9kZWdUb1JhZHMpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXhwcmVzc2lvblZhbHVlKHRyYW5zZm9ybS5yeiwgMS9kZWdUb1JhZHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCBcInhSb3RhdGlvblwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXhwcmVzc2lvblZhbHVlKHRyYW5zZm9ybS5yeCwgMS9kZWdUb1JhZHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCBcInlSb3RhdGlvblwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRXhwcmVzc2lvblZhbHVlKHRyYW5zZm9ybS5yeSwgMS9kZWdUb1JhZHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sIFwic2NhbGVcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBFeHByZXNzaW9uVmFsdWUodHJhbnNmb3JtLnMsIDEwMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sIFwicG9zaXRpb25cIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmKHRyYW5zZm9ybS5wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEV4cHJlc3Npb25WYWx1ZSh0cmFuc2Zvcm0ucCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdHJhbnNmb3JtLnB4LnYsIHRyYW5zZm9ybS5weS52LCB0cmFuc2Zvcm0ucHogPyB0cmFuc2Zvcm0ucHoudiA6IDBdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCBcInhQb3NpdGlvblwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEV4cHJlc3Npb25WYWx1ZSh0cmFuc2Zvcm0ucHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCBcInlQb3NpdGlvblwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEV4cHJlc3Npb25WYWx1ZSh0cmFuc2Zvcm0ucHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCBcInpQb3NpdGlvblwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEV4cHJlc3Npb25WYWx1ZSh0cmFuc2Zvcm0ucHopO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCBcImFuY2hvclBvaW50XCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRXhwcmVzc2lvblZhbHVlKHRyYW5zZm9ybS5hKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgXCJvcGFjaXR5XCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRXhwcmVzc2lvblZhbHVlKHRyYW5zZm9ybS5vLCAxMDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCBcInNrZXdcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBFeHByZXNzaW9uVmFsdWUodHJhbnNmb3JtLnNrKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgXCJza2V3QXhpc1wiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEV4cHJlc3Npb25WYWx1ZSh0cmFuc2Zvcm0uc2EpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCBcIm9yaWVudGF0aW9uXCIsIHtcclxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRXhwcmVzc2lvblZhbHVlKHRyYW5zZm9ybS5vcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb247XHJcbiAgICB9O1xyXG59KCkpO1xudmFyIFByb2plY3RJbnRlcmZhY2UgPSAoZnVuY3Rpb24gKCl7XHJcblxyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJDb21wb3NpdGlvbihjb21wKXtcclxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9ucy5wdXNoKGNvbXApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbigpe1xyXG4gICAgICAgIGZ1bmN0aW9uIF90aGlzUHJvamVjdEZ1bmN0aW9uKG5hbWUpe1xyXG4gICAgICAgICAgICB2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY29tcG9zaXRpb25zLmxlbmd0aDtcclxuICAgICAgICAgICAgd2hpbGUoaTxsZW4pe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jb21wb3NpdGlvbnNbaV0uZGF0YSAmJiB0aGlzLmNvbXBvc2l0aW9uc1tpXS5kYXRhLm5tID09PSBuYW1lKXtcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmNvbXBvc2l0aW9uc1tpXS5wcmVwYXJlRnJhbWUgJiYgdGhpcy5jb21wb3NpdGlvbnNbaV0uZGF0YS54dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvc2l0aW9uc1tpXS5wcmVwYXJlRnJhbWUodGhpcy5jdXJyZW50RnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wb3NpdGlvbnNbaV0uY29tcEludGVyZmFjZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGkrPTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIF90aGlzUHJvamVjdEZ1bmN0aW9uLmNvbXBvc2l0aW9ucyA9IFtdO1xyXG4gICAgICAgIF90aGlzUHJvamVjdEZ1bmN0aW9uLmN1cnJlbnRGcmFtZSA9IDA7XHJcblxyXG4gICAgICAgIF90aGlzUHJvamVjdEZ1bmN0aW9uLnJlZ2lzdGVyQ29tcG9zaXRpb24gPSByZWdpc3RlckNvbXBvc2l0aW9uO1xyXG5cclxuXHJcblxyXG4gICAgICAgIHJldHVybiBfdGhpc1Byb2plY3RGdW5jdGlvbjtcclxuICAgIH07XHJcbn0oKSk7XG52YXIgRWZmZWN0c0V4cHJlc3Npb25JbnRlcmZhY2UgPSAoZnVuY3Rpb24gKCl7XHJcbiAgICB2YXIgb2IgPSB7XHJcbiAgICAgICAgY3JlYXRlRWZmZWN0c0ludGVyZmFjZTogY3JlYXRlRWZmZWN0c0ludGVyZmFjZVxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVFZmZlY3RzSW50ZXJmYWNlKGVsZW0sIHByb3BlcnR5R3JvdXApe1xyXG4gICAgICAgIGlmKGVsZW0uZWZmZWN0c01hbmFnZXIpe1xyXG5cclxuICAgICAgICAgICAgdmFyIGVmZmVjdEVsZW1lbnRzID0gW107XHJcbiAgICAgICAgICAgIHZhciBlZmZlY3RzRGF0YSA9IGVsZW0uZGF0YS5lZjtcclxuICAgICAgICAgICAgdmFyIGksIGxlbiA9IGVsZW0uZWZmZWN0c01hbmFnZXIuZWZmZWN0RWxlbWVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0RWxlbWVudHMucHVzaChjcmVhdGVHcm91cEludGVyZmFjZShlZmZlY3RzRGF0YVtpXSxlbGVtLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzW2ldLHByb3BlcnR5R3JvdXAsZWxlbSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSl7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWZmZWN0cyA9IGVsZW0uZGF0YS5lZiB8fCBbXSwgaSA9IDAsIGxlbiA9IGVmZmVjdHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUoaTxsZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZihuYW1lID09PSBlZmZlY3RzW2ldLm5tIHx8IG5hbWUgPT09IGVmZmVjdHNbaV0ubW4gfHwgbmFtZSA9PT0gZWZmZWN0c1tpXS5peCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlZmZlY3RFbGVtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjcmVhdGVHcm91cEludGVyZmFjZShkYXRhLGVsZW1lbnRzLCBwcm9wZXJ0eUdyb3VwLCBlbGVtKXtcclxuICAgICAgICB2YXIgZWZmZWN0RWxlbWVudHMgPSBbXTtcclxuICAgICAgICB2YXIgaSwgbGVuID0gZGF0YS5lZi5sZW5ndGg7XHJcbiAgICAgICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICAgICAgaWYoZGF0YS5lZltpXS50eSA9PT0gNSl7XHJcbiAgICAgICAgICAgICAgICBlZmZlY3RFbGVtZW50cy5wdXNoKGNyZWF0ZUdyb3VwSW50ZXJmYWNlKGRhdGEuZWZbaV0sZWxlbWVudHMuZWZmZWN0RWxlbWVudHNbaV0sZWxlbWVudHMuZWZmZWN0RWxlbWVudHNbaV0ucHJvcGVydHlHcm91cCwgZWxlbSkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZWZmZWN0RWxlbWVudHMucHVzaChjcmVhdGVWYWx1ZUludGVyZmFjZShlbGVtZW50cy5lZmZlY3RFbGVtZW50c1tpXSxkYXRhLmVmW2ldLnR5LCBlbGVtLCBfcHJvcGVydHlHcm91cCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmdW5jdGlvbiBfcHJvcGVydHlHcm91cCh2YWwpIHtcclxuICAgICAgICAgICAgaWYodmFsID09PSAxKXtcclxuICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwSW50ZXJmYWNlO1xyXG4gICAgICAgICAgICB9IGVsc2V7XHJcbiAgICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eUdyb3VwKHZhbC0xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIGdyb3VwSW50ZXJmYWNlID0gZnVuY3Rpb24obmFtZSl7XHJcbiAgICAgICAgICAgIHZhciBlZmZlY3RzID0gZGF0YS5lZiwgaSA9IDAsIGxlbiA9IGVmZmVjdHMubGVuZ3RoO1xyXG4gICAgICAgICAgICB3aGlsZShpPGxlbikge1xyXG4gICAgICAgICAgICAgICAgaWYobmFtZSA9PT0gZWZmZWN0c1tpXS5ubSB8fCBuYW1lID09PSBlZmZlY3RzW2ldLm1uIHx8IG5hbWUgPT09IGVmZmVjdHNbaV0uaXgpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGVmZmVjdHNbaV0udHkgPT09IDUpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWZmZWN0RWxlbWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVmZmVjdEVsZW1lbnRzW2ldKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaSArPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBlZmZlY3RFbGVtZW50c1swXSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGdyb3VwSW50ZXJmYWNlLnByb3BlcnR5R3JvdXAgPSBfcHJvcGVydHlHcm91cDtcclxuXHJcbiAgICAgICAgaWYoZGF0YS5tbiA9PT0gJ0FEQkUgQ29sb3IgQ29udHJvbCcpe1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ3JvdXBJbnRlcmZhY2UsICdjb2xvcicsIHtcclxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWZmZWN0RWxlbWVudHNbMF0oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShncm91cEludGVyZmFjZSwgJ251bVByb3BlcnRpZXMnLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLm5wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZ3JvdXBJbnRlcmZhY2UuYWN0aXZlID0gZGF0YS5lbiAhPT0gMDtcclxuICAgICAgICByZXR1cm4gZ3JvdXBJbnRlcmZhY2U7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3JlYXRlVmFsdWVJbnRlcmZhY2UoZWxlbWVudCwgdHlwZSwgZWxlbSwgcHJvcGVydHlHcm91cCl7XHJcbiAgICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgaWYodHlwZSA9PT0gMTApe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW0uY29tcC5jb21wSW50ZXJmYWNlKGVsZW1lbnQucC52KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gRXhwcmVzc2lvblZhbHVlKGVsZW1lbnQucCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihlbGVtZW50LnAuc2V0R3JvdXBQcm9wZXJ0eSkge1xyXG4gICAgICAgICAgICBlbGVtZW50LnAuc2V0R3JvdXBQcm9wZXJ0eShwcm9wZXJ0eUdyb3VwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb2I7XHJcblxyXG59KCkpO1xudmFyIE1hc2tNYW5hZ2VySW50ZXJmYWNlID0gKGZ1bmN0aW9uKCl7XHJcblxyXG5cdGZ1bmN0aW9uIE1hc2tJbnRlcmZhY2UobWFzaywgZGF0YSl7XHJcblx0XHR0aGlzLl9tYXNrID0gbWFzaztcclxuXHRcdHRoaXMuX2RhdGEgPSBkYXRhO1xyXG5cdH1cclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFza0ludGVyZmFjZS5wcm90b3R5cGUsICdtYXNrUGF0aCcsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9tYXNrLnByb3Auayl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFzay5wcm9wLmdldFZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFzay5wcm9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG5cdHZhciBNYXNrTWFuYWdlciA9IGZ1bmN0aW9uKG1hc2tNYW5hZ2VyLCBlbGVtKXtcclxuXHRcdHZhciBfbWFza01hbmFnZXIgPSBtYXNrTWFuYWdlcjtcclxuXHRcdHZhciBfZWxlbSA9IGVsZW07XHJcblx0XHR2YXIgX21hc2tzSW50ZXJmYWNlcyA9IGNyZWF0ZVNpemVkQXJyYXkobWFza01hbmFnZXIudmlld0RhdGEubGVuZ3RoKTtcclxuXHRcdHZhciBpLCBsZW4gPSBtYXNrTWFuYWdlci52aWV3RGF0YS5sZW5ndGg7XHJcblx0XHRmb3IoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xyXG5cdFx0XHRfbWFza3NJbnRlcmZhY2VzW2ldID0gbmV3IE1hc2tJbnRlcmZhY2UobWFza01hbmFnZXIudmlld0RhdGFbaV0sIG1hc2tNYW5hZ2VyLm1hc2tzUHJvcGVydGllc1tpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG1hc2tGdW5jdGlvbiA9IGZ1bmN0aW9uKG5hbWUpe1xyXG5cdFx0XHRpID0gMDtcclxuXHRcdCAgICB3aGlsZShpPGxlbil7XHJcblx0XHQgICAgICAgIGlmKG1hc2tNYW5hZ2VyLm1hc2tzUHJvcGVydGllc1tpXS5ubSA9PT0gbmFtZSl7XHJcblx0XHQgICAgICAgICAgICByZXR1cm4gX21hc2tzSW50ZXJmYWNlc1tpXTtcclxuXHRcdCAgICAgICAgfVxyXG5cdFx0ICAgICAgICBpICs9IDE7XHJcblx0XHQgICAgfVxyXG5cdFx0fTtcclxuXHRcdHJldHVybiBtYXNrRnVuY3Rpb247XHJcblx0fTtcclxuXHRyZXR1cm4gTWFza01hbmFnZXI7XHJcbn0oKSk7XHJcblxudmFyIEV4cHJlc3Npb25WYWx1ZSA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gZnVuY3Rpb24oZWxlbWVudFByb3AsIG11bHQsIHR5cGUpIHtcclxuICAgICAgICBtdWx0ID0gbXVsdCB8fCAxO1xyXG4gICAgICAgIHZhciBleHByZXNzaW9uVmFsdWUsIGFycmF5VmFsdWU7XHJcblxyXG5cdFx0aWYgKGVsZW1lbnRQcm9wLmspIHtcclxuICAgICAgICAgICAgZWxlbWVudFByb3AuZ2V0VmFsdWUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGksIGxlbiwgYXJyVmFsdWUsIHZhbDtcclxuICAgICAgICBpZiAodHlwZSkge1xyXG4gICAgICAgIFx0aWYodHlwZSA9PT0gJ2NvbG9yJykge1xyXG4gICAgICAgIFx0XHRsZW4gPSA0O1xyXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvblZhbHVlID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XHJcbiAgICAgICAgICAgICAgICBhcnJWYWx1ZSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xyXG5cdFx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcclxuXHRcdCAgICAgICAgICAgIGV4cHJlc3Npb25WYWx1ZVtpXSA9IGFyclZhbHVlW2ldID0gKGkgPCAzKSA/IGVsZW1lbnRQcm9wLnZbaV0gKiBtdWx0IDogMTtcclxuXHRcdCAgICAgICAgfVxyXG5cdCAgICAgICAgXHRleHByZXNzaW9uVmFsdWUudmFsdWUgPSBhcnJWYWx1ZTtcclxuICAgICAgICBcdH1cclxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnRQcm9wLnByb3BUeXBlID09PSAndW5pZGltZW5zaW9uYWwnKXtcclxuICAgICAgICAgICAgdmFsID0gZWxlbWVudFByb3AudiAqIG11bHQ7XHJcbiAgICAgICAgICAgIGV4cHJlc3Npb25WYWx1ZSA9IG5ldyBOdW1iZXIodmFsKTtcclxuICAgICAgICAgICAgZXhwcmVzc2lvblZhbHVlLnZhbHVlID0gdmFsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgXHRsZW4gPSBlbGVtZW50UHJvcC5wdi5sZW5ndGg7XHJcbiAgICAgICAgICAgIGV4cHJlc3Npb25WYWx1ZSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xyXG4gICAgICAgICAgICBhcnJWYWx1ZSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xyXG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XHJcblx0ICAgICAgICAgICAgZXhwcmVzc2lvblZhbHVlW2ldID0gYXJyVmFsdWVbaV0gPSBlbGVtZW50UHJvcC52W2ldICogbXVsdDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgICAgIGV4cHJlc3Npb25WYWx1ZS52YWx1ZSA9IGFyclZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBleHByZXNzaW9uVmFsdWUubnVtS2V5cyA9IGVsZW1lbnRQcm9wLmtleWZyYW1lcyA/IGVsZW1lbnRQcm9wLmtleWZyYW1lcy5sZW5ndGggOiAwO1xyXG4gICAgICAgIGV4cHJlc3Npb25WYWx1ZS5rZXkgPSBmdW5jdGlvbihwb3MpIHtcclxuICAgICAgICAgICAgaWYgKCFleHByZXNzaW9uVmFsdWUubnVtS2V5cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudFByb3Aua2V5ZnJhbWVzW3Bvcy0xXS50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBleHByZXNzaW9uVmFsdWUudmFsdWVBdFRpbWUgPSBlbGVtZW50UHJvcC5nZXRWYWx1ZUF0VGltZTtcclxuICAgICAgICBleHByZXNzaW9uVmFsdWUuc3BlZWRBdFRpbWUgPSBlbGVtZW50UHJvcC5nZXRTcGVlZEF0VGltZTtcclxuICAgICAgICBleHByZXNzaW9uVmFsdWUudmVsb2NpdHlBdFRpbWUgPSBlbGVtZW50UHJvcC5nZXRWZWxvY2l0eUF0VGltZTtcclxuICAgICAgICBleHByZXNzaW9uVmFsdWUucHJvcGVydHlHcm91cCA9IGVsZW1lbnRQcm9wLnByb3BlcnR5R3JvdXA7XHJcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25WYWx1ZTtcclxuXHR9O1xyXG59KCkpO1xuZnVuY3Rpb24gU2xpZGVyRWZmZWN0KGRhdGEsZWxlbSwgY29udGFpbmVyKXtcclxuICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS52LDAsMCxjb250YWluZXIpO1xyXG59XHJcbmZ1bmN0aW9uIEFuZ2xlRWZmZWN0KGRhdGEsZWxlbSwgY29udGFpbmVyKXtcclxuICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS52LDAsMCxjb250YWluZXIpO1xyXG59XHJcbmZ1bmN0aW9uIENvbG9yRWZmZWN0KGRhdGEsZWxlbSwgY29udGFpbmVyKXtcclxuICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS52LDEsMCxjb250YWluZXIpO1xyXG59XHJcbmZ1bmN0aW9uIFBvaW50RWZmZWN0KGRhdGEsZWxlbSwgY29udGFpbmVyKXtcclxuICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS52LDEsMCxjb250YWluZXIpO1xyXG59XHJcbmZ1bmN0aW9uIExheWVySW5kZXhFZmZlY3QoZGF0YSxlbGVtLCBjb250YWluZXIpe1xyXG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSxkYXRhLnYsMCwwLGNvbnRhaW5lcik7XHJcbn1cclxuZnVuY3Rpb24gTWFza0luZGV4RWZmZWN0KGRhdGEsZWxlbSwgY29udGFpbmVyKXtcclxuICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS52LDAsMCxjb250YWluZXIpO1xyXG59XHJcbmZ1bmN0aW9uIENoZWNrYm94RWZmZWN0KGRhdGEsZWxlbSwgY29udGFpbmVyKXtcclxuICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sZGF0YS52LDAsMCxjb250YWluZXIpO1xyXG59XHJcbmZ1bmN0aW9uIE5vVmFsdWVFZmZlY3QoKXtcclxuICAgIHRoaXMucCA9IHt9O1xyXG59XG5mdW5jdGlvbiBFZmZlY3RzTWFuYWdlcihkYXRhLGVsZW1lbnQpe1xyXG4gICAgdmFyIGVmZmVjdHMgPSBkYXRhLmVmIHx8IFtdO1xyXG4gICAgdGhpcy5lZmZlY3RFbGVtZW50cyA9IFtdO1xyXG4gICAgdmFyIGksbGVuID0gZWZmZWN0cy5sZW5ndGg7XHJcbiAgICB2YXIgZWZmZWN0SXRlbTtcclxuICAgIGZvcihpPTA7aTxsZW47aSsrKSB7XHJcbiAgICAgICAgZWZmZWN0SXRlbSA9IG5ldyBHcm91cEVmZmVjdChlZmZlY3RzW2ldLGVsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuZWZmZWN0RWxlbWVudHMucHVzaChlZmZlY3RJdGVtKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gR3JvdXBFZmZlY3QoZGF0YSxlbGVtZW50KXtcclxuICAgIHRoaXMuaW5pdChkYXRhLGVsZW1lbnQpO1xyXG59XHJcblxyXG5leHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIEdyb3VwRWZmZWN0KTtcclxuXHJcbkdyb3VwRWZmZWN0LnByb3RvdHlwZS5nZXRWYWx1ZSA9IEdyb3VwRWZmZWN0LnByb3RvdHlwZS5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXM7XHJcblxyXG5Hcm91cEVmZmVjdC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGRhdGEsZWxlbWVudCl7XHJcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgdGhpcy5lZmZlY3RFbGVtZW50cyA9IFtdO1xyXG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW1lbnQpO1xyXG4gICAgdmFyIGksIGxlbiA9IHRoaXMuZGF0YS5lZi5sZW5ndGg7XHJcbiAgICB2YXIgZWZmLCBlZmZlY3RzID0gdGhpcy5kYXRhLmVmO1xyXG4gICAgZm9yKGk9MDtpPGxlbjtpKz0xKXtcclxuICAgICAgICBlZmYgPSBudWxsO1xyXG4gICAgICAgIHN3aXRjaChlZmZlY3RzW2ldLnR5KXtcclxuICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgZWZmID0gbmV3IFNsaWRlckVmZmVjdChlZmZlY3RzW2ldLGVsZW1lbnQsdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgZWZmID0gbmV3IEFuZ2xlRWZmZWN0KGVmZmVjdHNbaV0sZWxlbWVudCx0aGlzKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBlZmYgPSBuZXcgQ29sb3JFZmZlY3QoZWZmZWN0c1tpXSxlbGVtZW50LHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgIGVmZiA9IG5ldyBQb2ludEVmZmVjdChlZmZlY3RzW2ldLGVsZW1lbnQsdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICBjYXNlIDc6XHJcbiAgICAgICAgICAgICAgICBlZmYgPSBuZXcgQ2hlY2tib3hFZmZlY3QoZWZmZWN0c1tpXSxlbGVtZW50LHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMTA6XHJcbiAgICAgICAgICAgICAgICBlZmYgPSBuZXcgTGF5ZXJJbmRleEVmZmVjdChlZmZlY3RzW2ldLGVsZW1lbnQsdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAxMTpcclxuICAgICAgICAgICAgICAgIGVmZiA9IG5ldyBNYXNrSW5kZXhFZmZlY3QoZWZmZWN0c1tpXSxlbGVtZW50LHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgIGVmZiA9IG5ldyBFZmZlY3RzTWFuYWdlcihlZmZlY3RzW2ldLGVsZW1lbnQsdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgLy9jYXNlIDY6XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBlZmYgPSBuZXcgTm9WYWx1ZUVmZmVjdChlZmZlY3RzW2ldLGVsZW1lbnQsdGhpcyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoZWZmKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWZmZWN0RWxlbWVudHMucHVzaChlZmYpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuICAgIHZhciBsb3R0aWVqcyA9IHt9O1xyXG5cclxuICAgIHZhciBfaXNGcm96ZW4gPSBmYWxzZTtcclxuXHJcbiAgICBmdW5jdGlvbiBzZXRMb2NhdGlvbkhyZWYgKGhyZWYpIHtcclxuICAgICAgICBsb2NhdGlvbkhyZWYgPSBocmVmO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHNlYXJjaEFuaW1hdGlvbnMoKSB7XHJcbiAgICAgICAgaWYgKHN0YW5kYWxvbmUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgYW5pbWF0aW9uTWFuYWdlci5zZWFyY2hBbmltYXRpb25zKGFuaW1hdGlvbkRhdGEsIHN0YW5kYWxvbmUsIHJlbmRlcmVyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBhbmltYXRpb25NYW5hZ2VyLnNlYXJjaEFuaW1hdGlvbnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gc2V0U3ViZnJhbWVSZW5kZXJpbmcoZmxhZykge1xyXG4gICAgICAgIHN1YmZyYW1lRW5hYmxlZCA9IGZsYWc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbG9hZEFuaW1hdGlvbihwYXJhbXMpIHtcclxuICAgICAgICBpZiAoc3RhbmRhbG9uZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBwYXJhbXMuYW5pbWF0aW9uRGF0YSA9IEpTT04ucGFyc2UoYW5pbWF0aW9uRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhbmltYXRpb25NYW5hZ2VyLmxvYWRBbmltYXRpb24ocGFyYW1zKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzZXRRdWFsaXR5KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnaGlnaCc6XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEN1cnZlU2VnbWVudHMgPSAyMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdtZWRpdW0nOlxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDdXJ2ZVNlZ21lbnRzID0gNTA7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdsb3cnOlxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRDdXJ2ZVNlZ21lbnRzID0gMTA7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2UgaWYgKCFpc05hTih2YWx1ZSkgJiYgdmFsdWUgPiAxKSB7XHJcbiAgICAgICAgICAgIGRlZmF1bHRDdXJ2ZVNlZ21lbnRzID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWZhdWx0Q3VydmVTZWdtZW50cyA+PSA1MCkge1xyXG4gICAgICAgICAgICByb3VuZFZhbHVlcyhmYWxzZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcm91bmRWYWx1ZXModHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluQnJvd3NlcigpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBsdWdpbih0eXBlLCBwbHVnaW4pIHtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ2V4cHJlc3Npb25zJykge1xyXG4gICAgICAgICAgICBleHByZXNzaW9uc1BsdWdpbiA9IHBsdWdpbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZ2V0RmFjdG9yeShuYW1lKSB7XHJcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJwcm9wZXJ0eUZhY3RvcnlcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9wZXJ0eUZhY3Rvcnk7XHJcbiAgICAgICAgICAgIGNhc2UgXCJzaGFwZVByb3BlcnR5RmFjdG9yeVwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNoYXBlUHJvcGVydHlGYWN0b3J5O1xyXG4gICAgICAgICAgICBjYXNlIFwibWF0cml4XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0cml4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBsb3R0aWVqcy5wbGF5ID0gYW5pbWF0aW9uTWFuYWdlci5wbGF5O1xyXG4gICAgbG90dGllanMucGF1c2UgPSBhbmltYXRpb25NYW5hZ2VyLnBhdXNlO1xyXG4gICAgbG90dGllanMuc2V0TG9jYXRpb25IcmVmID0gc2V0TG9jYXRpb25IcmVmO1xyXG4gICAgbG90dGllanMudG9nZ2xlUGF1c2UgPSBhbmltYXRpb25NYW5hZ2VyLnRvZ2dsZVBhdXNlO1xyXG4gICAgbG90dGllanMuc2V0U3BlZWQgPSBhbmltYXRpb25NYW5hZ2VyLnNldFNwZWVkO1xyXG4gICAgbG90dGllanMuc2V0RGlyZWN0aW9uID0gYW5pbWF0aW9uTWFuYWdlci5zZXREaXJlY3Rpb247XHJcbiAgICBsb3R0aWVqcy5zdG9wID0gYW5pbWF0aW9uTWFuYWdlci5zdG9wO1xyXG4gICAgbG90dGllanMuc2VhcmNoQW5pbWF0aW9ucyA9IHNlYXJjaEFuaW1hdGlvbnM7XHJcbiAgICBsb3R0aWVqcy5yZWdpc3RlckFuaW1hdGlvbiA9IGFuaW1hdGlvbk1hbmFnZXIucmVnaXN0ZXJBbmltYXRpb247XHJcbiAgICBsb3R0aWVqcy5sb2FkQW5pbWF0aW9uID0gbG9hZEFuaW1hdGlvbjtcclxuICAgIGxvdHRpZWpzLnNldFN1YmZyYW1lUmVuZGVyaW5nID0gc2V0U3ViZnJhbWVSZW5kZXJpbmc7XHJcbiAgICBsb3R0aWVqcy5yZXNpemUgPSBhbmltYXRpb25NYW5hZ2VyLnJlc2l6ZTtcclxuICAgIC8vbG90dGllanMuc3RhcnQgPSBzdGFydDtcclxuICAgIGxvdHRpZWpzLmdvVG9BbmRTdG9wID0gYW5pbWF0aW9uTWFuYWdlci5nb1RvQW5kU3RvcDtcclxuICAgIGxvdHRpZWpzLmRlc3Ryb3kgPSBhbmltYXRpb25NYW5hZ2VyLmRlc3Ryb3k7XHJcbiAgICBsb3R0aWVqcy5zZXRRdWFsaXR5ID0gc2V0UXVhbGl0eTtcclxuICAgIGxvdHRpZWpzLmluQnJvd3NlciA9IGluQnJvd3NlcjtcclxuICAgIGxvdHRpZWpzLmluc3RhbGxQbHVnaW4gPSBpbnN0YWxsUGx1Z2luO1xyXG4gICAgbG90dGllanMuZnJlZXplID0gYW5pbWF0aW9uTWFuYWdlci5mcmVlemU7XHJcbiAgICBsb3R0aWVqcy51bmZyZWV6ZSA9IGFuaW1hdGlvbk1hbmFnZXIudW5mcmVlemU7XHJcbiAgICBsb3R0aWVqcy5nZXRSZWdpc3RlcmVkQW5pbWF0aW9ucyA9IGFuaW1hdGlvbk1hbmFnZXIuZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnM7XHJcbiAgICBsb3R0aWVqcy5fX2dldEZhY3RvcnkgPSBnZXRGYWN0b3J5O1xyXG4gICAgbG90dGllanMudmVyc2lvbiA9ICc1LjMuNCc7XHJcblxyXG4gICAgZnVuY3Rpb24gY2hlY2tSZWFkeSgpIHtcclxuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiKSB7XHJcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocmVhZHlTdGF0ZUNoZWNrSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICBzZWFyY2hBbmltYXRpb25zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGdldFF1ZXJ5VmFyaWFibGUodmFyaWFibGUpIHtcclxuICAgICAgICB2YXIgdmFycyA9IHF1ZXJ5U3RyaW5nLnNwbGl0KCcmJyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwYWlyID0gdmFyc1tpXS5zcGxpdCgnPScpO1xyXG4gICAgICAgICAgICBpZiAoZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pID09IHZhcmlhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIHN0YW5kYWxvbmUgPSAnX19bU1RBTkRBTE9ORV1fXyc7XHJcbiAgICB2YXIgYW5pbWF0aW9uRGF0YSA9ICdfX1tBTklNQVRJT05EQVRBXV9fJztcclxuICAgIHZhciByZW5kZXJlciA9ICcnO1xyXG4gICAgaWYgKHN0YW5kYWxvbmUpIHtcclxuICAgICAgICB2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcclxuICAgICAgICB2YXIgaW5kZXggPSBzY3JpcHRzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgdmFyIG15U2NyaXB0ID0gc2NyaXB0c1tpbmRleF0gfHwge1xyXG4gICAgICAgICAgICBzcmM6ICcnXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcXVlcnlTdHJpbmcgPSBteVNjcmlwdC5zcmMucmVwbGFjZSgvXlteXFw/XStcXD8/LywgJycpO1xyXG4gICAgICAgIHJlbmRlcmVyID0gZ2V0UXVlcnlWYXJpYWJsZSgncmVuZGVyZXInKTtcclxuICAgIH1cclxuICAgIHZhciByZWFkeVN0YXRlQ2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKGNoZWNrUmVhZHksIDEwMCk7XHJcbiAgICByZXR1cm4gbG90dGllanM7XHJcbn0pKTtcciJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///0\\n\")},function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var lottie_web__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\\n/* harmony import */ var lottie_web__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lottie_web__WEBPACK_IMPORTED_MODULE_0__);\\n\\n\\nconst greeter = __webpack_require__(2);\\ndocument.querySelector(\\\"#root\\\").appendChild(greeter());\\n\\nlottie_web__WEBPACK_IMPORTED_MODULE_0___default.a.loadAnimation({\\n  container: element, // the dom element that will contain the animation\\n  renderer: 'svg',\\n  loop: true,\\n  autoplay: true,\\n  path: 'test.json' // the path to the animation json\\n});\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvbWFpbi5qcz9mMTYxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGxvdHRpZSBmcm9tICdsb3R0aWUtd2ViJ1xuXG5jb25zdCBncmVldGVyID0gcmVxdWlyZShcIi4vZ3JlZXRlci5qc1wiKTtcbmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcm9vdFwiKS5hcHBlbmRDaGlsZChncmVldGVyKCkpO1xuXG5sb3R0aWUubG9hZEFuaW1hdGlvbih7XG4gIGNvbnRhaW5lcjogZWxlbWVudCwgLy8gdGhlIGRvbSBlbGVtZW50IHRoYXQgd2lsbCBjb250YWluIHRoZSBhbmltYXRpb25cbiAgcmVuZGVyZXI6ICdzdmcnLFxuICBsb29wOiB0cnVlLFxuICBhdXRvcGxheTogdHJ1ZSxcbiAgcGF0aDogJ3Rlc3QuanNvbicgLy8gdGhlIHBhdGggdG8gdGhlIGFuaW1hdGlvbiBqc29uXG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///1\\n\")},function(module,exports){eval('module.exports = function () {\\n  var greet = document.createElement(\"div\");\\n  // greet.textContent = \"Hi\";\\n  return greet;\\n};\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9hcHAvZ3JlZXRlci5qcz80Yzc4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ3JlZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAvLyBncmVldC50ZXh0Q29udGVudCA9IFwiSGlcIjtcbiAgcmV0dXJuIGdyZWV0O1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\\n//# sourceURL=webpack-internal:///2\\n')}]);","extractedComments":[]}